
<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>QTimer定时器的使用 - WhiteLemonade</title>

  
    <meta name="description" content="操作系统的时间片  定时器的 interval 属性表示的是超时间隔，以毫秒为单位默认值为 0。一旦窗口系统事件队列中的所有事件处理完毕，超时间隔为 0 的 QTimer 定时器将超时。 设置活动定时器的超时间隔会更改其 timerId()。 计时器QObject 是所有 Qt 对象的基类，为 Qt 提供了基本的定时器支持。使用 QObject::startTimer (), 可以以毫秒为单位的间">
<meta property="og:type" content="article">
<meta property="og:title" content="QTimer定时器的使用">
<meta property="og:url" content="http://liuluhua.github.io/2025/07/19/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-QTimer%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/">
<meta property="og:site_name" content="WhiteLemonade">
<meta property="og:description" content="操作系统的时间片  定时器的 interval 属性表示的是超时间隔，以毫秒为单位默认值为 0。一旦窗口系统事件队列中的所有事件处理完毕，超时间隔为 0 的 QTimer 定时器将超时。 设置活动定时器的超时间隔会更改其 timerId()。 计时器QObject 是所有 Qt 对象的基类，为 Qt 提供了基本的定时器支持。使用 QObject::startTimer (), 可以以毫秒为单位的间">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-07-19T10:36:05.000Z">
<meta property="article:modified_time" content="2025-07-19T13:58:32.000Z">
<meta property="article:author" content="liuluhua">
<meta name="twitter:card" content="summary">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"liuluhua","sameAs":[]},"dateCreated":"2025-07-19T10:36:05+00:00","dateModified":"2025-07-19T13:58:32+00:00","datePublished":"2025-07-19T10:36:05+00:00","description":"","headline":"QTimer定时器的使用","mainEntityOfPage":{"@type":"WebPage","@id":"http://liuluhua.github.io/2025/07/19/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-QTimer%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"},"publisher":{"@type":"Organization","name":"liuluhua","sameAs":[]},"url":"http://liuluhua.github.io/2025/07/19/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-QTimer%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","image":[]}</script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/satouriko/LxgwWenKai_Webfonts@v1.101/dist/LXGWWenKaiMono-Bold.css" />
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">WhiteLemonade</div><div class="sub cap">WhiteLemonade的充电站</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="Search"></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div>



<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">Recent Update</span></div><div class="widget-body fs14"><a class="item title" href="/2024/04/18/1-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8D%9A%E5%AE%A2-Hexo-GithubPages-%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"><span class="title">Hexo+GithubPages 部署博客</span></a><a class="item title" href="/2025/07/24/3-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CANaerospace-Wikipedia/"><span class="title">CANaerospace - Wikipedia</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt5-4-2%E7%A7%BB%E6%A4%8D%E5%88%B0ARM%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A/"><span class="title">Qt5.4.2移植到ARM开发板上</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-C-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90get%E5%92%8Cset%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7/"><span class="title">Qt/C++ 自动生成get和set方法以及属性</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%90%8EARM%E6%9D%BF%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE/"><span class="title">Qt交叉编译后ARM板启动配置</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-OpenCV-%E3%80%90%E5%A4%9A%E4%BC%A0%E6%84%9F%E8%9E%8D%E5%90%88%E3%80%91%E4%BC%98%E8%BE%BE%E5%AD%A6%E5%9F%8E%E5%A4%9A%E4%BC%A0%E6%84%9F%E8%9E%8D%E5%90%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%B0%86%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE3D%E7%82%B9%E4%BA%91%E6%98%A0%E5%B0%84%E5%88%B0%E7%9B%B8%E6%9C%BA%E5%9B%BE%E5%83%8F%EF%BC%88%E4%B8%8B%EF%BC%89-kitti%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%92%8C%E7%9B%B8%E6%9C%BA%E6%98%A0%E5%B0%84-CSDN%E5%8D%9A%E5%AE%A2/"><span class="title">【多传感融合】优达学城多传感融合学习笔记（四）——将激光雷达3D点云映射到相机图像（下）_kitti激光雷达和相机映射-CSDN博客</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-QT%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F-%E4%B8%80-%EF%BC%9A%E7%95%8C%E9%9D%A2%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB/"><span class="title">QT开发模式(一)：界面和业务逻辑分离</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-Creator-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%EF%BC%8C%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%B7%A5%E7%A8%8B/"><span class="title">Qt Creator 源码学习笔记03，大型项目如何管理工程</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-Creator-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%EF%BC%8C%E5%A4%9A%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"><span class="title">Qt Creator 源码学习笔记04，多插件实现原理分析</span></a><a class="item title" href="/2025/07/23/1-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8D%9A%E5%AE%A2-%E4%BE%9D%E8%B5%96%E7%9A%84package/"><span class="title">依赖的package</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6/">2.语言和框架</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6/Qt/">Qt</a></div>
<div class="flex-row" id="post-meta"><span class="text created">Posted on: <time datetime="2025-07-19T10:36:05.000Z">2025-07-19</time></span><span class="sep updated"></span><span class="text updated">Updated on: <time datetime="2025-07-19T13:58:32.000Z">2025-07-19</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>QTimer定时器的使用</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>操作系统的时间片 </p>
<p>定时器的 interval 属性表示的是超时间隔，以毫秒为单位默认值为 0。一旦窗口系统事件队列中的所有事件处理完毕，超时间隔为 0 的 QTimer 定时器将超时。</p>
<p>设置活动定时器的超时间隔会更改其 timerId()。</p>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p>QObject 是所有 Qt 对象的基类，为 Qt 提供了基本的定时器支持。使用 QObject::startTimer (), 可以以毫秒为单位的间隔作为参数启动定时器。该函数返回一个唯一的整数定时器 ID。定时器现在将以固定的间隔触发，直到你使用定时器 ID 显式调用 QObject::killTimer ()。</p>
<p>为了使这种机制正常工作，应用程序必须在事件循环中运行。可以使用 QApplication::exec () 启动事件循环。当定时器触发时，应用程序会发送一个 QTimerEvent, 控制流会离开事件循环，直到定时器事件被处理。这意味着当应用程序忙于其他事情时，定时器无法触发。换句话说，定时器的准确性取决于应用程序的粒度。</p>
<p>在多线程应用程序中，可以在任何具有事件循环的线程中使用定时器机制。要从非 GUI 线程启动事件循环，可以使用 QThread::exec ()。Qt 使用对象的线程亲和力来确定哪个线程将传递 QTimerEvent。因此，必须启动和停止对象线程中的所有定时器；不能为另一个线程中的对象启动定时器。</p>
<p>区间值的上限由有符号整数可以指定的毫秒数决定 (实际上，这是一个略长于 24 天的周期)。准确性取决于底层操作系统。Windows 2000 的准确性为 15 毫秒；我们测试过的其他系统可以处理 1 毫秒的区间。</p>
<p>定时器功能的主要 API 是 QTimer。这个类提供了常规定时器，当定时器触发时会发出信号，并继承 QObject, 因此它很好地适合大多数 GUI 程序的所有权结构。使用它的正常方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">Connect</span>(timer，<span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>())，<span class="keyword">this</span>，<span class="built_in">SLOT</span>(<span class="built_in">updateCaption</span>());</span><br><span class="line">Timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>QTimer 对象被创建为这个构件的子对象，因此当删除这个构件时，定时器也会被删除。接下来，它的 timeout () 信号连接到将执行该工作的槽，它以 1000 毫秒的值开始，表示它将每秒超时一次。</p>
<p>QTimer 还为单镜头 timer 提供了一个静态函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">singleShot</span>(<span class="number">200</span>，<span class="keyword">this</span>，<span class="built_in">SLOT</span>(<span class="built_in">updateCaption</span>());</span><br></pre></td></tr></table></figure>

<p>在执行这行代码 200 毫秒 (0.2 秒) 后，将调用 updateCaption () 槽。</p>
<p>要让 QTimer 工作，你的应用程序中必须有一个事件循环；也就是说，你必须在某个地方调用 QCoreApplication::exec ()。定时器事件只会在事件循环运行时传递。</p>
<p>在多线程应用程序中，可以在任何具有事件循环的线程中使用 QTimer。要从非 GUI 线程启动事件循环，可以使用 QThread::exec ()。Qt 使用定时器的线程亲和力来确定哪个线程将发出 timeout () 信号。因此，必须在其线程中启动和停止定时器；不能从另一个线程启动定时器。</p>
<p>Analog Clock 示例演示了如何使用 QTimer 定期重绘构件。来自 AnalogClock 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AnalogClock::<span class="built_in">AnalogClock</span>(QWidget *parent)</span><br><span class="line">:<span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">Connect</span>(timer，<span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>())，<span class="keyword">this</span>，<span class="built_in">SLOT</span>(<span class="built_in">update</span>());</span><br><span class="line">Timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每秒，QTimer 都会调用 QWidget::update () 槽来刷新时钟显示。</p>
<p>如果你已经有一个 QObject 子类，并且想要一个简单的优化，可以使用 QBasicTimer 而不是 QTimer。使用 QBasicTimer 时，你必须在 QObject 子类中重新实现 timerEvent (), 并在那里处理超时。Wiggly 示例演示了如何使用 QBasicTimer。</p>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>QTimer 类为定时器提供了一个高级的编程接口。要使用它，需要创建一个 QTimer, 将其 timeout 信号连接到相应的槽，然后调用 start ()。从那时起，它将以恒定的间隔发出 timeout 信号。</p>
<p>一秒 (1000 毫秒) timeout 的示例 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Connect</span>(timer，&amp;QTimer::timeout，<span class="keyword">this</span>，QOverload&lt;&gt;:<span class="built_in">of</span>(&amp;AnalogClock::update);</span><br><span class="line"></span><br><span class="line">Timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>从那时起，update () 槽每秒都会被调用。</p>
<p>可以通过调用 setSingleShot 来将定时器设置为仅超时一次 (true)。还可以使用静态 QTimer::singleShot() 函数在指定间隔后调用槽：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">singleShot</span>(<span class="number">200</span>，<span class="keyword">this</span>，<span class="built_in">SLOT</span>(<span class="built_in">updateCaption</span>());</span><br></pre></td></tr></table></figure>

<p>在多线程应用程序中，可以在任何具有事件循环的线程中使用 QTimer。要从非 GUI 线程启动事件循环，可以使用 QThread::exec。Qt 使用定时器的 线程亲和力来确定哪个线程将发出 timeout ()信号。因此，必须在其线程中启动和停止定时器；不能从另一个线程启动定时器。</p>
<p>作为一种特殊情况，超时为 0 的 QTimer 将尽快超时，尽管零定时器和其他事件源之间的顺序未指定。零定时器可以用来完成一些工作，同时仍然提供快速的用户界面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">Connect</span>(timer，<span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>())，<span class="keyword">this</span>，<span class="built_in">SLOT</span>(<span class="built_in">processOneThing</span>());</span><br><span class="line">Timer-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure>

<p>从那时起，processOneThing () 将被反复调用。它应该以一种始终快速返回的方式编写 (通常在处理一个数据项之后), 以便 Qt 可以将事件传递到用户界面，并在定时器完成所有工作后立即停止它。这是 GUI 应用程序中实现繁重工作的传统方式，但随着多线程现在在越来越多的平台上可用，我们预计零毫秒 QTimer 对象将逐渐被 QThread 取代。</p>
<h3 id="准确性和定时器解析"><a href="#准确性和定时器解析" class="headerlink" title="准确性和定时器解析"></a>准确性和定时器解析</h3><p>定时器的准确性取决于底层操作系统和硬件。大多数平台支持 1 毫秒的分辨率，尽管在许多现实情况下，定时器的准确性不会等于这个分辨率。</p>
<p>准确性也取决于 timer type。</p>
<blockquote>
<p>enum Qt::TimerType<br>The timer type indicates how accurate a timer can be.</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Constant</td>
<td>Value</td>
<td>Description</td>
</tr>
<tr>
<td>Qt::PreciseTimer</td>
<td>0</td>
<td>Precise timers try to keep millisecond accuracy</td>
</tr>
<tr>
<td>Qt::CoarseTimer</td>
<td>1</td>
<td>Coarse timers try to keep accuracy within 5% of the desired interval</td>
</tr>
<tr>
<td>Qt::VeryCoarseTimer</td>
<td>2</td>
<td>Very coarse timers only keep full second accuracy</td>
</tr>
</tbody></table>
<blockquote>
<p>On UNIX (including Linux, macOS, and iOS), Qt will keep millisecond accuracy for Qt::PreciseTimer. For Qt::CoarseTimer, the interval will be adjusted up to 5% to align the timer with other timers that are expected to fire at or around the same time. The objective is to make most timers wake up at the same time, thereby reducing CPU wakeups and power consumption.</p>
</blockquote>
<blockquote>
<p>On Windows, Qt will use Windows’s Multimedia timer facility (if available) for Qt::PreciseTimer and normal Windows timers for Qt::CoarseTimer and Qt::VeryCoarseTimer.</p>
</blockquote>
<blockquote>
<p>On all platforms, the interval for Qt::VeryCoarseTimer is rounded to the nearest full second (e.g. an interval of 23500ms will be rounded to 24000ms, and 20300ms to 20000ms).</p>
</blockquote>
<p>对于 Qt::PreciseTimer ,QTimer 将试图将准确性保持在 1 毫秒。精确的计时器也绝不会比预期更早超时。</p>
<p>对于 Qt::CoarseTimer 和 Qt::VeryCoarseTimer 类型，QTimer 可能会比预期更早唤醒，范围在这些类型的边界内：Qt::CoarseTimer 的 5% 时间间隔和 Qt::VeryCoarseTimer 的 500 毫秒。</p>
<p>如果系统繁忙或无法提供请求的准确性，所有定时器类型的超时可能会比预期晚。在这种超时超过的情况下，Qt 将只发出 timeout 一次，即使多个超时已经过期，然后将恢复原始间隔。</p>
<h3 id="QTimer-的替代方案"><a href="#QTimer-的替代方案" class="headerlink" title="QTimer 的替代方案"></a>QTimer 的替代方案</h3><p>使用 QTimer 的另一种方法是为你的对象调用 QObject::startTimer(), 并在你的类中重新实现 QObject::timerEvent() 事件处理程序 (它必须继承 QObject)。缺点是 timerEvent() 不支持像单发定时器或信号这样的高级功能。</p>
<p>另一种替代方法是 QBasicTimer 。它通常比直接使用 QObject::startTimer() 更省事。请参阅 Timers 了解所有三种方法的概述。</p>
<p>一些操作系统限制了可以使用的定时器数量；Qt 试图绕过这些限制。</p>
</article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>License</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Newer</div><a href="/2025/07/19/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-C-C-%E4%B8%AD%E7%9A%84friend-class-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93-CSDN%E5%8D%9A%E5%AE%A2/">C++中的friend class 用法总结-CSDN博客</a></div><div class="item" id="next"><div class="note">Older</div><a href="/2025/07/09/4-Others-%E8%88%AA%E7%94%B5-Stock-Flight-Systems-%E5%85%AC%E5%8F%B8/">Stock Flight Systems 公司</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">liuluhua</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">On This Page</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-text">计时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0"><span class="toc-text">详细描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E7%A1%AE%E6%80%A7%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E6%9E%90"><span class="toc-text">准确性和定时器解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QTimer-%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-text">QTimer 的替代方案</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>Scroll to Top</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `Just`,
      min: `minutes ago`,
      hour: `hours ago`,
      day: `days ago`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `Switched to Light Mode`,
      dark: `Switched to Dark Mode`,
      auto: `Switched to Auto Mode`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>

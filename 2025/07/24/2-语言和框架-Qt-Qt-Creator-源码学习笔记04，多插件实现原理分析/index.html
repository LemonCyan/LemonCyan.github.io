
<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>Qt Creator 源码学习笔记04，多插件实现原理分析 - WhiteLemonade</title>

  
    <meta name="description" content="阅读本文大概需要 8 分钟  插件听上去很高大上，实际上就是一个个动态库，动态库在不同平台下后缀名不一样，比如在 Windows 下以.dll 结尾， Linux 下以.so 结尾 开发插件其实就是开发一个动态库，该动态库能够很好的加载进主程序、访问主程序资源、和主程序之间进行通信 本篇文章一起学习下 Qt Creator 当中是如何实现插件的开发、加载、解析、管理以及互相通信的，方便我们开发自">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt Creator 源码学习笔记04，多插件实现原理分析">
<meta property="og:url" content="http://liuluhua.github.io/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-Creator-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%EF%BC%8C%E5%A4%9A%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">
<meta property="og:site_name" content="WhiteLemonade">
<meta property="og:description" content="阅读本文大概需要 8 分钟  插件听上去很高大上，实际上就是一个个动态库，动态库在不同平台下后缀名不一样，比如在 Windows 下以.dll 结尾， Linux 下以.so 结尾 开发插件其实就是开发一个动态库，该动态库能够很好的加载进主程序、访问主程序资源、和主程序之间进行通信 本篇文章一起学习下 Qt Creator 当中是如何实现插件的开发、加载、解析、管理以及互相通信的，方便我们开发自">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/devstone/imageBed/raw/master/images/202112192150398.png">
<meta property="og:image" content="https://gitee.com/devstone/imageBed/raw/master/images/202112062325279.png">
<meta property="og:image" content="https://gitee.com/devstone/imageBed/raw/master/images/202112192158402.png">
<meta property="og:image" content="https://gitee.com/devstone/imageBed/raw/master/images/202112192256200.png">
<meta property="article:published_time" content="2025-07-24T07:23:10.414Z">
<meta property="article:modified_time" content="2025-07-24T07:23:39.963Z">
<meta property="article:author" content="liuluhua">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/devstone/imageBed/raw/master/images/202112192150398.png">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"liuluhua","sameAs":[]},"dateCreated":"2025-07-24T07:23:10+00:00","dateModified":"2025-07-24T07:23:39+00:00","datePublished":"2025-07-24T07:23:10+00:00","description":"","headline":"Qt Creator 源码学习笔记04，多插件实现原理分析","mainEntityOfPage":{"@type":"WebPage","@id":"http://liuluhua.github.io/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-Creator-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%EF%BC%8C%E5%A4%9A%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},"publisher":{"@type":"Organization","name":"liuluhua","sameAs":[]},"url":"http://liuluhua.github.io/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-Creator-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%EF%BC%8C%E5%A4%9A%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","image":[]}</script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/satouriko/LxgwWenKai_Webfonts@v1.101/dist/LXGWWenKaiMono-Bold.css" />
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">WhiteLemonade</div><div class="sub cap">WhiteLemonade的充电站</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="Search"></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div>



<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">Recent Update</span></div><div class="widget-body fs14"><a class="item title" href="/2024/04/18/1-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8D%9A%E5%AE%A2-Hexo-GithubPages-%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"><span class="title">Hexo+GithubPages 部署博客</span></a><a class="item title" href="/2025/07/24/3-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CANaerospace-Wikipedia/"><span class="title">CANaerospace - Wikipedia</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt5-4-2%E7%A7%BB%E6%A4%8D%E5%88%B0ARM%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A/"><span class="title">Qt5.4.2移植到ARM开发板上</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-C-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90get%E5%92%8Cset%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7/"><span class="title">Qt/C++ 自动生成get和set方法以及属性</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%90%8EARM%E6%9D%BF%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE/"><span class="title">Qt交叉编译后ARM板启动配置</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-OpenCV-%E3%80%90%E5%A4%9A%E4%BC%A0%E6%84%9F%E8%9E%8D%E5%90%88%E3%80%91%E4%BC%98%E8%BE%BE%E5%AD%A6%E5%9F%8E%E5%A4%9A%E4%BC%A0%E6%84%9F%E8%9E%8D%E5%90%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%B0%86%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE3D%E7%82%B9%E4%BA%91%E6%98%A0%E5%B0%84%E5%88%B0%E7%9B%B8%E6%9C%BA%E5%9B%BE%E5%83%8F%EF%BC%88%E4%B8%8B%EF%BC%89-kitti%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%92%8C%E7%9B%B8%E6%9C%BA%E6%98%A0%E5%B0%84-CSDN%E5%8D%9A%E5%AE%A2/"><span class="title">【多传感融合】优达学城多传感融合学习笔记（四）——将激光雷达3D点云映射到相机图像（下）_kitti激光雷达和相机映射-CSDN博客</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-QT%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F-%E4%B8%80-%EF%BC%9A%E7%95%8C%E9%9D%A2%E5%92%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB/"><span class="title">QT开发模式(一)：界面和业务逻辑分离</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-Creator-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%EF%BC%8C%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%B7%A5%E7%A8%8B/"><span class="title">Qt Creator 源码学习笔记03，大型项目如何管理工程</span></a><a class="item title" href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-Creator-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%EF%BC%8C%E5%A4%9A%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"><span class="title">Qt Creator 源码学习笔记04，多插件实现原理分析</span></a><a class="item title" href="/2025/07/23/1-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8D%9A%E5%AE%A2-%E4%BE%9D%E8%B5%96%E7%9A%84package/"><span class="title">依赖的package</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6/">2.语言和框架</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6/Qt/">Qt</a></div>
<div class="flex-row" id="post-meta"><span class="text created">Posted on: <time datetime="2025-07-24T07:23:10.414Z">2025-07-24</time></span><span class="sep updated"></span><span class="text updated">Updated on: <time datetime="2025-07-24T07:23:39.963Z">2025-07-24</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Qt Creator 源码学习笔记04，多插件实现原理分析</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><blockquote>
<p>阅读本文大概需要 8 分钟</p>
</blockquote>
<p>插件听上去很高大上，实际上就是一个个动态库，动态库在不同平台下后缀名不一样，比如在 <code>Windows</code> 下以<code>.dll</code> 结尾， <code>Linux</code> 下以<code>.so</code> 结尾</p>
<p>开发插件其实就是开发一个动态库，该动态库能够很好的加载进主程序、访问主程序资源、和主程序之间进行通信</p>
<p>本篇文章一起学习下 <code>Qt Creator</code> 当中是如何实现插件的开发、加载、解析、管理以及互相通信的，方便我们开发自定义插件打下基础</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Qt Creator </code> 插件理解起来其实很简单，定义一个接口类作为基类，其他插件需要继承该类实现对应的虚方法，每个插件作为独立子工程编译后生成对应的动态库</p>
<p><img src="https://gitee.com/devstone/imageBed/raw/master/images/202112192150398.png"></p>
<p>主函数加载每个插件对象，然后转化为对应插件实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QPluginLoader loader(pluginName);</span><br><span class="line">loader.load();</span><br><span class="line">IPlugin *pluginObject = qobject_cast&lt;IPlugin*&gt;(loader.instance());</span><br><span class="line"></span><br><span class="line">// 比如转为核心插件实例</span><br><span class="line">CorePlugin *pCorePluginObj = qobject_cast&lt;CorePlugin*&gt;(loader.instance());</span><br></pre></td></tr></table></figure>

<p>然后每个插件各自根据对应业务逻辑调用接口就行了</p>
<p>当然了， <code>Qt Creator</code> 在实现过程当中肯定不止这么简单，插件的加载、解析、卸载等管理还是比较复杂的，非常值得我们去学习</p>
<h2 id="插件组成"><a href="#插件组成" class="headerlink" title="插件组成"></a>插件组成</h2><p>整个插件系统由插件管理器、核心插件、其它插件组成，其中核心插件是系统中不可缺少的，其它插件都要依赖核心插件来进行开发通信</p>
<p>我们先打开 <code>Qt Creator</code> 插件菜单看看都包含那些插件</p>
<p><img src="https://gitee.com/devstone/imageBed/raw/master/images/202112062325279.png"></p>
<p>可以看到所有的插件根据类型进行了分组，同一个类型插件同属一个树节点，每个插件后面有个复选框可以控制加载&#x2F;卸载该插件</p>
<p>每个插件还包含了版本信息以及归属作者信息，这些信息都可以通过对象元数据来配置，插件的版本也很有用，我们编写的插件可以限定在某个版本之间兼容，这个时候版本号就起作用了，详细实现后面会讲解到</p>
<p>我们可以加载、卸载某个插件，但是无论怎么选择，核心 <code>Core</code> 插件是不能卸载的，why? 因为整个插件系统是建立在 <code>Core</code> 核心插件基础之上的，离开核心插件其它插件无法存活</p>
<p>所以我们学习的重点应该放在核心插件上，学会后其它插件很容易上手了</p>
<h2 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h2><p>插件的核心其实就是对插件的管理，这个是本篇的重点，是我们阅读源码时需要重点关注的部分，为什么这么说呢，我举个栗子大家就清楚了</p>
<p>我们日常写代码的时候，比如定义一个变量，需要关注的有这么几点：</p>
<ul>
<li>变量的名</li>
<li>变量的值</li>
<li>变量的类型</li>
<li>变量的作用域</li>
<li>变量的生命周期</li>
</ul>
<p>对每个定义的变量都非常清楚它的一些要素，那么肯定不会出错的</p>
<p>插件也一样，每个插件到实际开发当中也是一个个对象，我们定义的对象是什么类型？名字叫什么？它的值是多少？它的作用域范围是什么？生命周期呢？什么时候创建和释放？</p>
<p>搞清楚上述这些，对于理解插件管理工作就更进一步了，下面重点来看看插件的生命周期</p>
<h3 id="插件管理器"><a href="#插件管理器" class="headerlink" title="插件管理器"></a>插件管理器</h3><p>插件管理器实现主要在 <code>PluginManager</code> 类当中实现，该类管理了所有的插件加载、卸载以及释放</p>
<h4 id="对象管理池"><a href="#对象管理池" class="headerlink" title="对象管理池"></a>对象管理池</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class EXTENSIONSYSTEM_EXPORT PluginManager : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    static PluginManager *instance();</span><br><span class="line">    static void addObject(QObject *obj);</span><br><span class="line">    static void removeObject(QObject *obj);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    friend class Internal::PluginManagerPrivate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类是一个单例类，主要管理插件对象，可以理解为对象池，详细实现都封装在了 <code>d</code> 指针类里面，</p>
<p>我们继续进去看看</p>
<p>pluginmanager_p.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class EXTENSIONSYSTEM_EXPORT PluginManagerPrivate : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    ......</span><br><span class="line">    QHash&lt;QString, QList&lt;PluginSpec *&gt;&gt; pluginCategories;</span><br><span class="line">    QList&lt;PluginSpec *&gt; pluginSpecs;</span><br><span class="line">    QList&lt;QObject *&gt; allObjects; // ### make this a QList&lt;QPointer&lt;QObject&gt; &gt; &gt; ?</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到底层存储每个对象用的容器是 <code>QList</code> ，从 <code>Qt Creator 4.10</code> 版本开始换成了 <code>QVector</code> 来存储，说起来这两个容器的区别让我想到了，现在最新版本的 <code>Qt</code> 当中，已经把两者合二为一了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; using QVector = QList&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<p>所以使用哪个无所谓了，不过我们还是要搞清楚这两个容器的区别，什么时候用 <code>Vector</code> ，什么时候用 <code>List</code></p>
<p><strong>添加对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void PluginManagerPrivate::addObject(QObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        QWriteLocker lock(&amp;m_lock);</span><br><span class="line">        if (obj == 0) &#123;</span><br><span class="line">            qWarning() &lt;&lt; &quot;PluginManagerPrivate::addObject(): trying to add null object&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (allObjects.contains(obj)) &#123;</span><br><span class="line">            qWarning() &lt;&lt; &quot;PluginManagerPrivate::addObject(): trying to add duplicate object&quot;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        allObjects.append(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    emit q-&gt;objectAdded(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块核心代码其实很好理解，每次添加对象前先加锁，由于使用的是读写锁，不用担心函数返回死锁问题，判断对象是否合法以及是否已经存在，不存在则追加到 <code>list</code> 当中，最后抛出一个信号，这个信号在外部需要使用的地方可以绑定，比如模式切换里面就使用到了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ModeManager::init()</span><br><span class="line">&#123;</span><br><span class="line">    QObject::connect(ExtensionSystem::PluginManager::instance(), &amp;ExtensionSystem::PluginManager::objectAdded,</span><br><span class="line">                     m_instance, &amp;ModeManager::objectAdded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加就对应的删除，原理和添加一样</p>
<p><strong>- 删除对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void PluginManagerPrivate::removeObject(QObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj == 0) &#123;</span><br><span class="line">        qWarning() &lt;&lt; &quot;PluginManagerPrivate::removeObject(): trying to remove null object&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!allObjects.contains(obj)) &#123;</span><br><span class="line">        qWarning() &lt;&lt; &quot;PluginManagerPrivate::removeObject(): object not in list:&quot;</span><br><span class="line">            &lt;&lt; obj &lt;&lt; obj-&gt;objectName();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit q-&gt;aboutToRemoveObject(obj);</span><br><span class="line">    QWriteLocker lock(&amp;m_lock);</span><br><span class="line">    allObjects.removeAll(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的把对象从 <code>list</code> 当中进行了删除，在删除之前也向外抛出了信号，用法和添加信号配对使用</p>
<p>这里有个疑问，为啥锁不在函数最开头加呢？</p>
<h4 id="插件管理-1"><a href="#插件管理-1" class="headerlink" title="插件管理"></a>插件管理</h4><p>每个插件对象对应到底层是由 <code>PluginSpec</code> 来实例化的，每个插件使用 <code>list</code> 容器存储，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;PluginSpec *&gt; pluginSpecs;</span><br></pre></td></tr></table></figure>

<p>插件核心类实现</p>
<p>阅读代码就可以发现，这个类主要是记录了每个插件的一些基本信息，那么这些信息是如何赋值的呢？通过插件描述文件来进行自动加载的，后面学习核心插件会看到</p>
<p>有个核心部分代码，插件依赖项 <code>dependencies</code> ，这个主要解决插件之间依赖关系使用，这个类也很简单很好理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 插件依赖相关信息</span><br><span class="line">*/</span><br><span class="line">struct EXTENSIONSYSTEM_EXPORT PluginDependency</span><br><span class="line">&#123;</span><br><span class="line">    enum Type &#123;</span><br><span class="line">        Required,       // 必须有此依赖</span><br><span class="line">        Optional,       // 此依赖不是必须的</span><br><span class="line">        Test</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PluginDependency() : type(Required) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    QString name;           //被依赖的插件名字</span><br><span class="line">    QString version;        //对应的版本号</span><br><span class="line">    Type type;              //依赖类型</span><br><span class="line">    bool operator==(const PluginDependency &amp;other) const;</span><br><span class="line">    QString toString() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如插件 <code>A</code> 依赖插件 <code>B</code> 和 <code>C</code> ，那么在插件 <code>A</code> 加载的时候对应的 <code>list</code> 当中就包含了 <code>B,C</code> 插件信息，必须等到这两个插件加载完成后才能加载插件 <code>A</code> ，这一点很重要</p>
<h4 id="插件加载流程"><a href="#插件加载流程" class="headerlink" title="插件加载流程"></a>插件加载流程</h4><p>前面学习了插件管理器当中的一些基本数据结构，现在来看看这些插件是怎么加载进去的，加载顺序和流程是怎么样的</p>
<p>插件加载流程比较复杂一些，同时也是最重要的部分，主要分为下面几个步骤</p>
<p>下面我们来详细看看每个步骤都干了那些工作，源码面前了无秘密</p>
<p><strong>设置插件 IID</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPluginIID(const QString &amp;iid)</span><br></pre></td></tr></table></figure>

<p>这个id 是全局唯一，加载插件时会首先判断插件 ID 合法性，用于确定是你自己编写的插件，这样可以防止其它插件恶意注册加载</p>
<p>大家可以想想一下，如果别人也写了一个类似的插件，那么如果没有 ID 区分是不是就能加载进插件系统当中，从而破坏软件结构？</p>
<p><code>Qt Creator</code> 默认的 ID 为 <code>org.qt-project.Qt.QtCreatorPlugin</code> ，每个插件加载时通过宏进行设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CorePlugin : public ExtensionSystem::IPlugin</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PLUGIN_METADATA(IID &quot;org.qt-project.Qt.QtCreatorPlugin&quot; FILE &quot;Core.json&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">宏展开后：</span><br><span class="line"></span><br><span class="line">#define Q_PLUGIN_METADATA(x) QT_ANNOTATE_CLASS(qt_plugin_metadata, x)</span><br><span class="line"></span><br><span class="line">#define QT_ANNOTATE_CLASS(type, ...)</span><br></pre></td></tr></table></figure>

<p>这个宏是为了配合 <code>moc</code> 处理器生成插件导出函数，最终在调用插件接口返回实例时能够准确返回自己。我们写个 <code>demo</code> 来验证下</p>
<p>新建一个插件叫做 <code>PluginDemo</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class PluginDemo : public ExtensionSystem::IPlugin</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PLUGIN_METADATA(IID &quot;org.qt-project.Qt.QtCreatorPlugin&quot; FILE &quot;PluginDemo.json&quot;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>qmake 编译一下看下中间结果内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static const qt_meta_stringdata_PluginDemo_t qt_meta_stringdata_PluginDemo = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">QT_MOC_LITERAL(0, 0, 10) // &quot;PluginDemo&quot;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;PluginDemo&quot;</span><br><span class="line">&#125;;</span><br><span class="line">void *PluginDemo::qt_metacast(const char *_clname)</span><br><span class="line">&#123;</span><br><span class="line">    if (!_clname) return Q_NULLPTR;</span><br><span class="line">    if (!strcmp(_clname, qt_meta_stringdata_PluginDemo.stringdata0))</span><br><span class="line">        return static_cast&lt;void*&gt;(const_cast&lt; PluginDemo*&gt;(this));</span><br><span class="line">    return ExtensionSystem::IPlugin::qt_metacast(_clname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置全局配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setGlobalSettings(QSettings *settings)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局配置，一般存放的是默认值,用于恢复设置使用</p>
</blockquote>
<p><strong>设置局部配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setSettings(QSettings *settings)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>存放程序当前配置参数类。比如我们设置某个参数配置保存后会存在某个配置文件中，程序加载时会从该文件加载到 <code>QSettings</code> 对象当中供我们调用</p>
</blockquote>
<p><strong>设置插件路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPluginPaths(const QStringList &amp;paths)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>插件路径一般是我们 exe 程序相邻路径下的，比如plugins&#x2F;xxx.dll，当然也可以为任意路径下的动态库，只要路径正确合法都可以加载的，可以设置多条插件路径</p>
</blockquote>
<p>比如正常 <code>Qt Creator</code> 启动时会给两个路径分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&quot;D:/CloundCode/QTC/bin/Win32/Debug/QTC/lib/qtc/plugins&quot;,</span><br><span class="line"> &quot;C:/Users/devstone/AppData/Local/QtProject/qtc/plugins/4.4.1&quot;)</span><br></pre></td></tr></table></figure>

<p>关于路径的获取可以看后面主程序加载部分可以看到</p>
<p><strong>读取插件信息</strong></p>
<blockquote>
<p>用于读取插件原对象信息，主要包含三个过程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readMetaData()</span><br><span class="line">resolveDependencies()</span><br><span class="line">pluginsChanged()</span><br></pre></td></tr></table></figure>
<ul>
<li>读元数据：这里会挨个读取每个插件，初始化 QPluginLoader，设置名字，为后面加载做准备，可以叫预加载，创建插件实例对象 PluginSpec，存储到 List 结构当中</li>
<li>检测依赖关系：：用于重新加载分析每个插件依赖关系，是一个双重循环，每个插件会和其它插件比较一次，最后按照插件名字进行排序</li>
<li>插件改变：向外抛出信号，插件管理窗口用来刷新 view 列表信息</li>
</ul>
<p><strong>加载插件</strong></p>
<blockquote>
<p>到了这里才开始真正加载插件了，主要包括下面几个流程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadQueue（）</span><br><span class="line">loadPlugins()</span><br><span class="line">(PluginSpec::Loaded)</span><br><span class="line">(PluginSpec::Initialized)</span><br><span class="line">(PluginSpec::Running)</span><br></pre></td></tr></table></figure>
<ul>
<li>依赖初始化</li>
<li>加载插件:这里里面才会真真去加载初始化每个插件,计算获取插件加载队列</li>
<li>加载(PluginSpec::Loaded):<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadPlugin(PluginSpec *spec, PluginSpec::State destState)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>调用 QPluginLoader.load()，真正加载插件，加载成功才可以获取每个插件方法,存储插件实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPlugin *pluginObject = qobject_cast&lt;IPlugin*&gt;(loader.instance());</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化(PluginSpec::Initialized)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadPlugin(PluginSpec *spec, PluginSpec::State destState)</span><br></pre></td></tr></table></figure>
  这里会调用每个插件的初始化函数：initialize(),该函数是纯虚函数，每个插件必须重新实现</li>
<li>运行(PluginSpec::Running)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadPlugin(PluginSpec *spec, PluginSpec::State destState)</span><br></pre></td></tr></table></figure>
  调用每个插件扩展初始化函数：extensionsInitialized（）,此时会挨个判断买个插件状态是否在运行，是的话加入到延迟队列</li>
<li>延迟初始化<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextDelayedInitialize（）</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>从延迟队列当中取出买个插件，调用各自延迟初始化函数：delayedInitialize（）</p>
</blockquote>
<p><strong>插件加载结束</strong></p>
<p>到此整个插件加载结束了，可以看出来，整个插件的加载过程说白了就是动态库加载解析然后调用每个动态库里面的虚函数来实现的，所有的插件都继承自共同的基类(接口)，原理很简单，但是要管理这些插件尤其是多种依赖关系并存情况下是非常不容易的</p>
<p>看到这里大家是不是很好奇，为啥不引用头文件直接可以调用动态库里面的方法了？这个主要使用 <code>QPluginLoader</code> 来实现动态加载动态库，这个类很好理解，详细使用可以看我之前写的 <code>SDK</code> 调用相关文章</p>
<p>包含了使用示例以及对应解析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T getFunction(QLibrary *lib, const char *symbol)</span><br><span class="line">&#123;</span><br><span class="line">    T f = (T)lib-&gt;resolve(func);</span><br><span class="line">    if (f == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNzY5NTQ1NQ==&mid=2247484281&idx=1&sn=9fa222c1b2f5e0f0d5c3f7cb230719ad&chksm=e85c0d49df2b845f7f59827b3758b5dfa3973679d6b7f5772f8e78d000fa92d4a156465ec4bb&token=201364907&lang=zh_CN#rd">如何使用 QLibrary 加载动态库</a></p>
<h2 id="核心插件"><a href="#核心插件" class="headerlink" title="核心插件"></a>核心插件</h2><p>学习了解清楚了插件如何管理，如何加载，下面来看看核心插件如何实现，以及如何实现自己的插件</p>
<h3 id="插件描述文件"><a href="#插件描述文件" class="headerlink" title="插件描述文件"></a>插件描述文件</h3><p>插件描述文件一般用于记录每个插件的基本信息，必须有，而且字段和用法都是固定的。名字一般取插件名字，结尾一般都是<code>.json.in</code></p>
<blockquote>
<p>看到这里是不是好奇，我记得自己第一次看到时也很好奇，为啥是<code>.in</code> 结尾，这个其实是一个模板文件，经过 <code>qmake</code> 构建后最终在临时目录下会生成最终的去掉<code>.in</code> 的文件</p>
</blockquote>
<p>Core.json.in</p>
<p>插件代码中包含该文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class CorePlugin : public ExtensionSystem::IPlugin</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PLUGIN_METADATA(IID &quot;org.qt-project.Qt.QtCreatorPlugin&quot; FILE &quot;Core.json&quot;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件内容大概如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    \<span class="string">&quot;Name\&quot; : \&quot;Core\&quot;,</span></span><br><span class="line"><span class="string">    \&quot;Version\&quot; : \&quot;$$QTCREATOR_VERSION\&quot;,</span></span><br><span class="line"><span class="string">    \&quot;CompatVersion\&quot; : \&quot;$$QTCREATOR_COMPAT_VERSION\&quot;,</span></span><br><span class="line"><span class="string">    \&quot;Required\&quot; : true,</span></span><br><span class="line"><span class="string">    \&quot;HiddenByDefault\&quot; : true,</span></span><br><span class="line"><span class="string">    \&quot;Vendor\&quot; : \&quot;The Qt Company Ltd\&quot;,</span></span><br><span class="line"><span class="string">    \&quot;Copyright\&quot; : \&quot;(C) $$QTCREATOR_COPYRIGHT_YEAR The Qt Company Ltd\&quot;,</span></span><br><span class="line"><span class="string">    \&quot;License\&quot; : [ \&quot;Commercial Usage\&quot;,</span></span><br><span class="line"><span class="string">                  \&quot;\&quot;,</span></span><br><span class="line"><span class="string">                  \&quot;Licensees holding valid Qt Commercial licenses may use this plugin in accordance with the Qt Commercial License Agreement provided with the Software or, alternatively, in accordance with the terms contained in a written agreement between you and The Qt Company.\&quot;,</span></span><br><span class="line"><span class="string">                  \&quot;\&quot;,</span></span><br><span class="line"><span class="string">                  \&quot;GNU General Public License Usage\&quot;,</span></span><br><span class="line"><span class="string">                  \&quot;\&quot;,</span></span><br><span class="line"><span class="string">                  \&quot;Alternatively, this plugin may be used under the terms of the GNU General Public License version 3 as published by the Free Software Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT included in the packaging of this plugin. Please review the following information to ensure the GNU General Public License requirements will be met: https://www.gnu.org/licenses/gpl-3.0.html.\&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    \&quot;Category\&quot; : \&quot;Qt Creator\&quot;,</span></span><br><span class="line"><span class="string">    \&quot;Description\&quot; : \&quot;The core plugin for the Qt IDE.\&quot;,</span></span><br><span class="line"><span class="string">    \&quot;Url\&quot; : \&quot;http://www.qt.io\&quot;,</span></span><br><span class="line"><span class="string">    \&quot;Arguments\&quot; : [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            \&quot;Name\&quot; : \&quot;-color\&quot;,</span></span><br><span class="line"><span class="string">            \&quot;Parameter\&quot; : \&quot;color\&quot;,</span></span><br><span class="line"><span class="string">            \&quot;Description\&quot; : \&quot;Override selected UI color\&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            \&quot;Name\&quot; : \&quot;-theme\&quot;,</span></span><br><span class="line"><span class="string">            \&quot;Parameter\&quot; : \&quot;default|dark\&quot;,</span></span><br><span class="line"><span class="string">            \&quot;Description\&quot; : \&quot;Choose a built-in theme or pass a .creatortheme file\&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            \&quot;Name\&quot; : \&quot;-presentationMode\&quot;,</span></span><br><span class="line"><span class="string">            \&quot;Description\&quot; : \&quot;Enable presentation mode with pop-ups for key combos\&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    $$dependencyList</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其实就是一个标准的 <code>json</code> 配置文件，每个字段都很清楚，可能有些变量值不清楚，这里一起学习下。比如版本号字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&quot;Version\&quot; : \&quot;$$QTCREATOR_VERSION\&quot;,</span><br></pre></td></tr></table></figure>

<p>很明显后面是一个变量值，也可以说是宏定义，我们一般定义 <code>json</code> 配置都是固定值，这里采用动态配置方法，其中 <code>QTCREATOR_VERSION</code> 变量是在 <code>pro</code> 工程中定义的</p>
<p>这样做有什么好处呢？想一想</p>
<p>是不是我们下次变更版本号的时候，直接在 <code>pro</code> 文件中更改一次，其它引用到该变量的地方都自动同步了，是不是很方便而且可以减少很多出错(这就是软件开发当中的封装思想)</p>
<p>其实，除过在配置文件中可以引用变量以外，在代码中也可以直接引用，关于如何使用，可以看我之前写的一篇文章，详细介绍了原理以及实现方法</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNzY5NTQ1NQ==&mid=2247484160&idx=1&sn=f9a8d86d093258168f7099726270a75d&chksm=e85c0d30df2b8426b9732c8399312da789e8644a14d01d105653c87fbbc539c7cdc4326ced42&token=201364907&lang=zh_CN#rd">qmake奇淫技巧之字符串宏定义</a></p>
<h3 id="核心插件初始化"><a href="#核心插件初始化" class="headerlink" title="核心插件初始化"></a>核心插件初始化</h3><p>核心插件主要初始化基本界面结构，包含一个 <code>QMainWindow</code> 、菜单栏、状态栏、模式工具栏、多窗口面板等等</p>
<p>正如第一篇笔记当中写到，如果只编译核心插件，那么运行后整个界面张这个样子</p>
<p><img src="https://gitee.com/devstone/imageBed/raw/master/images/202112192158402.png"></p>
<p>可以看到仅仅包含基本菜单，插件查看，状态栏等内容</p>
<p>每个插件都需要实现自己的初始化函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool CorePlugin::initialize(const QStringList &amp;arguments, QString *errorMessage)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化函数当中首先要注册所有插件的 <code>mime type</code> 类型，这个是从插件元数据当中读取的，会跳过已经关闭的插件</p>
<p>接着初始化系统主题，主题其实和我们经常用的 <code>qss</code> 样式表类似，大概张这个样子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">ThemeName=Flat Dark</span><br><span class="line">PreferredStyles=Fusion</span><br><span class="line">DefaultTextEditorColorScheme=creator-dark.xml</span><br><span class="line"></span><br><span class="line">[Palette]</span><br><span class="line">shadowBackground=ff404244</span><br><span class="line">text=ffd0d0d0</span><br><span class="line">textDisabled=60a4a6a8</span><br><span class="line">toolBarItem=b6fbfdff</span><br></pre></td></tr></table></figure>

<p>其实就是一个<code>.ini</code> 文件格式的内容，定义了很多界面样式相关变量字段，这些字段会一一映射到对应主题管理类当中，这样相关界面设置样式就可以直接调用了</p>
<p>接着也是一个很重要的模块，初始化菜单管理类，这个类管理了菜单栏所有的菜单&#x2F;Action，以供其它插件模块访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new ActionManager(this);</span><br><span class="line">    ActionManager::setPresentationModeEnabled(args.presentationMode);</span><br></pre></td></tr></table></figure>

<p><code>ActionManager</code> 这个类是一个特殊的单例类，单例对象初始化只能在核心插件当中，虽然提供了单例返回接口，但是首次如果没有初始化对象返回的是 <code>空指针</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class CORE_EXPORT ActionManager : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    static ActionManager *instance();</span><br><span class="line">private:</span><br><span class="line">    ActionManager(QObject *parent = 0);</span><br><span class="line">    ~ActionManager();</span><br><span class="line"></span><br><span class="line">    friend class Core::Internal::CorePlugin; // initialization</span><br><span class="line">    friend class Core::Internal::MainWindow; // saving settings and setting context</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static ActionManager *m_instance = 0;</span><br><span class="line">ActionManager *ActionManager::instance()</span><br><span class="line">&#123;</span><br><span class="line">    return m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有才有了后面两个友元类的声明了，这样可以直接访问并且初始化对象实例了，核心插件初始化完成后，其它地方可以直接调用单例函数了</p>
<p>接着就是主界面初始化，初始化 <code>mainWindow</code> 实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m_mainWindow = new MainWindow;</span><br><span class="line">    if (args.overrideColor.isValid())</span><br><span class="line">        m_mainWindow-&gt;setOverrideColor(args.overrideColor);</span><br><span class="line">    qsrand(QDateTime::currentDateTime().toTime_t());</span><br><span class="line">    const bool success = m_mainWindow-&gt;init(errorMessage);</span><br></pre></td></tr></table></figure>

<p>主界面实例初始化后，接着会调用主界面的初始化函数，主界面真正初始化了多插件界面实现，如果想要学习多插件界面是如何实现的，可以重点关注下这个初始化函数</p>
<p>最后是编辑模式、查找相关功能初始化，这些功能不是本次重点，后面有需要再详细看实现思想</p>
<h3 id="主界面初始化"><a href="#主界面初始化" class="headerlink" title="主界面初始化"></a>主界面初始化</h3><p>主界面和我们平时创建项目使用的 <code>QMainWindow</code> 没有两样，最大的区别就是 <code>Qt Creator</code> 把界面上所有的操作都进行了封装管理，这样其它插件也可以进行访问，更好的对界面系统进行了扩展</p>
<p>主界面我们重点来学习了菜单栏的使用，看看是如何封装管理的</p>
<p>主要涉及到下面几个类</p>
<ul>
<li>ActionContainer</li>
<li>ActionContainerPrivate</li>
<li>MenuActionContainer</li>
<li>MenuBarActionContainer</li>
<li>ActionManager</li>
</ul>
<p>这些类的关系如下所示</p>
<p><img src="https://gitee.com/devstone/imageBed/raw/master/images/202112192256200.png"></p>
<p>其中 <code>ActionContainer</code> 对象是基类，向外部所有插件暴露，后面访问某个菜单大部分场景是返回该类指针的</p>
<p><code>MenuActionContainer</code> 是菜单栏当中的菜单对象，可以包含 <code>n</code> 个菜单</p>
<p><code>MenuBarActionContainer</code> 是我们的菜单栏，整个 <code>MainWindows</code> 仅此一份实例</p>
<p>最后就是 <code>ActionManager</code> 类了，我们所有的操作均是通过该类来进行，很显然它是一个单例类，而且整个系统都是可以访问的</p>
<ul>
<li>创建菜单栏<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActionContainer *menubar = ActionManager::createMenuBar(Constants::MENU_BAR);</span><br><span class="line"></span><br><span class="line">if (!HostOsInfo::isMacHost()) // System menu bar on Mac</span><br><span class="line">    setMenuBar(menubar-&gt;menuBar());</span><br></pre></td></tr></table></figure></li>
<li>创建文件菜单</li>
</ul>
<p>可以看到使用是来是非常方便的，而且这种通过传入字符串创建菜单的方式也简单理解，外部使用的人员完全不用了解函数内部是怎么实现的，只需要根据自己需要传入规定格式的字符串即可</p>
<p>每个菜单都有唯一的字符串 <code>ID</code> 来进行区分，字符串命名严格按照菜单格式，比如</p>
<p>这样的格式也很好理解， <code>Menu</code> 相当于是大菜单，后面一级是每个子菜单，如果该菜单还有子菜单，那么继续扩展下去</p>
<p>其它界面菜单栏菜单创建和上面的过程是类似的，可以照猫画虎写出来</p>
<ul>
<li>创建每个 Action</li>
</ul>
<p>上面创建了界面的菜单栏，但是每个菜单下面还是空的，需要创建对应的 <code>Action</code> 才行，下面来看看是怎么创建的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ActionContainer *mfile = ActionManager::actionContainer(Constants::M_FILE);</span><br><span class="line">    </span><br><span class="line">    mfile-&gt;addSeparator(Constants::G_FILE_SAVE);</span><br><span class="line"></span><br><span class="line">    // Open Action</span><br><span class="line">    QIcon icon = QIcon::fromTheme(QLatin1String(&quot;document-open&quot;), Utils::Icons::OPENFILE.icon());</span><br><span class="line">    QAction *m_openAction = new QAction(icon, tr(&quot;&amp;Open File or Project...&quot;), this);</span><br><span class="line">    Command *cmd = ActionManager::registerAction(m_openAction, Constants::OPEN);</span><br><span class="line">    cmd-&gt;setDefaultKeySequence(QKeySequence::Open);</span><br><span class="line">    mfile-&gt;addAction(cmd, Constants::G_FILE_OPEN);</span><br><span class="line">    connect(m_openAction, &amp;QAction::triggered, this, &amp;MainWindow::openFile);</span><br></pre></td></tr></table></figure>

<p>第一行代码通过菜单管理器返回上面创建的「文件」菜单指针，第二行添加了一个分隔符，后面创建了一个 <code>Command</code> 对象，这个类是对每个 <code>QAction</code> 进行了封装，同时支持设置快捷键等操作，这样我们后续的操作就相当于是一个 <code>command</code></p>
<p>这样我们的菜单栏就创建初始化完成了，剩下的就是左侧模式工具条以及中央内容区域的创建了</p>
<p>限于篇幅原因，这些内容我们后面在看</p>
<h2 id="App-程序初始化"><a href="#App-程序初始化" class="headerlink" title="App 程序初始化"></a>App 程序初始化</h2><p>前面花费了大量篇幅来介绍插件的管理以及主界面的实现，下面我们来看看主程序是如何初始化的</p>
<p>主函数 <code>main.cpp</code> 里面的内容挺多的，我们看主要加载流程就行了</p>
<ul>
<li>设置系统配置对象指针<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QSettings *settings = userSettings();</span><br><span class="line">    QSettings *globalSettings = new QSettings(QSettings::IniFormat, QSettings::SystemScope,</span><br><span class="line">                                              QLatin1String(Core::Constants::IDE_SETTINGSVARIANT_STR),</span><br><span class="line">                                              QLatin1String(&quot;QTC&quot;));</span><br><span class="line">    PluginManager pluginManager;</span><br><span class="line">    PluginManager::setPluginIID(QLatin1String(&quot;org.qt-project.Qt.QtCreatorPlugin&quot;));</span><br><span class="line">    PluginManager::setGlobalSettings(globalSettings);</span><br><span class="line">    PluginManager::setSettings(settings);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>主要是系统当中的一些配置，插件管理器需要记录那些插件被禁用了，这样在后面插件初始化时可以跳过了</p>
<p>其中很重要的设置插件 <code>ID</code> ，这个作为插件唯一标识符，用来区分恶意插件，如果别人不知道你的软件插件 <code>IID</code> ，那么他编写的插件放入你程序目录下是可以直接通过这个 <code>IID</code> 过滤掉的</p>
<ul>
<li>设置插件路径<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const QStringList pluginPaths = getPluginPaths() + customPluginPaths;</span><br><span class="line">    PluginManager::setPluginPaths(pluginPaths);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这里的插件路径包含了两部分，一部分是我们程序目录下的插件目录，另一个是公共目录,比如下面这个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&quot;D:/CloundCode/QTC/bin/Win32/Debug/QTC/lib/qtc/plugins&quot;, &quot;C:/Users/devstone/AppData/Local/QtProject/qtc/plugins/4.4.1&quot;)</span><br></pre></td></tr></table></figure>

<p>这一步走完后，如果没有错误整个插件都加载完成了</p>
<ul>
<li>异常判断</li>
</ul>
<p>想法是美好的，但是事实总不如愿，插件在加载过程中可能会遇到一些问题导致加载异常，这样程序就无法正常运行了，需要抛出错误给用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const PluginSpecSet plugins = PluginManager::plugins();</span><br><span class="line">    PluginSpec *coreplugin = 0;</span><br><span class="line">    foreach (PluginSpec *spec, plugins) &#123;</span><br><span class="line">        if (spec-&gt;name() == QLatin1String(corePluginNameC)) &#123;</span><br><span class="line">            coreplugin = spec;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!coreplugin) &#123;</span><br><span class="line">        QString nativePaths = QDir::toNativeSeparators(pluginPaths.join(QLatin1Char(&#x27;,&#x27;)));</span><br><span class="line">        const QString reason = QCoreApplication::translate(&quot;Application&quot;, &quot;Could not find Core plugin in %1&quot;).arg(nativePaths);</span><br><span class="line">        displayError(msgCoreLoadFailure(reason));</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!coreplugin-&gt;isEffectivelyEnabled()) &#123;</span><br><span class="line">        const QString reason = QCoreApplication::translate(&quot;Application&quot;, &quot;Core plugin is disabled.&quot;);</span><br><span class="line">        displayError(msgCoreLoadFailure(reason));</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (coreplugin-&gt;hasError()) &#123;</span><br><span class="line">        displayError(msgCoreLoadFailure(coreplugin-&gt;errorString()));</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码对核插件加载状况进行了判断，如果有错误没有加载完成或者被禁用了，那么就直接返回了。理论上来说核心插件是无法被禁用的，但是如果有人恶意修改配置文件禁用了核心插件，那么此时程序会无法正常启动的</p>
<ul>
<li>加载插件</li>
</ul>
<p>这一步其实是最重要的，上面设置插件路径后仅仅是读取每个插件对象，此时这些对应都是静态的，到了这一步才真正动起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PluginManager::loadPlugins();</span><br><span class="line">if (coreplugin-&gt;hasError()) &#123;</span><br><span class="line">    displayError(msgCoreLoadFailure(coreplugin-&gt;errorString()));</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于插件加载这个流程最前面插件管理器当中介绍清楚了，这里我们直接略过就行了</p>
<p>好了关于插件加载学习就到这里了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>插件部分内容还是挺长，初次学习源码的朋友可能会感觉到无从下手、一脸茫然，不用担心，我第一次也是这种感觉，遇到不懂不理解的小标记下，先理解掌握整体设计思想和流程，再慢慢逐个模块攻破</p>
<p>软件开发也是这个道理，一开始你不可能考虑到所有模块细节，把握整体结构没有问题，再挨个实现细节部分</p>
<p><code>Qt Creator</code> 非常值得我们多看、多写的，所谓好事多磨么，看的多了也就明白了一些道理</p>
<p>我们日常开发过程中遇到的一些问题，可能 <code>Qt Creator</code> 当中早就实现好了，可以直接拿来使用，比如像奔溃 <code>dump</code> 管理、日志管理、网络通信、特殊控件实现等都可以拿来直接用的</p>
<p>希望本次分享的笔记对你有帮助，如果觉得有用不妨关注下，有任何问题可以互相交流学习</p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNzY5NTQ1NQ==&mid=2247484658&idx=1&sn=55af25cd6e608fa9cb1452610928e71b&chksm=e85c0ac2df2b83d453d80f66fcdefca31e998a8ac0ba0226edbd80b437f99ed5184478805d8e&scene=21#wechat_redirect">Qt Creator 源码学习笔记01，初识QTC</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNzY5NTQ1NQ==&mid=2247484676&idx=1&sn=c1bd8cbd78d8e098c22353f567cc3620&chksm=e85c0b34df2b822288a7baa016f4a64df47e5e119039836ff686cb2ad3a7e28a5808efc0c13a&scene=21#wechat_redirect">Qt Creator 源码学习笔记02，认识框架结构结构</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNzY5NTQ1NQ==&mid=2247484701&idx=1&sn=c69eb1edfb551c41690938423ca2ef7c&chksm=e85c0b2ddf2b823b1179f216e57ca91b9ce4068a0469e8ba062ab3596e9dc51ac05a1572da85&scene=21#wechat_redirect">Qt Creator 源码学习笔记03，大型项目如何管理工程</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNzY5NTQ1NQ==&mid=2247484767&idx=1&sn=971c14682095a8a84a8161311400100f&chksm=e85c0b6fdf2b82799db871eafb6d0b2465c75d8020b1f87a1f5825f82edcad2c051b7d6e1c2c&scene=21#wechat_redirect">Qt Creator 源码学习笔记04，多插件实现原理分析</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNzY5NTQ1NQ==&mid=2247484822&idx=1&sn=eff40e19952a534fc0d97cab2417ce9e&chksm=e85c0ba6df2b82b017eb568adacd5b407f269cc2c2e7d2c36609fdda76b029bdcd70003fadba&token=193645825&lang=zh_CN#rd">Qt Creator 源码学习笔记 05，菜单栏是怎么实现插件化的？</a></li>
</ul>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作者:鹅卵石</span><br><span class="line">时间: 2021年12月22日23:24:16</span><br><span class="line">版本:V 0.0.1</span><br><span class="line">邮箱:kevinlq@163.com</span><br><span class="line">版权:本博客若无特别声明，均属于作者原创文章，欢迎大家转载分享。但是，</span><br><span class="line">希望您注明来源，并留下原文地址，这是对作者最大的尊重，也是对知识的尊重。</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>如果您对本文有任何问题，可以在下方留言，或者Email我.</strong></p>
<h2 id="捐赠"><a href="#捐赠" class="headerlink" title="捐赠"></a>捐赠</h2><p>如果觉得分享的内容不错，可以请作者喝杯咖啡.</p>
</article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>License</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Newer</div><a href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt-Creator-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%EF%BC%8C%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%B7%A5%E7%A8%8B/">Qt Creator 源码学习笔记03，大型项目如何管理工程</a></div><div class="item" id="next"><div class="note">Older</div><a href="/2025/07/24/2-%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6-Qt-Qt5-4-2%E7%A7%BB%E6%A4%8D%E5%88%B0ARM%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A/">Qt5.4.2移植到ARM开发板上</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">liuluhua</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">On This Page</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%BB%84%E6%88%90"><span class="toc-text">插件组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">插件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-text">插件管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E6%B1%A0"><span class="toc-text">对象管理池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86-1"><span class="toc-text">插件管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-text">插件加载流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8F%92%E4%BB%B6"><span class="toc-text">核心插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6"><span class="toc-text">插件描述文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8F%92%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">核心插件初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%95%8C%E9%9D%A2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">主界面初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#App-%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">App 程序初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB"><span class="toc-text">相关阅读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%90%E8%B5%A0"><span class="toc-text">捐赠</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>Scroll to Top</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `Just`,
      min: `minutes ago`,
      hour: `hours ago`,
      day: `days ago`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `Switched to Light Mode`,
      dark: `Switched to Dark Mode`,
      auto: `Switched to Auto Mode`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>

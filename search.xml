<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI应用软件记录</title>
    <url>/2024/05/24/AI-AI%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Sora</p>
<p>Stable Diffusion</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>AnythingLLM笔记</title>
    <url>/2024/05/17/AI-AnythingLLM%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>RAG检索知识体系</title>
    <url>/2024/05/17/AI-RAG%E6%A3%80%E7%B4%A2%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="Windows-本地部署-Ollama-AnythingLLM-解读本地文档-构建私有知识库"><a href="#Windows-本地部署-Ollama-AnythingLLM-解读本地文档-构建私有知识库" class="headerlink" title="Windows 本地部署 Ollama + AnythingLLM 解读本地文档 构建私有知识库"></a>Windows 本地部署 Ollama + AnythingLLM 解读本地文档 构建私有知识库</h1><p>现阶段切入大模型应用落地最合适的方案依然是结合大模型基于 RAG 检索增强来实现知识库的检索和生存。从而构建个人或者企业私有化的本地知识库。</p>
<p>你只需要将本地私有的 PDF、Word 文档和文本文件嵌入到本地向量库，连接上 LLM，然后就可以通过对话、搜索的方式进行回答问题、提供见解，甚至生成摘要。</p>
<p>Ollama 下载地址 <a href="https://ollama.com/download">https://ollama.com/download</a></p>
<p>Ollama 配置文档 <a href="ollama%E7%AC%94%E8%AE%B0.md">ollama笔记</a></p>
<p>AnythingLLM 下载地址 <a href="https://useanything.com/download">https://useanything.com/download</a></p>
<p>AnythingLLM 配置文档 <a href="AnythingLLM%E7%AC%94%E8%AE%B0.md">AnythingLLM笔记</a></p>
<blockquote>
<p><strong>AnythingLLM</strong> 是 Mintplex Labs Inc. 开发的一个基于 RAG（Retrieval-Augmented Generation）方案构建的开源、高效、可定制的私有知识库解决方案，一款开源 ChatGPT 等效工具，用于在安全的环境中与文档等进行聊天，专为想要使用现有文档进行智能聊天或构建知识库的任何人而构建。</p>
<p><strong>AnythingLLM 能够把各种文档、资料或者内容转换成一种格式</strong>，让 LLM（如 ChatGPT）在聊天时可以引用这些内容。然后你就可以用它来和各种文档、内容、资料聊天，<strong>支持多个用户同时使用，还可以设置谁能看或改哪些内容。</strong> <strong>支持多种 LLM、嵌入器和向量数据库。</strong></p>
</blockquote>
<p>Open WebUI 安装地址 <a href="https://github.com/v1cc0/open-webui">https://github.com/v1cc0/open-webui</a></p>
<ol>
<li><p>安装 Ollama 工具后，在命令行输入 ollama pull qwen:4b 下载模型 千问 4b 的模型，也可以下载其他模型 ，支持的模型列表：<a href="https://ollama.com/library%E3%80%82">https://ollama.com/library。</a></p>
</li>
<li><p>要开始运行 Ollama 的话，只需要在命令行输入 ollama run qwen:4b 就可以使用并访问这个模型了。</p>
</li>
<li><p>接下来我们需要安装向量模型和数据库，在 <a href="https://ollama.com/%E9%87%8C%E9%9D%A2%E6%90%9C%E7%B4%A2">https://ollama.com/里面搜索</a> nomic-embed-text ，这个模型可以将文本内容转换成向量数据，里面是模型介绍。</p>
</li>
<li><p>安装模型可以在命令行输入 ollama pull nomic-embed-text 进行下载和安装。</p>
</li>
<li><p>安装 AnythingLLM 工具后打开初始化界面，会进入到配置页面，在 LLM Preference 选项卡中，选择 Ollama，然后配置 <a href="http://127.0.0.1:11434/">http://127.0.0.1:11434</a> 、选择运行的大模型 qwen:4b ，token 填 8192 </p>
</li>
<li><p>下一步是配置 Embedding Preference 选项卡中，一样选择 Ollama，然后配置 <a href="http://127.0.0.1:11434/">http://127.0.0.1:11434</a> 、选择运行的大模型 nomic-embed-text ，length 填 512 </p>
</li>
<li><p>下一步是配置 Vector Database ，选择默认的 LanceDB ，这是内置的向量数据库，如果想用云端数据库，可以选择 Pinecone 进行云端配置。</p>
</li>
<li><p>后面就是按提示下一步下一步，如果是要加新的工作空间，可以点 new workspace 来增加不同场景下的工作空间。如果需要更换模型，可以点左下角的配置按钮，重新执行上面三步完成配置。</p>
<p>到这里环境已经部署了，这时你已经可以跟大模型进行对话了。</p>
</li>
<li><p>接下来的步骤是对私有知识库的内容进行分析和获取。需要将文档上传到 AnythinLLM，通过 nomic-embed-text 模型进行向量转换，然后存在向量数据库中。最后通过提问，去向量数据库获取内容并分析回答。</p>
<blockquote>
<p>Data Connectors 是一种工具，它允许用户将外部数据源无缝集成到他们的 AnythingLLM 工作空间中，而无需编写任何自定义代码或处理复杂的配置。这些经过验证的数据连接器确保与你的 AnythingLLM 实例兼容，提供了一种简单且直接的方式来扩展你的工作空间功能。</p>
<p>以下是一些可用的数据连接器及其功能：</p>
<ol>
<li><p><strong>GitHub Repo</strong>:</p>
<p>- 通过这个连接器，你可以一键导入整个公共或私有的 GitHub 仓库到你的 AnythingLLM 工作空间中。</p>
<p>- 访问 <a href="%5Bhttps://github.com%5D(https://github.com/)">GitHub</a> 来获取你想要导入的仓库的链接。</p>
<p>- 这个功能对于开发者和团队来说非常有用，因为它允许他们直接在 AnythingLLM 中管理和查看代码库，跟踪问题和特性请求，以及审查代码。</p>
</li>
<li><p><strong>YouTube Transcript</strong>:</p>
<p>- 这个连接器允许你从 YouTube 视频链接导入整个视频的转录文本。</p>
<p>- 只需提供 YouTube 视频的链接，就可以轻松获取视频的文字内容。</p>
<p>- 这对于需要分析视频内容、创建视频摘要或者进行视频内容相关的研究的用户来说非常有用。</p>
</li>
</ol>
<p>使用这些数据连接器，你可以快速地将外部数据集成到你的工作流程中，从而提高效率和生产力。例如，如果你正在研究一个特定的编程问题，你可以直接导入相关的 GitHub 仓库来查看代码和文档；或者，如果你需要分析一个教育视频的内容，你可以导入视频的转录文本来进行文本分析。</p>
<p>这些连接器的使用通常涉及到在 AnythingLLM 工作空间中选择相应的连接器，然后按照提示输入必要的信息，如仓库链接或视频链接，之后就可以开始导入数据了。整个过程简单直观，无需专业的编程知识，使得用户可以专注于数据分析和决策，而不是技术细节。</p>
</blockquote>
</li>
<li><p>在工作空间页面上有一个上传文档的按钮，点击可以上传我们的文档内容。上传后选中文档，点击 Save and Embed ，等待一段时间，让模型进行向量转换和保存。</p>
</li>
<li><p>然后回到主界面点击工作空间的设置，选择 Chat Setting 选项卡，这里对话模式选择 Query ，这个模式是指只从提供的文档内容进行查找分析，而不要求大语言模型里面提供的信息作答。最后点击 Update workspace 进行更新。</p>
</li>
<li><p>然后就可以进行提问了，以上是本地部署应用的地方，如果你的电脑不太行，可以装 Ollama 部署在云端 GPU 服务器，然后本地安装 AnythingLLM，在选择 URL 上填写云端 Ollama 的地址即可。</p>
<blockquote>
<p><strong>配置 LLM</strong><br>这里选择 Ollama 作为后台的服务，URL 这里填写 <code>http://127.0.0.1:11434</code>，也就是前面 Ollama 启动的服务端口，填写后 LLM 模型选择 <code>gemma:2b</code></p>
<p><strong>配置 Embedding Model</strong><br>这里同样选择 Ollama 作为后台的服务，URL 这里同样填写 <code>http://127.0.0.1:11434</code>，填写后 Embedding Model 选择 <code>nomic-embed-text:latest</code></p>
<p><strong>配置 Vector Database</strong><br>Vector Database 选择默认的第一个 <code>LanceDB</code></p>
<p>以上三个关键配置完成后，就可以开始使用 AnythingLLM 了。</p>
<p><strong>创建文档库</strong><br>点击 <code>New Workspace</code> 新建文档库，并填写名称<br>点击按钮开始添加文档<br>我们使用的文档是 <code>paul_graham_essay.txt</code>，这个文档也可以从 github 上下载：<a href="https://github.com/xinsblog/try-llama-index/blob/master/data/paul_graham_essay.txt">https://github.com/xinsblog/try-llama-index/blob/master/data/paul_graham_essay.txt</a> 。</p>
<p>添加文档后还要将文档 <code>Move to Workspace</code><br>然后点击 <code>Save and Embed</code><br>出现 <code>Workspace updated successfully</code> 就表示配置已经完成</p>
<p><strong>开始测试</strong><br>回到主页面，输入问题 <code>What did the author do in 9th grade?</code><br>几秒钟后就可以看到 AnythingLLM 给出的回答</p>
</blockquote>
</li>
<li><p>第三个工具就是 Open WebUI，此工具可以支持云端部署 web 界面，在浏览器上访问大模型。</p>
</li>
<li><p>前置需要安装 Docker，具体安装步骤可以看 <a href="https://github.com/v1cc0/open-webui">https://github.com/v1cc0/open-webui</a> 上面的安装步骤，这里就不再赘述。</p>
</li>
<li><p>安装完后输入 github 上的指令即可连通 Ollama，并进行使用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>ollama笔记</title>
    <url>/2024/05/17/AI-ollama%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>支持的模型</p>
<p><a href="https://ollama.com/library">https://ollama.com/library</a></p>
<h1 id="在用的-ollama-模型"><a href="#在用的-ollama-模型" class="headerlink" title="在用的 ollama 模型"></a>在用的 ollama 模型</h1><p>ollama.exe list</p>
<p>ollama run llama3:8b</p>
<p>ollama run codellama:7b</p>
<p>ollama run qwen:14b</p>
<p>ollama run starcoder2:7b</p>
<p>ollama run nomic-embed-text</p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>SIZE</th>
<th>FEATURES</th>
</tr>
</thead>
<tbody><tr>
<td>codellama:latest</td>
<td>3.8 GB</td>
<td></td>
</tr>
<tr>
<td>llama3:latest</td>
<td>4.7 GB</td>
<td></td>
</tr>
<tr>
<td>starcoder2:3b</td>
<td>1.7 GB</td>
<td></td>
</tr>
<tr>
<td>qwen:4b</td>
<td></td>
<td></td>
</tr>
<tr>
<td>nomic-embed-text</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>新建系统环境变量，变量名：<code>OLLAMA_MODELS</code>，变量值中指定模型位置</p>
<p><a href="https://huggingface.co/">https://huggingface.co/</a></p>
<p><a href="https://github.com/LlamaFamily/Llama-Chinese?tab=readme-ov-file">https://github.com/LlamaFamily/Llama-Chinese?tab=readme-ov-file</a></p>
<h1 id="Ollama-on-Linux"><a href="#Ollama-on-Linux" class="headerlink" title="Ollama on Linux"></a>Ollama on Linux</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure>

<h1 id="Ollama-使用"><a href="#Ollama-使用" class="headerlink" title="Ollama 使用"></a>Ollama 使用</h1><h1 id="Ollama-大模型联网"><a href="#Ollama-大模型联网" class="headerlink" title="Ollama 大模型联网"></a>Ollama 大模型联网</h1><h2 id="Python-及库"><a href="#Python-及库" class="headerlink" title="Python 及库"></a>Python 及库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure>

<h2 id="定义联网函数"><a href="#定义联网函数" class="headerlink" title="定义联网函数"></a>定义联网函数</h2><p>需要定义一个联网函数，用于与互联网上的服务器进行通信。这个函数可以发送 HTTP 请求，接收服务器的响应，并返回结果。以下是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connect_to_server</span>(<span class="params">url, data</span>):</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;</span><br><span class="line">    response = requests.post(url, data=json.dumps(data), headers=headers)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error connecting to server:&quot;</span>, response.status_code)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-Ollama"><a href="#配置-Ollama" class="headerlink" title="配置 Ollama"></a>配置 Ollama</h2><p>在联网之前，我们需要对 Ollama 大模型进行一些配置。这包括设置模型的参数、训练数据和测试数据等。具体的配置方法取决于你所使用的 Ollama 大模型。以下是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置模型参数</span></span><br><span class="line">model_params = &#123;</span><br><span class="line">    <span class="string">&quot;learning_rate&quot;</span>: <span class="number">0.001</span>,</span><br><span class="line">    <span class="string">&quot;num_epochs&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">&quot;batch_size&quot;</span>: <span class="number">32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载训练数据和测试数据</span></span><br><span class="line">train_data = load_train_data()</span><br><span class="line">test_data = load_test_data()</span><br></pre></td></tr></table></figure>

<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>在配置好 Ollama 大模型后，我们可以开始训练模型。训练过程中，我们可以使用之前定义的联网函数将模型的中间结果上传到服务器上。以下是一个示例：</p>
<pre><code>for epoch in range(model_params[&quot;num_epochs&quot;]):
    # 训练模型
    train_model(train_data, model_params)

    # 将中间结果上传到服务器
    url = &quot;http://example.com/upload&quot;
    data = &#123;
        &quot;epoch&quot;: epoch,
        &quot;loss&quot;: get_current_loss(),
        &quot;accuracy&quot;: get_current_accuracy()
    &#125;
    connect_to_server(url, data)
</code></pre>
<h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><p>训练完成后，我们可以使用测试数据对模型进行测试。同样，我们可以使用联网函数将测试结果上传到服务器上。以下是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试模型</span></span><br><span class="line">test_model(test_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将测试结果上传到服务器</span></span><br><span class="line">url = <span class="string">&quot;http://example.com/upload&quot;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;test_loss&quot;</span>: get_test_loss(),</span><br><span class="line">    <span class="string">&quot;test_accuracy&quot;</span>: get_test_accuracy()</span><br><span class="line">&#125;</span><br><span class="line">connect_to_server(url, data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过以上步骤，我们已经成功地让 Ollama 大模型联网了。在实际应用中，你可能需要根据具体的需求和环境进行调整和优化。希望本文能够帮助你更好地理解和应用 Ollama 大模型的联网功能。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo博客建设</title>
    <url>/2024/05/17/%E5%8D%9A%E5%AE%A2-Hexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/</url>
    <content><![CDATA[<ol>
<li>√ 博客框架采用 Hexo </li>
<li>√ 部署到 GitHubPages（）</li>
<li>√ 部署到 Vercel（GitHub Publish）</li>
<li>× 通过 Netlify 部署和构建</li>
<li>√ 利用 Obsidian Digital Garden&#x2F;Flowershow 插件在 Vercel 上将笔记内容部署为 Obsidian 数字花园</li>
</ol>
<h1 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h1><ul>
<li>创建 GitHub 发布仓库 <a href="#GitHub%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2">GitHub仓库部署</a></li>
<li>创建 GitHub 源码仓库，并在仓库中部署 Hexo</li>
<li>在源码仓库中创建工作流，工作流主要完成任务是在接收到同步后，完成以下几个动作 <a href="#GitHub%20Actions">GitHub Actions</a><ul>
<li>构建静态页面生成 public 文件夹，在构建之前需要调用 hexo 插件自动生成 category 信息</li>
<li>将 public 文件夹拷贝至发布仓库</li>
</ul>
</li>
</ul>
<h1 id="确定-Hexo-仓库部署在-GitHub-还是本地"><a href="#确定-Hexo-仓库部署在-GitHub-还是本地" class="headerlink" title="确定 Hexo 仓库部署在 GitHub 还是本地"></a>确定 Hexo 仓库部署在 GitHub 还是本地</h1><h2 id="如果部署在-GitHub"><a href="#如果部署在-GitHub" class="headerlink" title="如果部署在 GitHub"></a>如果部署在 GitHub</h2><p>则需要整个仓库拉取到 obsidian，主要显示 post 下文件，需要通过 github actions 进行发布管理</p>
<p>优点：本地不需要 Hexo 环境，直接提交后自动构建页面</p>
<p>缺点：所有源码都在 Github 且仓库必须公开</p>
<h2 id="如果部署在本地"><a href="#如果部署在本地" class="headerlink" title="如果部署在本地"></a>如果部署在本地</h2><p>需要在本地生成静态网页，之后将静态网页通过 publisher 发布 public 文件夹到 github 仓库</p>
<p>优点：仓库可以不开源</p>
<p>缺点：本地需要具有 Hexo 环境，且需要在本地生成静态网页</p>
<h2 id="两个仓库都在-Github"><a href="#两个仓库都在-Github" class="headerlink" title="两个仓库都在 Github"></a>两个仓库都在 Github</h2><p>是否可以实现，编辑完成后，github 从源码仓库复制到发布仓库？</p>
<p>源码仓库闭源，同步笔记到源码仓库后，源码仓库通过 actions 时触发同步到发布仓库，更新发布仓库页面</p>
<p><em>扩展：三仓库管理，Markdown 仓库只用于编辑 Markdown 文件，同步后触发 actions，同步到源码仓库中的 post，源码仓库接受到 push 后，触发 actions 生成静态页面 public，public 生成完成后拷贝 public 到发布仓库利用 actions，可以实现，感觉没啥必要，太过复杂了，源码仓库 + 发布仓库基本就可以了</em></p>
<h2 id="两仓库实现步骤"><a href="#两仓库实现步骤" class="headerlink" title="两仓库实现步骤"></a>两仓库实现步骤</h2><p>可以实现两个仓库都在 GitHub，并通过 GitHub Actions 在源码仓库进行编译，编译完成后自动将源码仓库的静态页面内容复制到发布仓库，实现自动化的发布管理。</p>
<ol>
<li>将 Hexo 的源码仓库设置在 GitHub 上，你可以在这个仓库中编辑和管理 Hexo 的源代码、主题和文章。</li>
<li>创建另一个 GitHub 仓库作为发布仓库，用于存放生成的静态网页。你可以将 Hexo 生成的 public 文件夹的内容推送到这个仓库中。该仓库利用 GitHub Pages，直接通过.github.io 进行访问</li>
<li>在 Hexo 源码仓库中设置一个 GitHub Actions workflow，以便在每次提交或推送时自动将更新的内容复制到发布仓库。</li>
<li>需要配置 GitHub 的 ssh，可以有权限访问两个仓库</li>
<li>需要配置发布仓库的 deploy key，可以有权限写入发布仓库</li>
</ol>
<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><ul>
<li>GitHub 二级域名 <a href="https://pages.github.com/">GitHubPages</a></li>
<li>二级域名 <a href="https://freedomain.one/">https://freedomain.one/</a></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>包括添加三条解析记录</p>
<ul>
<li>192.30.252.153 是 GitHub 的地址，你也可以 ping 你的 <a href="https://liuluhua.github.io/">http:&#x2F;&#x2F;你的用户名.github.io</a> 的 ip 地址，填入进去。</li>
<li>第三个记录类型是 CNAME，CNAME 的记录值是：<a href="https://liuluhua.github.io/">http:&#x2F;&#x2F;你的用户名.github.io</a> 这里千万别弄错了。</li>
<li>绑定 Github 域名，登录 GitHub，进入之前创建的仓库，点击 settings，设置 Custom domain，输入你的域名</li>
</ul>
<h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><h2 id="GitHub-图床"><a href="#GitHub-图床" class="headerlink" title="GitHub 图床"></a>GitHub 图床</h2><ul>
<li>创建一个 public 仓库</li>
<li>进入 Settings-Developer Settings-Personal access tokens (classic) 生成 token</li>
</ul>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>PicGo 是一个开源的图片上传工具，主要用于将本地图片上传到各种图片托管服务，并生成图片链接。它提供了图形界面和命令行两种方式来使用。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>图片托管</strong>：将本地图片上传到图片托管服务，如 GitHub 等。<br><strong>图片压缩</strong>：在上传图片之前，可以选择对图片进行压缩以减小图片文件大小，节省存储空间和加快图片加载速度。<br><strong>图片管理</strong>：通过 PicGo 上传的图片可以在相应的托管服务上进行管理，包括查看、删除等操作。<br><strong>图片链接生成</strong>：上传成功后，PicGo 会生成图片链接，方便在博客、论坛等地方直接使用图片。</p>
<h3 id="配置-Github-图床"><a href="#配置-Github-图床" class="headerlink" title="配置 Github 图床"></a>配置 Github 图床</h3><p>图床设计选择 GitHub，输入在 GitHub 的仓库名，分支名和 token 即可</p>
<ul>
<li>设置 GitHub 为默认图床</li>
<li>设置图床参数</li>
<li>设定存储路径</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133915.png" alt="20240505000945.png"></p>
<h3 id="插件-super-prefix"><a href="#插件-super-prefix" class="headerlink" title="插件 super-prefix"></a>插件 super-prefix</h3><p>安装 super prefix 插件，将图片存储时按照时间分类存储</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133853.png" alt="20240505000510.png"></p>
<p>配置文件路径插件</p>
<ul>
<li>需要在 PicGo 设置中关闭时间戳重命名</li>
</ul>
<p><code>/img/2019/11/18/20191118005858.jpeg</code></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">建议值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">prefixFormat</td>
<td align="center"><code>YYYY/MM/DD/</code></td>
<td>文件名个性前缀格式 (以&#x2F;结尾)</td>
</tr>
<tr>
<td align="center">fileFormat</td>
<td align="center"><code>YYYYMMDDHHmmss</code></td>
<td>文件名个性格式</td>
</tr>
</tbody></table>
<h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="Github-Pages-部署"><a href="#Github-Pages-部署" class="headerlink" title="Github Pages 部署"></a>Github Pages 部署</h2><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p>
<p>创建 GitHub 账号，并创建一个基于用户名.github.io 的仓库</p>
<ul>
<li>使用 GitHub Pages 进行部署，所建仓库必须取名为“GitHub 用户名.github.io”</li>
<li>勾选“Add a README file”，不然后面会看不到 GitHub Pages 域名和部署分支</li>
<li>仓库需要创建为公有仓库，即 public</li>
<li>仓库大小限制为</li>
<li>创建完成后 GitHub Pages 给我们提供了一个格式为 <a href="https://liuluhua.github.io/">https://GitHub用户名.github.io</a>  的免费域名，并且相应的网站是从该仓库的 main&#x2F;master 分支构建得到的</li>
<li>自定义域名，在 GitHub 仓库 <code>Settings</code>-<code>Pages</code>-<code>Custom domain</code> 添加自己的域名</li>
</ul>
<h2 id="Git-Hook"><a href="#Git-Hook" class="headerlink" title="Git Hook"></a>Git Hook</h2><p>Git hook 是一种机制，允许在特定的 Git 事件发生时触发自定义的脚本或命令。这些事件可以包括提交 (commit)、推送 (push)、合并 (merge) 等。使用 Git hook，你可以在这些事件发生时执行自定义的操作，比如运行测试、格式化代码、触发构建等。Git 提供了一系列的预定义钩子，你可以将自己的脚本绑定到这些钩子上，或者创建自定义的钩子。</p>
<h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p>GitHub Actions 是 GitHub 提供的一项持续集成（CI）和持续部署（CD）服务，允许开发者自动化软件开发工作流程。通过 GitHub Actions，你可以在 GitHub 上运行自定义的代码（称为动作），以响应存储库中的事件，例如推送代码、创建拉取请求等。</p>
<p>一个 GitHub Actions 的核心概念是 workflow（工作流），它是一系列由动作组成的自定义任务，这些任务可以在特定的事件触发时自动执行。每个 workflow 都定义了一系列步骤，每个步骤又包含一个或多个动作。workflow 可以用 YAML 格式定义，并存储在存储库的 <code>.github/workflows</code> 目录中。</p>
<p>通过 GitHub Actions，实现将代码同步 GitHub 之后，由 GitHub Actions 执行页面的发布。</p>
<ul>
<li>执行 GitHub Actions，在需要执行的储存库中前往 <code>Settings &gt; Pages &gt; Source</code>，并将 <code>Source</code> 改为 <code>GitHub Actions</code>。</li>
<li>在储存库中建立 <code>.github/workflows/blogPublish.yml</code> 并写入内容</li>
<li>环境变量配置在 <code>Settings –&gt; Secrets and Variables –&gt; Actions</code> 里面,配置后，可以在 actions 里面通过 <code>$&#123;&#123; secrets.dingtalk_secret &#125;&#125;</code> 调用到对应的数据</li>
</ul>
<h3 id="文章更新时间问题"><a href="#文章更新时间问题" class="headerlink" title="文章更新时间问题"></a>文章更新时间问题</h3><p><strong>使用 Github Actions 造成的文章更新时间问题</strong><br>参考原文： <a href="https://mrseawave.github.io/blogs/articles/2021/01/07/ci-hexo-update-time/">https://mrseawave.github.io/blogs/articles/2021/01/07/ci-hexo-update-time/</a></p>
<p>当使用 Github Actions 自动化部署时，发现部署成功后，所有文章的更新时间都变成了此次提交修改的时间，但有些文章在上一次提交后是没有发生过任何修改的。</p>
<p>这是因为 git 在推送更新时，并不记录保存文件的访问时间、修改时间等元信息，（原因在这里）所以每次使用 git 把项目 clone 下来时，文件的时间都是克隆时的时间。又因为如果没有在 front-matter 中指定 updated，Hexo 会默认使用文件的最后修改时间作为文章的更新时间，所以会出现所有文章的更新时间都发生变化的情况。</p>
<p>总的来说，使用 git clone 下来的文件的时间都不是原来文件的时间，而自动化部署每次都需要 clone 源码才能进行后面的生成和部署操作，所以目前如果想正确显示更新时间。对于 Github Actions 可以使用命令在构建之前进行处理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy_gh_pages:</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restore</span> <span class="string">file</span> <span class="string">modification</span> <span class="string">time</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">git</span> <span class="string">ls-files</span> <span class="string">-z</span> <span class="string">|</span> <span class="string">while</span> <span class="string">read</span> <span class="string">-d</span> <span class="string">&#x27;&#x27;</span> <span class="string">path;</span> <span class="string">do</span> <span class="string">touch</span> <span class="string">-d</span> <span class="string">&quot;$(git log -1 --format=&quot;</span><span class="string">@%ct&quot;</span> <span class="string">&quot;$path&quot;</span><span class="string">)&quot;</span> <span class="string">&quot;$path&quot;</span><span class="string">;</span> <span class="string">done</span></span><br></pre></td></tr></table></figure>

<p>如果 git 命令不好用， 也可以使用 find 命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find <span class="built_in">source</span>/_posts -name <span class="string">&#x27;*.md&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> file; <span class="keyword">do</span> <span class="built_in">touch</span> -d <span class="string">&quot;<span class="subst">$(git log -1 --format=<span class="string">&quot;@%ct&quot;</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span>)</span>&quot;</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>实际上，clone 下来的文件的时间还是克隆时的时间，然后通过上面的命令，它将 clone 下来的文件的时间改成了该文件最近一次变动的推送时间（也即文件最后一次修改的 push 时间）。</p>
<p>注：如果 github actions 中使用 actions&#x2F;checkout@v2，请设定它的参数 fetch-depth: 0，因为 0 表示获取所有分支和标签的所有历史记录。默认值为 1</p>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>在 Git 仓库的根目录下编辑有.gitignore 文件，该文件中定义了一些不需要上传至 GitHub 的内容，列在该文件中的文件或文件夹将会被忽略，不在上传</p>
<h3 id="Hexo-忽略文件"><a href="#Hexo-忽略文件" class="headerlink" title="Hexo 忽略文件"></a>Hexo 忽略文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">_multiconfig.yml</span><br></pre></td></tr></table></figure>

<h3 id="Obsidian-忽略文件"><a href="#Obsidian-忽略文件" class="headerlink" title="Obsidian 忽略文件"></a>Obsidian 忽略文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.obsidian/workspace</span><br></pre></td></tr></table></figure>

<p>.obsidian 文件本身是可以同步的，当前存储库的插件以及相关的配置都会下载在这个文件夹中，因此将其同步到 git 记录中也是非常有用的，假如你切换设备就不需要重新为当前的存储库重新配置 Obsidian 了。</p>
<h2 id="GitHub-仓库部署"><a href="#GitHub-仓库部署" class="headerlink" title="GitHub 仓库部署"></a>GitHub 仓库部署</h2><h3 id="源码仓库部署"><a href="#源码仓库部署" class="headerlink" title="源码仓库部署"></a>源码仓库部署</h3><ul>
<li>创建一个私有仓库，此处我创建一个 BlogDeploy 仓库，仓库拉取到本地后，在仓库中部署 Hexo<a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li>创建 gitignore 文件，排除 Hexo 不用上传的文件</li>
<li>同步仓库到远端</li>
</ul>
<h3 id="发布仓库部署"><a href="#发布仓库部署" class="headerlink" title="发布仓库部署"></a>发布仓库部署</h3><ul>
<li>创建一个 GitHub 仓库，仓库必须取名为“GitHub 用户名.github.io”</li>
<li>仓库需要创建为公有仓库，即 public</li>
<li>创建一个分支，分支名为 ImageBed，用于做图床上传</li>
<li>获取 Token，选择用户 Settings-&gt;Developer settings-&gt;Personal access tokens，token 的权限获取，勾上 workflow 即可</li>
</ul>
<h4 id="图床分支创建"><a href="#图床分支创建" class="headerlink" title="图床分支创建"></a>图床分支创建</h4><p>用于存储图片，图床分支的相关信息部署完成后，需要在 <a href="#PicGo">PicGo</a> 中进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b my-test  //在当前分支下创建my-test的本地分支分支</span><br><span class="line">git push origin my-test  //将my-test分支推送到远程</span><br><span class="line">git branch --set-upstream-to=origin/my-test //将本地分支my-test关联到远程分支my-test上   </span><br><span class="line">git branch -a //查看远程分支 </span><br></pre></td></tr></table></figure>

<h1 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h1><p>Hexo 是一个基于 Node.js 的静态网站生成器，主要用于快速、简单地搭建个人博客或静态网站。它采用 Markdown 格式来撰写内容，并提供了丰富的主题和插件生态系统，可以轻松扩展和定制网站功能和外观。 适用于个人博客、项目文档、个人简历等各种静态网站的搭建和管理。</p>
<h2 id="目录架构"><a href="#目录架构" class="headerlink" title="目录架构"></a>目录架构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml #网站的配置信息</span><br><span class="line">package.json #应用程序的信息</span><br><span class="line">scaffolds #模版文件夹</span><br><span class="line">source #存放用户资源，Markdown 文档</span><br><span class="line">	_drafts</span><br><span class="line">	_posts</span><br><span class="line">themes #主题文件夹</span><br><span class="line">public #网站文件</span><br></pre></td></tr></table></figure>

<h2 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h2><p><strong>使用流程</strong></p>
<ol>
<li>安装 hexo<code>sudo npm install -g hexo-cli</code></li>
<li>查看版本，确认安装成功 <code>hexo -v</code></li>
<li>创建一个新文件夹 <code>Hexo</code>，并初始化该文件夹 <code>hexo init Hexo</code></li>
<li>清除缓存 <code>hexo clean</code></li>
<li>生成静态文件 <code>hexo g</code></li>
<li>开启本地服务器并修改端口为 80<code>hexo s -p 9050</code></li>
</ol>
<p><strong>常用命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli #安装Hexo  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init #初始化博客  </span><br><span class="line">  </span><br><span class="line">命令简写  </span><br><span class="line">hexo n &quot;我的博客&quot;</span><br><span class="line">hexo new &quot;我的博客&quot; #新建文章  </span><br><span class="line">hexo g</span><br><span class="line">hexo generate #生成  </span><br><span class="line">hexo s</span><br><span class="line">hexo server #启动服务预览  </span><br><span class="line">hexo d</span><br><span class="line">hexo deploy #部署  </span><br><span class="line">  </span><br><span class="line">hexo server #Hexo会监视文件变动并自动更新，无须重启服务器  </span><br><span class="line">hexo server -s #静态模式  </span><br><span class="line">hexo server -p 5000 #更改端口  </span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP  </span><br><span class="line">hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</span><br><span class="line"></span><br><span class="line">端口修改 node_modules\hexo-server\index.js </span><br><span class="line">临时启动 hexo s -p 9050</span><br></pre></td></tr></table></figure>

<p><code>hexo generate</code> 将 Hexo 源码目录中已有的源码编译生成为静态网页文件，生成以下：</p>
<ul>
<li>db.json 文件：编译过程中产生的中间文件，不用关心；</li>
<li>public 文件夹：新生成的静态网页文件就存放在这个目录下。</li>
</ul>
<p><code>hexo deploy</code> 将静态网页文件推送到 GitHub Pages</p>
<ul>
<li>Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置快捷打开</p>
<p>站点配置文件和主题配置文件是我们 DIY 博客经常要编辑的两个文件，在 Obsidian 中没法编辑 yml 文件，可以通过 URL 来打开 yml 文件，会自动调用默认的编辑器打开。创建一个专门用于编辑配置的文件，写入我们两个配置文件所在的相对路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[打开站点配置文件](Blog/_config.yml)</span><br><span class="line">[打开主题配置文件](Blog/themes/stellar/_config.yml)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者通过shellcommand形式打开.开头的隐藏文件</span></span><br><span class="line">[Github 同步忽略文件配置](obsidian://shell-commands/?vault=BlogDeploy&amp;execute=f4b02rlcvr)</span><br></pre></td></tr></table></figure>

<h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p>在 blog 根目录里的 <code>_config.yml</code> 文件称为<strong>站点</strong>配置文件</p>
<ul>
<li>主题修改：theme</li>
<li>网站标题:title</li>
<li>副标题:subtitle</li>
<li>网站描述:description</li>
<li>作者:author</li>
<li>网站头像外部链接:avatar</li>
<li>网站语言:language:zh-Hans</li>
<li>时区:timezone:Asia&#x2F;Shanghai</li>
<li>自定义域名：url:</li>
<li>忽略文件：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render:   </span><br><span class="line"># 排除一些obsidian编辑器的文件和一些脚本/模板文件  </span><br><span class="line">  - &#x27;_posts/.obsidian/*&#x27;  </span><br><span class="line">  - &#x27;_posts/Scripts/*&#x27;  </span><br><span class="line">  - &#x27;_posts/Templates/*&#x27;  </span><br></pre></td></tr></table></figure>

<h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><p>使用的主题：<code>stellar</code> 或者 <code>Next</code>，二选其一</p>
<ul>
<li>进入根目录 themes 文件夹，里面有个 <code>_config.yml</code> 文件，为<strong>主题</strong>配置文件</li>
</ul>
<ul>
<li>社交外链的设置，即在侧栏展示你的个人社交网站信息。(插件 jiathis)</li>
<li>插入网易云，进入网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器，在侧栏插入这首歌的音乐播放器，修改 <code>blog/themes/next/layout/_macro</code> 的 sidebar.swig 文件，添加刚刚复制的外链代码</li>
<li>设置背景，在 <code>blog/themes/next/source/css/_custom</code> 文件的 custom.styl 首部添加 <code>body &#123; background:url(./background.jpg);  background-attachment: fixed; &#125;</code>，fixed 固定背景图片</li>
<li>增加侧栏菜单条目，默认的侧栏菜单条目有：首页、归档、标签、关于、搜索等。如果你想要增加其他的菜单条目，修改主题配置文件 <code>_config.yml</code> 里的 <code>Menu Settings</code> 中的 <code>menu</code> 和 <code>menu_icons</code> 两个地方</li>
</ul>
<h3 id="域名配置文件"><a href="#域名配置文件" class="headerlink" title="域名配置文件"></a>域名配置文件</h3><p>进入 <code>blog/source</code> 目录下，创建一个文件，文件名 CNAME，写入你的自定义域名即可</p>
<h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/17/20240517101429.png" alt="在这里插入图片描述"></p>
<p>扩展：abbrlink&#x3D;文章永久链接</p>
<h3 id="category"><a href="#category" class="headerlink" title="category"></a>category</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并列分类，了解一下：  </span><br><span class="line">categories:  </span><br><span class="line">- [Linux]  </span><br><span class="line">- [Tools]</span><br><span class="line"></span><br><span class="line">并列+子分类，再了解一下：  </span><br><span class="line">categories:  </span><br><span class="line">- [Linux, Hexo]  </span><br><span class="line">- [Tools, PHP]</span><br></pre></td></tr></table></figure>

<h3 id="自定义文章标签"><a href="#自定义文章标签" class="headerlink" title="自定义文章标签"></a>自定义文章标签</h3><p>生成标签页面</p>
<p><code>hexo new page tags</code></p>
<p>修改 blog&#x2F;source&#x2F;tags&#x2F;index.md，添加 type: “tags”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2023-01-08 11:27:57</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<p>以后就可以在文章文件头添加标签了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Hexo + GitHub 搭建个人博客</span><br><span class="line">date: 2023-01-07 13:15:00</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Next</span><br><span class="line">- 博客 </span><br></pre></td></tr></table></figure>

<p>手动生成和添加是十分繁琐的，后续利用插件形式按照目录格式为文章自动生成标签。</p>
<h3 id="评论系统-Waline"><a href="#评论系统-Waline" class="headerlink" title="评论系统 Waline"></a>评论系统 Waline</h3><p> <a href="https://waline.js.org/guide/get-started/#leancloud-%E8%AE%BE%E7%BD%AE-%E6%95%B0%E6%8D%AE%E5%BA%93">Waline评论系统的配置</a> </p>
<ul>
<li>前往 Waline 官网 根据指引到 Vercel 进行 Waline 服务端部署</li>
<li>安装 @waline&#x2F;hexo-next<code>npm install @waline/hexo-next</code></li>
<li>为了不使用魔法也能正常评论，我们需要有自己的域名解析到 Waline 服务端，可以在域名控制台给自己的博客域名添加二级域名，添加 CNAME 解析到 cname-china.vercel-dns.com 或添加 A 解析到 76.223.126.88（也可以前往 Vercel All IP 自行挑选合适的节点），接着进入 Vercel 的 Waline 应用的控制台，在 Settings-Domains 里添加上文提到的二级域名，这样在主题配置文件添加配置后就可以正常评论了</li>
<li>主题配置文件添加配置</li>
<li>配置完评论后及时到 Waline 服务端登录，以便管理评论</li>
<li>可选择开启评论邮件提醒功能， <a href="https://waline.js.org/">Waline 官网</a> 有详细的说明</li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="部署插件-hexo-deployer-git"><a href="#部署插件-hexo-deployer-git" class="headerlink" title="部署插件 hexo-deployer-git"></a>部署插件 hexo-deployer-git</h3><p> 编辑 Hexo 顶层目录下的 <code>_config.yml</code> 文件，文件最后可以看到 deployment 相关内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">deploy：</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:liuluhua/liuluhua.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<ul>
<li>repo 填写仓库 ssh 地址</li>
<li>branch 的填写需要和 <a href="#%5Ed4aa3b">GitHub Pages部分指定的<strong>Branch</strong>保持一致</a></li>
</ul>
<h3 id="搜索插件-hexo-generator-searchdb"><a href="#搜索插件-hexo-generator-searchdb" class="headerlink" title="搜索插件 hexo-generator-searchdb"></a><del>搜索插件 hexo-generator-searchdb</del></h3><p><strong>stellar 自带了搜索插件，故未配置该插件</strong></p>
<ul>
<li>安装 hexo-generator-searchdb<code>npm install hexo-generator-searchdb</code></li>
<li>修改主题配置文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">	enable: true</span><br></pre></td></tr></table></figure>

<h3 id="自动标签插件-hexo-auto-category"><a href="#自动标签插件-hexo-auto-category" class="headerlink" title="自动标签插件 hexo-auto-category"></a>自动标签插件 hexo-auto-category</h3><p>该插件在 Hexo 进行 build 的时候会去自动根据文章目录情况来自动修改文章的 <code>categories</code> 信息</p>
<ul>
<li>安装插件 <code>npm install hexo-auto-category --save</code></li>
<li>修改站点配置文件 <code>_config.yml</code>，使文章链接清晰</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Generate categories from directory-tree</span><br><span class="line"># Dependencies: https://github.com/xu-song/hexo-auto-category</span><br><span class="line"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span><br><span class="line"># multiple: multiple category hierarchies</span><br><span class="line">auto_category:</span><br><span class="line"> enable: true</span><br><span class="line"> multiple: true</span><br><span class="line"> depth: 5</span><br><span class="line"></span><br><span class="line"># 修改 permalink 让你的文章链接更加友好，并且有益于 SEO </span><br><span class="line">permalink: :year/:month/:hash.html</span><br><span class="line"># 规定你的新文章在 _post 目录下是以 cateory   </span><br><span class="line">new_post_name: :category/:title|</span><br></pre></td></tr></table></figure>

<p>该插件需要每次手动构建执行 hexo g 时才会更新 <code>categories</code> 信息。</p>
<p><em>1.仓库部署在本地，上传时使用 git hook，在我们每次执行 <code>commit</code> 前都自动运行 <code>npx hexo generate</code> 触发自动生成 <code>categories</code> 的行为，并将生成后的变更自动添加到本次提交中，然后一同 push 到 github 上去。这里可以使用 husky 来很方便的设置这样一个 git hook</em><br><em>1. 安装 huksy：<code>npm install husky --save-dev</code></em><br><em>2. 执行 huksy 初始化指令：<code>npx husky install</code></em><br>*3. 在 <code>package.json</code> 中的 <code>scripts</code> 中写入：<code>&quot;prepare&quot;: &quot;husky install&quot;</code><br><em>4. 在生成的 <code>.husky</code> 目录创建 <code>pre-commit</code> 文件（<code>chmod a+x pre-commit</code>），并写入以下内容，之后提交代码时，检查有无 <code>categories</code> 的生成信息。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env sh  </span><br><span class="line">. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;  </span><br><span class="line">  </span><br><span class="line">npx hexo generate &amp;&amp; git add .</span><br></pre></td></tr></table></figure>

<p><em>2. 仓库部署在 GitHub 时直接利用 GitHub Actions 自动生成</em></p>
<h3 id="百度数据分析"><a href="#百度数据分析" class="headerlink" title="百度数据分析"></a>百度数据分析</h3><p>进入 <a href="https://tongji.baidu.com/">https://tongji.baidu.com/</a> 申请账号后，输入网址获取统计代码，之后在 stellar 主题的配置文件 <code>_config.yml</code> 的扩展插件部分插入以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">  <span class="attr">baiduanalytics:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 使能百度分析接口</span></span><br><span class="line">    <span class="attr">inject:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">...扩展插件代码</span></span><br></pre></td></tr></table></figure>

<h3 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a><del>阅读量统计</del></h3><p><strong>用于 next 主题</strong></p>
<p><code>Leancloud</code>（<a href="https://console.leancloud.cn/%EF%BC%89">https://console.leancloud.cn/）</a></p>
<ol>
<li>创建应用，进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用</li>
<li>配置 <code>_config.yml</code> 启用网页访问统计，配置 <code>leancloud</code> 的 <code>app_id</code> 和 <code>app_key</code>，打开计数功能，统计来源改为 <code>leancloud</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#网页访问统计</span><br><span class="line">#Analysis of website visitors</span><br><span class="line">web analytics:</span><br><span class="line">	enable:true</span><br><span class="line"></span><br><span class="line">leancloud:</span><br><span class="line">	app id: </span><br><span class="line">	app key: </span><br><span class="line"></span><br><span class="line"># 浏览量计数</span><br><span class="line"># Number of visits</span><br><span class="line">views:</span><br><span class="line">	enable:true</span><br><span class="line">	#统计数据来源</span><br><span class="line">	#Data Source</span><br><span class="line">	#Options:busuanzi | leancloud</span><br><span class="line">	source:&quot;leancloud&quot;</span><br><span class="line">	format:&quot;&#123;&#125;次&quot;</span><br></pre></td></tr></table></figure>

<h3 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a><del>页面底部展示网站的 PV、UV 统计数</del></h3><p><strong>用于 next 主题</strong>显示页面的访问量和访客数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 展示网站的 pv、w 统计数</span><br><span class="line"># Display website pv and uv statistics</span><br><span class="line">statistics:</span><br><span class="line">	enable:true</span><br><span class="line">	#统计数据来源，使用leancloud 需要设置&#x27;web analytics:leancloud&#x27;中的参数;busuanzi 显示统计数据很大属于正常现象，部署后会正常</span><br><span class="line">	# Data source.If use leancloud,you need to set the parameter in&#x27;web analytics:leancloud</span><br><span class="line">	# Options:busuanzian | leancloud</span><br><span class="line">	source:&quot;leancloud&#x27;</span><br><span class="line">	#页面显示的文本，&#123;&#125;是数字的占位符(必须包含)，下同</span><br><span class="line">	# Displayed text, &#123;&#125;is a placeholder for numbers (must be included), the same below</span><br><span class="line">	pv format:&quot;总访问量 &#123;&#125;次&quot;</span><br><span class="line">	uv format:&quot;总访客数 &#123;&#125;人&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Canvas-nest-背景动画"><a href="#Canvas-nest-背景动画" class="headerlink" title="Canvas nest 背景动画"></a>Canvas nest 背景动画</h3><ol>
<li>在 <code>blog/source/_data</code> 文件夹下新建 <code>footer.njk</code> 并编辑</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script color=&quot;0,255,255&quot; opacity=&quot;1&quot; zIndex=&quot;-1&quot; count=&quot;70&quot; src=&quot;https://cdn.staticfile.org/canvas-nest.js/1.0.1/canvas-nest.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改主题配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  footer: source/_data/footer.njk</span><br></pre></td></tr></table></figure>

<p>stellar 主题中直接添加在主题配置文件 <code>_config.yml</code> footer 的 content 中</p>
<h3 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h3><ol>
<li>安装 hexo-filter-mathjax</li>
<li>修改主题配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>

<p>此后可在文章文件开头添加参数 <code>mathjax: true</code> 以使用 MathJax</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ol>
<li>修改主题配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">plugins:</span> <span class="string">custom</span></span><br><span class="line">  <span class="attr">custom_cdn_url:</span> <span class="string">https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;cdnjs_file&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><ol>
<li>安装 hexo-word-counter</li>
</ol>
<h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p><strong>next 主题</strong><br>在 <code>/blog/themes/next/layout/_partials/footer.njk</code> 中添加</p>
<p><strong>stellar 主题</strong><br>在主题配置文件 <code>_config.yml</code> 中找到 <code>footer:</code> 中的 <code> content: |</code>，在其后添加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">createtime</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;05/20/2024 05:20:00&quot;</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间</span></span></span><br><span class="line"><span class="language-javascript">        now.<span class="title function_">setTime</span>(now.<span class="title function_">getTime</span>()+<span class="number">250</span>);</span></span><br><span class="line"><span class="language-javascript">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(days);</span></span><br><span class="line"><span class="language-javascript">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(hours);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(<span class="title class_">String</span>(hnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum);</span></span><br><span class="line"><span class="language-javascript">        mnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(minutes); <span class="keyword">if</span>(<span class="title class_">String</span>(mnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125;</span></span><br><span class="line"><span class="language-javascript">        seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum);</span></span><br><span class="line"><span class="language-javascript">        snum = <span class="title class_">Math</span>.<span class="title function_">round</span>(seconds); <span class="keyword">if</span>(<span class="title class_">String</span>(snum).<span class="property">length</span> ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;timeDate&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;本站已安全运行 &quot;</span>+dnum+<span class="string">&quot; 天 &quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;times&quot;</span>).<span class="property">innerHTML</span> = hnum + <span class="string">&quot; 小时 &quot;</span> + mnum + <span class="string">&quot; 分 &quot;</span> + snum + <span class="string">&quot; 秒&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setInterval</span>(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><ol>
<li>安装 hexo-generator-sitemap</li>
<li>修改主题配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行 <code>hexo cl &amp;&amp; hexo g</code> 生成 <code>sitemap.xml</code></li>
<li>此时可以在 <code>blog/public</code> 文件夹下看到 <code>sitemap.xml</code></li>
<li>验证，进入 <a href="https://search.google.com/search-console/welcome">Google Search Console</a> ，选择<strong>网址前缀</strong>，输入网址时记得加上 https:&#x2F;&#x2F;，选择 HTML 标记，你会得到元标记 <code>&lt;meta name=&quot;google-site-verification&quot; content=&quot;xxxxxxxx&quot; /&gt;</code>，将 content 后的内容加入到主题配置文件中 <code>google_site_verification: &quot;xxxxxxxx&quot;</code>，执行 <code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code></li>
</ol>
<p>点击前往资源页面</p>
<p>添加站点地图，成功提交</p>
<h3 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h3><ol>
<li>安装 hexo-neat</li>
<li>主题配置文件添加配置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.js&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="文章页眉显示标签"><a href="#文章页眉显示标签" class="headerlink" title="文章页眉显示标签"></a><del>文章页眉显示标签</del></h3><p><strong>用于 next 主题</strong></p>
<ol>
<li>在 <code>blog/source/_data</code> 文件夹下新建 <code>post-meta.njk</code> 并编辑</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span> </span><br><span class="line">  &#123;%- if post.tags and post.tags.length %&#125;</span><br><span class="line">    &#123;%- set tag_indicate = &#x27;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-tag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#x27; if theme.tag_icon else &#x27;#&#x27; %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-tags&quot;</span>&gt;</span></span><br><span class="line">      &#123;%- for tag in post.tags.toArray() %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      &#123;%- endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改主题配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">postMeta:</span> <span class="string">source/_data/post-meta.njk</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>Obsidian笔记建设</title>
    <url>/2024/05/22/%E5%8D%9A%E5%AE%A2-Obsidian%E7%AC%94%E8%AE%B0%E5%BB%BA%E8%AE%BE/</url>
    <content><![CDATA[<h1 id="Obsidian-配置"><a href="#Obsidian-配置" class="headerlink" title="Obsidian 配置"></a>Obsidian 配置</h1><p><code>Ctrl+Shift+I</code> 在控制台里可以查看详细日志，所有插件的日志都可以在这里看到</p>
<h2 id="Hexo-忽略文件和文件夹"><a href="#Hexo-忽略文件和文件夹" class="headerlink" title="Hexo 忽略文件和文件夹"></a>Hexo 忽略文件和文件夹</h2><p>由于 hexo 的文章只存在于 <code>source</code> 目录下，我们需要让 Obsidian 忽略其他文件的内容以优化性能以及减少不必要的搜索结果。具体的操作是在 <code>设置-文件与链接-Exclude Files</code>，将需要忽略的文件添加进去（尤其是 node_modules）。</p>
<h2 id="Templater"><a href="#Templater" class="headerlink" title="Templater"></a>Templater</h2><p>模板配置说明文档 <a href="https://silentvoid13.github.io/Templater/introduction.html">https://silentvoid13.github.io/Templater/introduction.html</a> </p>
<p>首先我们要创建模板，我们可以在 <code>source</code> 目录下创建 <code>_obsidian</code> 文件夹，并创建一篇 <code>Post Template</code> 的文章（md 文件），我们再创建新文章的时候，只需要点击侧边栏的『插入模板』按钮就可以快速生成 Front-matter 信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: &lt;% tp.file.title %&gt;</span><br><span class="line">date: &lt;% tp.file.creation_date(format=&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;</span><br><span class="line">update: &lt;% tp.file.last_modified_date(&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;</span><br><span class="line">comments: true</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">dg-publish: true</span><br><span class="line">---</span><br><span class="line">定义脚本</span><br><span class="line"></span><br><span class="line">function generateTimestampUrl() &#123;  </span><br><span class="line">  var timestamp = Math.round(new Date() / 1000);  </span><br><span class="line">  var url = timestamp.toString(36)  </span><br><span class="line">  return url;  </span><br><span class="line">&#125;  </span><br><span class="line">module.exports = generateTimestampUrl;</span><br></pre></td></tr></table></figure>

<h2 id="osidian-git"><a href="#osidian-git" class="headerlink" title="osidian-git"></a>osidian-git</h2><p>快捷键 <code>Ctrl + P</code> 打开命令面板，输入 open source control view 启用可视化操作面板</p>
<h2 id="obsidian-pangu"><a href="#obsidian-pangu" class="headerlink" title="obsidian-pangu"></a><del>obsidian-pangu</del></h2><p><strong>已用 Linter 替代</strong></p>
<p>中英文之间加空格</p>
<h2 id="Hidden-Folder"><a href="#Hidden-Folder" class="headerlink" title="Hidden Folder"></a>Hidden Folder</h2><p>目录隐藏插件</p>
<h2 id="FileTree"><a href="#FileTree" class="headerlink" title="FileTree"></a>FileTree</h2><p>左侧菜单出现了一个 <code>File Tree</code> 的 Tab 页，点击后就可以看到文件以树形的结构呈现，我们展开 <code>source</code> 文件夹，并右键 <code>_post</code> 文件夹，选择 <code>Focuse on Folder</code> 后，左侧的文件列表中就只会显示 <code>_post</code> 文件夹中的内容了</p>
<h2 id="Github-Publisher"><a href="#Github-Publisher" class="headerlink" title="Github Publisher"></a><del>Github Publisher</del></h2><p><strong>已使用整个仓库进行同步发布，不采用这种单页面发布形式</strong></p>
<p>将 Obsidian 中的文章和本地附件上传到 Github 仓库，上传前可以指定文件目录、自定义内容替换等操作。</p>
<p>能将 Obsidian 仓库里的任意笔记自动或者手动同步到 GitHub 代码仓库的任意位置。首先设置好 Github 相关信息，包括 Github repository，用户名，token 以及 Branch。当然也可以在单个笔记文件里，通过文档属性（frontmatter），单独设置接收笔记上传的 Github 仓库信息（可以选择同一用户下的不同仓库，同一仓库下的不同位置）。</p>
<p><strong>上传设置</strong></p>
<p>设定上传的笔记存储在 Github 仓库的位置。因为我的 hexo 博客日志文件保存在 source&#x2F;posts 目录下，故选择 Fixed Folder，设定好默认上传到的目录。</p>
<p><strong>文章发布</strong></p>
<p>在文章文档属性添加一个 share 属性（可以根据需要在插件设置里改成其他任意名称），赋予值 true。文章写好后，<code>share: true</code> 右键发布。</p>
<h2 id="ShellCommand"><a href="#ShellCommand" class="headerlink" title="ShellCommand"></a>ShellCommand</h2><p>可以解决 obsidian 无法打开 <code>.</code> 开头的默认文件的问题</p>
<p>再介绍个终极优化方案，之前我们执行命令是通过运行 bat 文件，而 Shell commands 可以在 Obsidian 中设置好命令，并通过 Obsidian 的命令面板或快捷键快速运行。</p>
<p>在插件设置面板中添加命令</p>
<p>运行博客：</p>
<ul>
<li>Shell commands 没有显示终端窗口的功能，所以需要我们启动 powershell 再传入命令</li>
<li>有了终端窗口我们才可以在窗口中按 Ctrl + C 关闭 Hexo 服务，否则它会一直占用端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start powershell <span class="string">&#x27;-NoExit -Command start http://localhost:4000 ; cd Blog ; hexo s&#x27;</span></span><br></pre></td></tr></table></figure>

<p>打开站点和主题配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">start Blog/_config.yml</span><br><span class="line">start Blog/themes/butterfly4.3.1/_config.yml</span><br></pre></td></tr></table></figure>

<p>然后修改默认执行环境为 PowerShell 5，可以为每个命令设置下别名，就是在命令面板显示的名字</p>
<h2 id="Emo-插件"><a href="#Emo-插件" class="headerlink" title="Emo 插件"></a><del>Emo 插件</del></h2><p><strong>用 PicGo 支持更多自定义设置</strong></p>
<p>用于自托管图片</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134039.png" alt="20240506093423.png"></p>
<h2 id="image-auto-upload-plugin"><a href="#image-auto-upload-plugin" class="headerlink" title="image auto upload plugin"></a>image auto upload plugin</h2><p>也是用于自托管图片</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134207.png" alt="20240506095310.png"></p>
<h2 id="Linter-插件"><a href="#Linter-插件" class="headerlink" title="Linter 插件"></a>Linter 插件</h2><p>用户在保存笔记时按照一定的格式，格式化笔记，这里用到的功能：</p>
<ul>
<li>保存笔记时自动插入 front-matter<ul>
<li>进入 Linter 的设置，选择 YAML 设置，找到其中的插入 YAML 设置（ Insert YAML attributes），打开开关后，输入要插入的 front-matter</li>
</ul>
</li>
<li>自动更新文件修改时间戳<ul>
<li>进入 Linter 的设置，选择 YAML 设置，找到其中的 YAML 时间戳（ yaml-timestamp），设置为 Hexo 识别的 date 和 update</li>
</ul>
</li>
<li>格式化笔记<ul>
<li>主要的是一个不同语言中间的空格自动添加，进入 Linter 的设置，选择空格，找到其中的 Space between Chinese Japanese or Korean and English or numbers，打开即可</li>
</ul>
</li>
</ul>
<h2 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h2><ul>
<li>Image Converter 转化图片格式，我统一转为 webp，并设置了图片分辨率大小。</li>
<li>Unique attachments 用于将附件的文件名统一为 “字母 + 数字”的格式,记着在配置里加入 webp 图片格式</li>
<li>Image Inserter 用于找图片，我用于设置文章封面，即设置 <code>cover.image</code> 属性。</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>Qexo管理后端建设</title>
    <url>/2024/05/21/%E5%8D%9A%E5%AE%A2-Qexo%E7%AE%A1%E7%90%86%E5%90%8E%E7%AB%AF%E5%BB%BA%E8%AE%BE/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>克隆 qexo 项目到本地</p>
<p><code>git clone https://github.com/Qexo/Qexo.git</code></p>
<p>编辑配置，以使用 Mysql 为例, 确认好安装相关依赖后在 manage.py 的同级目录下创建并修改 configs.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql  </span><br><span class="line">pymysql.install_as_MySQLdb()  </span><br><span class="line">DOMAINS = [<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;124.222.246.202&quot;</span>]  </span><br><span class="line">DATABASES = &#123;  </span><br><span class="line">	<span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">		<span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;数据库表&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;数据库用户名&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;数据库密码&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;OPTIONS&#x27;</span>: &#123;  </span><br><span class="line">		<span class="string">&quot;init_command&quot;</span>: <span class="string">&quot;SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;&quot;</span>  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirements.txt  </span><br><span class="line">python3 manage.py makemigrations  </span><br><span class="line">python3 manage.py migrate</span><br></pre></td></tr></table></figure>

<p>启动 Qexo 博客管理后端 </p>
<p><code>python3 manage.py runserver 0.0.0.0:9051 --noreload</code></p>
<p>访问公网 IP+ 端口即可打开管理页面</p>
<h2 id="配置在-vercel-上"><a href="#配置在-vercel-上" class="headerlink" title="配置在 vercel 上"></a>配置在 vercel 上</h2><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1>]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>博客部署相关文件</title>
    <url>/2024/05/25/%E5%8D%9A%E5%AE%A2-%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>部署涉及到的各项关键配置文件有以下，各文件路径基于 Hexo&#x2F;Github&#x2F;Obsidian 的仓库根目录</p>
<table>
<thead>
<tr>
<th align="center">文件所属</th>
<th>文件名</th>
<th>文件路径</th>
<th>文件用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GitHub Actions</td>
<td>blogPublish.yml</td>
<td><code>.github/workflows</code></td>
<td>用于仓库同步到 github 之后，自动将源码生成静态页面，同步到发布仓库进行发布</td>
</tr>
<tr>
<td align="center">GitHub</td>
<td>.gitignore</td>
<td><code>./</code></td>
<td>用于忽略 Hexo 和 Obsidian 中不需要同步到 Git 的文件(有些文件体积过大，占用仓库体积)</td>
</tr>
<tr>
<td align="center">Hexo</td>
<td>_config.yml</td>
<td><code>./</code></td>
<td>Hexo 站点配置文件</td>
</tr>
<tr>
<td align="center">Hexo</td>
<td>package.json</td>
<td><code>./</code></td>
<td>npm 安装包及命令文件，部署站点时所需的和 hexo 相关的依赖包都在此文件中</td>
</tr>
<tr>
<td align="center">Hexo-Stellar</td>
<td>_config.yml</td>
<td><code>themes/stellar/_config.yml</code></td>
<td>Hexo 主题配置文件</td>
</tr>
<tr>
<td align="center">Hexo-Stellar</td>
<td>widgets.yml</td>
<td><code>themes/stellar/_data/widgets.yml</code></td>
<td>Stellar 主题中的控件配置文件</td>
</tr>
</tbody></table>
<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><ul>
<li>修改 <code>.github/workflows/blogPublish.yml</code><br> <em>该文件中指定了主题仓库和主题配置文件，修改主题仓库</em></li>
<li>修改 <code>_config.theme.yml</code><br>  <em>该文件中默认为 stellar 的主题配置文件，需要修改为指定的主题配置文件</em></li>
<li>修改站点配置文件 <code>_config.yml</code><br>  <em>需要在站点配置文件中修改指定的主题</em></li>
<li><a href="Qexo%E7%AE%A1%E7%90%86%E5%90%8E%E7%AB%AF%E5%BB%BA%E8%AE%BE.md">Qexo管理后端建设</a></li>
</ul>
<p>拉取仓库并本地部署脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf ./BlogDeploy</span><br><span class="line">git clone git@github.com:liuluhua/BlogDeploy.git</span><br><span class="line">cd ./BlogDeploy</span><br><span class="line">mkdir themes</span><br><span class="line">cd themes</span><br><span class="line">git clone git@github.com:xaoxuu/hexo-theme-stellar.git</span><br><span class="line">git clone git@github.com:next-theme/hexo-theme-next.git</span><br><span class="line">cd ..</span><br><span class="line">npm install</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s -p 9050</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>博客部署相关服务</title>
    <url>/2024/05/25/%E5%8D%9A%E5%AE%A2-%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Github-托管服务"><a href="#Github-托管服务" class="headerlink" title="Github 托管服务"></a>Github 托管服务</h1><p>Github 是一个著名的互联网托管服务，用于软件开发和使用 Git 的版本控制。一直拥有各种奇怪的用途，被发掘出来当图床也见怪不怪了。</p>
<p>你可以上传<strong>各种类型的文件</strong>，只要 github 接受它们。当你在笔记中提到一个共享的文件时，比如图片&#x2F;脚本、配置文件或任何东西时， 能很好地将其嵌入到 markdown 文件中。  文件链接是否能在 Obsidian 中呈现，取决于 obsidian 本身的支持情况。没关系，即使它们不能被渲染，它们仍然可以作为链接使用。只要去掉开头的感叹号就可以了。</p>
<p>速度：国内可以接受，海外速度很快</p>
<p>CDN：Fastly CDN，几个节点在国内都解禁了的</p>
<p>HTTPS：支持（似乎不支持 HTTP2）</p>
<p>域名：user-images.githubusercontent.com 上传方式是新建一个 Repo，然后在 Issue 中传图（直接将图片拖动到 issue 输入框即可），GitHub 会将你的图片分发到 GitHub 用的 CDN 中。</p>
<p>这和使用 GitHub Raw 需要 GitHub 的服务器动态生成文件不同，user-image 这个子域名是 GitHub 专门为静态文件准备的，不会让当年某某抢票助手 CC GitHub 的事情重现的。 当然，这个接口不是公开的。善待 GitHub。</p>
<p>⚠️注意，</p>
<ol>
<li>github 目标仓库必须为 public，这意味着上传的所有文件都是公开。github 也更应该是为乐于共享者而服务的。请确保对你来说分享你上传的文件是无害的。我个人更期待着有一天你的某次上传就是为了无私共享。🌻</li>
<li>不要上传空文件。在这里是没有意义的，是错误的。</li>
<li>建议勾选面板中的随机文件名。重复的文件名会引起错误。随机文件名将大大避免重复的文件名。</li>
<li>一般来说，Github 足够慷慨。但你需要掌握分寸，不要太滥用 Github 的服务。放轻松，正常使用，比如在 Github pages 中使用，当然是可以接受的。但如果你需要大量使用图片，请使用专业的图床服务（现在该项服务已经集成到了本插件中）超出正常范围（如在单个资源库中存储超过 1GB 的文件），滥用 Github，上传不良文件，造成不良影响，可能会导致你的 Github 库甚至账户受到影响。</li>
<li>我在这里使用到了 <a href="https://www.jsdelivr.com/">jsdelivr</a>。它是免费的。就像上面关于 GitHub 的一样，不要滥用它。</li>
</ol>
<h2 id="Netlify"><a href="#Netlify" class="headerlink" title="Netlify"></a>Netlify</h2><h2 id="Railway"><a href="#Railway" class="headerlink" title="Railway"></a>Railway</h2><p><a href="https://railway.app/">https://railway.app/</a></p>
<p>Railway 提供免费容器服务。支持主流语言 python、nodejs 等直接运行，支持 Dockerfile 在线构建 docker 镜像。支持使用 CLI 部署。此外，还提供大量模板直接构建。例如 code server（vscode 网页版）等。</p>
<p>不自动休眠，不自动删数据（手动重新部署当然会删），支持自定义域名，自动 SSL 加密。</p>
<p>提供数据库支持，部署完成之后添加数据库插件即可。</p>
<p>按量付费，每个月 5 美元免费额度，跑个小程序够用。具体可以参考定价。</p>
<p><strong>部署</strong><br>railway 支持三种部署方式：</p>
<ul>
<li>通过 Github repo 进行部署，需要连接到你自己的特定仓库。如果你的仓库中有 Dockerfile 文件，则会自动解析。参见：Dockerfiles | Railway Docs</li>
<li>使用它们的 CLI，这个我试用了下感觉体验不是很好。不太推荐。</li>
<li>通过自带的模板进行部署，例如 code server。选择 Deploy Starter 即可</li>
</ul>
<h2 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h2><p><a href="https://vercel.com/">https://vercel.com/</a></p>
<p>Vercel 是一个云服务平台，支持静态网站和动态网站的应用部署、预览和上线。如果你用过 GitHub Pages ，那么心里可能不会太陌生，但你也能通过 vercel 集成 GitHub 后后，在 GitHub 项目进行代码推送，PR 合并自动部署的目的，且你不需要考虑服务器问题。</p>
<p>Vercel 它是一个免费的网站托管平台，也是我目前用过最好的网站托管平台，不仅仅可以部署静态网站，而且还可以部署动态网站，所以我们可以拿 vercel 充当你免费的服务器，主要有以下好处。</p>
<ul>
<li>关联 github，只需要往 github 提交代码，它会自动获取最新的提交，然后自动部署</li>
<li>提供了免费的域名，省去了申请域名的问题，如果有自己的域名，还可以做个域名解析到这个平台上</li>
<li>提供了免费的 Https 证书，如果证书到期了，它会自动替换，完全不需要操心</li>
<li>傻瓜式的部署方式，它的操作非常简单，Vercel 提供了两种方式：通过命令行部署、通过 Vercel 提供管理后台部署，这期视频我们主要介绍通过命令行部署，因为命令行的部署方式更加简单</li>
</ul>
<h2 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h2>]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>博客部署相关环境</title>
    <url>/2024/05/17/%E5%8D%9A%E5%AE%A2-%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h1><p><code>sudo apt update</code></p>
<h1 id="更新-nodejs-到最新版本"><a href="#更新-nodejs-到最新版本" class="headerlink" title="更新 nodejs 到最新版本"></a>更新 nodejs 到最新版本</h1><p>卸载自带的 nodejs</p>
<p><code>sudo apt autoremove nodejs</code></p>
<p><code>sudo apt purge nodejs</code></p>
<p>安装 20 版本的 nodejs</p>
<p><code>curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - &amp;&amp; sudo apt-get install -y nodejs</code></p>
<p>查看版本是否更新，否则关闭命令行重新打开</p>
<p><code>nodejs -v</code></p>
<p><del>安装 nodejs 安装工具到全局</del></p>
<p><del>sudo npm install n -g</del></p>
<p><del>安装稳定版本 nodejs</del></p>
<p><del>sudo n stable</del></p>
<h1 id="安装-npm"><a href="#安装-npm" class="headerlink" title="安装 npm"></a>安装 npm</h1><p><code>sudo apt install npm -y</code></p>
<h1 id="FTP-配置-用于图床"><a href="#FTP-配置-用于图床" class="headerlink" title="FTP 配置 - 用于图床"></a><del>FTP 配置 - 用于图床</del></h1><p><del>安装 ftp 服务端</del></p>
<p><del>sudo apt install vsftpd -y</del></p>
<p><del>修改配置文件</del></p>
<p><del>sudo vi &#x2F;etc&#x2F;vsftpd.conf</del></p>
<blockquote>
<p><del>#禁止匿名访问</del><br><del>anonymous_enable&#x3D;NO</del><br><del>#接受本地用户</del><br><del>local_enable&#x3D;YES</del><br><del>#允许上传</del><br><del>write_enable&#x3D;YES</del></p>
<p><del>#更改创建文件权限</del></p>
<p><del>local_umask&#x3D;022</del></p>
</blockquote>
<p><del>重启服务</del></p>
<p><del>sudo service vsftpd restart</del></p>
<p><del>创建 FTP 用户</del></p>
<p><del>sudo useradd -d &#x2F;home&#x2F;lemonade -M lemonade</del></p>
<p><del>sudo passwd lemonade</del></p>
<h1 id="Mysql-环境搭建"><a href="#Mysql-环境搭建" class="headerlink" title="Mysql 环境搭建"></a>Mysql 环境搭建</h1><p>安装 mysql</p>
<p><code>sudo apt install mysql-server -y</code></p>
<blockquote>
<p>sudo service mysql status # 查看服务状态<br>sudo service mysql start # 启动服务<br>sudo service mysql stop # 停止服务<br>sudo service mysql restart # 重启服务</p>
</blockquote>
<p>查看并更新密码</p>
<p><code>sudo cat /etc/mysql/debian.cnf</code></p>
<p>采用默认用户名密码登录</p>
<p><code>mysql -u *** -p</code></p>
<p>更新 root 用户密码</p>
<p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;newpasswd&#39;;</code></p>
<p>退出后，用 root 用户确认正常登录</p>
<p><code>mysql -u root -p newpasswd</code></p>
<p>创建 Qexo 要使用表</p>
<p><code>create database qexo;</code></p>
<h1 id="Python-环境安装"><a href="#Python-环境安装" class="headerlink" title="Python 环境安装"></a>Python 环境安装</h1><p>安装编译 Python 3.10 所需的依赖项：</p>
<p><code>sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev wget</code></p>
<p>下载 Python 3.10 的源代码：</p>
<p><code>wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz</code></p>
<p>解压源代码：</p>
<p><code>tar -xf Python-3.10.0.tgz</code></p>
<p>进入解压后的目录：</p>
<p><code>cd Python-3.10.0</code></p>
<p>配置 Python 3.10 的编译选项：</p>
<p><code>./configure --enable-optimizations</code></p>
<p>编译并安装 Python 3.10：</p>
<p><code>make -j 8</code></p>
<p><code>sudo make altinstall</code></p>
<p>确认 Python 3.10 是否安装成功：</p>
<p><code>python3.10 --version</code></p>
<p>如果输出了 Python 3.10 的版本号，则说明安装成功。</p>
<p>安装时网络问题见 <a href="../%E8%AF%AD%E8%A8%80/Python/pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.md">pip下载网络问题</a></p>
<h1 id="nginx-环境安装"><a href="#nginx-环境安装" class="headerlink" title="nginx 环境安装"></a>nginx 环境安装</h1><p><del>安装 nginx</del></p>
<p><code>sudo apt install nginx</code></p>
<p><del>访问公网 IP，发现 nginx 页面安装成功</del></p>
<p><del>修改 nginx 配置文件 <code>sudo vi /etc/nginx/sites-enabled/default</code></del></p>
<p><del>修改完成后重启 nginx 服务 <code>sudo service nginx restart</code></del></p>
<h1 id="FRP-内网穿透配置"><a href="#FRP-内网穿透配置" class="headerlink" title="FRP 内网穿透配置"></a>FRP 内网穿透配置</h1><p>待补充</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>数字花园建设</title>
    <url>/2024/05/17/%E5%8D%9A%E5%AE%A2-%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD%E5%BB%BA%E8%AE%BE/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133623.jpg"></p>
<h1 id="页面部署"><a href="#页面部署" class="headerlink" title="页面部署"></a>页面部署</h1><p>打开 github 下方仓库</p>
<p><a href="https://github.com/oleeskild/digitalgarden">https://github.com/oleeskild/digitalgarden</a></p>
<p>fork 到自己仓库</p>
<p>直接点击 deploy，部署到 vercel</p>
<h1 id="Obsidian-插件配置"><a href="#Obsidian-插件配置" class="headerlink" title="Obsidian 插件配置"></a>Obsidian 插件配置</h1><p>搜索 digital garden 插件，配置 Github 仓库即可</p>
<p>写文章时，需要在文章属性中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dg-publish: true</span><br></pre></td></tr></table></figure>

<p>搜索 publish single note，发布文章</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2024/05/22/%E8%AF%AD%E8%A8%80-JavaScript/</url>
    <content><![CDATA[<h1 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在当前页面重新载入页面</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reloadPageContent</span>(<span class="params">reloadPage</span>)&#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(reloadPage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按钮点击展开或隐藏</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="variable language_">document</span>).<span class="title function_">ready</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;	<span class="comment">//ready函数来确保文档加载完毕后再执行代码(jquery库代码)</span></span><br><span class="line">	$(<span class="string">&quot;a&quot;</span>).<span class="title function_">click</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;	<span class="comment">//为文档中的所有&lt;a&gt;标签绑定点击事件</span></span><br><span class="line">	    $(<span class="variable language_">this</span>).<span class="title function_">next</span>(<span class="string">&quot;.menu&quot;</span>).<span class="title function_">toggle</span>()<span class="comment">//找到当前被点击的&lt;a&gt;标签的下一个.menu类的元素，切换它的可见性</span></span><br><span class="line">	&#125;))</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取并更新innerHTML中的内容</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInnerHTML</span>(<span class="params">filePos</span>)&#123;	</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, filePos, <span class="literal">true</span>);</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        	<span class="keyword">var</span> htmlContent = xhr.<span class="property">responseText</span>;</span><br><span class="line">        	<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainmenu&quot;</span>).<span class="property">innerHTML</span> = htmlContent;</span><br><span class="line">		<span class="title function_">updateClick</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showPicture</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://124.222.246.202/get_picture?id=1&#x27;</span>,</span><br><span class="line">    &#123;<span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,<span class="attr">headers</span>: &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;,&#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainmenu&quot;</span>).<span class="property">innerHTML</span>=data&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">openFile</span>(<span class="params">filePos</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">            xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://124.222.246.202/getFileContent&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> message = &#123;</span><br><span class="line">                filePos</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">var</span> jsonMessage = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(message);</span><br><span class="line">            xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> responseContainer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainmenu&quot;</span>);</span><br><span class="line">                    responseContainer.<span class="property">innerHTML</span> = </span><br><span class="line">			<span class="string">&#x27;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;2.css/github-markdown-css/github-markdown.css&quot;&gt;&lt;style&gt;.markdown-body &#123;box-sizing: border-box;min-width: 200px;max-width: 980px;margin: 0 auto;padding: 45px;&#125;@media (max-width: 767px) &#123;.markdown-body &#123;padding: 15px;&#125;&#125;&lt;/style&gt;&lt;article class=&quot;markdown-body&quot;&gt;&#x27;</span>+marked.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>)+<span class="string">&#x27;&lt;/article&gt;&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            xhr.<span class="title function_">send</span>(jsonMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">blogList</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// 创建XMLHttpRequest对象</span></span><br><span class="line">		<span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 配置请求，将消息发送到后端Python服务器</span></span><br><span class="line">		xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://124.222.246.202/getFileList&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置请求头，告诉服务器发送的是JSON数据</span></span><br><span class="line">		xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建要发送的消息对象</span></span><br><span class="line">		<span class="keyword">var</span> message = &#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello, backend!&quot;</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将消息对象转换为JSON格式</span></span><br><span class="line">		<span class="keyword">var</span> jsonMessage = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(message);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理响应</span></span><br><span class="line">		xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">				<span class="comment">// 在页面上显示后端返回的消息</span></span><br><span class="line">				<span class="keyword">var</span> responseContainer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainmenu&quot;</span>);</span><br><span class="line">				responseContainer.<span class="property">innerHTML</span> = <span class="string">&quot;后端返回的消息: &quot;</span> + xhr.<span class="property">responseText</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送请求</span></span><br><span class="line">		xhr.<span class="title function_">send</span>(jsonMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript学习笔记</title>
    <url>/2024/05/22/%E8%AF%AD%E8%A8%80-JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JavaScript-用法"><a href="#JavaScript-用法" class="headerlink" title="JavaScript 用法"></a>JavaScript 用法</h1><p>HTML 中的 Javascript 脚本代码必须位于 <code>&lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 标签之间。</p>
<p>通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。</p>
<p>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。</p>
<p>Javascript 脚本代码可被放置在 HTML 页面的 <code>&lt;body&gt;</code> 和 <code>&lt;head&gt;</code> 部分中。</p>
<blockquote>
<p>通常的做法是把函数放入 <code>&lt;head&gt; </code> 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p>
</blockquote>
<h1 id="外部的-JavaScript"><a href="#外部的-JavaScript" class="headerlink" title="外部的 JavaScript"></a>外部的 JavaScript</h1><p>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p>
<p>外部 JavaScript 文件的文件扩展名是 .js。</p>
<p>如需使用外部文件，请在 <code>&lt;script&gt;</code> 标签的 “src” 属性中设置该 .js 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;</span><br><span class="line">&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;myFunction 保存在名为 &quot;myScript.js&quot; 的外部文件中。&lt;/p&gt;</span><br><span class="line">&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>js 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myFunction()</span><br><span class="line">&#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML=&quot;我的第一个 JavaScript 函数&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>外部脚本不能包含 <code>&lt;script&gt;</code> 标签。<br>在标签中填写 onclick 事件调用函数时，不是 onclick&#x3D;函数名， 而是 onclick&#x3D;函数名 +()</p>
</blockquote>
<h1 id="JavaScript-JSON"><a href="#JavaScript-JSON" class="headerlink" title="JavaScript JSON"></a>JavaScript JSON</h1><p>JSON 英文全称 JavaScript Object Notation</p>
<p>JSON 是用于存储和传输数据的格式。</p>
<p>JSON 通常用于服务端向网页传递数据 。</p>
<ul>
<li>数据为 键&#x2F;值 对。</li>
<li>数据由逗号分隔。</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<blockquote>
<p>JSON 是 JS 对象的字符串表示法。它使用文本表示一个 JS 对象的信息，（JSON）本质是一个字符串。<br> JSON 字符串转换为 JavaScript 对象</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var text = &#x27;&#123; &quot;sites&quot; : [&#x27; +</span><br><span class="line">    &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +</span><br><span class="line">    &#x27;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +</span><br><span class="line">    &#x27;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&#x27;;</span><br><span class="line">    </span><br><span class="line">obj = JSON.parse(text);</span><br><span class="line">document.getElementById(&quot;demo&quot;).innerHTML = obj.sites[1].name + &quot; &quot; + obj.sites[1].url;</span><br></pre></td></tr></table></figure>

<p>JSON.parse()	用于将一个 JSON 字符串转换为 JavaScript 对象。</p>
<p>JSON.stringify()	用于将 JavaScript 值转换为 JSON 字符串。</p>
<h1 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a>运行与调试</h1><p>在 Chrome 浏览器中可以通过按下 F12 按钮或者右击页面，选择 “ 检查 “ 来开启开发者工具</p>
<p>或者在右上角菜单栏选择 “ 更多工具 “&#x3D;》” 开发者工具 “ 来开启</p>
<ul>
<li>Console 窗口调试 JavaScript 代码<br>我们在 &gt; 符号后输入我们要执行的代码 console.log(“runoob”)，按回车后执行</li>
</ul>
<blockquote>
<p>清空 Console 窗口到内容</p>
</blockquote>
<ul>
<li>Chrome snippets 小脚本<br>我们也可以在 Chrome 浏览器中创建一个脚本来执行，在开发者工具中点击 Sources 面板，选择 Snippets 选项卡，在导航器中右击鼠标，然后选择 Create new snippet 来新建一个脚本文件</li>
</ul>
<p>点击 Create new snippet 后，会自动创建一个文件，你只需在右侧窗口输入以下代码，然后按 Ctrl+S 保存更改即可。</p>
<p>保存后，右击文件名，选择 “Run” 执行代码</p>
<h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p>debugger 关键字</p>
<h2 id="JavaScript-输出"><a href="#JavaScript-输出" class="headerlink" title="JavaScript 输出"></a>JavaScript 输出</h2><ul>
<li>使用 window.alert() 弹出警告框。</li>
<li>使用 document.write() 方法将内容写到 HTML 文档中。</li>
<li>使用 innerHTML 写入到 HTML 元素。</li>
<li>使用 console.log() 写入到浏览器的控制台。</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="JavaScript-字面量"><a href="#JavaScript-字面量" class="headerlink" title="JavaScript 字面量"></a>JavaScript 字面量</h2><ul>
<li>数字（Number）字面量 可以是整数或者是小数，或者是科学计数 (e)。</li>
<li>字符串（String）字面量 可以使用单引号或双引号:</li>
<li>表达式字面量 用于计算： 5 + 6</li>
<li>数组（Array）字面量 定义一个数组：[40, 100, 1, 5, 25, 10]</li>
<li>对象（Object）字面量 定义一个对象：{firstName:”John”, lastName:”Doe”, age:50, eyeColor:”blue”}</li>
<li>函数（Function）字面量 定义一个函数：function myFunction(a, b) { return a * b;}</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p> var 关键词来声明变量</p>
<p>当您声明新变量时，可以使用关键词 “new” 来声明其类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var carname=new String;</span><br><span class="line">var x=      new Number;</span><br><span class="line">var y=      new Boolean;</span><br><span class="line">var cars=   new Array;</span><br><span class="line">var person= new Object;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量的数据类型可以使用 typeof 操作符来查看：</p>
</blockquote>
<h2 id="值类型-基本类型-："><a href="#值类型-基本类型-：" class="headerlink" title="值类型 (基本类型)："></a>值类型 (基本类型)：</h2><ul>
<li>字符串（String）		var x &#x3D; “John”;	</li>
<li>数字 (Number)			var x &#x3D; 5; </li>
<li>布尔 (Boolean)			var x&#x3D;true;</li>
<li>空（Null）</li>
<li>未定义（Undefined）	var x;</li>
<li>Symbol。</li>
</ul>
<h2 id="引用数据类型（对象类型）："><a href="#引用数据类型（对象类型）：" class="headerlink" title="引用数据类型（对象类型）："></a>引用数据类型（对象类型）：</h2><ul>
<li>对象 (Object)</li>
</ul>
<p>			</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var person = &#123;</span><br><span class="line">    firstName: &quot;John&quot;,</span><br><span class="line">    lastName : &quot;Doe&quot;,</span><br><span class="line">    id : 5566,</span><br><span class="line">    fullName : function() </span><br><span class="line">	&#123;</span><br><span class="line">       return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象属性有两种寻址方式：<br>name&#x3D;person.lastname;<br>name&#x3D;person[“lastname”];</p>
</blockquote>
<ul>
<li>数组 (Array)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var cars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>var cars&#x3D;new Array();<br>cars[0]&#x3D;”Saab”;<br>cars[1]&#x3D;”Volvo”;<br>cars[2]&#x3D;”BMW”;<br>或者 (condensed array):<br>var cars&#x3D;new Array(“Saab”,”Volvo”,”BMW”);<br>或者 (literal array):<br>var cars&#x3D;[“Saab”,”Volvo”,”BMW”];</p>
</blockquote>
<ul>
<li>函数 (Function)</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;button onclick=&quot;myFunction(&#x27;Harry Potter&#x27;,&#x27;Wizard&#x27;)&quot;&gt;点击这里&lt;/button&gt;</span><br><span class="line">&lt;button onclick=&quot;myFunction(&#x27;Bob&#x27;,&#x27;Builder&#x27;)&quot;&gt;点击这里&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myFunction(name,job)</span><br><span class="line">&#123;</span><br><span class="line">	alert(&quot;Welcome &quot; + name + &quot;, the &quot; + job);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>带有返回值的函数</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function myFunction()</span><br><span class="line">&#123;</span><br><span class="line">    var x=5;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">var myVar=myFunction();</span><br></pre></td></tr></table></figure>

<p>函数表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = function (a, b) &#123;return a * b&#125;;</span><br></pre></td></tr></table></figure>

<p>还有两个特殊的对象：</p>
<ul>
<li>正则（RegExp）<br> &#x2F;正则表达式主体&#x2F;修饰符 (可选)</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var patt = /runoob/i 			//字符串</span><br><span class="line"> var n = str.search(/Runoob/i);</span><br><span class="line"> var patt = /e/;				//正则</span><br><span class="line">patt.test(&quot;The best things in life are free!&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;runoob&#x2F;i 是一个正则表达式。<br>runoob 是一个正则表达式主体 (用于检索)。<br>i 是一个修饰符 (搜索不区分大小写)。</p>
</blockquote>
<p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
<p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p>
<p>replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。</p>
<p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>
<ul>
<li>日期（Date）</li>
</ul>
<h2 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h2><ul>
<li><p>局部变量<br> 在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。</p>
</li>
<li><p>全局变量<br>函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。</p>
</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>HTML 事件可以是浏览器行为，也可以是用户行为。</p>
<ul>
<li>HTML 页面完成加载</li>
<li>HTML input 字段改变时</li>
<li>HTML 按钮被点击</li>
</ul>
<p>|事件 			|描述								|</p>
<p>|:–:			|:–:								|</p>
<p>|onchange		|HTML 元素改变						|</p>
<p>|onclick		|用户点击 HTML 元素 					|</p>
<p>|onmouseover	|鼠标指针移动到指定的元素上时发生		|</p>
<p>|onmouseout		|用户从一个 HTML 元素上移开鼠标时发生	|</p>
<p>|onkeydown		|用户按下键盘按键						|</p>
<p>|onload			|浏览器已完成页面的加载				|</p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><strong>if-else</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (condition1)&#123;</span><br><span class="line">    当条件 1 为 true 时执行的代码</span><br><span class="line">&#125;else if (condition2)&#123;</span><br><span class="line">    当条件 2 为 true 时执行的代码</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  当条件 1 和 条件 2 都不为 true 时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch(n)</span><br><span class="line">&#123;</span><br><span class="line">    case 1:</span><br><span class="line">        执行代码块 1</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        执行代码块 2</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        与 case 1 和 case 2 不同时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p><strong>for</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i=0,len=cars.length; i&lt;len; i++)</span><br><span class="line">&#123; </span><br><span class="line">    document.write(cars[i] + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person=&#123;fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56&#125;; </span><br><span class="line"> </span><br><span class="line">for (x in person)  // x 为属性名</span><br><span class="line">&#123;</span><br><span class="line">    txt=txt + person[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>while</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (条件)</span><br><span class="line">&#123;</span><br><span class="line">    需要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">    需要执行的代码</span><br><span class="line">&#125;</span><br><span class="line">while (条件);</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>break</strong><br><strong>continue</strong><br><strong>typeof</strong><br>检测变量的数据类型<br><strong>null</strong><br>null 是一个只有一个值的特殊类型。表示一个空对象引用。<br><strong>undefined</strong><br>undefined 是一个没有设置值的变量</p>
<blockquote>
<p>null 和 undefined 的值相等，但类型不等</p>
</blockquote>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><ul>
<li>try 语句测试代码块的错误。</li>
<li>catch 语句处理错误。</li>
<li>throw 语句创建自定义错误。</li>
<li>finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</li>
</ul>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>这段程序中的 setTimeout 就是一个消耗时间较长（3 秒）的过程，它的第一个参数是个回调函数，第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 3 秒，然后执行回调函数 “print”，在命令行输出 “RUNOOB!”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function print() &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML=&quot;RUNOOB!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(print, 3000);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML=&quot;RUNOOB!&quot;;</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-Promise"><a href="#JavaScript-Promise" class="headerlink" title="JavaScript Promise"></a>JavaScript Promise</h2><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h1 id="JavaScript-HTML-DOM"><a href="#JavaScript-HTML-DOM" class="headerlink" title="JavaScript HTML DOM"></a>JavaScript HTML DOM</h1><p>HTML DOM (文档对象模型)（Document Object Model）</p>
<ul>
<li>通过 id 找到 HTML 元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x=document.getElementById(&quot;intro&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过标签名找到 HTML 元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x=document.getElementById(&quot;main&quot;);</span><br><span class="line">var y=x.getElementsByTagName(&quot;p&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过类名找到 HTML 元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x=document.getElementsByClassName(&quot;intro&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-HTML-DOM-改变-HTML"><a href="#JavaScript-HTML-DOM-改变-HTML" class="headerlink" title="JavaScript HTML DOM - 改变 HTML"></a>JavaScript HTML DOM - 改变 HTML</h2><p><strong>内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;p1&quot;).innerHTML=&quot;新文本!&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img id=&quot;image&quot; src=&quot;smiley.gif&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-HTML-DOM-改变-CSS"><a href="#JavaScript-HTML-DOM-改变-CSS" class="headerlink" title="JavaScript HTML DOM - 改变 CSS"></a>JavaScript HTML DOM - 改变 CSS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;p id=&quot;p2&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;;</span><br><span class="line">document.getElementById(&quot;p2&quot;).style.fontFamily=&quot;Arial&quot;;</span><br><span class="line">document.getElementById(&quot;p2&quot;).style.fontSize=&quot;larger&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p&gt;以上段落通过脚本修改。&lt;/p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-HTML-DOM-事件"><a href="#JavaScript-HTML-DOM-事件" class="headerlink" title="JavaScript HTML DOM 事件"></a>JavaScript HTML DOM 事件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;myBtn&quot;).onclick=function()&#123;displayDate()&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>onload 和 onunload 事件会在用户进入或离开页面时被触发。</p>
<p>onchange 事件常结合对输入字段的验证来使用。</p>
<p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。</p>
<p>onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="JavaScript：直接写入-HTML-输出流"><a href="#JavaScript：直接写入-HTML-输出流" class="headerlink" title="JavaScript：直接写入 HTML 输出流"></a>JavaScript：直接写入 HTML 输出流</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;);</span><br><span class="line">document.write(&quot;&lt;p&gt;这是一个段落。&lt;/p&gt;&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您只能在 HTML 输出流中使用 document.write。 如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。</p>
</blockquote>
<h2 id="JavaScript：对事件的反应"><a href="#JavaScript：对事件的反应" class="headerlink" title="JavaScript：对事件的反应"></a>JavaScript：对事件的反应</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;alert(&#x27;欢迎!&#x27;)&quot;&gt;点我!&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript：改变-HTML-内容"><a href="#JavaScript：改变-HTML-内容" class="headerlink" title="JavaScript：改变 HTML 内容"></a>JavaScript：改变 HTML 内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=document.getElementById(&quot;demo&quot;);  //查找元素</span><br><span class="line">x.innerHTML=&quot;Hello JavaScript&quot;;    //改变内容</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DOM (Document Object Model)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。</p>
</blockquote>
<h2 id="JavaScript：改变-HTML-图像"><a href="#JavaScript：改变-HTML-图像" class="headerlink" title="JavaScript：改变 HTML 图像"></a>JavaScript：改变 HTML 图像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function changeImage()</span><br><span class="line">&#123;</span><br><span class="line">    element=document.getElementById(&#x27;myimage&#x27;)</span><br><span class="line">    if (element.src.match(&quot;bulbon&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        element.src=&quot;/images/pic_bulboff.gif&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        element.src=&quot;/images/pic_bulbon.gif&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;img decoding=&quot;async&quot; loading=&quot;lazy&quot; id=&quot;myimage&quot; onclick=&quot;changeImage()&quot; src=&quot;/images/pic_bulboff.gif&quot; width=&quot;100&quot; height=&quot;180&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript：改变-HTML-样式"><a href="#JavaScript：改变-HTML-样式" class="headerlink" title="JavaScript：改变 HTML 样式"></a>JavaScript：改变 HTML 样式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=document.getElementById(&quot;demo&quot;)  //找到元素 </span><br><span class="line">x.style.color=&quot;#ff0000&quot;;           //改变样式</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript：验证输入"><a href="#JavaScript：验证输入" class="headerlink" title="JavaScript：验证输入"></a>JavaScript：验证输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myFunction()</span><br><span class="line">&#123;</span><br><span class="line">	var x=document.getElementById(&quot;demo&quot;).value;</span><br><span class="line">	if(isNaN(x)||x.replace(/(^\s*)|(\s*$)/g,&quot;&quot;)==&quot;&quot;)&#123;</span><br><span class="line">		alert(&quot;不是数字&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown笔记</title>
    <url>/2024/05/16/%E8%AF%AD%E8%A8%80-Markdown%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Markdown-笔记语法"><a href="#Markdown-笔记语法" class="headerlink" title="Markdown 笔记语法"></a>Markdown 笔记语法</h1><h2 id="表格-文本样式"><a href="#表格-文本样式" class="headerlink" title="表格 &amp; 文本样式"></a>表格 &amp; 文本样式</h2><table>
<thead>
<tr>
<th align="center">样式</th>
<th>语法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">加粗</td>
<td>前后 <code>**</code> 或 <code>__</code></td>
<td><strong>加粗 1</strong> <strong>加粗 2</strong></td>
</tr>
<tr>
<td align="center">斜体</td>
<td>前后 <code>*</code> 或 <code>_</code></td>
<td><em>斜体 1</em> <em>斜体 2</em></td>
</tr>
<tr>
<td align="center">删除线</td>
<td>前后 <code>~~</code></td>
<td><del>删除线</del></td>
</tr>
<tr>
<td align="center">内联代码</td>
<td>前后 &#96;</td>
<td><code>code</code></td>
</tr>
<tr>
<td align="center">下划线</td>
<td>前<code>&lt;u&gt;</code>  后 <code>&lt;/u&gt;</code></td>
<td><u>下划线</u></td>
</tr>
<tr>
<td align="center">高亮</td>
<td>前后<code>==</code></td>
<td>&#x3D;&#x3D;高亮文本&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>此内容为引用内容</p>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><em>鼠标右击</em> 或 <em>Ctrl 键 + 点击</em> 系统默认浏览器打开链接</p>
<p><a href="https://liuluhua.github.io/">Blog网址</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>拖放图片文件、粘贴截图可直接将图片源数据存储到笔记中</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/GitHubImageBed/main/Qexo/24/3/title-icon_7de1fad10dc19f682355e8b3bbfb87c3.jpg" alt="LOGO"></p>
<p><em>图片可拖动为文件到任意窗口使用</em></p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li>项目<ul>
<li>项目 1<ul>
<li>项目 A</li>
<li>项目 B</li>
</ul>
</li>
<li>项目 2</li>
</ul>
</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol>
<li>项目 1<ol>
<li>项目 A</li>
<li>项目 B</li>
</ol>
</li>
<li>项目 2</li>
</ol>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><ul>
<li><input checked="" disabled="" type="checkbox"> A 计划<ul>
<li><input checked="" disabled="" type="checkbox"> A1 计划</li>
<li><input disabled="" type="checkbox"> A2 计划</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> B 计划</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块支持 168 种编程语言</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript 冒泡排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> swapped = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    swapped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; array.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = array[j];</span><br><span class="line">        array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">        array[j + <span class="number">1</span>] = temp;</span><br><span class="line">        swapped = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (swapped);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KaTeX-数学公式"><a href="#KaTeX-数学公式" class="headerlink" title="KaTeX 数学公式"></a><a href="https://katex.org/">KaTeX</a> 数学公式</h2><h3 id="内联公式"><a href="#内联公式" class="headerlink" title="内联公式"></a>内联公式</h3><p>质能方程 $E&#x3D;mc^2$</p>
<h3 id="公式块"><a href="#公式块" class="headerlink" title="公式块"></a>公式块</h3><p>$$<br>\displaystyle \left( \sum_{k&#x3D;1}^n a_k b_k \right)^2 \leq \left( \sum_{k&#x3D;1}^n a_k^2 \right) \left( \sum_{k&#x3D;1}^n b_k^2 \right)<br>$$</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2024/05/22/%E8%AF%AD%E8%A8%80-Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown-基础"><a href="#Markdown-基础" class="headerlink" title="Markdown 基础"></a>Markdown 基础</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <code>.md</code>, <code>.markdown</code>。</p>
<p>Markdown 能被使用来撰写电子书，如：Gitbook。</p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>Markdown 标题有两种格式。</p>
<p>使用 &#x3D; 和 - 标记一级和二级标题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">=================</span><br><span class="line">二级标题</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>Markdown 段落的换行有两种格式。</p>
<ul>
<li>使用两个以上空格加上回车</li>
<li>在段落后面使用一个空行</li>
</ul>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>

<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~这是要删除的文本~~</span><br></pre></td></tr></table></figure>

<h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><p>利用 html 的 <code>&lt;u&gt;</code> 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>脚注是对文本的补充说明。</p>
<p>Markdown 脚注的格式如下:</p>
<p>[^要注明的文本]</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>Markdown 支持有序列表和无序列表。</p>
<blockquote>
<p>无序列表使用星号 (*)、加号 (+) 或是减号 (-) 作为列表标记，这些标记后面要添加一个空格，然后再填写内容</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure>

<p>有序列表使用数字并加上 . 号来表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure>

<blockquote>
<p>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">- 第一项嵌套的第一个元素</span><br><span class="line">- 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">- 第二项嵌套的第一个元素</span><br><span class="line">- 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><ul>
<li><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p>
</li>
<li><p>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套</p>
</li>
<li><p>区块中也可以使用列表</p>
</li>
<li><p>列表中也可以使用区块，需要在 &gt; 前添加四个空格的缩进</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 区块</span><br><span class="line">&gt;&gt; 区块嵌套</span><br><span class="line">&gt;&gt;&gt; 区块嵌套</span><br><span class="line">&gt; 1. 区块列表1</span><br><span class="line">&gt; 2. 区块列表2</span><br><span class="line">&gt; + 区块列表1</span><br><span class="line">&gt; + 区块列表2</span><br><span class="line">* 列表1</span><br><span class="line">&gt; 列表区块1</span><br><span class="line">&gt; 列表区块2</span><br><span class="line">* 列表2</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>段落上的一个函数或片段的代码可以用反引号把它包起来（&#96;）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`printf()`</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong></p>
<ol>
<li>四个空格</li>
<li>tab 制表符</li>
<li>用 ``&#96; 包裹一段代码，并指定一种语言</li>
</ol>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[链接名称](baidu.com)</span><br><span class="line">&lt;baidu.com&gt;</span><br></pre></td></tr></table></figure>

<p><strong>高级链接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [Google][1]</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line">  [1]: http://www.google.com/</span><br></pre></td></tr></table></figure>

<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以按照高级链接的方式，将图片地址放在文档结尾<br><strong>图片大小</strong><br>如果要修改图片大小，采用 html 的 <code>&lt;img&gt;</code> 标签</p>
</blockquote>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>

<p><strong>对齐</strong></p>
<ul>
<li><code>-:</code> 设置内容和标题栏居右对齐。</li>
<li><code>:-</code> 设置内容和标题栏居左对齐。</li>
<li><code>:-:</code> 设置内容和标题栏居中对齐。</li>
</ul>
<h1 id="Markdown-技巧"><a href="#Markdown-技巧" class="headerlink" title="Markdown 技巧"></a>Markdown 技巧</h1><blockquote>
<p>不同的 markdown 编辑器支持的语法略有不同，下方介绍的相关技巧不一定支持</p>
</blockquote>
<h1 id="Github-Flavored-Markdown-GFM-的工作清单"><a href="#Github-Flavored-Markdown-GFM-的工作清单" class="headerlink" title="Github Flavored Markdown (GFM) 的工作清单"></a>Github Flavored Markdown (GFM) 的工作清单</h1><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522155927.png" alt="image-1689835023112.png"></p>
<h3 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522155942.png" alt="image-1689835036131.png"></p>
<h1 id="KaTeX-数学公式排版语法"><a href="#KaTeX-数学公式排版语法" class="headerlink" title="KaTeX 数学公式排版语法"></a>KaTeX 数学公式排版语法</h1><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522155955.png" alt="image-1689834802409.png"></p>
<h3 id="显示效果-1"><a href="#显示效果-1" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160005.png" alt="image-1689834753660.png"></p>
<h1 id="SVG-向量流程图"><a href="#SVG-向量流程图" class="headerlink" title="SVG 向量流程图"></a>SVG 向量流程图</h1><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160016.png" alt="image-1689834876711.png"></p>
<h3 id="显示效果-2"><a href="#显示效果-2" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160027.png" alt="image-1689834889569.png"></p>
<h1 id="向量-UML-顺序图表"><a href="#向量-UML-顺序图表" class="headerlink" title="向量 UML 顺序图表"></a>向量 UML 顺序图表</h1><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160037.png" alt="image-1689834917934.png"></p>
<h3 id="显示效果-3"><a href="#显示效果-3" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160043.png" alt="image-1689834929696.png"></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>RSS</title>
    <url>/2024/05/22/%E8%AF%AD%E8%A8%80-RSS/</url>
    <content><![CDATA[<h1 id="Rsshub-的-docker-部署"><a href="#Rsshub-的-docker-部署" class="headerlink" title="Rsshub 的 docker 部署"></a>Rsshub 的 docker 部署</h1><p>下载 docker-compose.yml</p>
<p><code>wget https://raw.githubusercontent.com/DIYgod/RSSHub/master/docker-compose.yml</code></p>
<p>检查是否有需要修改的配置</p>
<p><code>vi docker-compose.yml  # or your favorite editor</code></p>
<p>创建 redis 卷 Create a docker volume to persist Redis caches</p>
<p><code>docker volume create redis-data</code></p>
<p>启动</p>
<p><code>docker-compose up -d</code></p>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">channel</span>&gt;</span> 参考手册 元素 描述</span><br><span class="line"><span class="tag">&lt;<span class="name">category</span>&gt;</span> 可选的。为 feed 定义所属的一个或多个种类。</span><br><span class="line"><span class="tag">&lt;<span class="name">cloud</span>&gt;</span> 可选的。注册进程，以获得 feed 更新的立即通知。</span><br><span class="line"><span class="tag">&lt;<span class="name">copyright</span>&gt;</span> 可选。告知版权资料。</span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span> 必需的。描述频道。</span><br><span class="line"><span class="tag">&lt;<span class="name">docs</span>&gt;</span> 可选的。规定指向当前 RSS 文件所用格式说明的 URL。</span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span>&gt;</span> 可选的。规定用于生成 feed 的程序。</span><br><span class="line"><span class="tag">&lt;<span class="name">image</span>&gt;</span> 可选的。在聚合器呈现某个 feed 时，显示一个图像。</span><br><span class="line"><span class="tag">&lt;<span class="name">language</span>&gt;</span> 可选的。规定编写 feed 所用的语言。</span><br><span class="line"><span class="tag">&lt;<span class="name">lastBuildDate</span>&gt;</span> 可选的。定义 feed 内容的最后修改日期。</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span> 必需的。定义指向频道的超链接。</span><br><span class="line"><span class="tag">&lt;<span class="name">managingEditor</span>&gt;</span> 可选的。定义 feed 内容编辑的电子邮件地址。</span><br><span class="line"><span class="tag">&lt;<span class="name">pubDate</span>&gt;</span> 可选的。为 feed 的内容定义最后发布日期。</span><br><span class="line"><span class="tag">&lt;<span class="name">rating</span>&gt;</span> 可选的。feed 的 PICS 级别。</span><br><span class="line"><span class="tag">&lt;<span class="name">skipDays</span>&gt;</span> 可选的。规定忽略 feed 更新的天。</span><br><span class="line"><span class="tag">&lt;<span class="name">skipHours</span>&gt;</span> 可选的。规定忽略 feed 更新的小时。</span><br><span class="line"><span class="tag">&lt;<span class="name">textInput</span>&gt;</span> 可选的。规定应当与 feed 一同显示的文本输入域。</span><br></pre></td></tr></table></figure>

<h1 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span> 参考手册 元素 描述</span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span> 可选的。规定项目作者的电子邮件地址。</span><br><span class="line"><span class="tag">&lt;<span class="name">category</span>&gt;</span> 可选的。定义项目所属的一个或多个类别。</span><br><span class="line"><span class="tag">&lt;<span class="name">comments</span>&gt;</span> 可选的。允许项目连接到有关此项目的注释（文件）。</span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span> 必需的。描述此项目。</span><br><span class="line"><span class="tag">&lt;<span class="name">enclosure</span>&gt;</span> 可选的。允许将一个媒体文件导入一个项中。</span><br><span class="line"><span class="tag">&lt;<span class="name">guid</span>&gt;</span> 可选的。为项目定义一个唯一的标识符。</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span> 必需的。定义指向此项目的超链接。</span><br><span class="line"><span class="tag">&lt;<span class="name">pubDate</span>&gt;</span> 可选的。定义此项目的最后发布日期。</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span> 可选的。为此项目指定一个第三方来源。</span><br></pre></td></tr></table></figure>

<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>可以在 <a href="http://www.feedvalidator.org/">http://www.feedvalidator.org</a> 找到很好的验证器。</p>
<h1 id="RSS-阅读器功能"><a href="#RSS-阅读器功能" class="headerlink" title="RSS 阅读器功能"></a>RSS 阅读器功能</h1><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>    <strong>字体</strong></p>
<p>    <strong>字号</strong></p>
<p>    <strong>背景</strong></p>
<p>    <strong>翻页</strong></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>    <strong>缩放</strong></p>
<p>    <strong>移动</strong></p>
<p>    <strong>下载</strong></p>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>    <strong>播放&#x2F;暂停</strong></p>
<p>    <strong>快进</strong></p>
<p>    <strong>进度条</strong></p>
<p>    <strong>音量</strong></p>
<p>    <strong>下载</strong></p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>    <strong>订阅</strong></p>
<p>    <strong>自动&#x2F;手动同步</strong></p>
<h1 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h1><h2 id="多线程处理等待消息返回"><a href="#多线程处理等待消息返回" class="headerlink" title="多线程处理等待消息返回"></a>多线程处理等待消息返回</h2><h2 id="xml-文件本地缓存的命名方式"><a href="#xml-文件本地缓存的命名方式" class="headerlink" title="xml 文件本地缓存的命名方式"></a>xml 文件本地缓存的命名方式</h2><p>eg. <a href="https://rsshub.app/6v123/latestMovies">https://rsshub.app/6v123/latestMovies</a></p>
<p>&#x3D;&#x3D;&#x3D;&gt;&#96;6v123_latestMovies</p>
<p>eg. <a href="https://rsshub.app/t66y/20/2">https://rsshub.app/t66y/20/2</a></p>
<p>&#x3D;&#x3D;&#x3D;&gt;&#96;t66y_20_2</p>
<h2 id="页面元素布局"><a href="#页面元素布局" class="headerlink" title="页面元素布局"></a>页面元素布局</h2><p>根据实际返回的页面元素，分别显示不同的页面</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2024/05/17/%E8%AF%AD%E8%A8%80-shell/</url>
    <content><![CDATA[<h1 id="什么是-shell"><a href="#什么是-shell" class="headerlink" title="什么是 shell"></a>什么是 shell</h1><p>shell 是一个编程语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支；</p>
<p>也是一个命令行解释器，交互式地解释和执行用户输入的命令；</p>
<p>还是内核的保护工具，它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。</p>
<p><strong>Shell 有两种执行命令的方式：</strong><br><strong>交互式</strong>（Interactive）：解释执行用户的命令，用户输入一条命令，Shell 就解释执行一条。<br><strong>批处理</strong>（Batch）：用户事先写一个 Shell 脚本 (Script)，shell 脚本是 shell 命令的有限序列，将各类命令预先放入其中，方便一次性执行的一个程序文件，主要用于方便管理员进行设置或者管理，而不必一条一条地敲命令。</p>
<p>*Shell 脚本是解释执行的，不需要编译，Shell 程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到 Shell 提示符下执行</p>
<p>Linux 的 Shell 种类众多，常见的有：<code>Bourne Shell</code>（&#x2F;usr&#x2F;bin&#x2F;sh 或&#x2F;bin&#x2F;sh）、<code>Bourne Again Shell</code>（&#x2F;bin&#x2F;bash）、<code>C Shell</code>（&#x2F;usr&#x2F;bin&#x2F;csh）、<code>K Shell</code>（&#x2F;usr&#x2F;bin&#x2F;ksh）、<code>Shell for Root</code>（&#x2F;sbin&#x2F;sh）等等。</p>
<p>不同的 Shell 语言的语法有所不同，所以不能交换使用。我们关注的重点是 Bash，Bash 也是大多数 Linux 系统默认的 Shell。在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，在下面的文字中，我们可以看到#!&#x2F;bin&#x2F;sh，它同样也可以改为#!&#x2F;bin&#x2F;bash。</p>
<p>编写 Shell 脚本的格式是固定的，一个简单的 shell 脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#print hello world in the console window</span><br><span class="line">a = &quot;hello world&quot;</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>

<p>首行中的符号**#!告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序**。 如果首行没有这句话，在执行脚本文件的时候，将会出现错误。</p>
<p>后续的部分就是主程序，Shell 脚本像高级语言一样，也有变量赋值，也有控制语句。 除第一行外，以#开头的行就是注释行，直到此行的结束。 如果一行未完成，可以在行尾加上 “，这个符号表明下一行与此行会合并为同一行。</p>
<p>编辑完毕，将脚本存盘为 filename.sh，文件名后缀 sh 表明这是一个 Bash 脚本文件。</p>
<p>执行方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.加可执行权限</span><br><span class="line">    chmod u+x  filename.sh</span><br><span class="line">    ./filename.sh</span><br><span class="line">2.执行通过bash运行</span><br><span class="line">    /bin/bash  filename.sh</span><br><span class="line">3.将路径添加到环境变量</span><br><span class="line">    chmod u+x filename.sh</span><br><span class="line">    PATH+=:/home/fs/Temp</span><br><span class="line">    filename.sh  //任意目录运行</span><br><span class="line">4.添加到bin文件夹</span><br><span class="line">    chmod u+x filename.sh</span><br><span class="line">    sudo mv  filename.sh  /bin/</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，一定要写成.&#x2F;filename.sh，而不是 filename.sh。运行其它二进制的程序也一样，直接写 filename.sh，linux 系统会去 PATH 里寻找有没有叫 filename.sh 的，而只有&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 filename.sh 是会找不到命令的，要用.&#x2F;filename.sh 告诉系统说，就在当前目录找。</li>
</ul>
<p><strong>速查表</strong></p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%!xxd</td>
<td align="left">将二进制文件转换为 16 进制和 ASCII 表形式查看</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">代表通配符，可代表任意长度的任意字符；</td>
</tr>
<tr>
<td align="left">？</td>
<td align="left">可代表单个长度的任意字符</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">通配括号中的元素</td>
</tr>
<tr>
<td align="left">[^……]</td>
<td align="left">除去括号中的元素，其他通配</td>
</tr>
<tr>
<td align="left">&gt;file</td>
<td align="left">将输出重定向到 file 中去（新建）</td>
</tr>
<tr>
<td align="left">&gt;&gt;file</td>
<td align="left">将输出重定向到 file 中去（追加模式）</td>
</tr>
<tr>
<td align="left">&lt;file</td>
<td align="left">将 file 作为标准输入</td>
</tr>
<tr>
<td align="left">2&gt; 或 &amp;&gt;</td>
<td align="left">–&gt;标准错误</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">pipe 管道,将第一个命令的输出作为第二个命令的输入</td>
</tr>
</tbody></table>
<h1 id="shell-命令使用"><a href="#shell-命令使用" class="headerlink" title="shell 命令使用"></a>shell 命令使用</h1><ol>
<li>tab 补齐：命令 文件名 路径</li>
<li>history ：查看命令历史</li>
<li>通配符 *：匹配任意长度任意字符串</li>
<li>管道 |：第一个指令的输出作为第二个指令的输入：<code>ls /usr/bin | wc -l</code></li>
<li>重定向 :</li>
<li>命令置换：反撇号<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   ls `pwd`</span><br></pre></td></tr></table></figure></li>
<li>常用命令</li>
<li>用户管理命令</li>
<li>进程管理命令</li>
</ol>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">?</span><br><span class="line">[...]</span><br><span class="line">[-]</span><br><span class="line">[^...]</span><br><span class="line">[a-z, ABC] // 表示匹配a到z和A,B,C中任意一个字符</span><br><span class="line">ls file[3-4][5-9].c /*表示名匹配文件名含[3-4]中的一个字符和[5-9]中的一个字符，两个字符的共两个字符的文件名都符合规则。*/</span><br></pre></td></tr></table></figure>

<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>|</p>
<p>将第一个命令的正确输出内容 通过管道输出给 第二个命令作为输入.</p>
<p>要求第一个命令有输出，第二个命令有输入功能。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><code>echo &quot;hello world&quot; &gt; test</code> &#x2F;&#x2F;将内容输出到文件 test 中。</p>
<p><code>echo &quot;hello Eric&quot; &gt;&gt; test</code> &#x2F;&#x2F;将字符串内容追加到 test 中,在 test 原有的内容上添加</p>
<p><code>2&gt; 2&gt;&gt;</code> &#x2F;&#x2F;将报错信息重定向或追加到指定文件.</p>
<p><code>&amp;&gt; &amp;&gt;&gt;</code> &#x2F;&#x2F;将正确信息和错误信息一起重定向或追加到指定文件。</p>
<p>0 标准输入 stdin</p>
<p>1 标准输出 stdout ‘\n’ main() return ; fflush(stdout);</p>
<p>2 标准出错 stderr</p>
<p><code>/dev/null</code> 是一个被称作 Linux 黑洞的文件，把输出信息重定向到这个文件等同于删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; ~/.bash_history // 利用/dev/null清空指定文件。</span><br><span class="line">/dev/zero</span><br></pre></td></tr></table></figure>

<p><code>command &gt; file</code> 将输出重定向到 file。</p>
<p><code>command &lt; file</code> 将输入重定向到 file。</p>
<p><code>command &gt;&gt; file</code> 将输出以追加的方式重定向到 file。</p>
<p><code>n &gt; file</code> 将文件描述符为 n 的文件重定向到 file。</p>
<p><code>n &gt;&gt; file</code> 将文件描述符为 n 的文件以追加的方式重定向到 file。</p>
<p><code>n &gt;&amp; m</code> 将输出文件 m 和 n 合并。</p>
<p><code>n &lt;&amp; m</code> 将输入文件 m 和 n 合并。</p>
<p><code>&lt;&lt; tag</code> 将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
<h2 id="管道和重定向的比较"><a href="#管道和重定向的比较" class="headerlink" title="管道和重定向的比较"></a>管道和重定向的比较</h2><p><code>command1 | command2</code></p>
<p>左输出 | 右输入</p>
<p><code>command &gt; file</code></p>
<p>左输出 &gt; 右文件</p>
<p><code>command &lt; file</code></p>
<p>左输入 &lt; 右文件</p>
<p>管道的命令同时执行,command2 等待 command1 的输出 (阻塞)</p>
<p>重定向是有优先级的,由进程优先级决定.</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>less/more</code></p>
<p><code>alias</code> 定义别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias md=&#x27;mkdir&#x27;</span><br><span class="line">md dir1 dir2 //md就是mkdir了,这里创建了两个目录(文件夹)dir1和dir2.</span><br></pre></td></tr></table></figure>

<p><code>head/tail</code></p>
<p><code>sort</code> 排序命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | sort -t:   -k 4  -n //-t指定分隔符  -k 4 指定分隔后的段, -n 完整比较。</span><br><span class="line">man</span><br><span class="line">man 1  可执行程序或Shell命令</span><br><span class="line">man 2  ?</span><br><span class="line">man 3  ?</span><br></pre></td></tr></table></figure>

<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser</span><br><span class="line">deluser  --remove-home //删除用户的同时，删除其工作目录</span><br><span class="line">chown</span><br><span class="line">chown  xiaomeng  jielun //将文件jielun的所有者改为xiaomeng.</span><br><span class="line">su  切换用户</span><br><span class="line">passwd 修改密码</span><br><span class="line">sudo //用超级用户权限执行一次命令；</span><br><span class="line">sudo passwd //普通用户修改root用户密码;</span><br><span class="line">usermod</span><br><span class="line">usermod  -l Ez   xiaoming //更改用户名xiaoming为Ez,要保证用户不在登陆状态;</span><br></pre></td></tr></table></figure>

<p>相关文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/skel/</span><br><span class="line">/etc/group</span><br><span class="line">/etc/gshadow</span><br><span class="line">chmod 改变文件读写执行权限</span><br><span class="line">rw-     r-- r--</span><br><span class="line">110     100 100</span><br><span class="line">6        4    4</span><br><span class="line">|       |   |其他用户</span><br><span class="line">|       |组用户权限</span><br><span class="line">|所属者的权限Xm</span><br></pre></td></tr></table></figure>

<h2 id="进程管理信息"><a href="#进程管理信息" class="headerlink" title="进程管理信息"></a>进程管理信息</h2><p><strong>进程的概念:</strong><br>程是指正在执行的程序的实例。每个运行的程序都在系统中作为一个进程存在。进程是操作系统进行任务调度和资源管理的基本单位，它拥有自己的内存空间、执行代码、数据和资源。进程之间相互独立，彼此隔离，这样可以确保一个进程的异常不会影响其他进程的正常运行。<br><strong>进程与程序的区别:</strong><br>程序是一组静态的指令和数据的集合，它们存储在磁盘上；而进程是程序的实例，是程序在内存中的执行过程。程序只是静态的代码和数据的集合，而进程是具有动态特性、在系统中运行的实体。</p>
<table>
<thead>
<tr>
<th align="center">&#x2F;</th>
<th align="center">进程</th>
<th align="center">程序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义</td>
<td align="center">进程是正在运行的程序的实例。在操作系统中，进程代表了一个独立的执行单元，拥有自己的内存空间、程序代码、数据和资源。每个运行的程序都以进程的形式存在。</td>
<td align="center">程序是一组指令和数据的集合，它是静态的、存储在磁盘上的文件，描述了如何执行特定任务。程序本身并不占用系统资源，只有在被加载到内存并运行时，才成为一个进程。</td>
</tr>
<tr>
<td align="center">特性</td>
<td align="center">进程是一个动态的实体，具有生命周期，可以处于运行、就绪、阻塞、挂起等不同状态，而且进程之间相互独立，彼此隔离。</td>
<td align="center">程序是一个静态的实体，只是存储在磁盘上的文件，并不具有自己的执行状态和资源。</td>
</tr>
<tr>
<td align="center">生命周期</td>
<td align="center">进程从创建、运行到终止，进程有一个明确的生命周期。当进程终止时，它占用的资源会被操作系统回收。</td>
<td align="center">程序本身没有生命周期，只有在被加载到内存并执行为进程后，才会有生命周期。</td>
</tr>
</tbody></table>
<ul>
<li>进程和程序之间是一种从程序到进程的实例化关系。当运行一个程序时，操作系统会为该程序创建一个对应的进程，使得程序在内存中得以执行。</li>
</ul>
<p><strong>进程的查看:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br><span class="line">ps -elf</span><br></pre></td></tr></table></figure>

<p><strong>进程的几种状态:</strong></p>
<ul>
<li>运行（Running）：表示进程正在运行或正在执行。</li>
<li>就绪（Ready）：表示进程已经准备好运行，但由于系统资源限制或其他进程的运行，它暂时还没有得到处理器的分配。</li>
<li>阻塞（Blocked）：也称为等待（Waiting），表示进程由于等待某个事件的发生（如 I&#x2F;O 操作完成、信号等）而暂停执行，直到事件发生才能继续运行。</li>
<li>挂起（Suspended）：表示进程被暂时挂起，不占用 CPU 资源，并且可能被放置在磁盘上。这种状态通常用于系统中的一些特殊情况，如进程被调试或由于内存不足而被置换出来。</li>
</ul>
<h1 id="shell-命令行下查找"><a href="#shell-命令行下查找" class="headerlink" title="shell 命令行下查找"></a>shell 命令行下查找</h1><p>在当前目录下所有文件中查找内容包含 string 的文件并列出字符所在的文件,所在行及所在行的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*&quot; -exec grep -n &quot;string&quot; ./ &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>使用 find 查找时希望忽略某个目录 (-prune):</p>
<p>如果希望在&#x2F;app 目录下查找文件，但不希望在&#x2F;app&#x2F;bin 目录下查找:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /app -name &quot;/app/bin&quot; -prune -o -print</span><br></pre></td></tr></table></figure>

<p>使用 type 选项:</p>
<p>如果要在&#x2F;etc 目录下查找所有的目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /etc -type d -print</span><br></pre></td></tr></table></figure>

<p>如果要在&#x2F;etc 目录下查找.svn 的目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /etc -name .svn -type d -print</span><br></pre></td></tr></table></figure>

<p>为了在当前目录下查找除目录以外的所有类型的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . ! -type d -print</span><br></pre></td></tr></table></figure>

<p>为了在当前目录下查找所有的符号链接文件，可以用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type | -print</span><br></pre></td></tr></table></figure>

<p>为了用 ls -l 命令列出所匹配到的文件，可以把 ls -l 命令放在 find 命令的 -exec 选项中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>注：f 表示普通文件</p>
<h1 id="shell-脚本各种执行方式"><a href="#shell-脚本各种执行方式" class="headerlink" title="shell 脚本各种执行方式"></a>shell 脚本各种执行方式</h1><p><code>source ./*.sh</code> <code>. ./*.sh</code> <code>./*.sh</code> 的区别</p>
<ul>
<li><code>./*.sh</code> 的执行方式等价于 <code>sh ./*.sh</code> 或者 <code>bash ./*.sh</code>，<br>  此三种执行脚本的方式都是重新启动一个子 shell,在子 shell 中执行此脚本。</li>
<li><code>.source ./*.sh</code> 和 <code>. ./*.sh</code> 的执行方式是等价的，即两种执行方式都是在当前 shell 进程中执行此脚本，而不是重新启动一个 shell 而在子 shell 进程中执行此脚本。<br>验证依据：没有被 export 导出的变量（即非环境变量）是不能被子 shell 继承的<br>验证结果：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#name=dangxu //定义一般变量</span><br><span class="line">[root@localhost ~]# echo $&#123;name&#125;</span><br><span class="line">dangxu</span><br><span class="line">[root@localhost ~]# cat test.sh //验证脚本，实例化标题中的./*.sh</span><br><span class="line">#!/bin/sh</span><br><span class="line">echo $&#123;name&#125;</span><br><span class="line">[root@localhost ~]# ls -l test.sh //验证脚本可执行</span><br><span class="line">-rwxr-xr-x 1 root root 23 Feb 611:09 test.sh</span><br><span class="line">[root@localhost ~]# ./test.sh //以下三个命令证明了结论一</span><br><span class="line">[root@localhost ~]# sh ./test.sh</span><br><span class="line">[root@localhost ~]# bash ./test.sh</span><br><span class="line">[root@localhost ~]# . ./test.sh //以下两个命令证明了结论二</span><br><span class="line">dangxu</span><br><span class="line">[root@localhost ~]# source ./test.sh</span><br><span class="line">dangxu</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Shell 支持自定义变量，不区分数据类型,全部识别为字符串</p>
<p>定义变量时，命名符合标识符规定，变量名不加 $ 符号</p>
<p><code>varName=&quot;value&quot;</code></p>
<p>注意变量名和等号之间不能有空格，同时变量名的命令遵循以下规则</p>
<ul>
<li>首个字符必须为字母</li>
<li>中间不能有空格，支持下划线</li>
<li>不能使用标点符号，不能使用 bash 里的关键字</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用一个定义过的变量，只要在变量名前面加 $ 符号即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $varName</span><br><span class="line">echo $&#123;varName&#125; //&#123;&#125;帮助进行边界识别</span><br></pre></td></tr></table></figure>

<p>变量名外的花括号时可选的，可以用于帮助解释器识别变量，比如下面这种情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for skill in Ada</span><br><span class="line">do</span><br><span class="line">	echo &quot;i am good at $&#123;skill&#125;Script&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>如果不给 skill 变量加{}，解释器会把 $skillScript 当成一个变量</p>
<h2 id="重新定义"><a href="#重新定义" class="headerlink" title="重新定义"></a>重新定义</h2><p>已定义的变量可以被重新定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myUrl=&quot;http://see.xidian.edu.cn/cpp/linux/&quot;</span><br><span class="line">echo $&#123;myUrl&#125;</span><br><span class="line">myUrl=&quot;http://see.xidian.edu.cn/cpp/shell/&quot;</span><br><span class="line">echo $&#123;myUrl&#125;</span><br></pre></td></tr></table></figure>

<p>第二次赋值的时候不能写 <code>$myUrl=&quot;http://see.xidian.edu.cn/cpp/shell/&quot;</code>，只有使用变量时才加 $ 符号</p>
<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用 readonly 可以将变量定义为只读变变量，只读变量的值不能被改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">myUrl=&quot;http://see.xidian.edu.cn/cpp/shell/&quot;</span><br><span class="line">readonly myUrl</span><br><span class="line">myUrl=&quot;http://see.xidian.edu.cn/cpp/danpianji/&quot;</span><br></pre></td></tr></table></figure>

<p>运行脚本，会报如下错误：</p>
<p><code>/bin/sh: NAME: This variable is read only.</code></p>
<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用 unset 可以删除变量，unset 不能删除只读变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset 变量名</span><br><span class="line">set 显示本地的所有变量</span><br></pre></td></tr></table></figure>

<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h3><p><strong>接收用户参数</strong></p>
<ul>
<li>$0 表示当前脚本名称</li>
<li>$1 表示接收的第一个命令行参数</li>
<li>$2 表示第二个命令行参数，以此类推</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$# 参数的个数</span><br><span class="line">$? 命令执行结果,函数返回结果,</span><br><span class="line">$$ 进程id</span><br><span class="line">$1,$2..$9,$&#123;10&#125;, $&#123;11&#125;</span><br><span class="line">$@ &quot;&quot;</span><br><span class="line">$* &quot;$*&quot;  当做整体处理</span><br></pre></td></tr></table></figure>

<h3 id="环境变量-全局可以访问的变量"><a href="#环境变量-全局可以访问的变量" class="headerlink" title="环境变量 (全局可以访问的变量)"></a>环境变量 (全局可以访问的变量)</h3><p>脚本中定义的变量只在本脚本有效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env</span><br><span class="line">export 变量名  //将局部变量变为全局变量</span><br></pre></td></tr></table></figure>

<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><table>
<thead>
<tr>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td align="center">$n</td>
<td>传递给脚本或函数的参数，$1,$2</td>
</tr>
<tr>
<td align="center">$#</td>
<td>传递给脚本或函数的参数个数</td>
</tr>
<tr>
<td align="center">$*</td>
<td>传递给脚本或函数的所有参数</td>
</tr>
<tr>
<td align="center">$@</td>
<td></td>
</tr>
<tr>
<td align="center">$?</td>
<td>上个命令的退出状态或函数的返回值</td>
</tr>
<tr>
<td align="center">$$</td>
<td>当前 shell 进程 ID</td>
</tr>
</tbody></table>
<p><strong><code>$*</code> 和 <code>$@</code> 的区别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;\$*=&quot; $*</span><br><span class="line">echo &quot;\&quot;\$*\&quot;=&quot;&quot;$*&quot;</span><br><span class="line">echo &quot;\$@=&quot; $@</span><br><span class="line">echo &quot;\&quot;\$@\&quot;=&quot;&quot;$@&quot;</span><br><span class="line">echo &quot;print each param from \$*&quot;</span><br><span class="line">for var in $*</span><br><span class="line">do</span><br><span class="line">	echo &quot;$var&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;print each param from \$@&quot;</span><br><span class="line">for var in $@</span><br><span class="line">do</span><br><span class="line">	echo &quot;$var&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;print each param from \&quot;\$*\&quot;&quot;</span><br><span class="line">for var in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">	echo &quot;$var&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;print each param from \&quot;\$@\&quot;&quot;</span><br><span class="line">for var in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">	echo &quot;$var&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>运行 .&#x2F;test.sh “a” “b” “c” “d”，看到下面的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$*= a b c d&quot;</span><br><span class="line">$*&quot;= a b c d</span><br><span class="line">$@= a b c d&quot;</span><br><span class="line">$@&quot;= a b c d</span><br><span class="line">print each param from $*abcd</span><br><span class="line">print each param from $@abcd</span><br><span class="line">print each param from &quot;$*&quot;a b c d</span><br><span class="line">print each param from &quot;$@&quot;abcd</span><br></pre></td></tr></table></figure>

<h1 id="替换，运算符，字符串，数组"><a href="#替换，运算符，字符串，数组" class="headerlink" title="替换，运算符，字符串，数组"></a>替换，运算符，字符串，数组</h1><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">a=10</span><br><span class="line">echo -e &quot;Value of a is $a \n&quot;</span><br></pre></td></tr></table></figure>

<p>这里 -e 表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value of a is 10\n</span><br></pre></td></tr></table></figure>

<p><strong>命令替换</strong><br>命令替换是将一个命令的输出作为另一个命令的参数。命令格式如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1  `command2`</span><br></pre></td></tr></table></figure>

<p>其中，命令 command2 的输出将作为命令 command1 的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls `pwd`  //这里是反引号,和~是同一个按键</span><br></pre></td></tr></table></figure>

<p>pwd 命令用于显示当前目录的绝对路径。在上面的命令行中，使用命令置换符，将 pwd 的运行结果作为 ls 命令的参数。最终，命令执行结果是显示当前目录的文件内容。</p>
<ul>
<li>需要注意命令置换和管道 pipe 的区别</li>
</ul>
<p><strong>变量替换</strong><br>变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值可以使用的变量替换形式</p>
<table>
<thead>
<tr>
<th align="center">形式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">${var}</td>
<td align="center">变量本来的值</td>
</tr>
<tr>
<td align="center">${var:-word}</td>
<td align="center">如果变量 var 为空或已被删除 (unset)，那么返回 word，但不改变 var 的值。</td>
</tr>
<tr>
<td align="center">${var:&#x3D;word}</td>
<td align="center">如果变量 var 为空或已被删除(unset)，那么返回word，并将 var 的值设置为 word。</td>
</tr>
<tr>
<td align="center">${var:?message}</td>
<td align="center">如果变量 var 为空或已被删除 (unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在 Shell 脚本中，那么脚本将停止运行。</td>
</tr>
<tr>
<td align="center">${var:+word}</td>
<td align="center">如果变量 var 被定义，那么返回 word，但不改变 var 的值。</td>
</tr>
</tbody></table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Bash 支持很多运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符<br><strong>算数运算符</strong><br>awk 和 expr，expr</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo &quot;value : $val&quot;</span><br><span class="line">val=`expr 2 \* 2`</span><br><span class="line">echo &quot;value : $val&quot;</span><br></pre></td></tr></table></figure>

<p>输出 <code>value : 4 value : 4</code></p>
<ul>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2</li>
<li>完整的表达式要被 &#96;&#96; 包含，注意这个字符不是常用的单引号，在 Esc 键下边</li>
<li>乘号 <code>*</code> 前边必须加反斜杠 <code>\</code> 才能实现乘法运算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`+`</span><br><span class="line">`-`</span><br><span class="line">`*`</span><br><span class="line">`/`</span><br><span class="line">`%`取余</span><br><span class="line">`=`赋值</span><br><span class="line">`==`相等</span><br><span class="line">`!=`不等</span><br></pre></td></tr></table></figure>

<p><strong>关系运算符</strong><br>关系运算符只支持数字，不支持字符串，除非字符串的值是数字<br><code>-eq</code> 相等<br><code>-ne</code> 不等<br><code>-gt</code> 左侧大于右侧，返回 true<br><code>-lt</code> 小于<br><code>-ge</code> 大于等于<br><code>-le</code> 小于等于<br><strong>布尔运算符</strong><br><code>!</code> 非<br><code>-a</code> 与<br><code>-o</code> 或<br><strong>字符串运算符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ -z $String ] echo $?</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`=` 检测两个字符串是否相等，相等返回 true。</span><br><span class="line">`!=` 不等</span><br><span class="line">`-z` 检测字符串长度是否为0，为0返回 true</span><br><span class="line">`-n` 检测字符串长度是否为0，不为0返回 true</span><br><span class="line">`str` 检测字符串是否为空，不为空返回 true。</span><br></pre></td></tr></table></figure>

<p><strong>文件测试运算符</strong><br>文件测试运算符用于检测 Unix 文件的各种属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ -d /etc/fstab ] echo $?</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-b file</td>
<td align="center">检测文件是否是块设备文件</td>
</tr>
<tr>
<td align="center">-c file</td>
<td align="center">检测文件是否是字符设备文件</td>
</tr>
<tr>
<td align="center">-d file</td>
<td align="center">检测文件是否是目录</td>
</tr>
<tr>
<td align="center">-f file</td>
<td align="center">检测文件是否是普通文件（既不是目录，也不是设备文件）</td>
</tr>
<tr>
<td align="center">-g file</td>
<td align="center">检测文件是否设置了 SGID 位</td>
</tr>
<tr>
<td align="center">-k file</td>
<td align="center">检测文件是否设置了粘着位 (Sticky Bit)</td>
</tr>
<tr>
<td align="center">-p file</td>
<td align="center">检测文件是否是具名管道</td>
</tr>
<tr>
<td align="center">-u file</td>
<td align="center">检测文件是否设置了 SUID 位</td>
</tr>
<tr>
<td align="center">-r file</td>
<td align="center">检测文件是否可读</td>
</tr>
<tr>
<td align="center">-w file</td>
<td align="center">检测文件是否可写</td>
</tr>
<tr>
<td align="center">-x file</td>
<td align="center">检测文件是否可执行</td>
</tr>
<tr>
<td align="center">-s file</td>
<td align="center">检测文件是否为空（文件大小是否大于 0）</td>
</tr>
<tr>
<td align="center">-e file</td>
<td align="center">检测文件（包括目录）是否存在</td>
</tr>
</tbody></table>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串可以用单引号，也可以用双引号，也可以不用引号</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li>
<li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>bash 支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p>
<p><strong>定义数组</strong></p>
<p>在 Shell 中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure>

<p>还可以单独定义数组的各个分量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure>

<p><strong>读取数组</strong><br>读取数组元素值的一般格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;array_name[index]&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@</code> 或 <code>*</code> 可以获取数组中的所有元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;array_name[*]&#125;</span><br><span class="line">$&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取数组长度</strong><br>或取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]</span><br></pre></td></tr></table></figure>

<h1 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h1><h2 id="功能语句"><a href="#功能语句" class="headerlink" title="功能语句"></a>功能语句</h2><p>read 是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p 参数用于向用户显示一定的提示信息。</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-p</td>
<td align="center">“ 提示内容 “</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">等待用户输入时间</td>
</tr>
<tr>
<td align="center">-n</td>
<td align="center">读的字符个数</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="center">隐藏输入</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read -n 5 AA BB CC</span><br><span class="line">read AA BB CC</span><br><span class="line">hello xiaoming, mingtian you kong</span><br><span class="line">read -p &quot;Enter your score（0-100）：&quot; GRADE</span><br></pre></td></tr></table></figure>

<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p><strong>判断语句格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 条件表达式 ]</span><br></pre></td></tr></table></figure>

<p>对应两边应均有一个空格</p>
<p><strong>逻辑测试语句：</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="center">与 (当前面的命令执行成功后才会执行它后面的命令)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">或（当前面的命令执行失败后才会执行它后面的命令）</td>
</tr>
<tr>
<td align="center">！</td>
<td align="center">非（把条件测试中的判断结果取相反值）</td>
</tr>
</tbody></table>
<p>得到当前内存剩余量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FreeMem=`free -m | grep Mem: | awk &#x27;&#123;print $4&#125;&#x27;`</span><br><span class="line">[ $FreeMem -lt 1024 ] &amp;&amp; echo &quot;Insufficient Memory&quot;</span><br></pre></td></tr></table></figure>

<p><strong>break 语句</strong><br>break 命令允许跳出所有循环（终止执行后面的所有循环）。在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break n    //表示跳出第 n 层循环。</span><br></pre></td></tr></table></figure>

<p><strong>continue 语句</strong><br>continue 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。<br>同样，continue 后面也可以跟一个数字，表示跳出第几层循环。</p>
<h2 id="结构语句"><a href="#结构语句" class="headerlink" title="结构语句"></a>结构语句</h2><p><strong>case</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case</span><br><span class="line">case var in</span><br><span class="line">1)</span><br><span class="line">...</span><br><span class="line">;;</span><br><span class="line">2|3|4)</span><br><span class="line">...</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>case 工作方式如上所示。取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。</p>
<p>demo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入一个字符，并按Enter键确认：&quot; KEY</span><br><span class="line">case &quot;$KEY&quot; in</span><br><span class="line">[a-z]|[A-Z])</span><br><span class="line">    echo &quot;您输入的是 字母。&quot;</span><br><span class="line">    ;;</span><br><span class="line">[0-9])</span><br><span class="line">    echo &quot;您输入的是 数字。&quot;</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;您输入的是 空格、功能键或其他控制字符。&quot;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<p><strong>if</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ ] then</span><br><span class="line">else</span><br><span class="line">fi</span><br><span class="line">if [ ] then</span><br><span class="line">elif [ ] then</span><br><span class="line">else</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>demo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;Enter The Users Password : &quot; PASSWD</span><br><span class="line">for UNAME in `cat users.txt`</span><br><span class="line">do</span><br><span class="line">id $UNAME &amp;&gt; /dev/null （&amp;&gt;就是&quot;&gt;&quot;和&quot;2&gt;&quot;这两个的结合体）</span><br><span class="line">if [ $? -eq 0 ] then</span><br><span class="line">    echo &quot;Already exists&quot;</span><br><span class="line">else</span><br><span class="line">    useradd $UNAME &amp;&gt; /dev/null echo &quot;$PASSWD&quot; | passwd --stdin $UNAME &amp;&gt; /dev/null</span><br><span class="line">    if [ $? -eq 0 ] then</span><br><span class="line">    echo &quot;$UNAME , Create success&quot; else echo &quot;$UNAME , Create failure&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p><strong>for</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 变量 in 列表</span><br><span class="line">do</span><br><span class="line">..</span><br><span class="line">done</span><br><span class="line">for ((i=0; i&lt;N; i++))</span><br><span class="line">do</span><br><span class="line">done</span><br><span class="line">for var in `ls`</span><br><span class="line">for var in $(ls)</span><br><span class="line">for var    #列表的内容是位置参数变量时，可以省略in ...</span><br></pre></td></tr></table></figure>

<p>列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。</p>
<p>demo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HLIST=`echo www.baidu.com`</span><br><span class="line">for IP in $HLIST</span><br><span class="line">do</span><br><span class="line">    ping -c 3 -i 0.2 -W 3 $IP &amp;&gt; /dev/null</span><br><span class="line">if [ $? -eq 0 ] then</span><br><span class="line">    echo &quot;baidu is online&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;baidu is offline&quot;</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>while</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while 表达式</span><br><span class="line">do</span><br><span class="line">..</span><br><span class="line">done</span><br><span class="line">while (($i &lt; $loop))</span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>while 循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。</p>
<p>demo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRICE=$(expr $RANDOM % 1000)</span><br><span class="line">TIMES=0</span><br><span class="line">echo &quot;商品实际价格为0-999之间，猜猜看是多少？&quot;</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    read -p &quot;请输入您猜测的价格数目：&quot; INT</span><br><span class="line">    let TIMES++</span><br><span class="line">    if [ $INT -eq $PRICE ] ; then</span><br><span class="line">        echo &quot;恭喜您答对了，实际价格是 $PRICE&quot; echo &quot;您总共猜测了 $TIMES 次&quot;</span><br><span class="line">        exit 0</span><br><span class="line">    elif [ $INT -gt $PRICE] ; then</span><br><span class="line">        echo &quot;太高了！&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;太低了！&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>untill</strong><br>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般 while 循环优于 until 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=0</span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">echo $a</span><br><span class="line">a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><p><strong>定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function_name () &#123;</span><br><span class="line">    list of commands</span><br><span class="line">    [ return value ]</span><br><span class="line">&#125;</span><br><span class="line">function function_name () &#123;</span><br><span class="line">    list of commands</span><br><span class="line">    [ return value ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。<br><strong>返回值</strong><br>函数返回值，可以显式增加 return 语句；如果不加，会将最后一条命令运行结果作为返回值。接收函数返回值用 <code>$?</code>。<br>Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0 表示成功，其他值表示失败。（返回值范围 0-255）<br>如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。<br>如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。<br><strong>调用</strong><br>调用函数只需要给出函数名，不需要加括号。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello() &#123;</span><br><span class="line">echo &quot;hello, world&quot;</span><br><span class="line">&#125;</span><br><span class="line">Hello</span><br><span class="line">Hello2() &#123;</span><br><span class="line">echo &quot;hello2, world&quot;</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br><span class="line">Hello2</span><br><span class="line">ret=$?</span><br></pre></td></tr></table></figure>

<p>输出给了变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var=$(Hello2)</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong><br>像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 .f 选项，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset .f function_name</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>在 Shell 中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1 表示第一个参数，$2 表示第二个参数</p>
<p>获取第十个参数需要 <code>$&#123;10&#125;</code>。当 n&gt;&#x3D;10 时，需要使用 <code>$&#123;n&#125;</code> 来获取参数。</p>
<p><code>$#</code> 传递给函数的参数个数。</p>
<p><code>$*</code> 显示所有传递给函数的参数。</p>
<p><code>$@</code> 与 <code>$*</code> 相同，但是略有区别</p>
<p><code>$?</code> 函数的返回值。</p>
<p>传参:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add_fun () &#123;</span><br><span class="line">&#125;</span><br><span class="line">add_fun str1 str2 str3</span><br></pre></td></tr></table></figure>

<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. filename</span><br><span class="line">source filename</span><br></pre></td></tr></table></figure>

<p>两种方式的效果相同，简单起见，一般使用点号 (.)，但是注意点号 (.) 和文件名中间有一空格</p>
<ul>
<li>被包含脚本不需要有执行权限</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等等。</p>
<p><strong>变量种类</strong></p>
<p>按变量的生存周期来划分，Linux 变量可分为两类：</p>
<ul>
<li>永久的：需要修改配置文件，变量永久生效。</li>
<li>临时的：使用 export 命令声明即可，变量在关闭 shell 时失效。<br><strong>设置环境变量</strong></li>
<li>在&#x2F;etc&#x2F;profile 文件中添加变量【对所有用户生效（永久的）】<br>  用 VI 在文件&#x2F;etc&#x2F;profile 文件中增加变量，该变量将会对 Linux 下所有用户有效，并且是“永久的”。例如：编辑&#x2F;etc&#x2F;profile 文件，添加 PATH 变量<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  export PATH=/home/fs : $PATH</span><br></pre></td></tr></table></figure><br>  &gt; 注：修改文件后要想马上生效还要运行# source &#x2F;etc&#x2F;profile 不然只能在下次重进此用户时生效。</li>
<li>在用户目录下的.bash_profile 文件中增加变量【对单一用户生效（永久的）】<br>  用 VI 在用户目录下的.bash_profile 文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 例如：编辑 guok 用户目录（&#x2F;home&#x2F;guok）下的.bash_profile，添加如下内容：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure><br>  &gt; 注：修改文件后要想马上生效还要运行 $ source &#x2F;home&#x2F;guok&#x2F;.bash_profile 不然只能在下次重进此用户时生效。</li>
<li>直接运行 export 命令定义变量【只对当前 shell（BASH）有效（临时的）】<br>  在 shell 的命令行下直接使用 [export 变量名&#x3D;变量值] 定义变量，该变量只在当前的 shell（BASH）或其子 shell（BASH）下是有效的，shell 关闭了，变量也就失效了，再打开新 shell 时就没有这个变量，需要使用的话还需要重新定义。<br><strong>PATH 声明</strong><br>其格式为：<code>PATH=$PATH:</code> 你可以自己加上指定的路径，中间用冒号隔开。<br>环境变量更改后，在用户下次登陆时生效。<br>如果想立刻生效，则可执行下面的语句：<code>$source .bash_profile</code><br>需要注意的是，最好不要把当前路径 <code>./</code> 放到 PATH 里，这样可能会受到意想不到的攻击。<br>完成后，可以通过 <code>$ echo $PATH</code> 查看当前的搜索路径。这样定制后，就可以避免频繁的启动位于 shell 搜索的路径之外的程序了。<br><strong>常用的环境变量</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PATH</td>
<td align="center">决定了 shell 将到哪些目录中寻找命令或程序</td>
</tr>
<tr>
<td align="center">HOME</td>
<td align="center">当前用户主目录</td>
</tr>
<tr>
<td align="center">HISTSIZE</td>
<td align="center">历史记录数</td>
</tr>
<tr>
<td align="center">LOGNAME</td>
<td align="center">当前用户的登录名</td>
</tr>
<tr>
<td align="center">HOSTNAME</td>
<td align="center">指主机的名称</td>
</tr>
<tr>
<td align="center">SHELL</td>
<td align="center">当前用户 Shell 类型</td>
</tr>
<tr>
<td align="center">LANGUGE</td>
<td align="center">语言相关的环境变量，多语言可以修改此环境变量</td>
</tr>
<tr>
<td align="center">MAIL</td>
<td align="center">当前用户的邮件存放目录</td>
</tr>
<tr>
<td align="center">PS1</td>
<td align="center">基本提示符，对于 root 用户是#，对于普通用户是 $</td>
</tr>
</tbody></table>
<p><strong>常用的环境变量相关命令</strong></p>
<ul>
<li>设置一个新的环境变量 hello<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ export HELLO=&quot;Hello&quot;</span><br><span class="line">  fs@ubuntu:~$ echo $HELLO</span><br><span class="line">  Hello</span><br><span class="line">  fs@ubuntu:~$</span><br></pre></td></tr></table></figure></li>
<li>使用 env 命令显示所有的环境变量<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ env</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure></li>
<li>使用 set 命令显示所有本地定义的 Shell 变量，set 可以设置某个环境变量的值。<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ set</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>使用 unset 命令来清除环境变量，清除环境变量的值用 unset 命令。如果未指定值，则该变量值将被设为 NULL。示例如下：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ export TEST=&quot;Test&quot; \\增加一个环境变量TEST</span><br><span class="line">  fs@ubuntu:~$ env | grep TEST \\此命令有输出，证明环境变量TEST已存在</span><br><span class="line">  TEST=Test</span><br><span class="line">  fs@ubuntu:~$ unset $TEST \\删除环境变量TEST</span><br><span class="line">  fs@ubuntu:~$ env | grep TEST \\此命令没输出，证明环境变量TEST已经存在</span><br></pre></td></tr></table></figure></li>
<li>使用 readonly 命令设置只读变量，如果使用了 readonly 命令的话，变量就不可以被修改或清除了。示例如下：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ export TEST=&quot;Test&quot; \\增加一个环境变量TEST</span><br><span class="line">  fs@ubuntu:~$ readonly TEST \\将环境变量TEST设为只读</span><br><span class="line">  fs@ubuntu:~$ unset TEST \\此变量无法删除</span><br><span class="line">  bash: unset: TEST: cannot unset: readonly variable</span><br><span class="line">  fs@ubuntu:~$ TEST=&quot;NEW&quot; \\此变量不可更改</span><br><span class="line">  bash: TEST: readonly variable</span><br><span class="line">  fs@ubuntu:~$</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="计划任务服务程序"><a href="#计划任务服务程序" class="headerlink" title="计划任务服务程序"></a>计划任务服务程序</h2><p><strong>一次性计划任务</strong><br>“at 时间 “ 是一个命令行工具，用于在指定的时间执行一次性任务。<br>通过使用该命令，您可以安排计划在将来的某个时间运行的命令或脚本。<br>时间参数可以采用多种格式，如 HH:MM，HH:MM AM&#x2F;PM 或者明天的日期。<br>例如，以下命令将在下午 2 点运行一个脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at 2pm &lt;脚本路径&gt;</span><br></pre></td></tr></table></figure>

<p><strong>查看计划任务</strong><br>“at -l” 命令用于列出当前计划的 at 任务列表，显示已经被安排的任务及其相关信息，如任务序号、执行时间等。<br>例如，以下命令将列出当前计划的 at 任务列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at -l</span><br></pre></td></tr></table></figure>

<p><strong>取消计划任务</strong><br>“atrm 任务序号 “ 命令用于取消一个已经计划的 at 任务，其中任务序号是通过 “at -l” 命令列出的任务的序号。<br>例如，以下命令将取消任务序号为 1 的 at 任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atrm 1</span><br></pre></td></tr></table></figure>

<p><strong>长期性计划任务</strong><br><code>crontab -e</code> 创建、编辑计划任务<br><code>crontab -l</code> 查看当前计划任务<br><code>crontab -r</code> 删除某条计划任务<br><code>crontab -u</code> 编辑他人的计划任务<br>demo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">crontab -l</span><br><span class="line">&gt;25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar /home/wwwroot</span><br><span class="line">whereis rm</span><br></pre></td></tr></table></figure>

<p><strong>时间周期设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25 3 * * 1,3,5</span><br></pre></td></tr></table></figure>

<p>依次对应 分钟，小时，日期，月份，星期</p>
<p><strong>任务内容:</strong></p>
<p>要运行的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/tar -czvf backup.tar /home/wwwroot</span><br></pre></td></tr></table></figure>

<h2 id="终端和控制台"><a href="#终端和控制台" class="headerlink" title="终端和控制台"></a>终端和控制台</h2><p><strong>终端 (terminal，或者叫物理终端）：</strong><br>是一种设备，不是一个程序，一般说的就是能提供命令行用户界面的设备，典型的是屏幕和键盘，或其他的一些物理终端。</p>
<blockquote>
<p>虚拟终端：<br>屏幕和键盘只是一个终端，可能不够用，又不想增加设备投入，就产生了虚拟终端。<br>gnome-terminal,urxvt，mlterm，xterm 等等是一个程序，职责是模拟终端设备，和虚拟终端的区别表面上在于它以 GUI 形式的窗口出现，内部则是程序结构和系统控制结构有所不同，但本质上差不多。<br><strong>控制台（console):</strong><br>显示系统消息的终端就叫控制台，Linux 默认所有虚拟终端都是控制台，都能显示系统消息。<br>有时专指 CLI 下的模拟终端设备的一个程序，和 gnome-terminal,urxvt，mlterm，xterm 等相同，只是 CLI 和 GUI 界面的区别。<br>一般 console 有 6 个，tty1-6，CTRL+ALT+f1-6 切换。<br><strong>shell：</strong><br>shell 是一个抽象概念，shell 的一切操作都在计算机内部，负责处理人机交互，执行脚本等，是操作系统能正常运行的重要组成部分,bash，ash，zsh，tcsh 等是 shell 这个抽象概念的一种具体的实现，都是一个程序，都能生成一个进程对象<br>如果想换 shell 的程序，可以修改&#x2F;etc&#x2F;passwd，把里面的&#x2F;bin&#x2F;bash 换成你想要的 shell，或者用 chsh 命令来切换<br><strong>shell 与终端的关系：</strong><br>shell 把一些信息适当的输送到终端设备，同时还接收来自终端设备的输入。一般每个 shell 进程都会有一个终端关联，也可以没有。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符程序 &lt;---&gt; 虚拟终端 &lt;---&gt; 图像显示</span><br><span class="line">shell &lt;---&gt; xterm &lt;---&gt; X11</span><br></pre></td></tr></table></figure>

<p><strong>控制台和终端的历史遗留区别</strong><br>计算机最初由于价格昂贵，因此，一台计算机一般是由多个人同时使用的。在这种情况下一台计算机需要连接上许多套键盘和显示器来供多个人使用。</p>
<p>在以前专门有这种可以连上一台电脑的设备，只有显示器和键盘，还有简单的处理电路，本身不具有处理计算机信息的能力，他是负责连接到一台正常的计算机上（通常是通过串口） ，然后登陆计算机，并对该计算机进行操作。</p>
<p>当然，那时候的计算机操作系统都是多任务多用户的操作系统。</p>
<p>这样一台只有显示器和键盘能够通过串口连接到计算机 的设备就叫做终端。</p>
<p>而控制台又是什么回事呢？ 学机电的人应该知道，一台机床，或者数控设备的控制箱，通常会被称为控制台，顾名思义，控制台就是一个直接控制设备的台面（一个面板，上面有很多控制按钮）。</p>
<p>在计算机里，把那套直接连接在电脑上的键盘和显示器就叫做控制台。</p>
<p>请注意它和终端的区别，终端是通过串口连接上的，不是计算机本身就有的设备，而控制台是计算机本身就有的设备，一个计算机只有一个控制台。</p>
<p>计算机启动的时候，所有的信息都会显示到控制台上，而不会显示到终端上。</p>
<p>也就是说，控制台是计算机的基 本设备，而终端是附加设备。</p>
<p>当然，由于控制台也有终端一样的功能，控制台有时候也被模糊的统称为终端。</p>
<p>计算机操作系统中，与终端不相关的信息，比如内核消息，后台服务消息，都可以显示到控制台上，但不会显示到终端上。</p>
<p><strong>现在</strong><br>普通用户可以简单的把终端和控制台理解为：可以输入命令行并显示程序运行过程中的信息以及程序运行结果的窗口。 不必要严格区分这两者的差别。</p>
<p>现在由于计算机硬件越来越便宜，通常都是一个人独占一台计算机超做，不再连接以前那种真正意义上的“终端设备了”，因此，终端和控制台的概念也慢慢演化了。</p>
<p>终端和控制台由硬件的概念，演化成了软件的概念。</p>
<p>现在说的终端，比如 linux 中的虚拟终端，都是软件的概念，他用计算机的软件来模拟以前硬件的方式。</p>
<p>比如在 linux 中，你用 alt+f1 ~ f6 可以切换六个虚拟终端，就好比是以前多人公用的计算机中的六个终端设备，这就是为什么这个叫“虚拟终端”的原因。</p>
<p>当然，现在的 linux 也可以通过串口 线，连接一个真正的终端，现在这种终端设备已经非常罕见了，但是还存在，只是一般人很难见到。</p>
<p>也有人利用以前的老电脑（386，486）装上一个串口通信软件，连上一台计算机，来模拟一个终端来用。这样可以达到一台电脑多人使用的目的。</p>
<p>简单的说，能直接显示系统消息的那个终端称为控制台，其他的则称为终端。</p>
<p>但是在 linux 系统中，这个概念也已经模糊化了。</p>
<p>比如下面这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hello,world&quot; &gt; /dev/console</span><br></pre></td></tr></table></figure>

<p>这条命令的目的是将 “hello,world” 显示到控制台上&#x2F;dev&#x2F;console 是控制台设备的设备名。</p>
<p>在 linux 中，在字符模式下，你无论在哪个虚拟终端下执行这条命令，字符 hello,world 都会显示在当前的虚拟终端下。也就是说，linux 把当前的终端当作控制台来看待。可见，linux 中已经完全淡化了控制台和终端的区别。</p>
<p>但是在其他的 UNIX 类系统中，却很明显的有虚拟终端和控制台的区别。比如 freeBSD 系统。在 freebsd 中，只有第一个“终端”才是真正的控制台。（就是说按 alt+f1 得到的那个虚拟终端），你无论在哪个虚拟终端上执行上面的那条命令（哪怕是通过网络连接的伪终端上执行这条命令）。hello,world 字符总会显示到第一个“终端”也就是 真正的控制台上。</p>
<p>另外，其他的一些系统内部信息，比如哪个用户在哪个终端登陆，系统有何严重错误警告等信息，全都显示在这个真正的控制台上。在这里，就明显的区分了终端和控制台的概念。其他 UNIX 中也是这样的。</p>
<p>比如 Tru64 unix 在 X 下有一个控制台模拟软件，你无论在哪里输入 <code>echo &quot;hello,world&quot; &gt; /dev/console</code> 命令，hello,world 总会显示在这个控制台模拟器中。</p>
<p>我们在 X 界面下用的那些输入命令的软件，比如 xterm ,rxvt, gnome-terminal 等等，都应该被称为终端模拟软件。</p>
<p>请注意它和控制台模拟软件的区别。</p>
<p>linux 中好象没有控制台模拟软件。</p>
<p>在 X 中的终端模拟 软件中输入的 <code>echo &quot;hello,world&quot;&gt;/dev/console</code> 命令的输出信息，都会输出到启动该 X 服务器的虚拟终端上。</p>
<p>比如，你用字符方式登陆系统。进入第一个虚拟终端，然后 startx 启动 X 服务器。</p>
<p>再打开 xterm 来输入 <code>echo &quot;hello,world&quot;&gt;/dev/console</code> 命令，那么字符串 hello,world 就显示在第一个虚拟终端上。</p>
<p>你按 ctrl+alt+f1，回到那个启动 X 服务器的终端，就可以看到 hello, world 字符串。</p>
<p>现在该明白终端和控制台的区别了吧。</p>
<p>再简单的说，控制台是直接和计算机相连接的原生设备，终端是通过电缆、网络等等和主机连接的设备。在以前的硬件终端设备中，由于生产厂家不同，所遵循的标准不同，因此有不同的型号标准。</p>
<p>比如 vt100 等。这里的 vt100 就是一个标准，那么现在我 们所说的终端，往往不是真正的硬件终端了，而是终端模拟软件了，因此不同的终端模拟软件可能符合不同的标准，还有一些终端模拟软件符合很多种不同终端的标准。</p>
<p>比如 gnome 的终端模拟软件 gnome-terminal，他提供好几中标准可供用户选择。</p>
<p>用户只要设置一下就可以了。现在，由于原先的这些设备在我们的视线中渐渐淡出，控制台和终端的概念也慢慢谈化。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>3D打印控制命令</title>
    <url>/2024/05/21/%E5%85%B6%E4%BB%96-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>G-Code 协议指令 <a href="https://marlinfw.org/meta/gcode/">https://marlinfw.org/meta/gcode/</a></p>
<h1 id="限位开关"><a href="#限位开关" class="headerlink" title="限位开关"></a>限位开关</h1><p>确保 X、Y 和 Z 轴的限位开关都没有被触发，然后通过控制台发送命令：</p>
<p><code>QUERY_ENDSTOPS</code></p>
<p>返回值是 <code>open</code> 打开，则限位触发电平类型设置正确，如果是 <code>triggered</code>（触发），则需要修改限位的电平类型（以 X 轴为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[stepper_X]</span><br><span class="line">endstop_pin: ^PE5   #修改前</span><br><span class="line">endstop_pin: ^!PE5    #修改后</span><br></pre></td></tr></table></figure>

<h1 id="热床-PID-校正"><a href="#热床-PID-校正" class="headerlink" title="热床 PID 校正"></a>热床 PID 校正</h1><p>G28 归零后，将喷嘴移至热床中心，高出床面约 5-10mm，然后发送命令</p>
<p><code>PID_CALIBRATE HEATER=heater_bed TARGET=100</code></p>
<p>它将执行一个 PID 校准程序，将持续约 10 分钟，完成后控制台将会返回 PID 数值，将其复制到热床的 PID 设置即可。</p>
<h1 id="挤出头-PID-校正"><a href="#挤出头-PID-校正" class="headerlink" title="挤出头 PID 校正"></a>挤出头 PID 校正</h1><p>先将模型冷却风扇设置为 25% 的转速 <code>M106 S64</code> ，然后发送命令</p>
<p><code>PID_CALIBRATE HEATER=extruder TARGET=245</code></p>
<p>它将执行一个 PID 校准程序，将持续约 5 分钟，完成后控制台将返回 PID 数值，将其复制到配置文件即可。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>使 Klipper 进入 “shutdown”（关闭）状态</p>
<p><code>M112</code></p>
<p>重新加载配置文件并重启</p>
<p><code>FIRMWARE_RESTART</code></p>
<p>保存配置文件</p>
<p><code>SAVE_CONFIG</code></p>
<p>查看使用的 printer.cfg 文件位置</p>
<p><code>ps -ef | grep klippy</code></p>
<p>获取位置</p>
<p><code>GET_POSITION</code></p>
<p>调平</p>
<p><code>QUAD_GANTRY_LEVEL</code></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133821.png" alt="image_c7a7cda2a2274479a4842a06aa6ee475.png"></p>
]]></content>
      <categories>
        <category>其他</category>
        <category>3D打印机</category>
      </categories>
  </entry>
  <entry>
    <title>3D打印机介绍</title>
    <url>/2024/05/17/%E5%85%B6%E4%BB%96-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="3D-打印机"><a href="#3D-打印机" class="headerlink" title="3D 打印机"></a>3D 打印机</h1><p>3D 打印（3D printing）是一种快速成型技术，也被称为添加制造（Additive Manufacturing，AM）。它是一种通过将材料逐层叠加以构建三维实体物体的过程。与传统的制造方法不同，3D 打印不需要模具或切削工具，而是通过从计算机辅助设计（CAD）模型中生成的数字模型直接创建物体。</p>
<p><strong>FDM（熔融沉积成型）</strong>：FDM 是目前最常见的 3D 打印技术，它使用热塑性材料通过打印头喷出的方式逐层堆积，最终形成所需的物体。FDM 打印机的结构和控制系统比较简单，价格也比较实惠，因此广泛应用于家庭、办公室和教育等领域。</p>
<p><strong>SLA（光固化成型）</strong>：SLA 使用紫外线激光器或 LED 光源照射光敏树脂，使其逐层固化成为所需的物体。SLA 打印机的精度和表面光滑度比 FDM 更高，但价格也更贵。</p>
<p><strong>SLS（选择性激光烧结）</strong>：SLS 使用激光束将热塑性粉末烧结在一起，逐层堆积形成所需的物体。SLS 打印机可以使用多种材料，可以打印出更复杂的结构，但价格也更昂贵。</p>
<p><strong>DLP（数字光处理）</strong>：DLP 使用光敏树脂和数字投影仪，通过投影仪将光固化在涂层的树脂上，逐层堆积形成所需的物体。DLP 打印机的速度和精度都比较高，但价格也较贵。</p>
<h1 id="FDM"><a href="#FDM" class="headerlink" title="FDM"></a>FDM</h1><p>通过将加热的材料挤出打印头，逐层堆积形成打印件</p>
<ul>
<li>打印头</li>
<li>打印床&#x2F;热床</li>
<li>控制系统（主板、电机、传感器和用户界面）</li>
<li>打印材料</li>
<li>G-Code<ul>
<li>一种用于控制数控机床（包括 3D 打印机、数控铣床、数控车床等）运动和操作的编程语言。</li>
</ul>
</li>
</ul>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>结构主要分为两部分：</p>
<ul>
<li>一个负责三维空间的移动的组件 (三维移动部分)</li>
<li>一个负责进料、融化材料和挤出材料的组件（挤出部分）</li>
</ul>
<p>打印时材料会一层又一层地堆积在之前已经「挤出来」的材料上，所以在这两个组件共同协作下就能打印出一个完成的 3D 物体了。</p>
<h2 id="结构-三维移动部分"><a href="#结构-三维移动部分" class="headerlink" title="结构 - 三维移动部分"></a>结构 - 三维移动部分</h2><p>打印机在 3D 的空间运动的传动方式有很多种，一般较为便宜的打印机会选择笛卡尔结构。笛卡尔结构指的是 X Y Z 方向上的运动是独立的，这种方式比较直观，结构也比较简单。常用的 3D 打印机的结构有以下几种：</p>
<p><strong>Prusa i3 型：</strong><br>控制 X&#x2F;Z 轴，Y 轴通过工作台的移动来实现。<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522114837.png" alt="image-1689840246601.png"><br><strong>CoreXY 型：</strong><br>CoreXY 最大的特别之处在于其 X、Y 电机是协同运作的，并且它的同步带在不同同步轮的摆放下能够形成多种不一样的缠绕方法。由于两个电机的协同运动，电机带动的力比单一电机的力要大，且会减少在 XY 方向面上的一个电机重量，提高精准性。<br>**<strong>CoreXY 结构</strong>：CoreXY 结构采用的是两个电机通过传动带和滑块来实现打印头的运动，其中 X 和 Y 轴的传动带交叉布置，使得打印头的运动方向可以在 X 和 Y 轴上独立控制。CoreXY 结构的优点是打印速度快，同时打印头的重量对定位精度的影响较小，同时可以实现较大的打印范围。缺点是结构复杂，需要更多的零件和更高的制造精度，同时维护和升级也较为困难。<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133729.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522114901.png" alt="image-1689840339161.png"></p>
<p><strong>Um &#x2F;Ultimaker 型：</strong><br>X 轴、Y 轴的电机都在静止的框架上，但挤出头在两个互相垂直的光轴的交叉处。<br>**<strong>UM 结构（Ultimaker 结构）</strong>：UM 结构采用的是直线轴承和滑块来实现运动，其中 X 和 Y 轴分别由两个电机驱动，通过传动带和滑块来实现打印头的运动。UM 结构的优点是定位精度高，速度快，同时结构简单，易于维护和升级。缺点是打印头的质量和稳定性对定位精度有较大影响，同时打印头的重量也会影响打印速度。<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522114935.png" alt="image-1689840409065.png"></p>
<p><strong>MB：</strong><br>主要体现在挤出电机一般都装在喷头旁，近程进丝，双光轴承载挤出组件，X 方向的运动一般是通过电机带动同步带，通过带传动使两边一起运动。</p>
<p><strong>delta 三角洲（并联臂）型</strong></p>
<h2 id="结构-挤出部分"><a href="#结构-挤出部分" class="headerlink" title="结构 - 挤出部分"></a>结构 - 挤出部分</h2><p>挤出部分分为以下：</p>
<ul>
<li>挤出头</li>
<li>送料步进电机</li>
<li>送料步进电机驱动板</li>
</ul>
<p>FDM 3D 打印机除了怎么动的很关键以外，怎么取料、融化材料、挤出材料也非常重要。</p>
<p>其中取料和挤出材料是由挤出机处理的，融化材料则是由热端处理的。</p>
<p>挤出机从材料盘中将材料拉出来，送进去热端融化。</p>
<p>并持续往热端送更多的料让融化的材料从喷嘴中挤出来。</p>
<ul>
<li>其中挤出机的精度和挤出的速度决定了打印质量和速度。精度高意味着可以更好的控制挤出的量。挤出的材料太多或者太少对打印的质量影响都非常大。挤出的速度快就很直接的决定了你能打印多快。</li>
</ul>
<p>而影响挤出机的精度和速度的两个关键因素就是：</p>
<ul>
<li>挤出机的类型</li>
<li>挤出机的齿轮数量</li>
</ul>
<p>FDM 挤出机分为两个大类：</p>
<ul>
<li>远端挤出机<ul>
<li>远端挤出机在于挤出机不需要跟着喷嘴一块移动，减轻了需要移动的零件的重量<br>  远端挤出机由于从喷嘴挤出压力的是通过材料本身传递的，所以远端挤出机的反应时间较长，并且对打印的材料比较敏感，例如 TPU 之类的软质材料就没法很好的打印出来</li>
</ul>
</li>
<li>近端挤出机<ul>
<li>近程挤出机由于距离热端非常近，所以需要的挤出力量也比较小，这样挤出精度就会更高<br>  近程挤出机是和热端是集成在一起的，因此 X Y 轴上移动的部件的重量增加了，震动也会相对的增加</li>
</ul>
</li>
</ul>
<p>另外一个影响挤出机精度的就是挤出机的齿轮了。较低端的机器一般都是配备都是单齿轮，虽然对比双齿轮的挤出机，无论是对材料的咬合能力还是挤出精度都表现更差，但它便宜而且工作，对于预算相对比较紧张的朋友是一个不错的选择。</p>
<h2 id="传动系统"><a href="#传动系统" class="headerlink" title="传动系统"></a>传动系统</h2><p>传动系统分为以下几个部分：</p>
<ul>
<li>Xyz 步进电机</li>
<li>限位开关</li>
<li>步进电机驱动板</li>
<li>同步带</li>
</ul>
<p>传动系统是 3D 打印机中负责移动打印头（或喷嘴）和打印平台的机械组件。它在 3D 打印过程中发挥以下作用：</p>
<ul>
<li>控制位置：传动系统通过精确的运动控制，将打印头定位在正确的位置，以便在每个层次上精确地添加材料。</li>
<li>三维定位：传动系统的运动控制使得打印头可以在 X、Y、Z 三个方向上精确移动，从而实现三维打印。</li>
<li>打印速度：传动系统的运动控制还影响到打印速度。更快的传动系统能够加快打印速度，但需要保持精确性和稳定性，以确保打印质量不受影响。</li>
<li>自动校准：一些高级的传动系统具备自动校准功能，能够自动检测打印平台和打印头的位置，从而保持打印的准确性和稳定性。</li>
</ul>
<h2 id="加热部分"><a href="#加热部分" class="headerlink" title="加热部分"></a>加热部分</h2><p>加热部分分为以下：</p>
<ul>
<li>热床</li>
<li>MOS 管<br>打印机的床就是用来承载挤出机挤出来的材料。是 3D 打印机上的一个移动平台，用于支撑正在打印的物体。其主要作用如下：</li>
<li>粘附和稳定：打印平台上的特殊表面或涂层（例如热床、胶水、胶带等）可以提供粘附性，确保打印的第一层材料牢固地附着在平台上，并防止其在打印过程中发生位移或变形。<br>  * 塑料在不同的温度下粘性不一样，控制床的温度可以让不同的塑料在保持形状的同时达到最大的粘性。如果温度太高则有可让打印的形状变形，温度太低则有可能让打印的材料不粘床。床的温度和热端的温度共同决定了可以打印什么材料。如果能顺利融化材料，但是他并不能稳定的黏在床上，打印也会有非常大几率失败。</li>
<li>平整度：打印平台的调平性（平整度）对于打印质量至关重要。如果平台不平整，可能导致打印的物体底部出现变形或不平整的表面。</li>
<li>防止翘曲：特定类型的 3D 打印材料，例如 ABS（丙烯腈 - 丁二烯 - 苯乙烯）等，有时容易在冷却过程中产生翘曲。热床可以在打印过程中加热，有助于减少材料翘曲，提高打印的成功率。</li>
</ul>
<h2 id="电气系统"><a href="#电气系统" class="headerlink" title="电气系统"></a>电气系统</h2><p>电气系统分为以下几个模块：</p>
<ul>
<li>电源</li>
<li>主板（需要烧录固件代码如 Marlin）</li>
<li>显示屏</li>
<li>传感器&#x2F;加热模块等</li>
</ul>
<ul>
<li>了解各模块的所需电源电压，功耗等信息选取合适电源<br>了解打印机的所需功能，进行针对性选择主板</li>
</ul>
<h2 id="其他扩展模块"><a href="#其他扩展模块" class="headerlink" title="其他扩展模块"></a>其他扩展模块</h2><p><strong>Octoprint 远程监控模块</strong><br>3d 打印的成功率和模型文件、材料、切片 gcode 代码、天气、机器等关联，然后只有在打印中才能知道模型有没有出问题，octoprint 连接 Wifi，通过网页端远程摄像头监控进度，同时能够开始和停止打印机的操作。</p>
<p><strong>自动调平</strong><br>通常机器在几天内调平过一次之后很大几率不用重新调平，但是你对机器的一举一动包括机器自己的老化都会影响热床的位置移动和变形，自动调平模块 3D touch（也有别的）能够让完全手动的调平变成半自动调平。</p>
<p><strong>双 Z 结构</strong><br>顾名思义就是有两根 Z 轴。 单一的 Z 轴由于在一边容易导致 Z 轴变形造成模型垂直方向变形。同时也可能会让 XY 平面在变形的 Z 轴运动受阻。 双 Z 结构不仅能够减少变形，同时增强 Z 轴的稳定性。</p>
<h1 id="常用材料"><a href="#常用材料" class="headerlink" title="常用材料"></a>常用材料</h1><p>材料均需要密封干燥保存！买干燥盒</p>
<table>
<thead>
<tr>
<th align="center">主要成分简称</th>
<th align="center">推荐打印喷嘴温度</th>
<th align="center">推荐打印床温度</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PLA</td>
<td align="center">190˚C – 230˚C</td>
<td align="center">25˚C-60˚C</td>
<td align="center">易受潮</td>
</tr>
<tr>
<td align="center">TPU</td>
<td align="center">200˚C – 210˚C</td>
<td align="center">50˚C</td>
<td align="center">易拉丝</td>
</tr>
<tr>
<td align="center">PETG</td>
<td align="center">230˚C – 240˚C</td>
<td align="center">70˚C – 80˚C</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ABS</td>
<td align="center">245˚C – 265˚C</td>
<td align="center">90˚C – 100˚C</td>
<td align="center">有毒</td>
</tr>
<tr>
<td align="center">ASA</td>
<td align="center">240˚C – 260˚C</td>
<td align="center">75˚C – 95˚C</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PC</td>
<td align="center">250˚C – 270˚C</td>
<td align="center">90˚C – 105˚C</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PA6</td>
<td align="center">250˚C – 270˚C</td>
<td align="center">25˚C – 50˚C</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PA6-CF</td>
<td align="center">280˚C – 300˚C</td>
<td align="center">25˚C – 50˚C</td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><p>硬件采用 MKS Gen L v2.1，固件采用 Klipper</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522120131.png" alt="image-1689907953952.png"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522120145.png" alt="image-1689907869032.png"></p>
<p>pin 口图</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133116.png" alt="image.png"></p>
<p>硬件相关主要考虑因素:</p>
<ol>
<li>驱动电机数量（根据 3D 打印机的结构方案确定）</li>
<li>限位开关</li>
<li>风扇控制</li>
<li>挤出头控制</li>
<li>热敏电阻（热床&#x2F;加热棒&#x2F;挤出头）</li>
<li>单下位机方案需要支持屏幕接口</li>
<li>上位机方案需要支持 USB 连接</li>
</ol>
<h2 id="Klipper-固件配置及烧写"><a href="#Klipper-固件配置及烧写" class="headerlink" title="Klipper 固件配置及烧写"></a>Klipper 固件配置及烧写</h2><p>Klipper 官方文档 <a href="https://www.klipper3d.org/zh/Overview.html">https://www.klipper3d.org/zh/Overview.html</a></p>
<p>建议详细阅读，很多参数和问题都有说明</p>
<p>编译及下载 klipper</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Klipper3d/klipper</span><br><span class="line">./klipper/scripts/install-octopi.sh</span><br></pre></td></tr></table></figure>

<p>然后配置和构建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/klipper/</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>需要确定连接到微控制器的串行端口，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /dev/serial/by-id/*</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /dev/ttyUSB*</span><br></pre></td></tr></table></figure>

<p>可以用类似以下的方法来刷写固件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service klipper stop</span><br><span class="line">make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0</span><br><span class="line">sudo service klipper start</span><br></pre></td></tr></table></figure>

<p>第一次刷写时要确保 OctoPrint 没有直接连接到打印机（在 OctoPrint 网页的 “ 连接 “ 分段中点击 “ 断开连接 “）。</p>
<h1 id="上位机控制软件"><a href="#上位机控制软件" class="headerlink" title="上位机控制软件"></a>上位机控制软件</h1><p>上位机主板采用一块手头空余的 Linux 主板，软件采用 Fluidd</p>
<h2 id="控制软件介绍"><a href="#控制软件介绍" class="headerlink" title="控制软件介绍"></a>控制软件介绍</h2><p>如果是上位机的形式，则由运行在上位机的 3D 打印机控制软件来控制 3D 打印机</p>
<p><strong>Fluidd</strong><br><a href="https://github.com/th33xitus/kiauh">项目地址</a><br><a href="https://docs.fluidd.xyz/installation/kiauh">安装手册</a></p>
<p><strong>OctoPrint</strong><br><a href="https://github.com/guysoft/OctoPi">项目地址</a></p>
<h2 id="上位机硬件及操作系统要求"><a href="#上位机硬件及操作系统要求" class="headerlink" title="上位机硬件及操作系统要求"></a>上位机硬件及操作系统要求</h2><p>主要考虑因素:</p>
<ol>
<li>ARM 架构，功耗低（需要长时间工作）</li>
<li>USB 接口，连接下位机</li>
<li>网口，局域网 Web 显示打印机控制</li>
<li>显示屏，本地显示打印机控制</li>
<li>WIFI，可以无线打印</li>
</ol>
<h2 id="上位机控制软件配置步骤"><a href="#上位机控制软件配置步骤" class="headerlink" title="上位机控制软件配置步骤"></a>上位机控制软件配置步骤</h2><p>先在 WSL 环境下搭建调试</p>
<p><strong>安装</strong></p>
<p>安装方式采用推荐的安装脚本安装，该脚本不仅可以安装 fluidd，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522120520.png" alt="image-1689908818765.png"></p>
<ul>
<li><a href="https://docs.fluidd.xyz/">fluidd官方文档</a></li>
<li>KIAUH(Klipper Installation And Update Helper)<a href="https://github.com/th33xitus/kiauh">GitHub仓库地址</a></li>
</ul>
<p>执行脚本前需要安装 git</p>
<p><code>sudo apt-get update &amp;&amp; sudo apt-get install git -y</code></p>
<p>下载 KIAUH 到本地：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~ &amp;&amp; git clone https://github.com/th33xitus/kiauh.git</span><br></pre></td></tr></table></figure>

<p>执行脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./kiauh/kiauh.sh</span><br></pre></td></tr></table></figure>

<p>首先安装 moonraker，选择 1 Install,需要输入密码，之后选择 2 moonrarker</p>
<p>moonraker 的作用：</p>
<p>*Moonraker is the API that fluidd communicates with, which in turn communicates with Klipper. All three components are required for a healthy printer.</p>
<ul>
<li>如果出现 pip 下载速度太慢导致的失败，修改 kiauh&#x2F;scripts&#x2F;moonrarker.sh</li>
<li>在所有的 pip install 后追加 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li>
<li>或修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.pip/pip.conf</span><br></pre></td></tr></table></figure>

<p>(没有就创建一个)，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>安装 fluidd，选择 1 Install</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522120716.png" alt="image-1689908842123.png"></p>
<p>之后选择 4 Fluidd 进行安装</p>
<p><strong>问题解决</strong><br>由于本次安装是在 WSL 中的 Ubuntu 进行安装的，所以有以下两个问题需要解决<br>1）systemd 中的服务无法启动导致的 moonrarker.service 无法运行<br>Windows 版本要求 (已验证 Win11 22H2)<br>启动 windows Power Shell，更新 wsl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure>

<p>进入 Ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl ~</span><br></pre></td></tr></table></figure>

<p>编辑配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/wsl.conf</span><br></pre></td></tr></table></figure>

<p>添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[boot]</span><br><span class="line">systemd=true</span><br></pre></td></tr></table></figure>

<p>保存并退出 ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>在 windows power shell 中关闭 ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>

<p>然后重新进入 ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl ~</span><br></pre></td></tr></table></figure>

<p>查询 systemd 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl status</span><br></pre></td></tr></table></figure>

<p>2）在 WSL 中无法打开 Windows 的 USB 端口</p>
<p>WSL2 内核要求 &gt;&#x3D; 5.10.60.1</p>
<p>进入 Ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl ~</span><br></pre></td></tr></table></figure>

<p>查询内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<p>退出 Ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>安装 usbipd-win</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winget install usbipd</span><br></pre></td></tr></table></figure>

<p>进入 Ubuntu，安装客户端工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install linux-tools-virtual hwdata</span><br><span class="line">sudo update-alternatives --install /usr/local/bin/usbip usbip `ls /usr/lib/linux-tools/*/usbip | tail -n1` 20</span><br></pre></td></tr></table></figure>

<p>退出 Ubuntu，添加 USB 设备到 WSL 中去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usbipd wsl list //列出所有连接到Windows的USB设备。</span><br><span class="line">usbipd wsl attach --busid //添加USB设备进入Ubuntu，需要管理员权限</span><br><span class="line">usbipd wsl detach --busid //停止USB设备共享</span><br><span class="line">usbipd wsl attach -a --busid 2-7    // -a 自动绑定</span><br></pre></td></tr></table></figure>

<p>进入 Ubuntu，查看已经连接的 USB 设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure>

<p>配置 udev，允许非 root 用户访问 USB 设备,需要在设备连接前完成该操作</p>
<p>需要将根据自己 USB 设备编写的 60-myusb.rules 文件复制到&#x2F;etc&#x2F;udev&#x2F;rules.d</p>
<h2 id="远程监控模块-Obico-for-Remote-Access"><a href="#远程监控模块-Obico-for-Remote-Access" class="headerlink" title="远程监控模块 Obico for Remote Access"></a>远程监控模块 Obico for Remote Access</h2><p><a href="https://obico.io/docs/user-guides/klipper-setup/">Obico for Klipper</a> is an open-source solution to let you monitor and access your printer while you are not on the same local network.</p>
<p>Obico sends status messages as well as webcam snapshots to mobile push notification, Email, Telegram, Discord, and more.</p>
<p>You can get the real-time webcam feed and printer control using Obico’s mobile app or in the browser.</p>
<p>Obico also uses AI to detect print failures.</p>
<p>Follow this guide to set up Obico for Klipper.</p>
<h1 id="切片软件-Cura-设置"><a href="#切片软件-Cura-设置" class="headerlink" title="切片软件 Cura 设置"></a>切片软件 Cura 设置</h1><h2 id="设置打印机"><a href="#设置打印机" class="headerlink" title="设置打印机"></a>设置打印机</h2><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132404.png" alt="image-1689916973688.png"></p>
<h2 id="配置-Cura-设置可见性"><a href="#配置-Cura-设置可见性" class="headerlink" title="配置 Cura 设置可见性"></a>配置 Cura 设置可见性</h2><p>可以根据自己在切片时实际需要调整的相关参数进行显示</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133018.png" alt="image-1689918511713.png"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132411.png" alt="image-1689917153639.png"></p>
<h1 id="移动和缩放模型"><a href="#移动和缩放模型" class="headerlink" title="移动和缩放模型"></a>移动和缩放模型</h1><p>长按鼠标滚轮中键，可平移视角</p>
<p>长按鼠标右键，可旋转视角</p>
<p>滚动鼠标滚轮，可放大缩小视角</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132419.png" alt="image-1689917822752.png"></p>
<p>选中模型后，在 Cura 的左侧，依次功能为</p>
<ul>
<li>移动</li>
<li>缩放</li>
<li>旋转</li>
<li>镜像</li>
<li><em>单一模型设置</em></li>
<li>支撑拦截器<br>  在相应位置添加方块减少支撑应用<br>右击模型，可进行“复制”、“清空平台”、“居中模型等设置</li>
</ul>
<h1 id="设置打印参数"><a href="#设置打印参数" class="headerlink" title="设置打印参数"></a>设置打印参数</h1><p>点击右侧的打印参数设置栏，选择多种模式</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132446.png" alt="image-1689918511713.png"></p>
<h2 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h2><p>即层高：数值越小，打印物体表面效果越好，打印时间越长。默认选择 0.15mm</p>
<h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p>打印模型内部的模型密度，默认以网格状的形式填充。默认选择 20%</p>
<p>如果填充率过低，也会有一定程度导致翘边，不同的内部填充图案也可以有效减少翘边。</p>
<h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>主要设置打印时喷嘴和热床的温度。一般耗材上会写有打印温度。也可通过打印温度塔测试出每种最耗材品牌最佳的打印温度。建议首层温度用 230°C，容易粘床。</p>
<p>打印 PLA，热床的温度建议在 50-60°C。</p>
<h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><p>PLA 建议打印速度为 60mm&#x2F;s，±20 也在常用速度。</p>
<p>过快步进电机会丢步，按实际情况设置</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>当喷嘴移动到非打印区域上方时回抽耗材</p>
<p>当打印出现拉丝情况，可调整回抽设置。建议回抽距离用 2.0mm，回抽速度用 50mm&#x2F;s，加大数值可减少拉丝情况。如果打印过程中喷嘴有碰到打印物的情况，可勾选 Z 轴抬升。</p>
<h2 id="附着"><a href="#附着" class="headerlink" title="附着"></a>附着</h2><p>加大模型第一层与打印平台的接触面积，增加附着力，让模型在打印过程中更稳固。当打印模型的高度较高，接触面积较小时使用。</p>
<p>skirt 裙边</p>
<ul>
<li>在打印模型前，在模型外围打印一圈，让喷头里面的出丝比较顺滑,主要用于擦净喷头</li>
</ul>
<p>brim</p>
<ul>
<li>在模型的边缘处加上薄薄的一层，防止翘边，适用于打印较高的物体且接触面较小，容易倒塌的时候</li>
</ul>
<p>raft</p>
<ul>
<li>底座，在底座上在打印模型，适用于接触面多且复杂的情况</li>
</ul>
<h2 id="支撑"><a href="#支撑" class="headerlink" title="支撑"></a>支撑</h2><p>在模型的悬垂部分生成支撑结构，防止模型倒塌。作为入门最难的一个设置。通常角度过大，打印过程中悬空部位则需要添加支撑，否则容易下垂。支撑与模型接触面往往很粗糙，影响模型质量。</p>
<p><strong>支撑悬垂角度</strong>越大，需要支撑部位（红色部分）则越小。建议 45-50 间。</p>
<p>添加支撑的最小悬垂角度，当角度为 0 时，将支撑所有悬垂，当角度为 90 度时，不提供任何支持</p>
<p>Cura 提供普通支撑和树型支撑两种选择。</p>
<ul>
<li>树型支撑对模型影响更小，也节省材料。注意，它只适合于非平面的悬空，如鼻尖，指尖或拱形。对于平面的悬空，树形支撑无法提供足够的稳定性。</li>
</ul>
<p><strong>正常支撑建议参数</strong><br>支撑图案：锯齿形<br>支撑密度：15-20<br>支撑墙行数：0<br>支撑 Z 距离：推荐比层高略小（如：0.2 层高，设置为 0.15）<br>一般此参数为 0.6~1.5 倍层高。当模型底面较为平缓时，可设置较大的间隙，减少拆支撑难度。当模型底面变化大时，应设置较小的间隙。同时，支撑间隙与支撑密度也有关联，支撑密度较高时，可适当拉大间隙。<br>支撑 X&#x2F;Y 距离：1-1.5mm</p>
<p><strong>树形支撑建议参数</strong><br>支撑图案：锯齿形<br>支撑密度：15-20<br>支撑墙行数：1<br>连接支撑锯齿形: 勾选<br>支撑 Z 距离：推荐比层高略小（如：0.2 层高，设置为 0.15）<br>一般此参数为 0.6~1.5 倍层高。<br>支撑 X&#x2F;Y 距离：1-1.5</p>
<h1 id="保存和预览"><a href="#保存和预览" class="headerlink" title="保存和预览"></a>保存和预览</h1><p>点击右下角的切片，等待切片完毕后，可在预览界面预览打印效果、耗材用量及预计用时。拉动最右边进度条，可查看每层打印情况。点击右下角保存 gcode 文件准备打印。</p>
<h1 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h1><ul>
<li>偏好设置”—“基本”—“自动下降模型到打印平台”<br>  假如只想打印一半模型，可解除 Z 轴限制，可使模型下降至负数。切片后只会打印平台上方部分。</li>
</ul>
<h1 id="3D-打印机问题总结"><a href="#3D-打印机问题总结" class="headerlink" title="3D 打印机问题总结"></a>3D 打印机问题总结</h1><p><strong>平台上的蓝色纸有什么用处，用到什么程度需要更换？</strong><br>美纹纸，它的作用一是防止刮坏喷嘴，二让模型与平台粘接更稳。 由于打印材料的热胀冷缩效应，当打印大体积模型时，可能会发生翘边现象，建议打印前先贴上蓝色美纹纸，才开始打印。该纸可反复使用，直到破损或者明显粘不住模型为止。</p>
<p>大部分人都在用 PEI 喷涂的钢板作为底面。PEI 的特性是冷的时候不粘，热的时候具有一定的粘性。</p>
<p>新的 PEI 床和旧的自带的床。更换 PEI 后打印 PETG 就非常好用了。等床凉了以后轻轻一拿就可以从床上拿起来了，不像是原来那张床用铲子翘半天。</p>
<p>不过新床目前也是遇到了一些问题，就是打 PLA 没有原来粘了。所以用 PLA 打印第一层得时候需要压得更低一点，才能获得最佳得粘性。</p>
<p><strong>哪些模型要加支撑？如何判断？</strong></p>
<p>红色位置是需要加支撑的位置，Cura 右侧可以设置支撑的相关参数</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132634.png" alt="image-1689903635099.png"></p>
<p><strong>调平台这个步骤怎么确保距离调的 ok 呢？喷嘴距离平台距离太远或太近有什么区别？为什么模型打印过程中直接被拖走？</strong></p>
<p>首先在调节平台之前我们需要先保证 X 轴在丝杆上移动是水平的</p>
<p>喷嘴和平台的距离标准为一张 A4 纸的距离，如果不好判断，塞张纸在平台和喷嘴之间，以正常抽拉并附带阻力为标准；</p>
<p>在不会刮伤平台的前提下，调的越近模型粘的越牢固！</p>
<p>我们还可以通过模型打印第一层的状态来判断距离是否调好，有以下三种情况：</p>
<p>1、正确的距离：扁平，无间隙，铺在平台上面很平整无毛刺,喷头与热床是最佳距离能保证打印出的耗材被紧压在热床上成平整的带状（扁皮状）。如图所示：</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132656.png" alt="image-1689841940812.png"></p>
<p>2、不正确的距离：细圆的，粘上去时铺的不均匀，有空隙和翘起，说明距离太远,耗材是靠重力作用垂到热床，形成圆润的条状，其黏附效果不佳，模型容易移动，打印效果非常不理想。如图所示：</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132703.png" alt="image-1689841950878.png"></p>
<p>3、不正确的距离：出丝时，压在平台上会出现中间薄两边有不规则突起（有毛刺）的，说明贴的太紧，或者可能造成无法出丝以及喷头移动时会刮带到之前打印的地方，相关形状如图所示：</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132724.png" alt="image-1689841961988.png"></p>
<p>以上情况均可以通过调节热床下方的弹簧来调整。</p>
<p><strong>调节平台需要注意什么？而且每次打印前都需要检查平台吗？</strong></p>
<ul>
<li>调节弹簧螺丝时，请注意按住下方的羊角螺母，不然在拧的过程中也会一起转动；</li>
<li>每次调完或检查平台操作后，都必须移动喷嘴在平台上走一圈，确保不会刮伤平台才能进行下一步操作；</li>
<li>虽然不需要您每次在打印前调节平台，但需要以 1 天 1 次作为周期性检查，平台距离合适；</li>
</ul>
<p><strong>为什么预热后上料？为何我感觉插到底了，下方喷嘴却不出丝？换料的时候需要注意哪些情况？</strong></p>
<ul>
<li>上料时，如果喷头没有加热，耗材插到底也不会吐丝，客户就无法判断是否已正常上料，所以必须先预热，再上料！</li>
<li>在上料时，插入进料口后一段距离感觉已经无法插入，但是喷头下方并没有出丝，因为在耗材在进入进料口后需要穿过挤出轮和压料轮中间后再<strong>进入下方喷嘴导料管</strong>，在上耗材的时候没有把耗材前段剪尖和捋直，导致耗材插入时没能直接进入下方导料口而被旁边阻挡，如图：<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132739.png" alt="image-1689841982153.png"></li>
</ul>
<p>  正确上料步骤：预热—剪尖并捋直耗材—下压螺丝—笔直插入耗材—出丝</p>
<p><strong>每次打模型前都需要预热吗？</strong><br>提前预热的情况只有在进行换料前才需要提前预热，正常打印时，您只需要选择打印的模型文件即可自动加热；</p>
<p><strong>模型打印过程中停电了能否继续打印？</strong><br>如果停电了模型直接终止打印，下次开机无法延续打印（但可以通过测量已打印高度，仅将未打印的部分切片进行打印，再粘上，仅适合非精密零件模型）</p>
<p><strong>那中途可以暂停再继续打吗？</strong><br>看机器是否有设计暂停打印功能</p>
<p>在打印时暂停喷嘴依旧处于加热状态，耗材因重力作用会下垂流出，影响模型外观；</p>
<p><strong>中途耗材用完怎么办？</strong></p>
<ul>
<li>首先模型在软件进行切片转换格式的时候就会显示所需打印的时间，耗材长度以及重量，那您需要判断机器上余下的耗材能否支持本次打印完成，避免中途打印耗材用完；</li>
<li>若碰到耗材中途快用完，请在耗材还没进入进料口的时候及时的进行暂停，并迅速拔出剩余耗材，将新的耗材插入至喉管的深度即可</li>
</ul>
<p><strong>每次打完需要将耗材取出来做排空处理吗？</strong><br>不是，距离下次打印超过 72 小时，则需要排空处理；</p>
<p><strong>喷头需要定期清理吗？</strong><br>需要！</p>
<p>挤出头加热到指定温度后用最小号的内六角螺丝刀，压下进料弹簧，插入进料口，往下挤压，挤压的时候扳手插慢慢插到底时，来回挤压三次，扳手回抽不要过急或过长，插进去后小幅度的在里面挤压三次即可，再迅速拔出，空烧 1 分钟左右注意观察下方是否有东西流出，流完或没东西流出一分钟后请用我们配送的小捅针，从下方喷嘴插入，抽拉三次没东西流出即可；最后一步，请弄根新耗材，插入到底向下挤压出丝后猛的迅速拔出，尽量带出内壁附着物即可；</p>
<p><strong>模型刚开始打印第一层就不出丝，怎么回事？</strong><br>如果这种情况发生在您刚才有换过耗材的情况下，那您需要确定耗材已上到底，并出丝；确保喷嘴是否顶到平台，导致无间隙空间吐丝；</p>
<p><strong>打出来的模型很脆，外壁像网丝状，很脆，一捏就瘪了？</strong><br>此情况属于出丝量很小，需要检查以下几点：</p>
<ul>
<li>拉料正常，料盘上的耗材没有打结等缠住现象；</li>
<li>耗材在进入导料管与喷嘴（加热管&#x2F;喉管）之前，要穿过一个 u 型轮和挤出电机齿轮中间，u 型轮压住耗材让齿轮把耗材往下挤送，u 型轮压住耗材的力量是由旁边的六角螺钉顶着弹簧的力度来决定的，螺丝扭紧弹簧弹性越大，u 型轮压料就越紧，反之越松， 进料口旁螺丝太松或者太紧都有可能导致耗材挤出速度受到影响</li>
<li>齿轮本身带动耗材挤压也有许多因素，耗材从上往下经过齿轮的时候是否有在齿轮的中间，如果齿轮脱位，耗材在齿轮的牙边下去的，可能出现带不动耗材往下的情况而出丝不顺</li>
</ul>
<p><strong>模型打印时，突然在某一层高处整体向 X（左右）&#x2F;Y（前后）方向偏移？</strong><br>首先需要确定机器传动系统问题，再来排除软件参数和主板固件问题，排除方法如下：</p>
<ul>
<li>首先需要判断你的模型摆放在平台上时，偏移的方向是 x（横向）还是 y（纵向），然后我们需要检查对应的 xy 轴的传动系统是否正常，第一先检查皮带是否松动脱落；第二检查同步轮固定螺丝是否松动<br>  ① 带松动加紧： 首先，如果是 X 轴皮带松动，必须拉紧至绷紧状态，切平行；<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132757.png" alt="image-1689842003037.png"></li>
</ul>
<p>  ②同步轮松动：Y 轴传动系统同步轮和 X 轴同步轮都需要检查到；</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132803.png" alt="image-1689842010248.png"></p>
<ul>
<li>排除完机器问题，建议看下软件参数是否存在问题</li>
</ul>
<p>  例如检查是否是电机运动速度过快或出现阻碍导致的丢步</p>
<ul>
<li>以上两点排除完毕，需要对主板固件程序进行重新烧录来解决问题</li>
</ul>
<p><strong>打印模型过程中中间断了几层，但是上面打印还可以？为什么模型突然中途就不出丝，喷嘴一直在空走打印不出丝？</strong><br>这几种问题都属于前期能正常打，但是中途不出丝的情况，这种情况需要从以下几点判断：</p>
<ul>
<li>挤出电机接线口处四针排线松动，导致电机挤出齿轮来回正反转，耗材送不下去； 打印不出丝时，可以从电机右侧方弹簧方向往里面看到齿轮转到情况，如果齿轮来回摆动不定，说明接线出有问题，将接线拔掉重新插入尝试即可；</li>
<li>进料口旁螺丝太松或者太紧都有可能导致耗材挤出速度受到影响</li>
<li>耗材在料盘上缠住，导致进料不顺,检查料盘的耗材缠绕是否有拉扯住</li>
<li>喷嘴可能有残料堵塞,可以把喷头首先预热 230，一手按住进料口旁螺丝，一手快速挤压耗材（多送点丝），再迅速拔出，然后让喷嘴空烧一会儿，直到有黑色物质从喷嘴里流出，然后用钢丝从喷嘴端插入，抽拉，拔出，让里面剩余的耗材掉出，重复抽拉动作，直到喷嘴没料自然流出为止，最后上料，重新打印；</li>
</ul>
<p><strong>为什么打印模型在中途过程中，喷嘴周边缠着很多耗材，模型变成一团乱丝，不成形？</strong><br>这种情况分两种：</p>
<ul>
<li>刚开始打印阶段，此情况一般是喷嘴和平台之间的距离过远，喷嘴出丝无法粘住平台，就会被喷嘴带走并一直出丝形成一坨；</li>
<li>打印过程中出丝不均匀，有断层现象，打印模型比实际高度低，超过一定间隙距离后出料正常是没附着下面的模型上面就会缠成一坨；</li>
</ul>
<p><strong>打印过程中喷嘴突然停止在打印模型上方不打印，并未回原点，怎么回事？</strong></p>
<ul>
<li>切片问题,重新切片打印测试</li>
<li>内存卡松及读取问题</li>
<li>主板固件问题</li>
</ul>
<p><strong>为什么把模型保存在卡里是显示 ok，但插入机器后选择模型打印后不加热也没反应？为什么 SD 卡在电脑读取正常放入机器缺显示无卡？</strong><br>一般由于保存文件时的文件名上，切片完成后进行保存时文件名请使用英文字母或数字.</p>
<p><strong>为什么 SD 卡在电脑读取正常放入机器缺显示无卡？</strong><br>这种问题首先要排除卡和卡槽是否正常配合，保证卡和卡槽读取正常，如果重新插入还是无法读取，可用您身边的内存卡保存文件插入机器是否能正常读取</p>
<p><strong>为什么选择模型打印，机器没任何反应？或者加热了很久但是不打印？</strong><br>这种情况可能喷嘴冷却风扇提前开启，导致实际温度和设置温度总有 1-2 度差距，导致无法打印，请您选择停止打印并关掉风扇开关后，重新选择打印模型即可；</p>
<p><strong>宽度 5mm 高度 6mm 的字体打得出来不,类似这种小模型需要修改哪些参数呢？</strong><br>小模型打印需要将速度和挤出量降低，模型可以打得更好看。比如打 5mm 左右的字体，可以采用 22 左右的速度配合 85 的挤出量来进行切片打印，温度采用 190 左右的即溶温度即可，这适合小模型打印哦；</p>
<p><strong>为什么在打印模型时，某个位置会剧烈振动，机器声音很大？</strong><br>这种位置一般是模型实体部分的填充，特别是交窄的壁厚，填充为波浪形，打印速度很快的时候 xy 配合产生共振引起的</p>
<p><strong>为什么在打印很大模型例如 190*190*180 和平台尺寸相近的模型时，喷头移动到某个方向极限值时，会有振动然后再改方向进行移动呢？</strong><br>打印前，喷嘴会在模型周围打一圈进行排空出料的操作，这样的话就实际增加了大模型的成型空间，导致直接碰到机箱，可以把此设置关掉即可</p>
<p>查看切片时是否有裙边设置</p>
<p><strong>打印模型经常翘边问题怎么解决？</strong><br>PLA 与 ABS 通用原因：</p>
<ul>
<li><p>喷嘴距离与平台太远，没能充分贴紧平台</p>
</li>
<li><p>模型与热床接触面积太小，导致附着力不够</p>
</li>
</ul>
<p>  解决办法：可增加 brim 或者 raft 垫子 ；打印 ABS 的话 Brim 效果更理想；</p>
<ul>
<li>打印 ABS 时开了散热风扇。</li>
</ul>
<p>  解决办法：在打印是进入主界面的控制 – 温度 – 风扇速度 Bed 中由最高转速 255 改成 100 减少冷却效果，直接关闭风扇开关效果更理想；</p>
<p>  - 挤出头或热床温度不合适，挤出头温度不够可能导致挤出的材料流动性不够，无法完美的平铺在热床上，影响其粘滞力。热床温度过高也可能导致翘边，原因是材料受热流动性变大，不能稳固黏在热床上。</p>
<p>  - 热床表面不干净。手的汗与油粘在胶带上，表面上看不见，但也导致表面打滑，影响黏附效果。这种情况在湿度大的南方比较常见。</p>
<p>    ABS 材料很特殊因为它有一定的收缩率，打印较大的物体时，效果更佳明显，整体收缩导致底面翘起。最好能配合洞洞板。</p>
<p><strong>显示屏下方显示 Err 报错，挤出头&#x2F;热床温度温度显示不正常？</strong><br>喷头上热敏电阻的接触不良或者损坏了</p>
<p>拆下热敏电阻，若是接触不良，则重新拔插接好；若是线的焊点脱落，用电烙铁焊好否则易损坏电阻；若是损坏，则更换新的热敏电阻。注：固定线时螺丝不宜拧过紧</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132936.png" alt="image-1689842115318.png"></p>
<p>这个黑色螺丝拧松，热敏电阻取出来，同时热敏电阻线也从主板上拔下来，用万用表测一下阻值，80-100K 正常</p>
<p><strong>打完第一层，打印头在左边，要打上面一层的时候，打印头不是要回到右边的吗，回去的时候就会刮在之前打印的第一层上并留下一条线呢？</strong><br>那是距离平台过近，会刮到上一层打印的耗材</p>
<ul>
<li>平台距离喷嘴近有利于粘住平台，不会翘边;</li>
<li>会轻微刮到上一层打印模型，但不影响模型成型过程，最多挂点料在喷嘴上挂着，然后在掉下来</li>
</ul>
<p><strong>模型平面上字体打出来效果不好怎么办？</strong><br>如果字写在模型上，此情况可以将模型竖起来打，层厚 0.1 能更为细腻的打出字体；</p>
<p><strong>为什么从绘图软件里导出来的模型放在 cura 里显示不规整，弧面都是棱面组成的？</strong><br>在绘图软件里导出 stl 的时候会有二进制和 ASCⅡ，通常选择二进制并将角度和弦值设置默认最小值，但在 maya 等一些软件里，文件导出的时候 stl 格式是默认设置的，这是软件的特性，但是这个默认数值会随着你文件的建模时的网格细腻程度增加，也就是说文件平滑原本是一倍的，现在加到三倍导出来的 STL 就会比一倍的细腻很多</p>
<p><strong>调试机器时选择自动丝出来都不是直的，是弯曲的?</strong><br>如果出丝是弯曲的</p>
<ul>
<li>挤出量有关；挤出量一般由温度以及进料口旁边的螺丝松紧度有关，需要检查进料口旁边的螺丝</li>
<li>温度原因，1.风扇吹的 2.温度可以适当加高到 200 度左右</li>
</ul>
<p><strong>温度总是上不去或者不稳定？</strong></p>
<ul>
<li>挤出头的热敏感应件没固定好在铝块里，打印的时候易松，导致探温不准；</li>
<li>导风嘴冷却风扇的风是吹到喷嘴下方的模型，如果没有调好就会吹到 喷嘴，导致温度下降；</li>
</ul>
<p><strong>如果出现以下情况是怎么导致？</strong><br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132822.png" alt="image-1689842137085.png"></p>
<p>挤出齿轮底部缠料，一般是由此部位温度过高引起耗材变软，送丝过程中导致齿轮下部耗材折断而缠住；</p>
<ul>
<li>遇到此情况首先需检查电机前方的方形冷却风扇是否工作以及叶片是否完整，避免冷却不够而导致堵料；</li>
<li>请检查耗材是否长时间未密封保存而变脆，取一段从中间这段，若折后显白痕且有韧性即正常，若折后直接啪的应声而断即已变脆；</li>
</ul>
<p><strong>X 轴架构在 Z 轴电机丝杆控制上下过程中，会导致一边高一边低，每次都需要重新调节平台高度呢？</strong></p>
<ul>
<li>x 轴本身没有平衡，在移动过程中反应更明显；</li>
</ul>
<p>  请解决 X 轴调平问题；</p>
<ul>
<li>黄色 T 型螺母太紧，导致 T 型螺母与丝杆紧配受力不均匀，移动不顺畅；</li>
</ul>
<p>  将固定 T 型螺母上的螺丝不要拧紧，留半个螺纹的缝隙，给予缓冲，再将 x 轴调至平衡，移动 z 轴电机调试！</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132835.png" alt="image-1689842144121.png"></p>
<ul>
<li>x 轴光杆太长，没有完全捅到底去，顶住丝杆，导致移动不顺</li>
</ul>
<p>  检查光杆插入深度；</p>
<ul>
<li>将 Z 轴两边的两个光杆去掉，控制电机上升是否正常，排除光杆弯曲配合滑动轴承配合不顺问题（可以单独将光杆插入滑动轴承，上下移动是否顺滑）</li>
</ul>
<p>  更换光杆或者滑动轴承</p>
<ul>
<li>以上问题都检查后就可能: 移动不顺畅的丝杆部分弯曲或者螺纹损伤，更换丝杆</li>
</ul>
<p><strong>在更新固件后，挤出电机齿轮检测出反转，无法正常下料</strong></p>
<ul>
<li>固件中电机引脚配置反了</li>
<li>拔出挤出电机后端电机线接口，按照现在正常 1234 线序，把其中‘一组’12 对调或者 34 对掉即可</li>
</ul>
<p><strong>如果模型摆放在软件里为中心点，但在实际打印过程中并不在平台中间；</strong><br>因为机器喷嘴回原点的时候并不在热床平台上方而是在外面，而 cura 软件的机器设置里原点就在平台某个角的正上方，为了补偿原点所在误差，需要将软件的平台设置扩大，才能让模型打印在正中间，如图操作更改即可：<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132852.png" alt="image-1689842164637.png"></p>
<p><strong>加热后拔料感觉扯不出来，也无法下压了</strong><br>铝块融化处剩余耗材口径较大，加热后直接上拉耗材，易堵在口径较小的喉管处，并迅速冷却，以至堵塞喉管</p>
<p>预热达到温度后，一只手按住进料口旁边的螺丝，另一只手将耗材往下挤压，让前端耗材挤出一段距离后，再迅速拔出耗材即可避免堵塞喉管</p>
<p><strong>选择自动回原点时，当喷头移动至限位开关的时候，电机一直不停的往前走，撞击限位开关并抖动，这是怎么回事？</strong></p>
<ul>
<li>您需要检查在部件回原点触碰到限位开关之前是否有东西挡住它前进才无法触碰到限位开关而不停止运动；<br>  - 可能是限位开关坏了导致的，检查方法是将每个轴的移动部件移至轴中部，选择自动回原点，在部件向原点限位开关移动的过程中，请按住限位开关，观察部件是否停止移动，如果没有停止，请马上切断电源，基本上可以确定限位开关问题</li>
</ul>
<p><strong>为什么 X 轴上的喷头在移动过程中，一顿一顿的，特别是在回原点的时候，移动时几乎在抖动很不顺畅？</strong></p>
<ul>
<li>排除下电机线与电机的问题：拆卸底板：需要用万用表检查 x 轴四根电机线是否都是通路，如果正常就是电机本身问题；</li>
<li>可以断电后手动运动下挤出头，是否丝杆或滑块中的钢珠生锈导致运动不流畅</li>
</ul>
<p><strong>超出打印范围</strong><br>安装软件的时候初始设置选择错误机型导致的，重新设置机型即可</p>
<h1 id="不粘床，找平"><a href="#不粘床，找平" class="headerlink" title="不粘床，找平"></a>不粘床，找平</h1><p>自动找平后，但有的时候打印出来的第一层还是和床粘的不紧密</p>
<ul>
<li>Z Offset 设置也会影响粘不粘床。<br>  其中白色部分为压力传感器（BLTouch），右边蓝色硅胶罩下面的为喷头<br>  可以看到左边白色的压力传感器的高度和右边蓝色硅胶套下面的喷嘴是不在一个高度的。设置喷嘴和床之前的距离是以压力传感器的反馈为准的。但是压力传感器测到的距离是传感器本身到床的距离，并不是喷嘴到床的距离。所以压力传感器到喷嘴之间的高度差就是 Z Offset，需要通过调整它来设置合适的喷嘴高度。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132911.png" alt="image-1689841590481.png"></p>
<h2 id="手动调平"><a href="#手动调平" class="headerlink" title="手动调平"></a>手动调平</h2><p>需要用到一张纸，一般打印用的 A4 即可。</p>
<p>然后在床的中点进行 Z Offset 调整，在四个角落（螺丝位置）手动调整床的高低。具体步骤如下： 中点 Z-Offset 调整 首先通过控制面板将喷嘴移动到床的中间的正上方，接下来将纸放喷嘴下方的床上，紧接着慢慢将 Z 轴的高度降低到 0（如果降不下去不要硬来），喷嘴可能会压住纸或者没碰到纸；尝试前后不停的移动纸张。 如果纸张能移动并且刚好有一点阻力就是合适的喷嘴高度不需要调节，通常而言不会那么顺利；如果如果喷嘴完全没碰到纸张，或者纸张移动完全没有任何阻力，可以尝试通过调整 Z-Offset ，一点点降低喷嘴高度。直到达到上述的移动纸张有一点点阻力的状态；如果纸张被压的很死无法动弹，则先将 Z 轴升高到 5mm 然后尝试调整 Z-Offset 升高喷嘴，然后再继续尝试慢慢降低 Z 轴到 0mm，反复调整直到移动纸张有一点点阻力的状态。</p>
<p>使用一张纸来手动找到喷头合适高度的方法。但是这个能移动但是有一点点阻力状态有点模糊，它并不是一个固定的点，是一段区间内都可以感觉到能移动但是有摩擦力。我建议是选摩擦力稍微轻一点的力度的点，这样喷嘴高度较高，后面调整的时候不容易刮伤床上的底板。</p>
<p>四周螺丝调整 在中间确定了最基本的 Z 轴的高度之后则需要物理调整四周的螺丝了，调整四周的螺丝需要按照顺序一个一个的调整，并且需要多次调整和确认，具体步骤如下： 首先抬起 Z 轴让喷嘴距离床大概 5mm 的距离，再移动到任意一个距离调整螺母的正上方，将纸放在喷嘴正下方的床上，紧接着一点点尝试往下移动 Z 轴到 0mm，和上面一样如果降不下去不要硬来；接下来就和上面一样，尝试移动不停的前后移动纸张，如果处于能移动但是有摩擦力的状态则是合适的，如果完全没碰到纸张，在移动纸张的同时旋转下方的螺丝来物理调节这个角落的高度，直到纸张处于能移动但是有摩擦力的状态。最后将 Z 抬起到 5mm 左右，顺&#x2F;逆时针移动到下一个调节螺母的上方，重复以上步骤。 上面步骤是单个角落手动物理调整床高度的方法，完成四个点（上图的床只有四个螺丝，有几个螺丝就校准几个点）为一个循环。因为打印机的床是一个固体，所以当你上下移动某一个角落的高度的时候另外三个角落的高低也是会受到影响的，尤其是相邻的两个角落。所以这里需要多个循环来拧螺丝调整各个角落的高度，直到四个角落的高度都合适的情况，即为纸张能移动但是有阻力的状态。 在拧玩螺丝校准完四个角落的高度后，需要再次通过 Z-Offset 校准中间喷嘴的高度。因为在调整四角的螺丝的时候可能会整体抬高或者降低了床的高度，所以中间的喷嘴高度需要再一次校准。重复上面中点 Z-Offset 校准即可。</p>
<p>如果固件自带自动找平还是比较简单的，选择自动找平等就好了。虽然手动找平完之后床基本上是处于可以用的状态了，但是便宜的桌面打印机的床它本身可能就是凹凸不平的，所以需要自动找平来弥补床本身的凹凸起伏的部分。如果没有自动找平的打印机就没有太好的办法避免这个了。只能通过稍微压低一点点喷嘴来做到尽量都粘到床。 测试调平是否成功 在做完上述的调整后就可以进行最终的调整了。这一步是通过打印一些模型来确认喷嘴的高度是否合适。</p>
<p>虽然用纸调整好了喷嘴的高度，但是纸有薄有厚，调整出来的喷嘴高度并不一定是最好的打印高度，所以最终还是需要通过打印来调整。 打印测试时尽量选择有颜色的材料，透明透明材料会看不清楚第一层有没有打好，在打印模型的时候，手需要在电源附近随时待命。在喷嘴高度设置错误或者床不平的时能及时停止打印机降低损失。 打印出来的模型主要是用来检查喷嘴的高度和床是否倾斜的，四周的圆柱和绕场一周的线条用来检查床的倾斜度。 外围线条如果高低不平均，薄的那边就是较高的地方，厚的那边则是较低的地方。四角的圆柱则可以和上述的 Raise 3D 的示意图来比较确认喷头的高度是否合适。如果不合适可能需要重新手动找平。中间的圆形是确认喷嘴高度用的。同样通过对比来观察高度是否合适，如果床并没有很严重的倾斜，则只需要调整 Z-Offset 来移动喷嘴。然后重新打印确认。如果确认床有倾斜，就要重新走一遍手动找平的流程的了，然后重新打印确认。</p>
<p>当然找平也不是一定完美的。但是有自动找平后，整个过程还是比较简单的。但是也有无论怎么调整，都觉得床有倾斜或者高度不对的时候。这里就要分两种情况讨论了。如果能正常打印不想折腾了就选一个能调整到的最好的状态直接用吧。如果严重到了无法打印的程度，则需要检查打印的装配是不是有问题了。</p>
<h1 id="过度挤出"><a href="#过度挤出" class="headerlink" title="过度挤出"></a>过度挤出</h1><p>打印出来的东西都有奇怪的纹理。而且质量也参差不齐。</p>
<p>检查之后是 klipper 配置里面的挤出机的「roration_distance」配错了。导致挤出机往外挤的时候给了远比正常情况多的料，进而溢出到边缘产生了神奇的纹理。</p>
<p>Klipper 配置里面的挤出机转一圈挤多少料这些东西都需要自己配置。所以配置挤出参数时是需要校准的，当你给指令让他挤 100mm 的材料的时候，他应该就挤出来 100mm 左右的材料。没有校准所以导致了非常严重的过度挤出，配置正确后打印的东西表面的问题就漂亮多了。 正常挤出打印的零件的表面质感</p>
<h1 id="材料与环境湿度"><a href="#材料与环境湿度" class="headerlink" title="材料与环境湿度"></a>材料与环境湿度</h1><p>由于 FDM 3D 打印件一般都需要将材料加热到 200 摄氏度或以上的温度才能打印，所以当材料通过热端的时候，其中的水蒸气会蒸发出来，造成喷嘴里面的材料有间隙，这些现象还会造成打印件在物理特性上的改变： 水汽膨胀造成挤出原料不均匀导致的表面粗糙 水汽膨胀造成材料之间有很多空隙导致的强度下降 水汽膨胀喷嘴中黏在一块的材料有缝隙，导致拉丝。解决方案其实很简单，就是使用干燥盒存放材料</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>3D打印机</category>
      </categories>
      <tags>
        <tag>3D打印机</tag>
      </tags>
  </entry>
  <entry>
    <title>3D打印机环境配置</title>
    <url>/2024/05/17/%E5%85%B6%E4%BB%96-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>目前 3D 打印机的主流架构一般情况下，有以下两种方式：</p>
<ol>
<li><p>上位机（运行 fluidd 控制软件）+ 下位机（运行 kilpper 固件）+Web 显示<br>   * 由于手头上正好有一块 Linux 开发板，所以准备采用上位机方案，局域网部署（<code>OctoPrint</code> 和 <code>Fluidd</code> 二选一安装配置即可。）</p>
</li>
<li><p>下位机（运行 marlin 固件）+ 串口屏显示<br>   * 优点：只需要一块控制板加上串口屏，不需要上位机控制软件，节约成本 缺点：屏幕小，显示的信息少</p>
</li>
</ol>
<h1 id="Klipper"><a href="#Klipper" class="headerlink" title="Klipper"></a>Klipper</h1><p>本次机器组装选择的方案是 klipper，可以很方便的直接在上位机修改打印机参数，不需要每次修改参数后重新烧写固件</p>
<p>在 3D 打印机中，固件是一种运行在单片机上的软件，它控制着 3D 打印机的运动和操作。固件负责将 G 代码转换为实际的运动和操作，例如将 G 代码中的坐标转换为电机的运动，控制加热器的温度等。 固件还负责处理传感器的输入，例如温度传感器、限位开关等，并根据这些输入控制 3D 打印机的运动和操作。 3D 打印机的固件通常是预装在单片机上的，但用户也可以根据需要进行更新和修改，以实现更好的性能和功能。 在 3D 打印领域，主流的固件有以下几种：</p>
<ol>
<li>Marlin：Marlin 是一款开源固件，它是 3D 打印领域最流行的固件之一，具有广泛的硬件支持和强大的功能。</li>
<li>Repetier：Repetier 是另一款流行的开源固件，它具有类似于 Marlin 的功能和支持。</li>
<li>Smoothie：Smoothie 是一款基于 ARM 处理器的开源固件，它支持多个独立的电机和传感器，并具有良好的可扩展性。</li>
<li>Klipper：Klipper 是一款比较新的开源固件，它具有更高的计算能力，可以实现更快的运动和更高的精度。</li>
</ol>
<p><strong>Klipper</strong><br>Klipper 是一种用于 3D 打印的固件软件，它可以在单片机上运行，控制 3D 打印机的运动。与其他 3D 打印机固件相比，Klipper 具有更高的计算能力，因此可以实现更快的运动和更高的精度。Klipper 还支持多种硬件平台，包括树莓派和 BeagleBone Black 等。使用 Klipper 可以提高 3D 打印机的性能，并且可以通过配置文件进行高度自定义。</p>
<p><strong>Marlin</strong><br>Marlin 是一种用于 3D 打印的开源固件软件，它可以在单片机上运行，控制 3D 打印机的运动。Marlin 是 3D 打印机领域最流行的固件之一，因为它具有广泛的硬件支持和强大的功能。Marlin 支持多种传感器和功能，如自动床平衡、断电续打、LCD 屏幕等。Marlin 还提供了一套易于使用的配置文件，可以通过修改这些文件来对 3D 打印机进行高度自定义。由于 Marlin 是开源软件，因此用户可以根据自己的需要进行修改和定制，以实现更好的性能和功能。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>获取 klipper 源码</p>
<p><code>git clone https://github.com/Klipper3d/klipper</code></p>
<p>执行脚本安装一些系统依赖、设置</p>
<p><code>./klipper/scripts/install-octopi.sh</code></p>
<ul>
<li>安装很慢时，可以更换下 pip 的源 <a href="source/_posts/%E8%AF%AD%E8%A8%80/Python/pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.md">pip下载网络问题</a></li>
</ul>
<p>然后配置和构建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/klipper/</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>需要确定连接到微控制器的串行端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/serial/by-id/*</span><br><span class="line"><span class="built_in">ls</span> /dev/ttyUSB*</span><br></pre></td></tr></table></figure>

<p>可以用类似以下的方法来刷写固件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service klipper stop</span><br><span class="line">make flash FLASH_DEVICE=/dev/ttyUSB0</span><br><span class="line">sudo service klipper start</span><br></pre></td></tr></table></figure>

<ul>
<li>刷写时要确保 端口没有被占用</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打印机配置文件，一般在用户主目录中名为 <code>printer.cfg</code> 的文件</p>
<p><a href="source/_posts/%E5%85%B6%E4%BB%96/3D%E6%89%93%E5%8D%B0%E6%9C%BA/printer.cfg">配置文件示例</a></p>
<p><code>/home/linux/printer.cfg</code>。</p>
<p>刷写 Klipper 后，名称可能会改变，检查 USB 节点名称：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/serial/by-id/*</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">ls</span> /dev/ttyUSB*</span><br></pre></td></tr></table></figure>

<p>确认节点名称并写入配置文件中去。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0</span><br><span class="line">或者</span><br><span class="line">/dev/ttyUSB0</span><br></pre></td></tr></table></figure>

<p>用这个唯一的名字更新配置文件。更新 [mcu] 部分，类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mcu]</span><br><span class="line">serial: /dev/ttyUSB0</span><br></pre></td></tr></table></figure>

<p>在编辑该文件后，发出 <code>restart</code> 或 <code>FIREWARE_RESTART</code> 命令以重新加载配置（命令根据实际上位机）。如果 Klipper 配置文件被成功读取，并且成功找到并配置了微控制器，那么 “status” 命令将报告打印机已准备就绪。</p>
<ul>
<li>默认的 Klipper 启动脚本也在&#x2F;tmp&#x2F;klippy.log 中放置一个日志，提供更详细的信息。</li>
</ul>
<h2 id="GCode-协议指令"><a href="#GCode-协议指令" class="headerlink" title="GCode 协议指令"></a>GCode 协议指令</h2><p>Klipper 支持的 G-Codes 命令官方文档 <a href="https://www.klipper3d.org/G-Codes.html">https://www.klipper3d.org/G-Codes.html</a></p>
<p><strong>部分我使用到的命令</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M112</td>
<td align="center">使 Klipper 进入 “shutdown”（关闭）状态</td>
</tr>
<tr>
<td align="center">FIRMWARE_RESTART</td>
<td align="center">重新加载配置文件并重启</td>
</tr>
<tr>
<td align="center">SAVE_CONFIG</td>
<td align="center">保存配置文件</td>
</tr>
<tr>
<td align="center">GET_POSITION</td>
<td align="center">获取位置</td>
</tr>
</tbody></table>
<p><strong>限位开关测试相关</strong><br>确保 X、Y 和 Z 轴的限位开关都没有被触发，然后通过控制台发送命令：<code>QUERY_ENDSTOPS</code></p>
<ul>
<li>返回值是 <code>open</code> 打开，则限位触发电平类型设置正确</li>
<li>如果是 <code>triggered</code>（触发），则需要修改限位的电平类型（以 X 轴为例）<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  [stepper_X]</span><br><span class="line">  endstop_pin: ^PE5   #修改前</span><br><span class="line">  endstop_pin: ^!PE5    #修改后</span><br><span class="line">        或</span><br><span class="line">  endstop_pin: PE5     #修改前</span><br><span class="line">  endstop_pin: ^PE5     #修改后</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>热床 PID 校正</strong><br>G28 归零后，将喷嘴移至热床中心，高出床面约 5-10mm，然后发送命令<br><code>PID_CALIBRATE HEATER=heater_bed TARGET=100</code><br>它将执行一个 PID 校准程序，将持续约 10 分钟，完成后控制台将会返回 PID 数值，将其复制到热床的 PID 设置即可。</p>
<p><strong>挤出头 PID 校正</strong><br>先将模型冷却风扇设置为 25% 的转速（ M106 S64 ），然后发送命令<br><code>PID_CALIBRATE HEATER=extruder TARGET=245</code><br>它将执行一个 PID 校准程序，将持续约 5 分钟，完成后控制台将返回 PID 数值，将其复制到配置文件即可。</p>
<h1 id="OctoPrint"><a href="#OctoPrint" class="headerlink" title="OctoPrint"></a>OctoPrint</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>应该在虚拟环境中完成，以帮助防止依赖性冲突。</p>
<p>首先设置 Python、依赖项和虚拟环境。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3 python3-pip python3-dev python3-setuptools python3-venv git libyaml-dev build-essential libffi-dev libssl-dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> OctoPrint &amp;&amp; <span class="built_in">cd</span> OctoPrint</span><br><span class="line">python3 -m venv venv</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br></pre></td></tr></table></figure>

<p>然后可以使用以下命令安装 OctoPrint 及其 Python 依赖项 pip：</p>
<p><code>pip install pip --upgrade</code></p>
<p><code>pip install octoprint</code></p>
<ul>
<li>如果安装了旧版本的 OctoPrint，pip 可能仍然有一些缓存。在那种情况下添加 <code>--no-cache-dir</code> 到安装命令，例如 <code>pip install --no-cache-dir octoprint</code></li>
</ul>
<p>要使这个永久的、干净的 pip 缓存：<code>rm -r ~/.cache/pip</code></p>
<p>在启动 OctoPrint 之前，添加用户权限，以便用户可以访问串行端口：</p>
<p><code>sudo usermod -a -G tty pi</code></p>
<p><code>sudo usermod -a -G dialout pi</code></p>
<p>您可能必须注销并重新登录才能使这些更改生效。</p>
<p>之后使用 <code>octoprint serve</code> 命令启动 <code>OctoPrint</code> 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ ~/OctoPrint/venv/bin/octoprint serve</span><br><span class="line">2020-11-03 17:39:17,979 - octoprint.startup - INFO - ***************************</span><br><span class="line">2020-11-03 17:39:17,980 - octoprint.startup - INFO - Starting OctoPrint 1.4.2</span><br><span class="line">2020-11-03 17:39:17,980 - octoprint.startup - INFO - ***************************</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://&lt;pi&#39;s IP&gt;:5000</code></p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>OctoPrint 网络服务器需要进行配置，以便与 Klipper host 软件进行通信。使用网络浏览器，登录到 OctoPrint 网页，然后配置以下项目：</p>
<ul>
<li>导航到 “ 设置 “（页面顶部的扳手图标）。在 “ 串行连接 “ 下的 “ 附加串行端口 “ 中添加 “&#x2F;tmp&#x2F;printer”。然后点击 “ 保存 “。</li>
<li>再次进入 “ 设置 “，在 “ 串行连接 “ 下将 “ 串行端口 “ 设置改为 “&#x2F;tmp&#x2F;printer”。</li>
<li>在 “ 设置 “ 中，浏览到 “Behavior “ 子选项卡，选择 “ 取消任何正在进行的打印，但保持与打印机的连接 “ 选项。点击 “ 保存 “。</li>
<li>在主页上，在 “ 连接 “ 部分（在页面的左上方），确保 “ 串行端口 “ 被设置为 “&#x2F;tmp&#x2F;printer”，然后点击 “ 连接 “。(如果 “&#x2F;tmp&#x2F;printer “ 不是一个可用的选择，那么试着重新加载页面)</li>
<li>连接后，导航到 “ 终端 “ 选项卡，在命令输入框中输入 “status”（不带引号），然后点击 “ 发送 “。终端窗口可能会报告在打开配置文件时出现了错误 – 这意味着 OctoPrint 与 Klipper 成功地进行了通信。</li>
<li>需要继续配置 klipper 的 print.cfg 文件。</li>
</ul>
<h1 id="Fluidd"><a href="#Fluidd" class="headerlink" title="Fluidd"></a>Fluidd</h1><p>Fluidd 适用于 3D 打印机的 Klipper 固件，提供 WEB 页面和控制。</p>
<p>项目地址 <a href="https://github.com/fluidd-core/fluidd">https://github.com/fluidd-core/fluidd</a></p>
<h2 id="KIAUH-安装"><a href="#KIAUH-安装" class="headerlink" title="KIAUH 安装"></a>KIAUH 安装</h2><p>项目地址 <a href="https://github.com/dw-0/kiauh">https://github.com/dw-0/kiauh</a></p>
<p>安装 git 后，克隆 KIAUH 项目</p>
<p><code>git clone https://github.com/dw-0/kiauh.git</code></p>
<p>启动 KIAUH</p>
<p><code>./kiauh/kiauh.sh</code></p>
<p>KIAUH 的主菜单中。您将看到多个操作可供选择，具体取决于您想要执行的操作。要选择操作，只需在“执行操作”提示中输入相应的数字，然后按 ENTER 确认即可。</p>
<h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p>Fluidd 附带一个 <code>build</code> 脚本，可在项目地址 </p>
<p><a href="https://github.com/fluidd-core/fluidd/releases">https://github.com/fluidd-core/fluidd/releases</a> 的 <code>fluidd.zip</code> 中找到。</p>
<p>需要安装 NodeJS (v16.x) 和 Git</p>
<p>克隆 Fluidd 源代码</p>
<p><code>git clone https://github.com/fluidd-core/fluidd.git</code></p>
<p>导航到 Fluidd 源代码目录</p>
<p><code>cd fluidd</code></p>
<p>安装依赖</p>
<p><code>npm ci</code></p>
<p>构建并捆绑 Fluidd</p>
<p><code>npm run build</code></p>
<p>构建的文件将写入该 <code>dist</code> 目录。您可以使用您首选的 HTTP 服务器来提供这些服务，例如 NGINX。</p>
<ul>
<li>要出于开发目的构建 Fluidd，请运行 <code>npm run serve</code> 而不是 <code>npm run build</code> 启用热重载。</li>
</ul>
<h2 id="windows-下-docker-安装"><a href="#windows-下-docker-安装" class="headerlink" title="windows 下 docker 安装"></a>windows 下 docker 安装</h2><p><code>docker pull ghcr.io/fluidd-core/fluidd:sha-8f091c2c75c6646cd29ab288863a379b7ca6c63e</code></p>
<h2 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h2><p>热床找平及各限位开关触发状态</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>3D打印机</category>
      </categories>
      <tags>
        <tag>3D打印机</tag>
      </tags>
  </entry>
  <entry>
    <title>3D打印相关软件</title>
    <url>/2024/05/21/%E5%85%B6%E4%BB%96-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="系统固件"><a href="#系统固件" class="headerlink" title="系统固件"></a>系统固件</h1><p><strong>Klipper</strong><br>Klipper 是一个高性能、灵活的 3D 打印机固件，它通过将一些计算工作转移到更强大的主机（如 Raspberry Pi）上来提高打印质量和速度。</p>
<p><strong>Marlin</strong><br>Marlin 是目前最流行的 3D 打印机固件之一，支持广泛的硬件平台和 3D 打印机模型，具有丰富的功能和高度的可定制性。</p>
<h1 id="控制软件"><a href="#控制软件" class="headerlink" title="控制软件"></a>控制软件</h1><p><strong>fluidd</strong><br>Fluidd 是一个基于网页的控制界面，用于管理和监控运行 Klipper 固件的 3D 打印机。它提供了用户友好的界面和实时监控功能。<br>GitHub 地址: <a href="https://github.com/fluidd-core/fluidd">https://github.com/fluidd-core/fluidd</a><br>安装手册: <a href="https://github.com/dw-0/kiauh">https://github.com/dw-0/kiauh</a></p>
<p><strong>Make-me</strong><br>Make-me 是一个通过 WiFi 控制 Replicator 2 打印机的开源项目，使用 GitHub 的聊天机器人 Hubot 来监控和完成打印任务。目前只支持 Mac 的 OS X。</p>
<p><strong>Pepeteir-Server</strong><br>Pepeteir-Server 是一个新型的 Repeteir 产品，可以在 Raspberry Pi 上运行，支持控制多台打印机，内存消耗极小。它的网页操作界面简单，但不支持 Mac 和 PC。</p>
<p><strong>Octoprint</strong><br>Octoprint 是一个完全基于网页的 3D 打印机控制程序，可以远程控制打印机，并通过网络摄像头监控打印过程。支持 Raspberry Pi。</p>
<p><strong>Botqueue</strong><br>Botqueue 是一个开源的远程打印机控制软件，可以控制多台打印机。用户上传 .stl 文件后，软件会完成切片和打印工作。它支持为每台打印机设置独立的切片特性。</p>
<h1 id="切片软件"><a href="#切片软件" class="headerlink" title="切片软件"></a>切片软件</h1><p>切片软件用于将 3D 模型按层切片，并生成用于打印的 G 代码。</p>
<p><strong>Cura</strong><br>Cura 由 Ultimaker 开发，兼容多种 3D 打印机。它不仅可以切片，还提供 3D 打印机控制界面，尤其适用于 Ultimaker 的 3D 打印机。</p>
<p><strong>Slic3r</strong><br>Slic3r 是开源且免费的切片软件，因其快捷性和高度可定制化而广受欢迎。许多 3D 打印机制造商提供默认的 Slic3r 配置文件（.INI 文件），可以用作初始设置。</p>
<p><strong>Skeinforge</strong><br>另一款非常流行的切片软件。同样开源，免费。</p>
<p><strong>kisslicer</strong><br>KISSlicer 是一款跨平台的切片软件，名称源自 “Keep It Simple”（保持简单），目标是提供一个简单易用的界面。</p>
<p><strong>Printrun</strong><br>Printrun 既是控制软件，也是切片软件，可以独立完成从切片到打印的整个过程。支持 Mac、Linux 和 PC 操作平台。</p>
<p><strong>Repetier-Host</strong><br>Repetier-Host 与 Printrun 类似，是一款综合性软件，具有切片、零件定位和机器控制功能。用户界面相对更复杂但更直观，同样支持 Mac、Linux 和 PC 操作平台。</p>
<h1 id="3D-建模软件"><a href="#3D-建模软件" class="headerlink" title="3D 建模软件"></a>3D 建模软件</h1><p><strong>Blender</strong><br>Blender 是一款开源的 3D 建模软件，功能强大且完全免费。它不仅可以用于 3D 建模，还支持动画、渲染、雕刻等多种功能，适用于各种复杂的 3D 设计和制作。</p>
<p><strong>Tinkercad</strong><br>Tinkercad 是一个由 Autodesk 开发的在线 3D 建模工具，适合初学者使用。它基于浏览器，无需下载软件，界面友好且易于使用。</p>
<p><strong>Fusion 360</strong><br>Fusion 360 同样由 Autodesk 开发，是一款功能强大的云端 3D CAD、CAM 和 CAE 工具。它适用于从初学者到专业人士的各个层级，提供了全面的建模、仿真和制造功能。</p>
<p><strong>SketchUp</strong><br>SketchUp 是一款广受欢迎的 3D 建模软件，以其直观的用户界面和易用性著称。它有免费版本（SketchUp Free）和专业版本（SketchUp Pro），适用于建筑、工程、游戏开发等多个领域。</p>
<p><strong>FreeCAD</strong><br>FreeCAD 是一款开源的 3D CAD 建模软件，适合于产品设计、机械工程以及建筑设计。它具有模块化的架构，可以通过插件扩展其功能。</p>
<p><strong>SolidWorks</strong><br>SolidWorks 是一款由 Dassault Systèmes 开发的专业 3D CAD 软件，广泛应用于工程设计、产品设计和制造业。它功能强大，但价格较高，通常用于工业级应用。</p>
<p><strong>Onshape</strong><br>Onshape 是一个基于云的 3D CAD 建模软件，适用于团队协作和设计项目。它无需安装，直接在浏览器中运行，支持实时协作和版本控制。</p>
<p><strong>OpenSCAD</strong><br>OpenSCAD 是一款开源的 3D CAD 建模软件，适用于创建精确的 3D 模型。它使用编程语言来定义模型，适合那些有编程经验的用户。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>3D打印机</category>
      </categories>
  </entry>
  <entry>
    <title>16-8禁食软件架构设计</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-16-8%E7%A6%81%E9%A3%9F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用于记录每日的禁食时间，保证不间断禁食时间保持十六个小时</p>
<p>如何提供奖励机制</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p> - 点击按钮开始计时<br> - 再次点击按钮结束计时<br> - 期间中途如果 APP 有退出情况，应记录中途退出情况，并能够续写禁食时间</p>
<p>程序启动时，开始时读取上次的计时状态和禁食日志</p>
<p>如果之前的禁食状态未为结束，根据中间经过的时间间隔继续计时，接着开始禁食</p>
<p>否则进入正常流程，等待重新开始计时</p>
<p>点击开始计时后</p>
<p>判断日志中是否已经有今日的禁食时间，是否覆盖？</p>
<p>如果否，则不启动计时</p>
<p>如果是，则清除文件中已保存的禁食时间，启动定时器</p>
<p>定时器启动，实时写入当前的禁食数值及禁食状态</p>
<p> - 2023-07-26-10-10-10-1</p>
<p>点击结束计时后，</p>
<p>停止计时器</p>
<p>覆写当前时间和禁食时间以及禁食状态</p>
<p> - 2023-07-26-10-10-30-0</p>
<p>写入当前当前日期和禁食时间</p>
<p> - 2023-07-26-0-0-20</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>能够查询到每日的禁食时间</p>
<p> - 保存每日的禁食数据，如果有重复的禁食数据，弹窗提示，让用户选择哪条禁食数据有效</p>
<p> - 查询每日禁食数据，根据点击的日期显示禁食时长</p>
<p> - 表格显示禁食进度完成情况，绿色代表完成，红色代表未完成</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>建立每日目标及目标达成情况</p>
<p> - 表格显示每日目标及目标达成情况</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p> - 能够设置每日禁食时长<br> - 能够手动设立目标</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>软件设计</category>
      </categories>
  </entry>
  <entry>
    <title>文件夹双向同步软件设计</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%8C%E5%90%91%E5%90%8C%E6%AD%A5%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522162114.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>其他</category>
        <category>软件设计</category>
      </categories>
  </entry>
  <entry>
    <title>植物大战僵尸游戏架构</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522144408.png" alt="image-20240103121751622.png"></p>
]]></content>
      <categories>
        <category>其他</category>
        <category>软件设计</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式笔记</title>
    <url>/2024/05/17/%E8%AF%AD%E8%A8%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h1 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h1><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。</p>
<p><strong>正则表达式就是记录文本规则的代码</strong>，用于模式匹配和搜索文本的工具。</p>
<h1 id="正则表达式的模式"><a href="#正则表达式的模式" class="headerlink" title="正则表达式的模式"></a>正则表达式的模式</h1><ul>
<li><strong>字面值字符</strong>：普通字符按照字面意义进行匹配,例如字母、数字、空格等，可以直接匹配它们自身。</li>
<li><strong>特殊字符</strong>：例如点号 <code>.</code>、星号 <code>*</code>、加号 <code>+</code>、问号 <code>?</code> 等，它们具有特殊的含义和功能。</li>
<li><strong>字符类</strong>：用方括号 <code>[ ]</code> 包围的字符集合，用于匹配方括号内的任意一个字符。<code>[^ ]</code> 匹配除了括号内的字符以外的任意一个字符</li>
<li><strong>元字符</strong>：例如 <code>\d</code>、<code>\w</code>、<code>\s</code> 等，用于匹配特定类型的字符，如数字、字母、空白字符等。</li>
<li><strong>量词</strong>：例如 <code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code> 等，用于指定匹配的次数或范围。</li>
<li><strong>边界符号</strong>：例如 <code>^</code>、<code>$</code>、<code>\b</code>、<code>\B</code> 等，用于匹配字符串的开头、结尾或单词边界与非边界位置。</li>
<li><strong>分组和捕获</strong>：<code>( )</code>：用于分组和捕获子表达式。<code>(?: )</code>：用于分组但不捕获子表达式。</li>
</ul>
<h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><p>字符匹配直接在方括号里列出：</p>
<ul>
<li>[aeiou] 就匹配任何一个英文元音字母</li>
<li>[.?!] 匹配标点符号 (.或?或!)</li>
</ul>
<p>也可以指定一个字符范围：</p>
<ul>
<li>[0-9] 代表的含意与\d 就是完全一致的：一位数字</li>
<li>[a-z0-9A-Z_] 也完全等同于\w。</li>
</ul>
<p><strong>普通字符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[ABC]</td>
<td align="left">匹配 […] 中的所有字符</td>
</tr>
<tr>
<td align="center">[^ABC]</td>
<td align="left">匹配除了 […] 中字符的所有字符</td>
</tr>
<tr>
<td align="center">[A-Z]</td>
<td align="left">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。</td>
</tr>
<tr>
<td align="center">[\s\S]</td>
<td align="left">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配字母、数字、下划线。等价于 <code>[A-Za-z0-9_]</code></td>
</tr>
</tbody></table>
<p><strong>非打印字符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\cx</td>
<td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<p><strong>特殊字符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$</td>
<td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则$ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td>
</tr>
<tr>
<td align="center">( )</td>
<td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次。要匹配 * 字符，请使用*。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td align="center">[</td>
<td align="left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用?。</td>
</tr>
<tr>
<td align="center"><code>\</code></td>
<td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘&#39; 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用^。</td>
</tr>
<tr>
<td align="center">{</td>
<td align="left">标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">指明两项之间的一个选择。要匹配|，请使用 |。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>分支条件</strong><br><code>|</code> 元字符，用于在两种或多种模式之间进行选择</p>
<p>匹配分枝条件时，将会从左到右地测试每个条件，如果满足某个分枝，就不会再去向右测试。</p>
<p><strong>分组</strong><br>() 元字符，标记一个子表达式的开始和结束位置。例如 IP 地址表达式:<br><code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code></p>
</blockquote>
<p><strong>限定符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配 “z” 以及 “zoo”。</em> 等价于 {0,}。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，zo+ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 “do” 、 “does”、 “doxy” 中的 “do” 和 “does”。? 等价于 {0,1}。</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 “Bob” 中的 o，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配 n 次。例如，o{2,} 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 <code>o*</code>。</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 “fooooood” 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<p><strong>定位符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">非单词边界匹配。</td>
</tr>
</tbody></table>
<blockquote>
<p>不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <code>^*</code> 之类的表达式</p>
</blockquote>
<p><strong>转义字符与反义字符</strong></p>
<p>在正则表达式中，还有一些常用的转义字符,转义字符可以方便地匹配一些常见的字符类型:</p>
<table>
<thead>
<tr>
<th align="center">—</th>
<th align="center">—</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\d</td>
<td align="center">表示匹配任意一个数字字符</td>
<td></td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">表示匹配任意一个字母、数字或下划线字符</td>
<td></td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">表示匹配任意一个空白字符（包括空格、制表符、换行符等）</td>
<td></td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">表示匹配单词的边界等。</td>
<td></td>
</tr>
</tbody></table>
<p>在正则表达式中，反义字符是指用于匹配除了某些字符之外的任意字符的特殊字符。</p>
<p>反义字符以 \ 开头，后面跟着一个大写字母，表示匹配除了这个字符类别中的任意一个字符之外的所有字符。</p>
<table>
<thead>
<tr>
<th align="center">—</th>
<th align="center">—</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\D</td>
<td align="center">匹配任意一个非数字字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">匹配任意一个非字母、数字或下划线字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">匹配任意一个非空白字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">匹配不在单词边界上的任意一个字符。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>小括号的另一种用途是通过语法 (?#comment) 来包含注释</p>
<blockquote>
<p>IP 地址 2[0-4]\d(?#200-249)|25<a href="http://124.222.246.202:8080/2023/06/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#250-255">0-5</a>|[01]?\d\d?(?#0-199)。</p>
</blockquote>
<h1 id="贪婪和懒惰"><a href="#贪婪和懒惰" class="headerlink" title="贪婪和懒惰"></a>贪婪和懒惰</h1><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。</p>
<p>以这个表达式为例：a.*b，它将会匹配最长的以 a 开始，以 b 结束的字符串。</p>
<p>如果用它来搜索 aabab 的话，它会匹配整个字符串 aabab。这被称为<strong>贪婪匹配</strong>。</p>
<p>有时，我们更需要<strong>懒惰匹配</strong>，也就是匹配尽可能少的字符。</p>
<p>前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。</p>
<p>这样 <code>.*?</code> 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>
<p>现在看看懒惰版的例子吧： <code>a.*?b</code> 匹配最短的，以 a 开始，以 b 结束的字符串。如果把它应用于 aabab 的话，它会匹配 aab（第一到第三个字符）和 ab（第四到第五个字符）。</p>
<h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>
<p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">转义符</td>
</tr>
<tr>
<td align="center">(), (?:), (?&#x3D;), []</td>
<td align="center">圆括号和方括号</td>
</tr>
<tr>
<td align="center">*, +, ?, {n}, {n,}, {n,m}</td>
<td align="center">限定符</td>
</tr>
<tr>
<td align="center">^, $, \任何元字符、任何字符</td>
<td align="center">定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">替换，” 或 “ 操作,字符具有高于替换运算符的优先级，使得&#96;m</td>
</tr>
</tbody></table>
<h1 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h1><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本 (也就是此分组捕获的内容) 可以在表达式或其它程序中作进一步的处理。</p>
<p><strong>反向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code> 代表分组 1 匹配的文本。</strong></p>
<blockquote>
<p>分组 0 对应整个正则表达式 <code>\b(\w+)\b\s+\1\b</code> 可以用来匹配重复的单词，像 go go, 或者 kitty kitty。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>确定需要匹配的基本字符或字符类别&#x2F;集合等</li>
<li>确定匹配的字符或字符集合的数量</li>
<li>特殊字符和转义字符的处理</li>
<li>边界和位置的匹配</li>
<li>使用捕获组 <code>()</code> 进行多组匹配</li>
<li>使用反向引用</li>
<li>使用逻辑操作符进行判定</li>
</ol>
<h1 id="正则表达式字符含义表"><a href="#正则表达式字符含义表" class="headerlink" title="正则表达式字符含义表"></a>正则表达式字符含义表</h1><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，<code>n</code> 匹配字符 “n”。<code>\\n</code> 匹配一个换行符。序列 <code>\\</code> 匹配 “\ 而 “(“ 则匹配 “(“。</td>
<td></td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 <code>\\n</code> 或 <code>\\r</code> 之后的位置。</td>
<td></td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 <code>\\n</code> 或 <code>\\r</code> 之前的位置。</td>
<td></td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
<td></td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，<code>zo+</code> 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
<td></td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td>
<td></td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，<code>o&#123;2&#125;</code> 不能匹配 “Bob” 中的 <code>o</code>，但是能匹配 “food” 中的两个 o。</td>
<td></td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配 n 次。例如，<code>o&#123;2,&#125;</code> 不能匹配 “Bob” 中的 <code>o</code>，但能匹配 “foooood” 中的所有 o。<code>o&#123;1,&#125;</code> 等价于 <code>o+</code>。<code>o&#123;0,&#125;</code> 则等价于 <code>o*</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。<code>o&#123;0,1&#125;</code> 等价于 <code>o?</code>。请注意在逗号和两个数之间不能有空格。</td>
<td></td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，<code>o+?</code> 将匹配单个 “o”，而 <code>o+</code> 将匹配所有 <code>o</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 <code>\\n</code> 在内的任何字符，请使用像 &#96;(.</td>
<td>\n)&#96; 的模式。</td>
</tr>
<tr>
<td align="center">(pattern)</td>
<td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在 VBScript 中使用 SubMatches 集合，在 JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 <code>(</code> 或 <code>)</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">(?:pattern)</td>
<td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “ 或 “ 字符 (&#96;</td>
<td><code>) 来组合一个模式的各个部分是很有用。例如， </code>industr(?:y</td>
</tr>
<tr>
<td align="center">(?&#x3D;pattern)</td>
<td align="left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，&#96;Windows(?&#x3D;95</td>
<td>98</td>
</tr>
<tr>
<td align="center">(?!pattern)</td>
<td align="left">正向否定预查 (negative assert)，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如 &#96;Windows(?!95</td>
<td>98</td>
</tr>
<tr>
<td align="center">(?&lt;&#x3D;pattern)</td>
<td align="left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，&#96;(?&lt;&#x3D;95</td>
<td>98</td>
</tr>
<tr>
<td align="center">(?</td>
<td align="left">反向否定预查，与正向否定预查类似，只是方向相反。例如 “(?” 能匹配 “3.1Windows” 中的 “Windows”，但不能匹配 “2000Windows” 中的 “Windows”。</td>
<td></td>
</tr>
<tr>
<td align="center">&#96;x</td>
<td align="left">y&#96;</td>
<td>匹配 x 或 y。例如，&#96;z</td>
</tr>
<tr>
<td align="center">[xyz]</td>
<td align="left">字符集合。匹配所包含的任意一个字符。例如，<code>[abc]</code> 可以匹配 “plain” 中的 <code>a</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">[^xyz]</td>
<td align="left">负值字符集合。匹配未包含的任意字符。例如，<code>[^abc]</code> 可以匹配 “plain” 中的p、l、i、n。</td>
<td></td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="left">字符范围。匹配指定范围内的任意字符。例如，<code>[a-z]</code> 可以匹配 <code>a</code> 到 <code>z</code> 范围内的任意小写字母字符。</td>
<td></td>
</tr>
<tr>
<td align="center">[^a-z]</td>
<td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，<code>[^a-z]</code> 可以匹配任何不在 <code>a</code> 到 <code>z</code> 范围内的任意字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如，<code>er\\b</code> 可以匹配”never” 中的 <code>er</code>，但不能匹配 “verb” 中的 <code>er</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">匹配非单词边界。<code>er\\B</code> 能匹配 “verb” 中的 <code>er</code>，但不能匹配 “never” 中的 <code>er</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\cx</td>
<td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的<code>c</code> 字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">匹配一个数字字符。等价于 [0-9]。</td>
<td></td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">匹配一个非数字字符。等价于 [^0-9]。</td>
<td></td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
<td></td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
<td></td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
<td></td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
<td></td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
<td></td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
<td></td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
<td></td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配字母、数字、下划线。等价于<code>[A-Za-z0-9_]</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">匹配非字母、数字、下划线。等价于<code>[^A-Za-z0-9_]</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\xn</td>
<td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，<code>\\x41</code> 匹配 “A”。<code>\\x041</code> 则等价于 <code>\\x04</code> &amp; “1”。正则表达式中可以使用 ASCII 编码。</td>
<td></td>
</tr>
<tr>
<td align="center">\num</td>
<td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，<code>(.)\\1</code> 匹配两个连续的相同字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td>
<td></td>
</tr>
<tr>
<td align="center">\nm</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td>
<td></td>
</tr>
<tr>
<td align="center">\nml</td>
<td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td>
<td></td>
</tr>
<tr>
<td align="center">\un</td>
<td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td>
<td>&#96;</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>中华字经</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E9%98%85%E8%AF%BB-%E4%B8%AD%E5%8D%8E%E5%AD%97%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a><strong>第一部分</strong></h2><p>乾坤有序，宇宙无疆，星辰密布，斗柄指航。昼白夜黑，日明月亮，风驰雪舞，电闪雷响。 云腾致雨，露结晨霜，虹霓霞辉，雾沉雹降。春生夏长，秋收冬藏，时令应候，寒来暑往。 远古洪荒，海田沧桑，陆地漂移，板块碰撞。山岳巍峨，湖泊荡漾，植被旷野，岛撒汪洋。 冰川冻土，沙漠沃壤，木丰树森，岩多滩广。鸟飞兽走，鳞潜羽翔，境态和谐，物种安详。 形分上下，道合阴阳，幽冥杳渺，天体著彰。凝气为精，聚能以场，缩浓而质，积微显量。 化巨幻虚，恍惚成象，强固凌弱，柔亦制刚。终极必反，存兴趋亡，色空轮回，动静恒常。 唯实众名，一理万方，父母爹娘，没齿难忘。兄弟姐妹，危困助帮，姑姨叔舅，亲戚互访。 侄男闺少，哺育茁壮，夫妻相敬，梦忆糟糠。隔屋邻舍，遇事谦谅，伯公妪婆，慈孝赡养。 尊朋礼友，仁义君郎，炎黄二帝，尧舜禅让。禹启世袭，灭桀商汤，周武伐纣，侯列各邦。 秦皇集权，汉刘楚项，鼎立割据，乱晋霸王。南北对峙，腐朽隋炀，贞观政要，五代续唐。 陈桥兵变，耻辱靖康，耶律完颜，元建宋僵。钟离太祖，崇祯吊丧，清军入关，大臣驻藏。 粉碎叛卓，犁域设将，台湾复归，守卫边防。鸦片战争，英占香港，戊戌维新，社会改良。 辛亥革命，孙文思想，联盟抗倭，国共两党。定都京师，人民解放，诸子百家，孔孟老庄。 扁鹊灵医，鲁班巧匠，罗盘硝药，针灸疗伤。蔡伦毕升，鉴真玄奘，易经论语，史记达畅。 河图洛书，算术九章，西三红水，聊儒瓶厢。诗词曲赋，戏剧说唱，琵琶琴瑟，锣镲铿锵。 笙箫呜咽，卧笛悠扬，筝音奔奋，唢呐高亢。荆浩匡庐，董源潇湘，米芾写意，悲鸿骏昂。 笔墨纸砚，匾楣楹榜，楷隶篆刻，碑帖草狂。敦煌石窟，长城伟墙，青铜甲骨，缕衣纱裳。 虎符越剑，陶马俑葬，彩瓷宝瓮，丝绸他乡。凡尔赛宫，金字塔状，泰姬陵墓，彼得教堂。 自由女神，希腊塑像，最后晚餐，创造亚当。亭榭楼阁，寺庙殿廊，蓬门荜户，丈室绿窗。 府弟别墅，画栋雕梁，庭院踏步，影屏幕障。承尘藻井，篱笆柱桩，舷舵扶靠，凭栏眺望。 悬崖峭壁，峰峦叠嶂，泉喷岚罩，湍急瀑宕。峡沟潭渊，溪涧流淌，池渠堰坝，沼泽泥塘。 漩涡带波，礁屿连江，汹涌澎湃，惊涛骇浪。灾涝溢泻，汛潮浮涨，苍松寿柏，垂柳毛杨。 芭蕉蒲扇，斑竹篾筐，槐椿榆桦，杉桂榕樟，斋扉紧闭，栅苑濒旁，坪埔莱茵，菲窥坞坊。 蔷薇翩跹，莆菏蔚茫，蕴蒂荚芯，蓓蕾琳琅。奇花异卉，艳丽荣秧，兰荷菊梅，四季芬芳。 杜鹃泣血，芙蓉吉祥，茉莉馥郁，玫瑰刺芒。瓜果蔬菜，葱蒜韭姜，茴椒芹葵，皮芥辣酱。 芸苔芋笋，葫芦瓢瓤，番茄蘑菇，乳蛋醇酿。碘盐食醋，脆卜甜糖，珍馐旨甘，肴馔膏粱。 葡萄美酒，玉液琼浆，咖啡益智，茗茶顺肠。桃李杏柿，汁鲜味爽，椰柚橙桔，渴饮品尝。 菠萝柑橘，橄榄槟榔，梨枣苹楂，荔栗榴棠。蝌蚪摆尾，蛤蟆鼓囊，钓饵蚯蚓，蠕虫蚂蟥。 鹦鹉学舌，蜜蜂穿忙，蝙蝠栖洞，梧桐引凰。蜘蛛牵补，螟蛉蛀粮，蜻蜓振翅，鸠鹏张膀。 鸥莺燕雀，蝴蝶鸳鸯，鲤鲫鲇鲸，蛙蚌螺螃。蚜蛾蝉蛹，龟卵翼蝗，蚊蝇鼠蚁，蛇蝎鳝蟒。 蜈蚣毒腺，蟋蟀蹬闯，鹿狈狐狸，熊豹豺狼。猿啼猴吱，鸵孵獭躺，雏猩攀梢，雌牡匿冈。 砂舟骆驼，迅捷羚羊。</p>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a><strong>第二部分</strong></h2><p>中华初繁，睡狮渐醒，玖久纪末，千年始零。宏业昌盛，妙策递迎，左右兼顾，总揽统领。 内取稳进，外交志同，阶梯过度，切忌狠猛。六贼七害，监视审听，戒贪须效，践约宜行。 贬恶褒绩，赏劝罚惩，操刃执斧，塞涓救荧。势如突起，抽薪熄平，途逢险兆，消芽于萌。 调息止纷，贵在用衡，依法谋治，官吏皆正。推贤荐材，睹貌辨容，纯朴宽厚，侠烈尽忠。 耿直肃仪，襟怀袒诚，谄媚狡猾，机敏慧颖。懈怠懒惰，拙笨碌庸，愚昧糊涂，偏才至聪。 羞涩拘束，杰健悍雄，恭谨畏惧，缄默持重。骄奢傲慢，怯懦惶恐，超逸独居，恬淡匀宁。 猜疑诡秘，威严毅勇，币帛钱钞，攘夺其宗。企财盼利，价值均等，务工开厂，增富减穷。 资产累计，税率加乘，银行贷款，储蓄倍宠。抵押拆借，循例不停，供给需求，市货充盈。 销售买卖，亏差余剩，债券股票，博赌输赢。闻赚虽喜，跌赔癫疯，休闲退优，涣虑受逍。 拒宾疏客，忧谢欢招，把盏讲趣，倚床读晓。游景筏渡，迹绝喧嚣，茂冠蔽枝，莽园出条。 碧岭滴翠，落叶飘摇，心澄彻透，雅悦去燥。挥毫绎就，佳句抒了，漆珠镶眸，秀眉斜弯。 樱口含笑，脂靥隐现，敖鼻单翘，坠耳双环。舒额弹腮，龙睛凤眼，纤手藕臂，软颈削肩。 乌发比臀，酥胸腰间，修腿负躯，弓脚婷站。沐浴洁身，梳妆乔扮，薄黛轻施，靓耀矫莲。 服锦饰佩，缤绫绣缎，赞叹称颂，宛若娥仙。阿弥陀佛，觉悟融圆，僧尼寂寞，菩萨向善。 情投系姻，欲净见缘，转识迷性，苦乐恼烦。圣诞基督，原罪赎还，目的辩证，裁判邪端。 朝觐跪拜，先知注传，我主保佑，好娃阿丹。格林童话，伊索寓言，莎翁托氏，福摩探案。 但丁哥德，伽丘十谈，培根牛顿，爱因斯坦。试管婴儿，克隆遗传，细胞速冷，脱氧核酸。 脉冲数码，几何规范，网络通讯，程控遥感。驱逐舰艇，洲际导弹，激光辐射，捆绑火箭。 声纳测距，贫铀污染，点线面段，球弧侧弦。菱锥棱角，凸凹顶尖，竖撇捺折，陡拱椭圈。 奥运竞技，淘汰筛选，跨跃短跑，蹦跳撑竿。铁饼标枪，垒足排篮，汽车拉力，驾舢驶帆。 刀锤棍棒，钩爪杖鞭，锁链杠铃，摔跤击拳。省区署郊，村镇屯店，耕耘耧耙，播耪搅拌。 农垦灌溉，渔猎驳船，柴棚炊热，牧畜粪烟。膜压窖湿，肥攻磷氮，穴浇尿深，灰埋屎浅。 稻麦谷豆，蓖麻薯棉，粟苞芝麸，秫秸稼秆。糜黍荸荠，蓑稗蔗豌，埂堤垄畦，荞秕稞旱。 禾苗缨穗，蔓附藤缠，棕榈柠檬，枫棵紫檀。剪丫打杈，嫁接插扦，颗粒籽核，株蕊茎杆。 鸡鸭抱群，猪仔满圈，驴骡啃坡，犬狗护岸。厩驹罕鬃，驯犊乍唤，鱼鳖虾蟹，猫兔鹅蚕。 旋绕鹰鸽，哀孤鹤雁，宿营扎寨，枕戈待旦。哨岗戎诫，挎锐披坚，帅旗挺拔，训士阅演。 磐踞较劲，擎帜呼喊，伪装跟踪，信号遮掩。稍纵即逝，竟忽瞬暂，驭舆骋骛，靶轰州县。 趁却骚扰，构筑壕堑，谍报频渗，御挡阻拦。耗损酬饲，迈历委艰，垢卸焚址，盔甩烬焰。 擒敌破阵，调派遣返，围追堵截，伏剿全歼。崭旅另召，蜕衰勿厌，碉堡摧毁，拥挤逃窜。 俘虏缴械，胜败前沿，枉允肯否，咀嚼凯宴。惨遭牺牲，素裹席卷，坟棺尸闹，魂魄寝眠。 活着祈祷，死则祭奠，廉奉殉职，奖功颁衔。组织筹备，抚恤申签，部属僚员，涕泪潸然。 彪炳铭册，炫烁灿烂。</p>
<h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a><strong>第三部分</strong></h2><p>狱牢禁卒，司典刑宪，辞讼哭诉，鸣屈伸冤。敞释矛盾，剖层剥茧，淀滤猖浊，昭划界限。 妨碍侦察，贿赂仕宦，诅咒吓唬，挑衅侮谩。讥讽诽谤，浑噩撤验，朦胧伎俩，仍留隙嫌。 斟酌掺谎，包庇捂瞒，陨堕棘阱，殃及祠眷。检举查封，逮捕魁顽，作奸犯科，缉拿协办。 妖魔鬼怪，凶煞酷阎，歹徒坏类，狰狞嘴脸。勒逼豪阔，搜刮卑贱，拐架孩提，坑蒙孕残。 盗匪劫窃，敲诈欺骗，唆使怂勇，横征暴敛。烧杀抢掠，栽赃诬陷，宰虐淫霸，痞劣刁蛮。 狎昵娼妓，蹂躏鬓鬟，猥亵妇寡，屠戮毙斩。氓绅诱瘾，倒置昏暗，婢奴躲避，怨斥责谴。 酗殴滋祸，弊秽泛滥，偷漏假冒，妄贩募捐。剃囚拷问，傀儡敷衍，侥幸饶恕，期告赦免。 镣铐锒铛，忏悔已憾，匆慌失措，徐踱圃团。踌躇徘徊，彷徨怖添，窘焦愁绪，沦颓苟喘。 虱蚤蛆蛔，茅厕臭便，钾钠钙铝，锌钢锡铅。镍锑锗钨，铬钡铂钒，硼汞硅硫，苯氰锰碳。 氯氢氦氟，烯烃炔烷，砒砷硒矽，酚酞酮醛。腔膛脏腑，脾肾髓胆，唇嗓喉咙，颐臆腹腆。 肛胯脐趾，膝颅眶睑，肪膘冗赘，颧颊骸嵌。憨傻痴呆，聋哑瘫痪，疙瘩痘疹，脓疮秃癣。 霉肤搔痒，疤痕愈痊，痈疽痔痢，癞疥脖腕。瘴瘪痹瘸，瘁疟腋胺，胳膊腋弛，胫肢抖颤。 胃胰溃疡，筋肌痉挛，胁肋疼痛，膀胱菌沾。艾兹侵略，瘟疫扩散，肿瘤癌症，劳惫疲倦。 警惕疾病，诊恙预患，侍姆雇佣，仆役聘换。东街采购，磅秤肉馅，掌勺炉灶，料堆厨馆。 溜炸熏烤，炖煮卤腌，烘焙烙炕，烩炒灼涮。焖爆燎烫，烹蒸熬煎，烽焕泼沥，酝酵醉酣。 荤腥肺脯，滑嫩肚肝，笼屉羔肘，粘润糯丸。粳糕馍饺，稀粥稠饭，糜费羹灸，油浸漫馒。 饿择粗糙，饱剔腻咸，钥匙纽扣，兜袋帷帘。盒套箱柜，瓦罐盂痰，皂缸牙具，杯碟筷碗。 帐幔靴帽，整齐挂拴，壶锅盆桶，器皿匣坛。笤帚垃圾，矿蛰碱矾，夹裆袄袍，篓臼灯伞。 钵钎铰钮，叉橱表镰，乒乓晃瞳，缰绳磕绊。珊瑚贝壳，玛瑙煤炭，泡沫膨胀，蒿苇飒冕。 佃畴租赁，埠位此般，辊辗蜗斡，闸贮淼畔。享爵彬斌，胄裔娟隽，雉翎并勃，婀娜妮曼。 舱釜锈蚀，釉磨铆焊，誊蜡印刷，赠寄邮件。琐屑账簿，惠赐牒翰，棋牌奕拼，衙巷畜豢。 乞丐住讨，叼吃饥馋，库仓巡逻，翱峪俯瞰。鞍骑骤遁，刹那近垣，坎坷崎岖，岔径蜿蜒。 遵逾轨辙，逛遨峻颠，霹雳贯霄，淤础溺淹。厦幢崩塌，窑庵囤填，邑廓倾覆，箍垮隧涵。 淮泄滞沽，浦溅汀澜，泅泳涉滔，渤澳浚涎。舶舨豁缺，桅桨歪坍，陋巢凋囱，畸枢裂檐。 涯涸竭枯，渣滓臊膻，谣决淆惑，是非确断。翻译授课，考究钻研，误错耽搁，犹豫岂敢。 页篇汇稿，编辑校勘，故谜梗概，载版登刊。专题删节，普遍浏览，嘉偶婚配，函恋私已。 叙述绵延，缓迟寻觅，做媒介绍，卿获娇媳。槌簧铙钹，乐吹轿娶，炮震房宅，宣沸弄里。 喇叭噪晌，暮催串艺，叮嘱钦陪，辈份矮低。庶孽继嗣，昆仲甥姊，柬贴逞送，族姥婶婿。 赶赴邀请，祝贺庆禧，扭捏局促，羡慕妒嫉。哥嫂咨询，伙伴参议，爸妈恩准，爷奶评批。 吾你俺她，咱们勉励，模样俊俏，娴淑伶俐。纶巾裙衫，混纺绒絮，框展倩照，镜示映姿。 叩首鞠躬，随俗迁徙，戴璧秉圭，呈诺或与。誓牍弘愿，燃烛洽娱，妊娠胚胎，呕吐娩嬉。 特殊贡献，永享勋誉。</p>
<h2 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a><strong>第四部分</strong></h2><p>幼稚早窍，玩耍练习，头脑认念，诀勤简析。壹贰摹仿，叁肆韵底，伍陆描绘，柒捌譬喻。 吟从倡哦，咏夸所悉，背欠熟旧，诵似谱吕。韶努宵寐，谆诲朝夕，孜挚弗馁，磋砣窒肄。 胖瘦小囡，嗅舔吮吸，咿呀啊哪，喂哄乖嫡。坐摸滚爬，炽汗淋漓，岁半倔犟，赤脊裸屁。 洒扫厅除，擦抹桌椅，墩蹈矩凳，晶莹玻璃。锯锉凿刨，钝锨锋匕，锹锄镐铲，箩纹簸箕。 鞋袜衬裤，缝纫缀洗，毡垫毯褥，晾晒更替。肮袱褂渍，挽袖濯涤，铺盖篷履，废粕丢弃。 泵谓唧筒，矗曰耸屹，怎么姓咋，辅佐答翊。莅临撰到，砌级乃陛，霎诠俄顷，次可叫翌。 笃录甚很，紊奏芜鄙，暇疵兑玷，吝啬阐惜。鹜窝暖禽，晦朔旺汐，之乎者也，噫嘘兮矣。 且又焉哉，吧吗吁呢，夭午酉巳，寅卯丑乙。丙庚壬癸，干支今昔，吨钧亩斤，拾佰仟亿。 只每秒个，尺寸盎厘，轴幅艘瓣，枚朵茬匹。盅旬辆届，本座矢剂，队档副处，仗式趟隅。 慷慨愉快，狭隘惆怅，愤怒憎恨，憋闷嘟囔。萎靡憔悴，疚歉抑怏，怜悯惭愧，怆恻凄凉。 掏挖抠掘，担抬扛搬，揪掐卡握，抡劈拧扳。搓揉揩拭，拂撩拖掸，捅挟搂括，拓扑撬掀。 抄捞撮捧，摘揭抓拣，擂捣捶砸，抛扔掷掼。拍揣拢扯，扒拨挠捡，挪搭挨掖，挣拽搏栓。 搀夯碾轧，撅搪携捻，拈援拄摄，拯挫拗按。摊撵捎找，摞搞掉捍，搽掇搐抉，揍拟拇擅。 抨撕摈扼，掂挝挞攒，揖捉攫掳，擞掣掰撼。钉键铣锚，钳锭镀锻，煽铡炯镊，熔铸冶炼。 跷踊跛跺，踢踩蹋蹿，趴蹲躁踵，蹭蹄跋昙。眯睫盹瞪，睁睬眨瞻，盯瞧瞅瞄，盲瞽瞎看。 瞥瞩央未，晕曙炬眩，谁讶讳谬，谒订讹谚。诌诛谊诧，该诙讫谗，堪坯砖碴，砰砧磁砍。 苛茨萍萤，藐蔑蔫蕃，茸藉芍蘸，绉缚绞缆。纲综纬绰，绢绦绷绽，绚纠缭缔，毗澈沮漫。 澡溯沤沁，溶涅漱浣，滨沂泞沏，漳淖洼涟。潦凑凛冽，怔怕懂惋，悄悼忱悸，怡恃惬惮。 惺愕恢怃，惟恰慑惯，忍恳惹慰，恫懊忿惦。枷檄橇檩，椎札梭椽，楔梆楞榨，榛橡槽栈。 璋瑞琉玲，乏瑶屡奄，偎偿倘僻，仅伺傍俭。估佯侈俱，什侨侣笺，篙箔篡簇，够氛氖氨。 埃墒垛墟，违磺硬砾，逆遂逊迫，迂逗迸迄。褪赅这廷，迢遏迭犀，刽剁剐舀，昨曝晴晰。 鳍鳄吞噎，孺龄蠢殖，它赊您予，帧聩粹既。馏凫酪膳，驮猬歇狙，禀型辖贸，胶某卦敝。 仑殡衩幌，些陌皑窄，甸妥奈彤，颇竣戳契。衷辫帕耐，臻祟窿诣，率晤睦歧，甭殆厄毖。 阀龋褐鞘，阉曳皱辟，呵叱咆哮，吆喝吵骂。吩咐嘀咕，叽哩哇啦，哆嗦唠叨，吭哧嘁喳。 呻吼嚎啸，嗡嘶嘹哗，啮噬喋咬，咚呛唉啥。嚏唾咳嗽，哎哟哼哈，嘻嚷嘿唁，呸吻嘲啪。 嗯吠啤噤，咪嗜嗤嘛，匈哲亳皖，兢渭邯郸。彝傣傈侗，汾绥罢汕，津冀沪辽，浙闽粤陕。 徽鄂滇渝，陇蜀赣黔，郭吴赵魏，聂路况袁。朱许巩邓，彭姚厉韩，崔胡贾郑，苏殷寇谭。 萧任尚付，仇沈庞潘，勾朗韦甫，丛霍娄闫。邹朴俞雒，薛尉杭婉，冯褚禄夷，狄赖稽翦。 巴巫尤虞，欧傅肖樊，辜卢郝沛，荫邢牟阚。曾蒋曹窦，邱邵泌阮，龚祁靳鲍，穆倪莫卞。 淳裴蓟滁，邰邝尹詹，甄毋襄皋，藩茹蔼蓝。赫闰嘎韧，塞竺郜冼，箴郏熠阙，岑奎裘栾。 忻汝汲慎，翟解丞冉，欣苻济肇，柯仵湛晏。嵇佘仝缪，黎葛轩辕。</p>
<h1 id="《中华字经》注释本"><a href="#《中华字经》注释本" class="headerlink" title="《中华字经》注释本"></a><strong>《中华字经》注释本</strong></h1><h2 id="天-文"><a href="#天-文" class="headerlink" title="天 文"></a><strong>天 文</strong></h2><p>《中华字经》是我国历史上第一部韵文式常用字表，共 50 篇，500 韵，1000 句，4000 个常用汉字。它涵盖了人民教育出版社小学语文课本的生字 2540 个，国家汉语水平考试大纲规定的常用字 2905 个，国务院公布的常用汉字 3500 个，国标汉字信息字符集基本集的 3755 个汉字。</p>
<p>《天文》是第一篇，共 8 韵，16 句，64 字。本篇从包罗万象的乾坤和宇宙开始，描述了 种常见的天象。</p>
<p>【原文】 乾坤有序，宇宙无疆。星辰密布，斗柄指航。</p>
<p>【注释】 [1] 乾坤：《周易》第一卦和第二卦。《易·乾·彖辞》曰：“大哉乾元，万物资始，乃统天”。 乾之象为天，表示阳性。《易·坤·彖辞》曰：“至哉坤元，万物资生，乃顺天”。坤之象为地，表示阴性。《易传》认为乾的作用在使万物发生，坤的作用在使万物成长。乾坤相互交感推动万物发生变化。故乾坤又引申为天地、日月、男女、父母等。 [2] 序：次序、顺序。 [3] 宇宙：空间与时间的总和。宇：指上下四方无边无际的空间；宙：指古往今来无始无终的时间。 [4] 疆：边界。 [5] 星辰：天体的总称。星是发亮的天体，辰是比星暗一些的天体。星按物理性质和运动状态分为恒星、行星、卫星、小行星、彗星和流星。太阳是恒星，月亮是卫星，人类居住的地球是行星。 [6] 布：陈列、铺开； [7] 斗柄：北斗七星，即大熊星座。北斗七星排列形状如一把杓子，故民间又称为“杓子星”。北斗星从斗头到斗柄分别为天枢、天璇（或天璿）、天玑、天权、玉衡、开阳、摇（或瑶）光。天枢、天璇、天玑、天权四星组成斗头，又称“斗魁”或“璇玑”。玉衡、开阳、摇光三星组成斗柄，也叫“斗杓”。斗柄在这里指北斗七星。北斗星较亮，而且在北极星附近，连接天璇、天枢二星的线延长约五倍处便可找到北极星，故又被称为指极星，人们夜间走路行船常把北斗星作为辨别方向的重要标志。此外，由于地球的公转，北斗星在一年中处于北极星的不同方位，《鶡冠子·环流》：“斗柄东指，天下皆春；斗柄南指，天下皆夏；斗柄西指，天下皆秋；斗柄北指，天下皆冬。”人们从斗柄所指方向，分季节、辨农时； [8] 航：航向。</p>
<p>【译文】 天地啊，你化育万物，包罗万象，运行井然而有序。 宇宙啊，你无边无际，无始无终，哪儿才是界疆？ 闪烁的星辰密布于太空，北斗星为地球指航。</p>
<p>【评析】 《中华字经》以“乾坤”作为开端，把文章的起始点和自然界的起始点统一起来，体现了作者天人合一的哲学思想。“星辰密布，斗柄指航。”不仅说明北斗星自古以来就是地球运动的参照物，同时也暗示了人类社会的运行规律和自然界的运行规律是一致的。</p>
<p>【原文】 昼白夜黑，日明月亮。风驰雪舞，电闪雷响。</p>
<p>【注释】 [1] 昼：白天。地球对着太阳的一面所处的时间。 [2] 夜：黑夜。地球背着太阳的一面所处的时间。昼与夜相对； [3] 日：太阳的简称，也是太阳系的中心天体。与地球的平均距离 14959.787 万千米，直径 139 万千米，为地球的 109 倍，体积为地球的 130 万倍，质量为地球的 33 万倍，平均密度 1.4 克&#x2F;立方厘米。太阳是一个炽热的气体球，表面温度 5770K，愈向内部温度愈高。中心由氢核聚变成氦核的热核反应产生巨大的能量，以辐射的方式，由内部转移到表面，而发射到宇宙空间。太阳也在自转，其周期在日面赤道带约２５天，两极区约３５天。总体说，太阳是稳定的，但其大气层却处于局部激烈运动中； [4] 月：月球的简称，旧称“太阴”。地球的天然卫星。与地球平均距离 384402 千米。本身不发光，因反射太阳光才能被看到。月球直径 3476 千米，约为地球的 1&#x2F;4，质量为地球的 1&#x2F;81.3，密度为水的 3.3 倍，重力约为地球的 1&#x2F;6。自转周期与其绕地球转动的周期相等，都是 27.3 日，故月球总是以同一面对着地球。 [5] 风：地球上空气的流动。古代把风分为四种：春为和风，夏为熏风，秋为金风，冬为朔风。气象学常用风力表示风的强度，风力分为十三级：0 级无风；1 级软风；2 级轻风；3 级微风；4 级和风；5 级清劲风；6 级强风；7 级疾风；8 级大风；9 级烈风；10 级狂风；11 级暴风；12 级飓风。 [6] 雪：水气在空中遇冷直接凝华成六角形白色结晶的固体降水物。空气中所含水汽多少和温度高低等不同，所形成的雪花形状、雪片大小也就不同；气象学上将雪分为大雪、中雪和小雪。 [7] 雷：伴随闪电出现的强烈爆炸声。由闪道中的高温使水滴汽化、空气体积迅速膨胀而产生。 [8] 电：闪电。云团与空气摩擦而生电，闪电则是云层间、云地间或云和空气间的电位差增大到一定程度时的猛烈放电现象；</p>
<p>【译文】 昼是白天显尽一切，夜晚却漆黑无光。日出一天明，月升满地亮。 风儿驰骋，雪花飞舞。电闪即逝，雷鸣轰响。</p>
<p>【评析】 第一句描写了日出日落、昼夜交替，月缺月圆、岁月流逝的天象。第二句描写了风、雪、雷、电四种自然现象。</p>
<p>【原文】 云腾致雨，露结晨霜。虹霓霞辉，雾沉雹降。</p>
<p>【注释】 [1] 云：地面的湿空气升至高处，遇冷而凝成无数细微水点，成团浮游空中。按云底的高度不同，一般可分为高云、中云和低云三族。外形或分层、或团聚，或呈波状。云状演变常能表明大气结构情况和天气的变化。 [2] 雨：云中的微小水点积重增大到上升气流无力支持时，下落而为雨。雨滴直径约 0.1<del>7 毫米。 [3] 露：接近地面的水汽遇冷凝为水点是露，常见于晴朗无风的夜间或清晨。 [4] 霜：空气中水汽因地面或地物表面散发热量而凝华在其上的白色结晶微粒是霜。一般出现于晚秋和早春季节的晴朗无风夜间或清晨，晚秋产生的霜叫“早霜”，早春产生的霜叫“晚霜”。 [5] 虹霓：是太阳光线与水汽相映，出现在天空的彩晕。主虹为虹，副虹为霓，霓位于虹外侧，常出现于雨后；霞，是因日光斜射而呈现赤色的彩云。 [6] 雾：空气中的水汽凝成细水点或冰晶，象云烟一样弥漫在空中则是雾。 [7] 雹：雨遇冷气凝结成大小不一的冰块随雨降下，便是冰雹。雹呈球形、圆锥形或不规则形，直径大小不一，常见的 5</del>50 毫米。</p>
<p>【译文】 云升腾于空中才致雨，露凝结于深秋方成霜。 长虹伴彩霓，朝霞眩辉光，迷雾沉大地，冰雹从天降。</p>
<p>【评析】这几句说自然气候现象，及其之间的相互作用和联系。</p>
<p>【原文】 春生夏长，秋收冬藏。时令应候，寒来暑往。</p>
<p>【注释】 [1] 春：中国农历将一年分为春、夏、秋、冬四季，春是一年中的第一季。春天，天上轻清之气下降，地上地中之气上升，天地交感，万物萌生，百花齐放，之间极为调和，故春天是万物生长的季节。 [2] 夏：一年中的第二个季节，农历四至六月为夏季，四季的第二季。七至九月为秋季，十至十二月为冬季。夏天是它们迅速成长的季节，秋天是收获果实的季节，冬天是植物贞藏的季节。 此二句是说植物和农作物在春天播种萌生，夏天生长，秋天成熟，冬天储藏的自然规律。</p>
<p>时：岁时、季节。令：政令，古时的政令分为春令、夏令、秋令、冬令。农历按季节气候变化将一年分为二十四个节气，从春至冬依次为立春、雨水、惊蛰、春分、清明、谷雨、立夏、小满、芒种、夏至、小暑、大暑、立秋、处暑、白露、秋分、寒露、霜降、立冬、小雪、大雪、冬至、小寒、大寒。 民间有《二十四节气歌》：“春雨惊春清谷天，夏满芒夏暑相连，秋处露秋寒霜降，冬雪雪冬小大寒。”农人随节气更替安排农事；应候：根据季节、气候变化；寒：冷。此指寒冷的季节；暑：热。此指炎热的季节。寒来暑往指四时相代，季节交替。 句文大意说岁时节令啊，就是应天候而作，这才有冷与热的循环，寒与暑的来往。</p>
<h2 id="地-理"><a href="#地-理" class="headerlink" title="地 理"></a><strong>地 理</strong></h2><p>远古洪荒，海田沧桑。</p>
<p>远古：遥远的古代、古时候；洪荒：指远古时代混沌蒙昧的状态；海田沧桑：即沧海桑田，喻世事变迁巨大。沧是水汇集的地方；桑田即植桑的农田，泛指农田。《神仙传·麻姑》：“麻姑自说云，接侍以来，已见东海三为桑田。” 该句反映出作者叹古的感慨：看，远古时代，洪水肆虐,一片荒凉，大海变成桑田，桑田又变成大海，世事的变化是多么巨大。</p>
<p>陆地漂移，板块碰撞。</p>
<p>陆地：地球表面未被海水浸没的部分，总面积为 14900 万平方公里，约占地球表面总面积的 29%；漂移：漂流移动；板块指成块的陆地。 大陆漂移说是德国科学家 A·魏格纳于 1912 年提出的。它发现相隔在大洋两岸的南美州和非洲两大陆的海岸线，有着惊人的相似性和连续性，恰如一张被撕成两块的报纸，完全可以重新拼合起来，此说后来被科学界观测论证并认同。 板块构造说是 20 世纪 60 年代后期发展起来的关于地壳水平运动的新假说，实际上它是在大陆漂移、海底扩张说的基础上，综合各个方面的科研成果而形成的。这一学说是法国地质学家勒皮顺和英国剑桥大学的麦肯齐等青年学者首先提出来的。它们认为全球石圈分为六大板块，即太平洋板块、印度板块、欧亚板块、非洲板块、美洲板块和南极洲板块。这些板块之间海底的扩张，使陆地板块在地幔上漂移，若两块板块相碰撞，就会产生巨大的水平挤压力，使地槽中的地层发生复杂的褶皱和断裂并上升成为构造山系，导致山的产生。 该句在述说地球演化的科学成因：大地在海洋中缓缓漂移，这些板块相互分离，又相互碰撞。</p>
<p>山岳巍峨，湖泊荡漾。</p>
<p>山岳：陆地表面高度较大、坡度较陡的隆起地貌，海拔一般在 500 米以上的称为山。并以较小的峰顶面积区别于高原，又以较大的高度区别于丘陵。自上而下分为山顶、山坡和山麓。山上有丘为岳，所以高大的山称为岳。一般的概念，也把山岳、丘陵通称为山。山按成因分可分为褶皱山、断块山、侵蚀山、火山等；巍峨：山的高大雄伟貌； 湖泊：地表洼地积水形成比较宽广的水域，如太湖、梁山泊。湖按成因可分为构造湖、火口湖、冰川湖、堰塞湖、喀斯特湖、潟湖、牛轭湖、风蚀湖、人工湖等。按泄水情况，分为排水湖和非排水湖。按盐度高低，分为淡水湖、咸水湖和盐湖。地球上湖泊总面积约 205.87 万平方公里，占陆地面积的 1.38%；荡漾：形容水的起伏微动貌。 这句话是接上而言：因为大陆板块相互碰撞，所以才造出了山岳巍峨挺拔，形成了湖泊涟漪荡漾。</p>
<p>植被旷野，岛撒汪洋。</p>
<p>植被：覆盖地面的植物及其群落的泛称。全球地表的植物称为“世界植被”，某个地区的植物称为“地方植被”，天然森林或草甸称为“自然植被”，耕作的农田或树林称为“人工植被”；旷野：空阔的原野； 岛：也称“岛屿”，散处在海洋、河流或湖泊中的小块陆地，通常大的称岛，较小的称屿。按成因主要分为大陆岛、海洋岛（火山岛、珊瑚岛）和冲积岛。如中国台湾岛属大陆岛，南沙群岛属海洋岛，崇明岛属冲积岛。世界最大的格陵兰岛面积达 217 万余平方公里。世界岛屿总面积约为 970 多万平方公里，约占陆地总面积的 7%；汪洋：形容水宽广无际貌。 句文描写自然环境的优美：植被满山遍野，岛屿象播撒到汪洋大海的种子崭露出头角。</p>
<p>冰川冻土，沙漠沃壤。</p>
<p>冰川：极地或高山地区沿地面运动的巨大冰体。由降落在雪线以上的大量积雪在重力和巨大压力下形成。雪线以上是冰川积累区，以下是冰川消融区。按其形态和规模主要分为大陆冰川和山岳冰川。现代冰川覆盖总面积约为 1620 多平方公里，占地球总面积 11%，占地球淡水总量的 69%；冻土：温度在冰点以下导致所含水分冻结的土壤或疏松岩石。按照冻结的持续时间不同，分别为暂时性冻土、季节性冻土和多年冻土。多年冻土又叫“永久冻土”，指多年连续保持冻结，即使在盛夏，融化深度也不大的土壤或稀松岩石，其面积约占全球陆地总面积 20%~25%，主要成带出现于极地区域。中国东北部分地区和青藏高原高山地区也有多年冻土； 沙漠：沙质荒漠。地表覆盖大片流沙，分布各种沙丘，在风力的推动下，沙丘不时移动，往往侵没农田、村镇、道路；沃壤：肥沃的土壤。土壤是地球陆地表面能生长植物的疏松表层，由矿物质、有机质以及水分、空气等组成。在成土母质、生物、地形、气候等自然因素和耕种、施肥、灌排等人为因素综合作用下，不断演变和发展。是农业生产的基本资料，也是人类生存的重要环境因素。</p>
<p>木丰树森，岩多滩广。</p>
<p>木，树：树木，指木本植物；丰：茂盛、茂密；森：树木丛生繁密貌； 岩：岩石的简称，组成岩石圈的主要物质。一般是固态，由一种或几种造岩矿物或天然玻璃质或生物遗骸所组成，并具有一定的结构和构造。根据形成岩石地质作用可把岩石分为火成岩、沉积岩和变质岩三大类；滩：河道中水浅流急多沙石的地方或海边、河边泥沙淤积的地方。这两句说树木茂盛，种类繁多，岩石丰富，滩地广阔。</p>
<p>鸟飞兽走，鳞潜羽翔。</p>
<p>鸟：飞禽的统称，为脊椎动物亚门的一纲。体均被羽，只具二足而前肢成翼，心脏具两心耳和两心室，骨多空隙，内充气体。呼吸器官除肺外，还有肺壁凸出而形成的气囊，用以帮助肺进行双重呼吸。体温恒定，卵生。种类繁多，现存的鸟类，可分古颚总目、楔翼总目和今颚总目三个总目。有 9000 余种，中国有 1200 余种；兽：即兽类，哺乳纲动物，脊椎动物亚门的一纲。全身披毛，运动快速，恒温，胎生和哺乳，是脊椎动物中躯体结构、功能和行为最复杂的一个高等动物类群。哺乳纲包括 3 个亚纲：原兽亚纲、后兽亚纲和真兽亚纲，其中原兽亚纲最原始，真兽亚纲最高等。分布几乎遍及全球，广泛适应辐射于陆栖、穴居、飞翔和水栖等多种环境。现有 19 目，约 4237 种，中国有 17 目。 鳞：鱼类、爬行类和少数哺乳类体表以及鸟类局部区域所被覆的皮肤衍生物。一般呈薄片状，具有保护作用，这里代指鱼类。鱼是脊椎动物亚门的一纲，为冷血动物，即不定体温的脊椎动物。鱼类长期生活在水中，有适应在水里呼吸的鳃器官，仅有少数种类可用鳔辅助呼吸。鱼体多呈纺锤形，也有侧扁形、平扁形或棍棒形，并常覆有保护性的鳞片。鱼以鳍运动和维持身体平衡，有成对的偶鳍和不成对的奇鳍两类。具有两对鼻孔，听觉器只有内耳，能感知声响。体温几乎完全随水的温度变化而相应变化，为变温动物。一般为卵生，少数卵胎生或胎生。鱼类的寿命长短相差很大，长的可达百岁，短的只能活一年。个体差别更大，大的可长 20 米、重 40 吨，小的只有 0.75~1.5 厘米长。现存鱼类分为软骨鱼类和硬骨鱼类两个类群，几乎遍布世界各地水域。中国鱼类约 2800 多种，其中海洋鱼类约 2100 多种，淡水鱼类约 700 多种；羽：鸟类表皮细胞衍生的角质化产物。被覆在体表，质轻而韧，略有弹性，具一定的防水性，有保护、保温、飞翔等功能，这里代指会飞翔的鸟类。 鸟在天上飞，兽在地上走。鳞生的动物在水中潜游，羽生的禽类在空中飞翔。句文描绘了一幅飞禽走兽在大自然中和谐相处图画。</p>
<p>境态和谐，物种安详。</p>
<p>境态：环境与生态；和谐：协调、和顺；物种：生物种类，即具有一定形态和生理特征以及一定的自然分布区的生物类群。一定的动植物群落和生态系统发展过程中，物种和环境相互制约、依存，达到相对稳定、协调和合的状态，各种生物在这种状态中安然生存。 地球的生态啊是多么和谐!物种的环境啊是多么安详!该句表达了作者对自然环境的赞美，也反映出作者对生态环境的渴望。</p>
<h2 id="人-伦"><a href="#人-伦" class="headerlink" title="人 伦"></a><strong>人 伦</strong></h2><p>父母爹娘，没齿难忘。</p>
<p>父母爹娘：爹娘和父母是一个意思，现代人称父母为爸爸妈妈，古时人则称爹和娘；没齿：没世，犹言一辈子，终身。这两句说父母的生身养育之恩，终身不忘。</p>
<p>兄弟姐妹，危困助帮。</p>
<p>兄弟：同辈人中男性年长者为兄，习惯称哥哥。同辈人中男性年幼者为弟；姐妹：同辈人中女性年长者为姐，年幼者为妹；危：危险、危急；困：困难、贫乏；助帮：即帮助。兄弟姐妹之间，谁有了危急困难，应该互相帮助。</p>
<p>姑姨叔舅，亲戚互访。</p>
<p>姑：父亲的姐姐、妹妹为姑；姨：母亲的姐姐、妹妹为姨；叔：父亲的哥哥称伯，父亲的弟弟称叔，这里叔代指父亲的哥弟；舅：母亲的哥哥、弟弟为舅；亲戚：内外亲属；互访：互相拜访探望。这两句是说亲戚之间，要经常联系来往。</p>
<p>侄男闺少，哺育茁壮。</p>
<p>侄男闺少：兄弟的孩子为侄，男指儿子，闺指闺女，侄男闺少即侄子、儿子、闺女、小孩，泛指下一代幼小的男女孩子；哺育：喂养、培养；茁壮：强壮、健壮，生长旺盛。这两句意思为哺养教育下一代孩子，让他们健康成长。</p>
<p>夫妻相敬，梦忆糟糠。</p>
<p>夫妻：丈夫与妻子的合称。即男女双方通过合法婚姻组成的配偶。夫的配偶称妻，妻的配偶称夫，由此而形成的关系称为夫妻关系，是血亲关系与姻亲关系的基础；糟糠：酒滓、谷皮，喻粗劣的食物。《后汉书·宋弘传》：“弘曰：‘臣闻贫贱之知不可忘，糟糠之妻不下堂’”。是说贫贱时交的朋友不能忘记，共过患难的妻子不能抛弃，因此后来以糟糠为曾共过患难的妻子的代称。夫妻相敬，梦忆糟糠两句说夫妻之间要相敬相爱，在富贵的时候要常想夫妻共患难、同贫贱时候的深厚感情。</p>
<p>隔屋邻舍，遇事谦谅。</p>
<p>隔屋邻舍：指前后左右房舍相邻的家庭住户；谦谅：谦让、谅解。这两句说邻居之间要友好相处，遇事要互相谅解谦让。</p>
<p>伯公妪婆，慈孝赡养。</p>
<p>伯公：父亲的哥哥称伯，伯也是对父辈亲友的通称，旧时又是对文章品德足为表率者的尊称。公是对尊长的敬称。伯公在这里泛指男性长辈；妪婆：妪和婆都是指年老的妇人，这里泛指年长女性；慈孝：慈指对父母的孝敬奉养。孝是古代的道德规范，儒家指对父母等长辈的尊敬奉养。这两句是说对长辈和老人，要孝敬赡养。</p>
<p>尊朋礼友，仁义君郎。</p>
<p>尊：尊重；礼：本为敬神，引申为表示敬意；朋友：《周礼》郑玄注：“同师曰朋，同志曰友。”泛指相交好的人；仁：人与人相互亲爱，古代儒家一种含义广泛的道德范畴，包括恭、宽、信、敏、惠、智、勇、忠、恕、孝、弟等内容；义：情义、恩义。这两句意为朋友之间，互相尊重有礼貌，重情谊，做仁义之人。</p>
<h2 id="大-道"><a href="#大-道" class="headerlink" title="大 道"></a><strong>大 道</strong></h2><p>形分上下，道合阴阳。</p>
<p>形：形体。中国古代哲学上把看不见，摸不着的客观存在称为形而上，如精神、思想等，研究此类的学问为形而上学。有形的东西为形而下，研究此类的学问为形而下学；道：法则、规律，韩非《解老》：“道者，万物之所然也，万理之所稽也。”把道解为万物产生、变化的总规律。也指宇宙万物的本原、本体；合：符合；阴阳：本指日光的向背，向日为阳，背日为阴。这里指古代哲学的一对范畴，古人看到一切事物都具有正反两方面，就用阴阳这个概念来解释自然界中两种对立和相互消长的气或物质势力，如天地，日月，山河，雌雄等等。孔子曰：“一阴一阳为之道”，就是把阴阳交替看作宇宙的根本规律，并用阴阳来比附社会现象，引申为上下、君民、君臣、夫妻等关系。</p>
<p>幽冥杳渺，天体著彰。</p>
<p>幽：深远、昏暗、隐秘；冥：昏暗、幽深；杳：幽暗、深远，见不到踪影；渺：水远貌。幽冥杳渺就是形容深远昏暗；天体：太阳、地球、月亮和其它恒星、行星、卫星以及彗星、流星、宇宙尘、星云、星团等的统称；著彰：明显，看的清楚。这二句是说物质可以无穷无尽的微分下去，小到什么都看不见，达到一种“无”的状态。 也可以累积起来形成巨大的天体显明彰著。</p>
<p>凝气为精，聚能以场。</p>
<p>气与精为中国古代哲学的概念，指构成万物的物质。《易经·系辞》：“精气为物。”就是说天地阴阳的精灵之气，凝合积聚成万物；能：物理学名词，即能量。场：平坦的空地，这里指物理场，即相互作用场，物质存在的一种基本形态，具有能量、动量和质量，能传达实物间的相互作用，存在于整个空间。这二句说阴阳二气交合形成万物的精华，弥漫于宇宙中的各种能量形成不同的物理场。</p>
<p>缩浓而质，积微显量。</p>
<p>浓：厚、密。质：性质、本质。缩浓而质指人的视野中无形或未成形的物质，浓缩才显出它的性质；微：细、小。量：质和量均为哲学名词，一起构成事物的规定性。质是指事物区别于它事物的一种内部规定性，由事物内部的特殊矛盾规定，事物的不同就是事物之间质的差别的表现。量是质的等级、规模和结构的表现，可用数量表示，如多少、大小、高低、长短、轻重、快慢等。事物的质以一定量为自己存在的条件。积微显量即积少成多。</p>
<p>化巨幻虚，恍惚成象。</p>
<p>化：变化、融解。幻虚：模模糊糊，虚而不实，似有似无。化巨幻虚是说很大的东西可以化解，消融为微小至模糊看不见的东西；恍惚：模糊不清。象：形状有影有形。恍惚成象意为模糊无形的东西可聚成有形象的实物，《道德经·上篇》：“道之为物，惟恍惟惚，惚兮恍兮，其中有象；恍兮惚兮，其中有物。”</p>
<p>强固凌弱，柔亦制刚。</p>
<p>强：健壮、有力，与“弱”相对。固：必然。凌：侵犯，欺凌。强固凌弱即强大的必然欺负弱小的；柔：柔弱，与“刚”相对。亦：也。制：制服。柔亦制刚即柔软的也能制服刚硬的。</p>
<p>终极必反，存兴趋亡。</p>
<p>终极：穷尽，最后。终极必反即物极必反，为中国古代哲学概念，认为事物发展到极限时，就会向相反的方向转化。《鶡冠子·环流》：“物极则反，命曰环流”；兴：兴盛。亡：衰败、灭亡。存兴趋亡意为兴盛到顶点就开始走向败亡。</p>
<p>唯实众名，一理万方。</p>
<p>实：实际。名：名称。实与名为中国古代哲学的一对范畴。唯实众名意即一个实际内容有众多名称；一理万方就是万物一理，世上很多事物都包含着同一道理。 以上讲宇宙天地间的大道理，说世上的事物都是发展变化的，对立的一对事物互相联系，互相影响，互相作用，又互相转化，最后以“一理万方”作结。反映了作者的普遍联系和运动变化的唯物辩证世界观。</p>
<h2 id="历-史"><a href="#历-史" class="headerlink" title="历 史"></a><strong>历 史</strong></h2><p>炎黄二帝，尧舜禅让。</p>
<p>炎黄二帝：炎帝和黄帝，传说中国上古时期的帝王。《国语·晋语》：“昔少典娶于有蟜氏，生黄帝，炎帝”。 炎黄都是在中原发展起来的部族，炎帝为姜姓部族的首领，号烈山氏，一作厉山氏。原居姜水流域，后向东发展到沿海，向南发展到湖南、浙江以远。农业比较发达，称为神农氏。黄帝为有熊氏部族的首领，姬姓，号轩辕氏。他联合其他部族共同发展，在阪泉（今河北涿鹿东南）打败扰乱各部落的炎帝，又率领各部落在涿鹿（今河北涿鹿东南）击杀与之为敌的蚩尤，被部落首领拥戴为部落联盟首领，号称轩辕黄帝。传说黄帝带领各部族人民进行了很多发明创造，如养蚕抽丝、纺线织布、舟车、文字、音律、医学、算数、指南车、天文等，人们以炎黄代表中华民族的祖先，华人皆自称“炎黄子孙”；尧舜：即唐尧和虞舜，远古部落联盟的首长，相传为圣明之君。禅让：将帝位让授于贤者。据说在尧舜之时，帝位的传续不是父子相承，而是帝王在年老时挑选贤能之人，把帝位让给他。尧将帝位禅让于舜，舜将帝位禅让于禹。</p>
<p>禹启世袭，灭桀商汤。</p>
<p>禹：远古夏后氏部落领袖，又称夏禹，大禹。姒姓，鲧的儿子。古史相传禹继承其父的治水事业，曾三过家门而不入。他采用疏导的办法，经过 13 年的治理，终于除了水患。舜死后，禹继任部落联盟领袖，在安邑（今山西运城县境内）建都，后来东巡狩猎，死在会稽；启：也称夏启，禹的儿子。禹死后，启继王位，从此改禅让为世袭，中国由此开始了王位世袭的几千年历史，所以说“禹启世袭”。夏启建立夏朝，先后都阳城（今河南登封市东）、斟鄩（今河南登封市西北）、安邑（今山西夏县西北）等地，是中国历史上第一个朝代。共传 13 代、16 王，约在公元前 21 世纪到前 16 世纪左右；桀：相传为夏代的最后一个君王，故又称夏桀。夏桀暴虐荒淫，民怨沸腾，成汤起兵讨伐，桀兵败被俘，死于南巢（古地名，今安徽省巢湖市西南）。商汤：远古时商部落的首领，始祖名契，子姓，居于商（今河南商丘市南），其势力达到今勃海一带。从契传到汤，共 14 代。公元前 16 世纪，汤伐桀灭夏，建立商朝，建都于亳（今河南商丘一带），故又称商汤。灭桀商汤即商汤消灭了夏桀。商汤后世曾多次迁都，后盘庚迁都殷（今河南省安阳市小屯村），因而商也被称为殷。农业、手工业比较发达，是当时世界上的文明大国。传至纣，共传 17 代、31 王，约在公元前 16 世纪到前 11 世纪。</p>
<p>周武伐纣，侯列各邦。</p>
<p>周武：即周武王姬发，周文王姬昌的儿子。周是上古时的一个部落，姬姓，始祖后稷，原居邰（今陕西武功），传至四代公刘，迁都于豳（今陕西彬县东北），传至十二代古公亶父，为戎、狄族所逼，迁都周原（今陕西岐山北），发展农业，部族日臻强盛。周文王时，建立丰邑（今陕西长安沣河以西）作为国都。周文王死后，传位于长子姬发，是为周武王。公元前 11 世纪，周武王联合庸、蜀、羌、髳、微、卢、彭、濮等族起兵伐纣，牧野（今河南淇县西南）之战取得大胜，灭商朝，建立周王朝，都镐京（今陕西省长安沣河以东）。周朝确立了宗法制，创立典章制度，并不断分封诸侯。农业比商代发达，农产品种类增多，手工业也有发展。公元前 771 年，申侯联合犬戎攻杀周幽王。次年，周平王东迁到洛邑（今河南洛阳）。历史上称平王东迁以前为西周，以后为东周。东周又分春秋和战国两个时期。公元前 256 年为秦所灭，共历 34 王，800 多年；纣：即纣王，商代最后一个君王，帝乙之子，名受，号帝辛。暴敛重刑，大失民心。周武王起兵征伐，商军队倒戈，纣王兵败自焚，商王朝灭亡。故为 “周武伐纣”；侯，即诸侯，商代开始分封诸侯，有侯、伯等称号。武王建周后，大规模以封地连同居民分赏王室子弟和功臣，分公、侯、伯、子、男五等。诸侯在封国内有世袭的统治权，对天子有服从命令、定期朝贡和提供军赋、力役等责任。邦，国土。侯列各邦：意为诸侯都分别统治着自己的封地国土。</p>
<p>秦皇集权，汉刘楚项。</p>
<p>秦皇：即秦始皇嬴政，秦庄襄王之子。秦是古时一个部落，嬴姓，传为伯益的后代。非子为部落首领时，居于犬丘（今陕西兴平东南），被周孝王封于秦（今甘肃张家川东），作为附庸。传到秦仲，周宣王命为大夫。后秦仲之孙秦襄公以护送周平王东迁有功，被分封为诸侯。春秋时建都于雍（今陕西凤翔南）。秦孝公时，任用商鞅变法，国力富强，并迁都咸阳（今陕西咸阳东北），成为战国七雄之一。嬴政于公元前 246 年继秦王位，时年 13 岁。公元前 221 年，灭诸侯六国，建立中央集权的秦王朝，称皇帝，自为始皇帝，都咸阳。收天下兵器，聚之咸阳。统一法度，车同轨、书同文，筑长城、治驰道，焚书坑儒。公元前 210 年，东巡死于沙丘。由于秦王朝赋役繁重，刑政苛暴，激化了各种社会矛盾，公元前 209 年（秦二世元年）爆发了以陈胜、吴广为首的农民大起义，公元前 206 年为刘邦（汉高祖）所灭。共历 2 世，统治 15 年；集权：秦始皇统一中国后，废除封建分封制，结束了诸侯割据称雄威胁天子的混战局面，建立中央集权制度。一切权力收回中央，政事不论大小，全由皇帝一人裁决。实行郡县制，分全天下为 36 郡（后增至 40 郡），郡下设县若干，郡守县令由朝廷任命，随时听从中央调遣；汉刘：指汉高祖刘邦和西楚霸王项羽。刘邦，字季，秦末沛县人。秦二世元年（公元前 209 年），陈胜、吴广在蕲县大泽乡（今安徽宿县东南）发动起义，刘邦也于沛地起兵，号为沛公。与项羽分兵入关破秦，先攻入秦都咸阳。项羽自据关中，封刘邦汉王，刘邦先平定三秦，然后与项羽争夺天下。双方在荥阳成皋间争战相持五年，终于击败项羽，公元前 202 年在汜水即帝位，立国号为汉，建都长安，历史上称为西汉或前汉。疆域东、南至海，西到巴尔喀什湖、费尔干纳盆地、葱岭，西南至云南、广西以及越南北、中部，北到大漠，东北迤至朝鲜半岛北部。汉武帝时成为亚洲最富强繁荣的多民族国家。公元 8 年，外戚王莽代汉称帝，国号新。公元 17 年，爆发赤眉、绿林农民大起义。公元 25 年，远支皇族刘秀（汉光武帝）重建汉朝，建都洛阳，历史上称为东汉或后汉。中平元年（184 年）爆发了黄巾农民起义，东汉王朝名存实亡，延康元年（220 年）曹丕称帝，东汉灭亡。汉代共历 26 帝，统治 406 年；楚项：项羽，也是秦末农民起义军领袖，名籍，字羽，下相（今江苏宿迁西南）人，楚国贵州出身。从叔父项梁在吴（今江苏苏州）起义，在巨鹿之战中摧毁秦军主力。秦之后，自立为西楚霸王。在楚汉战争中，被刘邦击败，最后从垓下（今安徽灵璧南）突围到乌江（今安徽和县东北），自刎而死。</p>
<p>鼎立割据，乱晋八王。</p>
<p>鼎立割据是说东汉后出现的魏、蜀、吴三国时代。鼎立：三方并峙如鼎足分立；割据：一国之内，拥有武力的人占据部分地区，形成分裂对抗的局面。这里指魏、蜀、吴三方割据鼎立的局面。三国从公元 220 年曹丕代汉称帝起，至 280 年吴国灭亡止，共历时 61 年。一般也将赤壁之战后魏、蜀、吴建国前的历史划入三国时期；乱晋八王：即八王乱晋，西晋末年皇族争夺政权的斗争。公元 265 年司马炎（晋武帝）代魏称帝，国号为晋，建都洛阳，史称西晋。太康元年（280 年）灭吴，统一全国，疆域东、南到海，西到葱岭，西南到云南、广西以及越南北、中部，北抵燕山，东北至朝鲜半岛西北部。司马炎称帝后，一是大封皇子和宗室为诸侯国王，国王有大臣有军队有百姓，在受封国内拥有全部权力，是实在的统治者。二是重用外戚 ，使一些外戚掌握了实际的权力。他还收买一部分高级士族，组成司马氏集团，助他夺取曹魏政权，以至形成了西晋高级士族的贪暴统治层。这些都种下了后来争战混乱的祸根。公元 290 年，晋武帝去世，其妻杨皇后和父亲杨骏争夺政权，大乱即从宫廷内开始。公元 291 年，晋惠帝妻贾皇后杀杨骏夺得政权。贾皇后使用汝南王司马亮辅政，又使楚王司马玮杀司马亮，贾皇后又杀司马玮。大乱从宫廷伸展到宗室诸王间，这就是历史上的八王之乱。八王分别为：楚王司马玮，赵王司马伦，齐王司马同，汝南王司马亮，成都王司马颖，河间王司马禺，长沙王司马乂，东海王司马越。八王之乱导致了西晋的灭亡。公元 316 年，被匈奴贵族建立的汉朝所灭。317 年，司马睿（晋元帝）在南方重建晋朝，都建康（今江苏南京），史称东晋。420 年，刘裕代晋，东晋灭亡。两晋共历 15 帝，156 年。</p>
<p>南北对峙，腐朽隋炀。</p>
<p>南北对峙：南北指南北朝，从公元 420 年东晋灭亡到 589 年隋统一中国的 170 年间，历史上形成南北对峙的局面，称为南北朝。南朝从 420 年刘裕代晋，经历宋、齐、梁、陈四代，到 589 年陈亡。北朝从 439 年北魏统一北方开始，534 年分裂为东魏、西魏 ，后来北齐伐东魏，北周伐西魏，北周又灭北齐，581 年北周被隋所代。589 年，隋灭陈和后梁，结束了南北对峙的局面；腐朽隋炀：隋炀即隋炀帝杨广，隋朝第二代皇帝，生于公元 569 年，604 年杀其父隋文帝杨坚而继帝位，至 618 年共在位 15 年。581 年杨坚（隋文帝）代北周称帝，国号隋，都大兴（今陕西西安）。589 年灭陈统一全国，疆域东、南到海，西到新疆东部，西南至云南、广西和越南北部，北到大漠，东北迤至辽河。隋炀帝登基后，大兴土木，严重破坏了生产，又横征暴敛，兵役繁重，给人民造成了沉重的负担。其生活极其荒淫奢侈，腐烂颓靡，故曰“腐朽隋炀”。公元 618 年隋朝在农民大起义下瓦解灭亡，共历 2 帝，38 年。</p>
<p>贞观政要，五代续唐。</p>
<p>贞观政要：贞观是唐太宗年号，从公元 627 年至 649 年，共 23 年。贞观政要为书名，唐代人吴兢撰写，10 卷 40 篇，分类编辑唐太宗与魏徵、房玄龄、杜如晦等大臣的问答，大臣的争议和所上劝谏的奏疏，以及政治上的设施；五代续唐：公元 618 年，李渊在关中称帝，国号唐，建都长安。唐前期国势强盛，疆域初年南部同隋，北部在 7 世纪后半叶极盛时北界包有今贝加尔湖和叶尼塞河上游，西北曾到达里海，东北曾到达日本海。其后时有变动，至安史乱后丧失过半。唐末政治腐败，赋役繁重，加上藩镇割据，战乱不息，最终爆发了农民大起义，公元 907 年被朱温所灭。共历 20 帝，290 年。唐以后，又先后出现了五代朝廷。907 年，朱温灭唐称帝，国号为梁，史称后梁。至 960 年，交替出现了后唐、后晋、后汉、后周几代朝廷。称为五代，所以说五代续唐。后梁、后唐、后晋、后汉、后周五代共 13 帝，54 年。</p>
<p>陈桥兵变，耻辱靖康。</p>
<p>陈桥兵变：即后周大将赵匡胤（宋太祖）夺取后周政权的政变。公元 959 年，后周皇帝周世宗柴荣死后，他 7 岁的儿子柴宗训继位，是为周恭帝。赵匡胤当时是后周禁军的最高将领，久已谋夺后周政权。960 年初，边境传来急报，说契丹和北汉要联兵攻打后周。赵匡胤趁机率军出征，与其弟赵匡义，亲信赵普、张守信等策划兵变。大军来到陈桥驿（今河南开封东北陈桥镇）时，赵匡胤佯装醉酒。第二天早上，众多将士拥入他的帐中，把一件皇袍披在他身上，向他跪拜，高呼“万岁”，这便是“皇袍加身”故事的来历。赵匡胤当了皇帝，立国号宋，从此开始了北宋 168 年的历史；耻辱靖康，即靖康耻辱。靖康为北宋第九代皇帝宋钦宗赵桓的年号。北宋末年，政治黑暗，宋徽宗（宋钦宗之父）宠信奸臣蔡京，宦官童贯等人，大肆搜刮民财，穷奢极欲。北方的金朝看到北宋的虚弱，挥师南下，进攻北宋。于靖康元年冬（公元 1126 年）攻破东京（今河南开封）。次年四月，金朝贵族于大肆搜刮后，俘徽宗、钦宗和宗室、后妃等数千人，以及乐工，工匠，携大量珍宝玩物、皇家藏书、州府地图等北去，北宋灭亡。</p>
<p>耶律完颜，元建宋僵。</p>
<p>耶律：复姓。初为契丹部落名，辽建立后为国族姓。这里指耶律族建立的朝代——辽。公元 916 年，契丹族领袖耶律阿保机建立王朝，国号契丹，947 年改国号为辽。疆城为东北到今日本海黑龙江口，西北到蒙古人民共和国中部，南以今天津市海河、河北霸县、山西雁门关一线与北宋接界，是统治中国北部的一个王朝，1125 年为金所灭；完颜：复姓，女真族。完颜姓始祖函普定居于完颜部族，后娶其部人之女为妻，成为完颜部人，遂以完颜为姓。此指完颜族人建立的朝代——金。1115 年，女真族完颜部领袖完颜阿骨打建立金王朝，疆域为东北到今日本海、鄂霍次克海、外兴安岭，西北到蒙古人民共和国，西以河套、陕西横山、甘肃东部与西夏接界，南以秦岭、淮河与南宋接界，是继辽之后统治中国北部的一个王朝，1234 年在蒙古和宋联合进攻下灭亡；元：朝代名。1206 年（宋宁宗开禧二年）蒙古族领袖孛儿只斤铁木真（成吉思汗）建立蒙古汗国，其后不断向黄河流域扩张，至第六代蒙古汗王孛儿只斤蒙哥时，陆续击败西辽、西夏、金、大理，并在吐蕃建立行政机构，进行统治。1271 年，第七代蒙古汗王、元世祖孛儿只斤忽必烈定国号为元。1279 年灭亡南宋，统一全国，建都大都（今北京）。疆域东、南到海，西到今新疆，西南包括西藏、云南，北面包括西伯利亚大部，东北到鄂霍次克海。1368 年朱元璋军攻入大都，推翻元朝的统治，自元世祖忽必烈定国号至此，共历 11 帝，98 年；宋：指南宋。1126 年，金兵攻入汴梁（今开封），北宋灭亡。第二年，宋高宗赵构在南京（今河南商丘）称帝，后建都临安（今浙江杭州），史称南京。南宋北以淮河、秦岭与金接界。1279 年为元所灭，两宋共历 16 帝，320 年。元建宋僵即元朝建立宋朝灭亡。</p>
<p>朱轮太祖，崇祯吊丧。</p>
<p>朱轮太祖：指明太祖朱元璋，明代的建立者，1328 年~1398 年在世，幼名重八，又名兴宗，字国瑞，濠州钟离（今安徽风阳东）人。幼时家贫，曾入皇觉寺为僧。元末爆发农民起义，1352 年朱元璋率众投红巾军，属郭子兴部。郭子兴死后代领其众，遥奉小明王韩林儿为首领。1356 年攻占集庆（今江苏南京），称吴国公。接受朱升的“高筑墙，广积粮，缓称王”的建议，实行屯田壮大军力，先后击败陈友琼、张士诚，改称吴王。1368 年，建立明王朝，都南京，年号洪武。同年攻克大都（今北京），推翻元朝统治，逐步统一全国。明太祖建国后，实行一系列改革措施：普查户口，丈量土地，均平赋役，兴修水利，推行屯田。抑制豪强贪吏，制订《大明律》，废除宰相职位，巩固中央集权，为社会经济文化的发展提供了有利条件。1421 年明成祖迁都北京。疆域东北抵日本海、鄂霍次克海、乌地河流域，西界在河套西喇木伦河一线，西北到新疆哈密，西南包有今西藏、云南，东南到海及海外诸岛。轮，轮换、接替；崇祯吊丧：指明末农民起义军攻入北京，崇祯皇帝上吊而死，明朝灭亡一事。明思宗朱由检 1628 年继帝位，年号崇祯，故世人又称其为“崇祯皇帝”。1644 年，李自成率起义军攻克北京，明思宗在煤山（今北京景山）自缢，明遂亡。明朝共历 16 帝，277 年。</p>
<p>清军入关，大臣住藏。</p>
<p>清军入关：指清王朝军队进入中原，统治全国。1616 年，东北女真贵族爱新觉罗努尔哈赤建立后金政权。1627 年，其子爱新觉罗皇太极继皇帝位，1636 年改国号为清，年号崇德。1644 年清世祖爱新觉罗福临继帝位，年号顺治。同年进军中原，定都北京，统一了全国。至 1911 年辛亥革命推翻清王朝封建帝制，清朝共历 11 帝，276 年；关；即山海关，又称榆关或渝关。在河北秦皇岛市，长城起点，明初置关戍守。北依角山，南临渤海，联接华北与东北地区。形势险要，自古为交通要冲，有“天下第一关”之称；大臣住藏：清朝时中央政府在西藏设置了驻藏大臣，并订立各种政治制度和宗教制度，管理西藏地方事务。</p>
<p>粉碎叛卓，犁域设将。</p>
<p>卓：即和卓或和卓木，意为伊斯兰教始祖的后裔，旧时信仰伊斯兰教的维吾尔族封建主自称“和卓”，居住在新疆天山南路的伊斯兰教白山派清朝称为回部；粉碎叛卓：指 18 世纪中期，回族贵族大小和卓兄弟布那敦、霍集占发动叛乱，清朝乾隆皇帝派兵平叛。1758 年，大小和卓兵败被杀，平叛取得胜利；犁域设将：犁域指伊犁地区。乾隆二十七年（1762 年），清朝在新疆设置“总统伊犁等处将军”，简称“伊犁将军”。驻惠远域，管辖包括巴尔喀什湖在内的整个新疆地区。</p>
<p>台湾复归，守卫边防。</p>
<p>这两句是说郑成功收复台湾，清王朝在台湾设府的一段历史。1624 年，荷兰殖民者侵占我国台湾南部地区，修筑了热兰遮和赤嵌楼两个要塞，后来他们陆续侵占了台湾全省。1661 年民族英雄郑成功决心收复台湾。他亲率战舰 350 多艘，将士 25000 多人，从金门出发，经彭湖，横渡台湾海峡，于台湾禾寮港（在今台南境）登陆，在台湾人民的欢迎、支持下，经过八个月的激烈战斗，终于打败了盘踞台湾三十八年的荷兰殖民者。1662 年 2 月，荷兰殖民者投降，台湾回到了祖国怀抱。 郑成功，明清之际的著名将领，生于 1624 年，南安（今属福建）人。本名森，字大木，曾被南明隆武皇帝赐姓朱，名成功，字明俨，称为“国姓爷”。1646 年，清军攻进福建，他率部分将士到金门，誓师复明抗清。1662 年率军将荷兰侵略军赶出台湾，歼敌 1600 多人。收复台湾五个月后病逝，年仅 39 岁。长子郑经继承父亲遗志，带领将士和民众肃清荷兰殖民主义残余势力，对台湾进行开发建设，发展农业、工业、贸易和教育，促进了台湾经济的繁荣。1683 年，郑成功之孙郑爽看恢复明朝已不可能，便归顺了清廷，清军驻进台湾。次年，清政府设置台湾府，隶属福建省。台湾府的设置，加强了台湾同祖国内地的联系，促进了台湾的开发，巩固了祖国的边防。</p>
<p>鸦片战争，英占香港。</p>
<p>鸦片战争：1840~1842 年英国对中国发动的侵略战争。18 世纪末，英国对中国实行侵略政策，大量输入毒品鸦片。1838 年（道光十八年）达到四万余箱，引起中国白银外流，财政国难。1838 年底，道光皇帝派林则徐为钦差大臣赴广东查禁鸦片。林则徐在广州严厉禁烟。于 1839 年 6 月 3 日至 25 日，在广州虎门海滩当众销毁鸦片 230 余万斤，并多次打退英军的挑衅。1840 年，英国在美国、法国支持下发动侵华战争。由于清廷腐败和武器落后，虽中国军队和民众英勇抗英御敌，仍失陷一些城市。1842 年 8 月，清王朝派人与英国在南京议和，签订了丧权辱国的《南京条约》，从此，中国逐步沦为半封建半殖民地社会；英占香港：按照《南京条约》的“割让香港”条款，英国占领了中国香港。到 1997 年 7 月 1 日香港回归祖国，英人侵占香港达 150 余年。</p>
<p>戊戌维新，社会改良。</p>
<p>戊戌维新也称作戊戌变法，即 1898 年（农历戊戌年）资产阶级改良主义的政治运动。1895 年（光绪 21 年）清政府被日本战败后，民族危机十分严重。代表资产阶级和开明士绅政治要求的康有为、梁启超等人，在北京发动各省应试举人 1300 余人上书光绪皇帝，反对签定日本强加给的《马关条约》，以“变法图强”为号召，组织“强学会” ，掀起维新变法运动。1897 年冬，德国强占胶州湾，帝国主义阴谋瓜分中国的步伐加快，康有为又赶到北京上书，请求变法。1898 年 4 月康有为等以保国、保种、保教为宗旨，在北京倡设“保国会”。光绪皇帝接受变法主张，引用维新人士，从 6 月到 9 月陆续颁发维新法令，推行新政（故又称“百日维新”）。但以慈禧太后为首的守旧派操纵军政实权，坚决反对变法维新，9 月 21 日发动政变，光绪帝被幽禁，谭嗣同等 6 人被杀害，康有为、梁启超逃亡日本，变法运动失败，改良社会的设想破灭。</p>
<p>辛亥革命，孙文思想。</p>
<p>辛亥革命：即 1911 年（宣统三年，农历辛亥年）10 月 10 日爆发的中国资产阶级民主主义革命。1905 年，孙中山组织建立中国第一个资产阶级革命团体——中国同盟会，以“驱除鞑虏、恢复中华、建立民国、平均地权”为纲领，同资产阶级改良派作斗争。在各省和海外建立革命组织，多次发动武装起义，为辛亥革命做准备。1911 年，清政府出卖铁路修筑权，激起全国人民的反对。10 月 10 日爆发武昌起义，各省纷纷响应，两个月内即有鄂、湘、陕、赣、晋、滇、黔、苏、浙、桂、皖、粤、闽、川等先后宣布独立，清政府迅速解体。12 月，孙中山经 17 省代表会议推举为临时大总统。1912 年 1 月 1 日在南京成立中华民国临时政府，2 月 12 日，清朝皇帝被迫宣告退位，结束了清朝政府的统治。随后颁布了《中华民国临时约法》。这次革命是经过资产阶级和农民、工人及城市小资产阶级的同盟而取得了确定性的胜利。但由于没有广大的民众基础，在帝国主义和封建势力的压力下，4 月，孙中山被迫解职，代表地主买办阶级利益的袁士凯窃据了政权，革命遂告失败。辛亥革命推翻了清政府，结束了中国两千年封建君主专制，使民主共和国的观念深入人心。 孙文：即孙中山，生于 1866 年，卒于 1925 年，名文，字逸仙，广东香山（今中山）人，中国伟大的革命先行者。1894 年，上书李鸿章，提出革新政治主张，被拒绝。遂赴檀香山组织兴中会，提出“振兴中华”的口号和“驱除鞑虏，恢复中国，创立合众政府”的政纲。1905 年组织中国同盟会，被推为总理，确定了“驱除鞑虏、恢复中华、建立民国、平均他权”的资产阶级革命政纲，提出“民主、民权、民生”三民主义学说。1911 年 10 月，领导辛亥革命；1912 年 1 月 1 日在南京建立中华民国临时政府，宣布就任临时大总统职；2 月 13 日，因革命党人与袁世凯妥协，被迫提请辞职。8 月，同盟会改组为国民党，被选为理事长；1914 年建立中华革命党，重举资产阶级革命旗帜。1918 年，将中华革命党改组为中国国民党；1921 年就任非常大总统；1924 年 1 月在广州召开中国国民党第一次全国代表大会，通过宣言，实行联俄、联共、扶助农工的三大政策，把旧三民主义重新解释，发展为新三民主义；改组中国国民党成为工人、农民、小资产阶级和民族资产阶级的革命联盟。11 月，应邀北上讨论国是，提出“召开国民会议和废除不平等条约”两大号召。1925 年 3 月 12 日在北京逝世，遗嘱“必须唤起民众，及联合世界上以平等待我之民族，共同奋斗”。在哲学上，提出“知难行易”说，批判“知之非艰，行之惟艰”的保守思想。遗嘱编有《孙中山选集》、《孙中山全集》。</p>
<p>联盟抗倭，国共两党。</p>
<p>联盟：国家、阶级、政党或团体之间结成的联合关系；倭：即日本，古称日本为倭；国共两党：指中国国民党和中国共产党。这二句说的是国共两党第二次合作，联合抗日。1931 年 9 月 18 日，日本关东军发动“九·一八”事变，侵占了东三省。蒋介石命令东北军“绝对不得抵抗”，并将以张学良为首的东北军调至陕甘一带和以杨虎城为首的西北军一起，进攻中国工农红军。在外敌当前的形势下，张杨二人与红军实现停战，要求蒋介石联共抗日，遭到蒋介石的无理拒绝。1936 年 12 月，蒋介石到西安督战，12 日，张杨发动西安事变，在临潼华清池扣留蒋介石，实行兵谏。并通电全国，提出停止内战，联共抗日等 8 项主张。在中共代表周恩来等人的调停下，蒋被迫接受了张杨的条件。西安事变得以和平解决后，从 1937 年 2 月至 7 月，中国共产党多次派周恩来等人同国民党就两党合作抗日的问题举行谈判。7 月 7 日，日本侵略军炮轰卢沟桥，发动全面侵华战争，第二天，共产党通电全国，号召全民族抗战，再次提出国共两党合作问题。之后，又将国共合作宣言送交国民党，表示愿意在团结抗日、实行民主政治的前提下，取消苏维埃政府，改编红军。根据两党协议，西北红军主力改编为国民革命军第八路军，简称“八路军”。南方八省红军游击队改编为国民革命军新编第四军，简称“新四军”。9 月 22 日，国民党公布了国共合作宣言。23 日，蒋介石发表承认共产党合法地位的谈话。自此，国共两党实现第二次合作。在抗日民族统一战线的旗帜下，开始了全民族的抗战。 定都京师，人民解放。 京师：首都的旧称，这里指北京。这两句说 1949 年 10 月 1 日，中华人民共和国成立，定首都为北京。从此劳动人民翻身解放，做了国家主人。第五课的内容写了中国上下五千年，二十六个朝代更迭的历史。</p>
<h2 id="政-治"><a href="#政-治" class="headerlink" title="政 治"></a><strong>政 治</strong></h2><p>中华初繁，睡狮渐醒。</p>
<p>中华：指中华人民共和国；繁：繁荣；睡狮：20 世纪 20 年代前后西方人把当时贫穷、懦弱、麻木的中国比为睡狮。 这两句是说从中华人民共和国从 1949 年成立到 20 世纪结束，经过 50 年的艰苦奋斗、全面建设，取得了令世人瞩目的成就。1976 年中国共产党结束了给人民带来巨大灾难的“文化大革命”，1979 年召开了十一届三中全会，决定国家把工作重心转移到经济建设上来，经过二十多年的努力，解决了 13 亿人温饱问题，在世界经济连年低迷的情况下，一枝独秀，连续多年以 7-9% 的速度向小康社会迈进，世界制造业逐渐向中国转移，香港和澳门顺利回归，中国加入世界贸易组织，北京取得 2008 年奥运会的举办权，上海取得世界博览会的举办权等一系列事件表明：中国已经走上了初步繁荣昌盛的道路，这只“睡狮”也已逐渐苏醒，就要屹立在世界的东方。</p>
<p>玖久纪末，千年始零。</p>
<p>玖久：玖指 1999 年；久指 20 世纪；纪末：世纪之末；千年：指 2000 年。这两句说 1999 年是 20 世纪的末尾，也表明上个千年的结束。新千年的计数从零开始，也标志着中国的经济建设进入一个崭新的快速发展时期。 宏业盛昌，妙策禀迎。左右兼顾，总揽统领。 宏业：指中国实现现代化建设的设宏伟大业；盛昌：即昌盛。是兴隆、繁荣、丰茂意；妙策：好的政策；禀迎：承受、接受、迎接。这两句说中国自 80 代以来，在一系列正确路线、方针、政策指导下，现代化建设的大业逐步兴旺发达、繁荣昌盛。 兼：同时进行几件事情或占有几样东西；顾：看、望；揽：把持、管领、统属。这两句说把握全局，兼顾各个方面、各个层次，制定国家各个时期的路线、方针、政策，领导全国人民构建和谐社会。</p>
<p>内取稳进，外交志同。阶梯过度，切忌狠猛。</p>
<p>志同：看法、认识相同。阶：台阶。阶梯，渐进的阶级。这四句是说国家进入初步繁荣的阶段，对内要采取稳妥渐进的方针，使政治经济的发展平稳有序，千万不可头脑发热，盲目冒进，使来之不易的形势毁于一旦。对外要多交志趣相同的朋友，实行独立自主的和平外交政策，主张国家无论大小、贫富、强弱，一律平等。反对霸权主义和大欺小、强凌弱。1953 年提出国家之间交往的“和平共处五项原则”，即：互相尊重主权和领土完整，互不侵犯，互不干涉内政，平等互利，和平共处。和平共处五项原则很快被世界大多数国家承认和认同，成为国与国之间交往所遵循的基本原则。在这个基础上， 中国同世界上绝大多数国家建立了外交关系，同各国人民发展友好往来。</p>
<p>六贼七害，监视审听。</p>
<p>六贼七害：指六种坏事和七种坏人。原文出自《六韬·文韬》上贤第九。太公曰：“夫六贼者：一曰臣有大作宫室池榭，游观倡乐者，伤王之德；二曰民有不事农桑，任气游侠，犯历法禁，不从吏教者，伤王之化；三曰臣有结明党，蔽贤智，障主明者，伤王之权；四曰士的抗志高节，以为气势，外交诸候，不重其主者，伤王之威；五曰臣有轻爵者，贱有司，羞为上犯难者，伤功臣之劳；六曰强宗侵夺，陵侮贫弱者，伤庶人之业。 七害者：一曰无智略权谋，而以重赏尊爵之故，强勇轻战，侥幸于外，王者慎勿使为将；二曰有名无实，出入异言，掩善扬恶，进退为巧，王者慎无与谋；三曰朴其身躬，恶其衣服，语无为以求名，言无欲以求利，此伪人也，王者慎勿近；四曰奇其冠带，伟其衣服，博闻辨词，虚论高议，以为容美，穷居静处，而诽时欲，此奸人也，王者慎勿宠；五曰谗佞苟得，以求官爵，果敢轻死，以贪禄秩，不图大事，贪利而动，以高谈虚论，说于人主，王者慎勿使；六曰为雕文刻镂，技巧华饰，而伤农事，王者必禁之；七曰伪方异技，巫蛊左道，不祥之言，幻惑良民，王者必止之。” 这里以六贼七害指臣属中奸伪、贪佞和弄权误国之流；监视：监察注视；审听：详究、考察听到的、看到的东西。这二句是说在国家治理中，要用好人，用对人，时刻警惕像六贼七害这样的人和事误国。</p>
<p>戒贪须效，践约宜恒。</p>
<p>戒贪：节制、禁止各种过分的欲望、爱好；效：效果、功用；践约：履行预先约定的事；宜恒：应当长久，持之以恒。这两句说从政为官应当节制自己的不良欲望，不贪不占，清正廉洁，有信守恒。 贬恶褒绩，赏劝罚惩。 贬：不好的评价，褒：嘉奖、称赞。贬与褒相对；恶：坏、坏事，与“好”、“善”相对；绩：功业、成绩； 赏：赏赐、奖赏；劝：提倡、勉励；罚惩：即惩罚，处分、鞭挞犯罪或犯规的人。 “赏劝罚惩”出自《六韬·文韬》赏罚第十一。“文王问太公曰：‘赏所以存劝，罚所以示惩。吾欲赏一以劝百，罚一以惩众，为之奈何？’”。本句的意思是说：奖赏是为了激励人，劝人向善；惩罚是为了警戒人，惩治罪恶。</p>
<p>操刃执斧，塞涓救荧。</p>
<p>刃：即刀。涓：细小的流水，荧：火星。 该句出自《六韬·文韬》守土第七。太公曰：“操刀不割，失利之期；执斧不伐，贼人将来。涓涓不塞，将为江河；荧荧不救，炎炎奈何；”意思是持刀不宰割，也就失去了有利的时机；手持斧钺不征伐，敌人就会抢先而至。涓涓细流不堵塞，就会变成江河；荧荧火星不扑灭，就会燃成熊熊烈火。 这里引伸为高度重视出现的小问题，以防范于未然。</p>
<p>势如突起，抽薪熄平。</p>
<p>势：形势；突起：突然而起；薪：柴。要使燃起的大火熄灭，需抽掉下面的木柴，要彻底解决问题，必须解开其根本症结。</p>
<p>途逢险兆，消芽于萌。</p>
<p>兆：征兆；消芽于萌即消灭于萌芽。出现不好的苗头要在其萌芽之际禁毁，出现危险的征兆要及早消除。</p>
<p>调息止纷，贵在用衡。</p>
<p>纷：纠纷、纷争；衡：称、衡器，借用为公平。处理问题、解决矛盾、平息纷争，重要的是公平、公正。</p>
<p>依法谋治，官吏皆正。</p>
<p>治：治理；吏：旧时大小官员的通称，与“官”同义；正：纯、平、直，不偏邪。依法管理干部、治理国家，各级官员和工作人员才能正直守法、勤政奉公。</p>
<h2 id="经-济"><a href="#经-济" class="headerlink" title="经 济"></a><strong>经 济</strong></h2><p>币帛钱钞，攘夺其宗。</p>
<p>币帛钱钞：币帛与钱钞同义，都是货币的称谓，钱币是进行货物交换的代用品，财富的象征；攘夺：强取、侵夺；宗：原本、主旨。这两句说钱币财富是人们竞争、争夺的根源。 企财盼利，价值均等。 企：踮起脚跟。引申为仰望、盼望的意思；盼：盼望、渴望；价值：凝结在商品中的一般的、无差别的人类劳动，通过商品交换的量的比例即交换价值表现出来；均等：平均、相等。这两句是说人们企盼发财获利，无非是追求价值的均等和心理的平衡。</p>
<p>务工开厂，增富减穷。</p>
<p>务工：努力工作；开厂：开办工厂；增富：增加财富；减穷：减少贫穷。</p>
<p>资产累计，税率加乘。</p>
<p>资产：资金财产；税率：税的征收率；加乘：加减乘除。</p>
<p>银行贷款，储蓄倍宠。</p>
<p>银行：通过存款、放款、汇兑、储蓄等业务，承担信用中介的信用机构。世界上最早的银行出现在 16 世纪 80 年代意大利的威尼斯。中国第一家银行是中国通商银行，1897 年（清光绪二十三年）成立，是经营货币资本、充当债权人和债务人中介的金融企业，主要通过存放款获取利息差额；贷款：贷是借入的意思，贷款是借得钱款。银行贷款实际上是银行放款；储蓄：积贮备用。这里指居民把暂时不用的钱存入银行、信用合作社等信用机构；宠：喜爱。</p>
<p>抵押拆借，循例不停。</p>
<p>抵押：债务人或第三人向债权人提供不动产作为清偿债务的担保而不移转占有的法律行为。债务人不履行债务时，债权人有权依法以该财产折价或者以拍卖、变卖该财产的价款优先受偿；拆借：金融市场上银行等金融机构相互间的短期借款，一般以两天为期。除金融机构外，一般企业及个人也按一定利率进行短期的借贷；循例：遵循旧例、常例。</p>
<p>供给需求，市货充盈。</p>
<p>供给：供应给养，使不匮乏。这里指市场经济中卖方对市场的货物供应；需求：有机体对一定客观事物需求的表现。人类在发展过程中，形成对某些事物的必然需要，如营养、自卫、繁殖后代等。这里指人们对社会生活各方面的物质需要。供给与需求是市场经济中的一对矛盾；市货：市场上的各种货物；充盈：充足丰富。</p>
<p>销售买卖，亏差余剩。</p>
<p>销售：卖出；亏差：亏损、欠缺、短少；余剩：多、余。</p>
<p>债券股票，博赌输赢。</p>
<p>债券：依法定程序发行，约定在一定期限内还本付息的有价证券。依发行主体分类，有国债券、地方政府债券、金融债券、公司债券等；股票：股份公司发给股东证明其所入股份并有权取得股息的书面凭证。可作为买卖对象或抵押品的有价证券。股票可分为记名股票与无记名股票，前者须经过一定的手续才能转移其所有权，后者则可以自由转移；博赌：即赌博，用财物作注比输赢。这两句是说买卖债券、股票，是金融投资，也是以钱财进行输赢赌博。</p>
<p>闻赚虽喜，跌赔癫疯。</p>
<p>赚：买卖获得盈利；跌：下降、低落，如物价大跌、股市下跌；赔：折损、亏蚀，与赚相对；癫疯：精神错乱失常。这两句说做生意盈利赚钱了就高兴喜欢，亏本赔钱则痛苦沮丧，甚至于发疯癫狂。</p>
<h2 id="文-化"><a href="#文-化" class="headerlink" title="文 化"></a><strong>文 化</strong></h2><p>诸子百家，孔孟老庄。</p>
<p>诸子百家：春秋战国至汉初各种学派的总称。诸子指各派的代表人物，如儒家的孔子、孟子，道家的老子、庄子，墨家的墨子等，也指他们的代表作。百家指各学派。西汉刘歆将各学派著作辑为《诸子略》，其中把各学派分为儒、道、阴阳、法、名、墨、纵横、杂、农、小说等 10 家，辑录各家著作“凡诸子百八十九家，四千三百二十四篇”；孔孟：儒家的代表人物。孔即孔子。生于公元前 551<del>前 479 年，名丘，字仲尼，鲁国陬邑（今山东曲阜东南）人。春秋末期思想家、政治家、教育家，儒家的创始者。曾长期聚徒讲学，传说有弟子三千，其中著名者七十二人，古文学家说他曾删《诗》、《书》，定《礼》、《乐》，修《春秋》。其学以仁为核心，提出“己所不欲，勿施于人”的论点，相信天命，承认“生而知之”，但又强调“学而时习之”，主张因材施教，提倡“学而不厌，诲人不倦”的精神，在政治上主张“正名”，提倡德治和教化，反对苛政和任意刑杀，提出“不患寡而患不均，不患贫而患不安”的观点。他创立的儒家学派对后世产生重大影响，成为汉以后历代封建王朝的统治思想，他也被历代统治者尊奉为至圣先师。他的言论事迹，主要见于他的弟子及再传弟子所纂辑的《论语》一书中。孟即孟子，生于公元前 372 年</del>前 289 年，名轲，字子舆，邹（今山东邹县东南）人，战国时期思想家、政治家、教育家。受业于子思（孔子的孙子）的门徒，继承孔子的学说，兼言仁和义，提出“民贵君轻”说。被统治者奉为“亚圣”，在儒家中其地位仅次于孔子，思想事迹大都见于其弟子纂辑的《孟子》一书；老庄：道家的代表人物。老指老子，即老聃，姓李名耳，字伯阳，楚国苦县（今河南鹿邑东）厉乡曲仁里人，春秋时思想家，道家的创始人。做过周朝“守藏室之史”（管理藏书的史官），孔子曾向他问礼，后退隐。著有《老子》（《道德经》），书中用“道”来说明宇宙万物的演变，提出“道生一，一生二，二生三，三生万物”的观点，认为“道”是“夫莫之命而常自然”的，所以说“人法地，地法天，天法道，道法自然”。书中包括朴素辩证法因素，意识到一切事物都有正反两方面及对立面的互相转化，“祸兮福之所倚，福兮祸之所伏”，“天下万物生于有，有生于无”。老子学说对中国哲学的发展有很大影响，后世很多学者都从不同的角度吸取了他的思想。被道教奉为教主，称“太上老君”。庄即庄子，生于公元前 369 年~前 286 年，名周，宋国蒙（今河南商丘市东北）人，战国时哲学家。他继承和发展老子的“道法自然”观点，认为“道”是无限的，是“无所不在”的，强调事物的自生自化，否认有神的主宰。主张齐物我，齐是非，齐大小，齐生死，齐贵贱，幻想一种“天地与我并生，万物与我为一”的主观精神境界，安时处顺，逍遥自得。著作有《庄子》。</p>
<p>僧尼寂寞，菩萨忍常。</p>
<p>僧尼：从事佛教职业的男女，也称和尚。佛教与基督教、伊斯兰教并称为世界三大宗教，相传公元前 6~前 5 世纪中，古印度迦毗罗卫国（今尼泊尔境内）王子悉达多·乔答摩（即释迦牟尼）所创，是当时反婆罗门的思潮之一。基本教理有四谛、五蕴、十二因缘等，主张依经、律、论三藏，修持戒、定、慧三学，以断除烦恼而成佛为最终目的。汉代时传入中国，至隋唐达到鼎盛，对中国哲学、文学、艺术和民间风俗都有一定影响；寂寞：清静、冷落、孤独；菩萨：梵语音译。佛教指达到自觉、觉他两项修行果位者。原为释迦牟尼修行尚未成佛时的称号，后泛称大乘思想的实行者，一般也称所崇拜的神像为菩萨；忍：忍耐、克制。</p>
<p>扁鹊灵医，鲁班巧匠。</p>
<p>扁鹊：战国时著名医生、医学家，姓秦，名越人，勃海郡鄚（今河北任丘）人。精于医道，有丰富的医疗实践经验，反对巫术治病。扁鹊吸取前人经验，创造切脉医术，擅长内科、妇科、五官科、小儿科等各科，医名甚著。曾游历齐、赵，后入秦，因为秦武王诊治疾病，被秦太医令李醯妒忌杀害。著有《扁鹊内经》，《外经》等，已失传。《史记》、《战国策》里载有他的传记和医案，但有人认为扁鹊乃古代良医的称号，医案非出自他一人。现存《难经》，题为秦越人撰。因其家在庐国，又名庐医。后世各地修建的庐医庙，供祀的就是这位古代神医；鲁班：春秋时鲁国的建筑巧匠。姓公输，名般，又作盘、班，因是鲁国人，又称鲁班。曾创造攻城的云梯和磨粉的石硙，相传还发明木作工具，故民间泥作、木作和砖瓦建筑行业中人皆尊奉其为祖师。</p>
<p>蔡伦毕升，鉴真玄奘。</p>
<p>蔡伦：东汉时人，字敬仲。和帝时，为中常侍，曾任主管制造御用器物的尚方令。安帝元初元年（公元 114 年）封龙亭侯。他总结西汉以来用麻质纤维造纸的经验，改进造纸术，采用树皮、麻头、破木、旧鱼网为原料造纸，于元兴元年（公元 105 年），奏报朝廷，时有“蔡侯纸”之称。后世传为我国造纸术的发明人。造纸术为中国古代四大发明之一；毕升：宋代人，活字版印刷术的发明者。宋庆历年间 （1041—1048 ），毕升发明在胶泥片上刻字，一字一印，用火烧硬后，便成活字。活字可以多次使用，比整版雕刻经济方便。此外，他还研究过木活字排版。活版印刷术是中国古代四大发明之一；鉴真：唐高僧，生于公元 668<del>763 年，俗姓淳于，扬州江阳县（今江苏扬州市）人。14 岁于故乡大云寺出家，22 岁受戒。后至长安洛阳学习佛学，归后主持扬州大明寺。天宝元年（公元 742 年），应日本僧人荣叡、普照等邀请东渡日本，但多次出行均未如愿，直到天宝十二年（公元 753 年），第六次航行始到达日本。第二年于奈良东大寺建戒坛，传授戒法。公元 759 年，建唐朝招提寺，传布律宗，为日本律宗始祖。并将中国的建筑、雕塑、医药学等介绍到日本。公元 763 年卒于日本；玄奘：唐高僧，通称三藏法师，民间呼为唐僧，佛教学者，旅行家，与鸠摩罗什、真谛并称为中国佛教三大翻译家，唯识宗的创始人之一。生于公元 602</del>664 年，俗姓陈，名禕，洛州缑氏（今河南偃师县缑氏镇）人。13 岁出家，博涉经论。唐太宗贞观三年（公元 629 年，一说贞观元年），从凉州出玉门关西行赴天竺。在那烂陀寺从戒贤受学，后又游学天竺各地，名震五竺。历 17 年，于贞观十九年回到长安。携回佛教经论 657 部，奉诏在弘法寺、大慈恩寺译经。10 年译经 75 部，总 1335 卷，多用直译，笔法严谨。编译《成唯识论》，撰有《大唐西域记》一书。</p>
<p>罗盘硝药，针灸疗伤。</p>
<p>罗盘：又叫指南针，指示方位的一种仪器，由有方位刻度的圆盘和中间装置一根可以水平转动的磁针构成。静止时，大致指南北方向。是中国古代四大发明之一。相传黄帝时发明了指南车，战国时已有了用天然磁铁矿琢磨成的指南针，称为“司南”；硝药：指火药，炸药的一类，主要用作引燃药或发射药，中国古代四大发明之一；针灸：中医治病之术，针法和灸法的总称。针法是应用各种特制针具，施行一定的刺激方法作用于经络穴位以治疗疾病。灸法主要是用艾绒等物薰灼经络穴位以治疗疾病。针和灸早在《内经》中就有丰富的论述，已有 3000 多年的历史；疗伤：即疗治伤病。</p>
<p>拼牌拨珠，围棋麻纲。</p>
<p>牌：珠：即珠算，运用算盘进行加、减、乘、除、开方等计算的方法。最先见之于《数术记遗》，是中国最早用滚珠在盘上计算的记载。但珠不穿档，不是元明后的珠算盘。宋元时人们创造的乘除捷算法促进了筹算向珠算的演变，筹算口诀亦变成珠算口诀，便于记忆，算法简捷，运算迅速，明代已盛行；围棋：中国传统棋种，战国时已有关于围棋的文字记载，南北朝时传入朝鲜半岛、日本，19 世纪初传入欧美，建国后列入体育运动竞赛项目。棋局纵横各 19 道，共 361 个交叉点，二人对局，分黑白子，现代对子局执黑子者先行，让子局上手执白子先行。对局时，双方在棋盘的交叉点上轮流下子，每次只能下一子，下定后不准再移动位置。终局将实有空位和子数相加计算，或单记空位，多者为胜；麻：指麻将牌，也作“麻雀牌”、“雀牌”，博具。始于清代，由马吊牌演变而成，牌分万、索、筒三门，每门自一至九，各 4 张，另加中、发、白、东、西、南、北各 4 张，后又增加花牌和百搭，共 144 张。4 人同玩，每人 13 张，以先合成 4 组兼另一对牌者为胜；纲：纲领、规则，这里指麻将牌的游戏方法、规则。</p>
<p>易经论语，史记达畅。</p>
<p>易经：即《周易》，我国古代有哲学思想的占卜书。是儒家的重要经典之一，旧传孔子作，据近人研究，大抵系战国或秦汉之际的儒家作品，并非出自一时一人之手。易有变易（穷究事物变化）、简易（执简驭繁）、不易（永恒不变）三义。内容包括经、传两部分，六十四卦，三百八十四爻，附卦辞、爻辞，为经。上彖、下彖、上象、下象、上系、下系、文言、说卦、序卦、离卦称十翼，为传。主要通过象征天、地、风、雷、水、火、山、泽 8 种自然现象的八卦形式，推测自然和人事的变化，以阴阳二气的交感作用为产生万物的本源；论语：儒家经典之一。共 20 篇，是孔子弟子及其再传弟子关于孔子言行的记录。内容有孔子谈话、答弟子问及弟子间的相与谈论，是研究孔子思想的主要资料。东汉将其列为七经之一。南宋儒学大师、理学家朱熹把它和《大学》、《中庸》、《孟子》合为四书；史记：原名《太史公书》，为中国第一部纪传体通史。西汉司马迁撰，约于汉武帝太初元年至征和二年间（公元前 104~前 91 年）成书，共 130 篇，记事起于传说的黄帝，迄于汉武帝，前后 3 千年左右。采用本纪、表、书、世家、列传体裁。取材丰富，保存了上古至汉武帝时的较为系统的珍贵资料。文字通畅，语言生动，形象鲜明，在中国历史学、文学史上都有重要地位；达畅：即顺达流畅。</p>
<p>河图洛书，算术九章。</p>
<p>河图洛书：古代儒家关于《周易》和《洪范》两书来源的传说。《易·系辞上》说：“河出图，洛出书，圣人则之”，传说伏羲氏时，有龙马从黄河出现，背负“河图”，有神龟从洛水出现，背负“洛书”。伏羲根据这种“图”“书”画成八卦，就是后来《周易》的来源；算术九章：即《九章算术》，中国古代数学书，大约在公元前 2 世纪到公元 1 世纪成书，全书共 9 章。记载 246 个数学问题，连同每个问题的解法，分 9 大类，每一类为一章。《九章算术》记载了当时世界上最先进的分数四则运算和比例算法，解决各种面积和体积问题的算法以及利用勾股定理进行测量的各种问题，开平方和开立方的方法以及求解一般一元二次方程的数值解法，联合一次方程组解法。还在世界数学史上第一次记载了负数概念和正负数的加减法运算法则，对中国古代数学发展和世界数学的发展都做出了重大贡献，是世界著名数学著作之一。</p>
<p>西三红水，聊儒瓶厢。</p>
<p>西三红水：指《西游记》《三国演义》《红楼梦》《水浒传》四部中国古典长篇章回小说。《西游记》的作者是明朝的吴承恩。吴承恩，小说家，大约生活于 1500<del>1582 年，字汝忠，号射阳山人，山阳（今江苏淮安）人。自幼喜爱神话故事，后来他在前人作品和民间传说基础上进行再创作，写出了富有积极浪漫主义精神的长篇神话小说《西游记》。《西游记》共 100 回，写唐僧、孙悟空、猪八戒、沙僧师徒 4 人克服艰难险阻，降妖伏魔，除精拿怪，到西天取回真经的故事，成功塑造了孙悟空等众多形象。作品想象丰富，情节曲折，语言生动诙谐，别具风格；《三国演义》的作者是元末明初的小说家罗贯中。罗贯中大约生活于 1330</del>1400 年，名本，号湖海散人。山西太原人，一说钱塘（今浙江杭州）或庐陵（今江西吉安）人。《三国演义》全称为《三国志通俗演义》，共 120 回，故事始于刘备、关羽、张飞桃园结义，终于王濬平吴，描写了东汉末年和整个三国时代封建统治集团的矛盾和斗争，对当时动乱的社会状况亦有所反映。文字用浅近的文言，典雅晓畅。结构宏大，人物众多，情节曲折；《红楼梦》的作者为清朝小说家曹雪芹。曹雪芹，生年不详，卒于 1763 年，名霑，字梦阮，号雪芹、芹圃、芹溪。满洲正白旗“包衣”人。自曾祖起，三代任江宁织造，雍正初年，其父被免职，家产被抄，遂迁居北京。晚年居北京西郊，贫病而卒，年未及 50。《红楼梦》也叫《石头记》，书中以贾宝玉、林黛玉的爱情悲剧为主线，通过一个贵族官僚大家庭——贾府的盛衰历史的描写，塑造了许多典型人物形象，深刻解剖和批判了当时的社会，是我国古典小说中伟大的现实主义作品。全书 120 回，学界一般认为前 80 回为曹原作，后 40 回为高鹗所续。高鹗约生活于 1738-1815 年，清汉军镶黄旗人，字蘭墅，一字云士，别号红楼外史。乾隆六十年进士，入翰林院；《水浒传》的作者为元末明初的小说家施耐庵，《兴化县续志》载《施耐庵墓志》，说他原籍苏州，后迁淮安，元朝至顺进士，卒于明朝洪武初年，终年 75 岁。《水浒传》又称《忠义水浒传》，是在民间有关话本、故事的基础上再创作而成，描写了宋代梁山农民起义的故事，揭示了当时封建统治阶级的腐朽和社会矛盾、人民生活，塑造了宋江、李逵、武松、林冲、鲁智深等众多农民起义军领袖人物，人物性格鲜明，语言生动有力，具有很高的艺术成就。《水浒传》的版本很多，主要有 100 回本，120 回本，70 回本等，有人认为是施耐庵作，罗贯中编；聊儒瓶厢：指《聊斋志异》、《儒林外史》、《金瓶梅》、《西厢记》4 部中国古典作品。《聊斋志异》的作者为清朝文学家蒲松龄。蒲松龄生活于 1640<del>1715 年，字留仙，一字剑臣，别号柳泉居士，世称聊斋先生，山东淄川（今属淄博市）人。早岁即有文名，但屡试皆落第。以数十年时间，写成文言短篇小说集《聊斋志异》。全书共 24 卷，476 篇，加上补遗与附录 27 篇，总 503 篇。作者以民间故事为基础，通过丰富想象，创作出很多优秀作品。作品构思奇妙大胆，语言生动，借谈狐说鬼对当时的社会黑暗和官吏罪恶给予暴露，批判了封建礼教和科举制度，也歌颂了纯真爱情和自由精神；《儒林外史》的作者为清朝的小说家吴敬梓。吴敬梓生活于 1701</del>1754 年，字敏轩，一字文木，安徽全椒人。擅长诗赋，尤以小说著称。所著长篇小说《儒林外史》，刻画了各种类型士人利欲熏心、虚伪丑恶的心态、行为，暴露了封建社会的腐朽黑暗，对科举制度和封建礼教进行深刻的嘲讽。语言纯净精炼，富于表达能力；《金瓶梅》的作者署名兰陵笑笑生，兰陵即山东峄县（今枣庄市）人，笑笑生是笔名，其真名实姓尚不清楚。此书写作年代大约在明代万历年间，写的是宋代的人物故事，实际反映的都是作者所处的明代中叶以来的社会事实。作品以《水浒传》中西门庆、潘金莲的故事为引子，描写恶霸、官僚、豪商西门庆的一生。对西门庆勾结权贵、横行乡里、蹂躏妇女等罪恶作了深刻揭露，反映了封建社会处于腐朽没落时期统治阶级的特有本性。这是第一部文人独创的小说，在我国长篇小说的发展史上具有重要意义。另外，此书把描写重点对准市井百姓，通过一个家庭的解剖和日常琐事的描写反映社会，开创了“人情小说”的先河。但书中大量的色情描写产生了消极影响；《西厢记》的作者为元朝戏曲作家王实甫。王实甫，一说名德信，大都（今北京市）人，生卒年月不详。所作杂剧 14 种，现存《西厢记》、《破窑记》、《丽春堂》3 种。剧作大都以青年女性反抗封建礼教为题材。《西厢记》全名为《崔莺莺待月西厢记》，杂剧剧本，写书生张珙在蒲东普救寺遇见崔相国的女儿莺莺，二人发生爱情，在侍女红娘的帮助下，终于冲破封建礼教约束而结合。故事源出唐朝元稹传奇小说《莺莺传》。王实甫突破元杂剧每剧 4 折的体例，全剧共分 5 本 21 折。剧本表达反对封建礼教的主题思想，并丰富了人物性格和情节。文词优美生动，在戏曲文学发展史上影响深远。</p>
<p>诗词曲赋，戏剧说唱。</p>
<p>诗、词、曲、赋为文学的几种体裁形式，文学的重要类别。诗：通过有节奏、韵律的语言反映生活，发抒情感。词：由五言诗、七言诗和民间歌谣发展而成，起于唐代，盛于宋代，原是配乐歌唱的一种诗体，句的长短随着歌调而改变，因此又叫作长短句，有小令和慢词两种，一般分上下两阕。曲：乐曲的唱词，是韵文的一种文体，泛指秦汉以来各种可以入乐的乐曲，通常则多指宋代以来的南曲和北曲，同词的体式相近，但一般在字数定格外可加衬字，较为自由，并多使用口语，分为戏曲（包括杂剧、传奇）、散曲两类。赋：是韵文和散文的综合体，通常用来写景叙事，也有以较短的篇幅抒情说理的，盛行于汉魏六朝。在中国文学发展史上，以唐诗、宋词、元曲、汉赋著称；戏剧、说唱为文艺的两种表达形式。戏剧：是由演员扮演角色，在舞台上当众表演故事情节的一种艺术，是以表演艺术为中心的文学、音乐、舞蹈等艺术的综合，分为话剧、戏曲、歌剧、舞剧等。说唱：是由一人或二人在台上有说有唱地表演故事情节的一种民间艺术。</p>
<h2 id="艺术"><a href="#艺术" class="headerlink" title="艺术"></a><strong>艺术</strong></h2><p>琵琶琴瑟，锣鼓铿锵。</p>
<p>琵琶、琴、瑟、锣、鼓为中国传统的几种乐器，琵琶、琴、瑟是弦乐器，锣与鼓是打击乐器。琵琶：用木料制成，有 4 根弦，下部瓜子形的盘，上部为长柄，柄端弯曲；琴：亦称“七弦琴”，俗称“古琴”。周代已有，魏晋以后，形制已和现在的大致相同。琴身为狭长形木制音箱，长约 110 厘米，琴头宽约 17 厘米，琴尾宽约 13 厘米。面板用桐木或杉木制成，外侧有徽 13 个。底板用梓木制成，开有大小不同的出音孔两个，称“凤沼”、“龙池”。琴面张弦 7 根，奏时右手弹弦，左手按弦，有吟、猱、绰、注等手法。音域较宽，音色变化丰富。在长期的历史发展过程中，形成了独特的演奏艺术和各具特色的多种流派。现在琴是多种弦乐器的通称，如胡琴、月琴、风琴、钢琴等；瑟：春秋时已流行，形似琴，但无徽位，通常有 25 弦，每弦有一柱。古时瑟常与琴或笙合奏；锣：用铜制成，形状象盘子，用锣槌敲打；鼓：为圆桶形或扁圆形，中间空，一面或两面蒙着皮革，用鼓槌敲打；铿锵：形容锣、鼓、琴、琵琶等乐器有节奏而响亮的声音。</p>
<p>笙箫呜咽，卧笛悠扬。</p>
<p>笙、箫、笛为中国传统的几种管乐器。笙：有大小数种，用若干根装有簧的竹管和一根吹气管装在一个锅形的座子上制成；箫：古代用许多竹管排在一起做成，现代一般用一根竹管做成；呜咽：形容凄切的水声或丝竹声；卧笛：即横笛，横着吹奏的笛。用竹子制成，上面有一排供吹气、蒙笛膜和调节发音的孔；悠扬：形容时高时低而和谐的声音。 筝音奔奋，唢呐高亢。 筝、唢呐为中国传统的两种乐器，筝：弦乐器，木制长形。唐宋时有 13 根弦，后增至 16 根，现发展到 25 根弦；唢呐：管乐器，管身正面有七孔，背有一孔；高亢：高而宏亮的声音。</p>
<p>钟铃鸣脆，喇叭噪晌。</p>
<p>钟：用铜或铁制成的响器，中空，用木棒撞击会发出响声；铃：用金属制成的响器，最常见的是球形而下面开一条口，里面放金属丸。也有钟形而里面悬着金属小锤的，振动时相击发声；鸣脆：声音清脆；喇叭：管乐器，用铜制成，上细下粗，最下端的口部向四周扩张，可以扩大声音；噪：形容喇叭的声音；晌：押韵用字。</p>
<p>荆浩匡庐，董源潇湘。</p>
<p>荆浩：人名，五代后梁画家，字浩然，沁水（今属山西）人。通经史，能文章，隐居太行山的洪谷，号洪谷子。擅画山水，常携笔摹写山中古松。著有《笔法记》，他对中国山水画的发展有重要影响；匡庐：即《匡庐图》，荆浩的存世画作；董源：人名，五代南唐画家，董源一作董元，字叔达，仲陵（今江西进贤西北）人，曾任北苑副使，人称“董北苑”。工画山水、牛、虎、人物，最擅山水。其水墨山水，影响很大，巨然加以发展，并称“董巨”，为五代北宋间南方山水画的主要流派。存世作品有《潇湘》、《夏山》、《夏景口山待渡》、《半幅溪山行旅》、《龙宿郊民》等；潇湘：即指董源的画作《潇湘》图。</p>
<p>米芾写意，悲鸿骏昂。</p>
<p>米芾：北宋书画家。生活于 1051~1107 年，初名黻，字元章，号襄阳漫士、海岳外史等。世居太原（今属山西），迁襄阳（今属湖北），后定居润州（今江苏镇江）。宋徽宗召其为书画学博士，曾官礼部员外郎，人称“米南宫”，因举止颠狂，又称之“米颠”。能诗文，擅书画，精鉴别。行、草书用笔俊迈，有“风樯阵马，沉着痛快”之评，与蔡襄、苏轼、黄庭坚合称“宋四家”。画山水从董源演化而来。不求工细，多用水墨点染，突破了勾廓加皴的传统技法，开创独特风格。其子米友仁继承父法，自称“墨戏”，画史上有“米家山”，“米氏云山”和“米派”之称。著有《书世》、《画史》、《宝章待访录》、《山林集》，存世书法有《苕溪诗》、《蜀素》、《虹县诗》《向太后挽词》等；写意：中国画中属于纵放一类的画法，与“工笔”对称。要求通过简练的笔墨，写出物象的形神，表达作者的意境。米芾的画即属此类；悲鸿：即徐悲鸿，生于 1895 年，卒于 1953 年，现代画家、美术教育家，江苏宜兴人。少时刻苦学画，后留学法国。曾任中央美术学院院长，中国全国美术工作者协会主席。其画融合中西技法，而自成面貌。在绘画创作上，提倡“尽精微，致广大”，对中国画主张“古法之佳者守之，垂绝者继之，不佳者改之，未足者增之，西方绘画可采入者融之”。擅长油画、中国画，尤精素描。人物造型注重写实，善传达神情，其历史画寓意深刻。所画花鸟、风景、走兽，简练明快，富有生气，尤以画马驰誉中外，其《八骏图》世界著名，故说“悲鸿骏昂”。</p>
<p>笔墨纸砚，匾楣楹榜。</p>
<p>笔、墨、纸、砚合称“文房四宝”。笔：写字画图的用具，有很多种类，如毛笔、钢笔、铅笔等；墨：写字绘画的用品，是用煤烟或松烟等制成的黑色块状物，间或有用其它材料制成别种颜色的。也指用墨和水研出来的汁。现泛指写字、绘画或印刷用的某种颜料；纸：写字、绘画、印刷、包装等所用的东西，多用植物纤维制造。中国在汉代已开始用纸；砚：砚台，研墨的文具，有石头的，有瓦的；匾：悬在门顶或墙上的题字横牌：楣：门框上的横木，也叫门楣；楹：厅堂前部的柱子，也指柱子上的联语，即楹联；榜：木牌，匾额。</p>
<p>楷隶篆刻，碑帖草狂。</p>
<p>楷、隶、篆为汉字的几种书写形体，楷、隶、篆、刻又同为中国书法艺术的组成部分。楷：楷书，也称真书、正书，就是通行的汉字书写正体字，由隶书演变而来。形体方正，笔画平直；隶：隶书，亦称“隶字”、“佐书”，由篆书简化演变而来，形成于秦时，通行于汉朝；篆：篆书，又叫“篆字”，秦朝整理字体后规定的写法；刻：也称“篆刻”，镌刻印章。印章字体，多采用篆书，先写后刻，故称篆刻；碑帖：书法的临摹范本，因是从石碑上拓印的字帖，故称碑帖；草狂：即狂草，草书的一种。</p>
<h2 id="文物（8）"><a href="#文物（8）" class="headerlink" title="文物（8）"></a><strong>文物（8）</strong></h2><p>敦煌石窟，长城伟墙。</p>
<p>敦煌石窟：我国著名的石窟。包括古代隶属敦煌境内的莫高窟、西千佛洞、榆林窟和水峡口小千佛洞四窟，一般指莫高窟。保存有 4 世纪至 14 世纪遗留的壁画、雕塑等艺术珍品；长城伟墙：即万里长城。春秋战国时各国为了互相防御，各在形势险要的地方修筑长城。秦始皇完成统一后，为了防御北方匈奴贵族的南侵，于公元前 214 年，将秦、赵、燕 3 国的北边长城予以修缮，连贯为一，故址西起临洮（今甘肃岷县），北傍阴山，东至辽东，俗称“万里长城”。明代自洪武至万历时，曾 18 次修筑长城，西起嘉峪关，东至山海关，称为“边墙”。宣化、大同二镇之南，直隶山西界上，并筑有内长城，称为“次边”。总长约 6700 公里，大部分至今仍基本完好。居庸关一带墙高 8.5 米，厚 6.5 米，顶部厚 5.7 米，女墙高 1 米。气魄雄伟，是世界历史上伟大工程之一。</p>
<p>青铜甲骨，缕衣纱裳。</p>
<p>青铜：铜锡合金的旧称，现称“锡青铜”。它标志一个历史时期——青铜时代。青铜的冶炼和铸造技术，我国发展很早，据传说，禹铸九鼎，远在约公元前 2200 年。商代青铜器盛行，建立了冶炼青铜的工业。河南郑州、安阳等地发现的青铜厂遗迹，和大量青铜器的发掘出土，证明商代青铜冶炼、铸造技术的发展；甲骨：指甲骨文，商周时代刻在龟甲兽骨上的文字，也叫“契文”、“卜辞”、“龟甲文字”“殷墟文字”。甲骨文于 1899 年最初出土于河南安阳小屯村的殷墟。1928 年后作了多次发掘，先后出土达 10 余万片，皆为盘庚迁殷到纣亡 273 年间的遗物，是研究商周社会历史的重要资料。已发现的甲骨文单字在 4500 字左右，可认识的约 1700 字。文字结构不仅已经由独体趋向合体，而且有了大批的形声字，是一种相当进步的文字。在可识的汉字中，甲骨文是最古的文字体系；缕衣：即金缕玉衣，金丝穿玉片而成的衣服，是汉代皇族和贵族死后的殓服。由于等级不同，玉衣有金缕、银缕、铜缕之分，我国考古中，这 3 种玉衣都有发现；纱裳：轻纱料做成的衣裳。1972 年在长沙马王堆一号墓中出土了两件纱衣，其中一件是素色的，衣长 128 厘米，袖长 190 厘米，重 49 克。除去袖口、领口较厚重的边饰，衣服只有 25 克。因纱衣质地非常轻薄，像蝉翼，所以叫它蝉翼纱，这件衣服称为“素纱禅衣”（禅衣即为单衣）。从此可看出汉代纺纱技术的发展。</p>
<p>虎符越剑，陶马俑葬。</p>
<p>虎符：虎形的兵符，古代帝王授予臣属兵权和调发军队的信物。用青铜铸成虎形，背有铭文，分为两半，右半留存朝廷，左半发给统兵将帅或地方官吏。调发军队时，须由使臣持符验合，方能生效。虎符盛行于战国、秦、汉，唐代以后废除。历史上有“窃符救赵”的故事：战国时，秦军攻打赵国，赵国向魏国求救，但魏王不肯发兵。魏王之弟信陵君请赵国女子、魏王宠姬如姬偷出虎符。信陵君持符夺得兵权，击退秦军，解了赵国之围；越剑：即越王勾践剑。春秋时越王勾践被吴王打败，从此卧薪尝胆，发愤图强，立志报仇。后来国强兵壮，便起兵进攻吴国，最后终于打败吴国，成为春秋一霸。1965 年在湖北江陵望山一号墓中，发掘一把青铜剑，剑上刻着“越王勾践自作用剑”几个铭文。铜剑全长 55.7 厘米，剑首向外翻卷，像一道圆箍。里边铸有 11 道极细小的同心圆，剑柄正面用蓝色玻璃、背面用绿色宝石镶嵌出美丽的花纹，剑身上还饰有菱形的暗纹。出土时依然寒光闪闪，锋利非常；陶马俑葬：古代陪葬用的陶制人、马、牛、车等。秦始皇陵兵马俑，是 1974 年在陕西临潼县秦始皇陵东南一公里处发现的，已发掘出陶制武士 800 多个，战马 100 多匹，木质战车 18 辆。陶俑按兵种的不同分为步兵俑、骑兵俑、车兵俑、弓弩手、将军俑等，真人实物般大小，全副披挂武装，按阵势排列，神情逼真，栩栩如生，被称为世界第八大奇迹。</p>
<p>彩瓷宝瓮，丝绸他乡。</p>
<p>彩瓷：即彩色的瓷器。中国素有“瓷国”之称，从商代就开始了瓷器生产。最初的瓷器呈青色，后有白瓷，再后有彩瓷。从青瓷到彩瓷，标志着瓷器制造技术的提高。彩瓷大量出现在明代，明成化年间始创“斗彩瓷”，嘉靖、万历年间又制成“五彩瓷”。故宫博物院内藏有一件明万历年间的五彩镂空凤纹瓶，瓶高 49.8 厘米，通体以褐色、褐赤色勾勒出整个轮廓，以青花、红、绿、孔雀蓝等七种色彩。镂空凤纹瓶是以镂空手法为主要特征的瓷器，镂空技术相当细腻，在世界瓷器艺术上是史无前例的，被视为五彩瓷的珍品。清朝，彩器的烧制技术进一步得到发展，创造出众多闻名中外的粉彩、珐琅彩；宝瓮：指团城玉瓮。我国现存形体最大、时间最早的传世玉器是北京团城上的玉瓮，通身用玉雕成，青白色中夹杂些墨色。瓮高 70 厘米，长 182 厘米，宽 135 厘米，周长 493 厘米，重量大约为 3500 公斤。玉瓮形体古朴厚重，瓮口为椭圆形，周身雕有精美的花纹。海马、海龙、海猪、海犀在云涛、激流、漩涡中翻跃奔腾，时隐时现。这些图案都是因玉的质地、花纹而精心设计雕刻的，整个玉瓮造型生动，气度不凡。清乾隆十年（公元 1745 年），乾隆皇帝派人以千金换来，置于团城承光殿内，以后又修建了玉瓮亭，配以汉白玉宝座，他自己写了三首七言诗刻在玉瓮膛内，40 名翰林学士的诗刻在石亭楹柱上；丝绸他乡：是说中国的丝绸运往世界其他国家。中国是发明丝绸最早的国家，远在四五千年前的新石器时代，中国就已经有了蚕桑丝织生产，到唐代织造技术更为提高，花式品种更加繁富，其中江南的“缭绫”、“红绒毯”最为著名。唐王朝开辟了一条横贯欧亚大陆的交通要道，东起当时中国的都城长安（今陕西省西安市），经过许多国家和地区，直到意大利的罗马，沟通了中外贸易，中国丝绸和其它商品经由这条道路运往西亚及欧洲各国，欧洲就称这条路为“丝绸之路”，中国也因此被称为“东方丝国”。</p>
<p>凡尔赛宫，金字塔状。</p>
<p>凡尔赛宫：法国封建时代帝王的行宫，在巴黎市西南凡尔赛城，始建于 16 世纪。17 世纪末屡经改建扩建，至 18 世纪形成现存规模。包括宫前大花园、宫殿和放射性大道三部分。形体对称，轴线东西向。花园纵深约 3 公里，布有水池、几何形的道路网和修剪成形的花圃、树丛，并有小亭、台阶、雕像和喷泉等。宫殿南北全长 580 米，中央为王宫，其他为王子和亲王的宫室以及王权政府办公处、教堂和歌剧院等。凡尔赛宫是西欧最大的宫殿，突出表现了伟大的气概；金字塔：为古代埃及的一种方锥形建筑，形似汉字“金”字，故称“金字塔”。金字塔是安放古埃及法老（即国王）木乃伊的陵墓。公元前 30 世纪中叶，在尼罗河三角洲的吉萨地方造了三座大金字塔，胡夫金字塔是最大的金字塔，高 146.6 米，底边长 230.4 米，用了 230 万块平均 2.5 吨重的大石块。石块磨得非常平整，石缝间不用灰浆粘结，连刮胡子的刀片都插不进。整个塔身外面又粘着一层磨光的白色大理石板，在沙漠地带呈现出一片神话般壮观景象。1816 年，在哈夫拉金字塔不远处，又发现了被掩埋四千多年的斯芬克斯狮身人面像。这是世界上最古最大的巨石像，长 57 米，高 20 余米，除狮爪外，用整块石头雕成。它和金字塔一起，成为世界七大奇迹之一。</p>
<p>泰姬陵墓，彼得教堂。</p>
<p>泰姬陵墓：也称“泰姬·马哈尔陵”，在印度北方邦的亚格拉近郊，是莫卧儿帝国皇帝沙·贾汗于 1632<del>1654 年为其爱妃蒙泰姬修建的陵墓，兼做离宫。用白色大理石筑成，墙上镶嵌五彩宝石，中央覆盖着一个直径约 17 米的圆形穹窿，四角有四座高 41 米的光塔。左右各有一座清真寺花园及水池。泰姬墓不仅具有陵墓建筑的庄严和肃穆，而且明快欢畅，给人飘然欲仙的感觉，是印度伊斯兰建筑的主要代表；彼得教堂：即罗马圣彼得大教堂。建于 1506</del>1626 年，是文艺复兴建筑的代表作，也是世界上最大的教堂。总面积达 1.8 万多平方米，平面为纵长十字形，在十字形交叉处，覆盖着高大的穹窿顶，高 137.7 米，圆屋顶周长 71 米，直径 42.34 米。大厅中央有一座高 29 米的金色华盖，由四根描金铜柱支撑。教堂前的椭圆形广场两侧为两组半圆形的柱廊，由 284 根圆柱和 88 根方柱组成，柱高 18 米，每根柱上各有一尊大理石雕像，气势雄伟，气象万千。</p>
<p>自由女神，希腊塑像。</p>
<p>自由女神：即自由女神铜像，由法国雕刻艺术家巴托尔第创作，是法国送给美国独立一百周年（1876）的礼物。1876 年，美国国会通过一项议案，授权当时的格兰特总统，接受法国赠送的自由女神像，并决定树立在纽约港口的伯德罗埃岛。1885 年 6 月，自由女神像分装成 210 箱，由法国运抵美国纽约港，以后又按装了日夜不灭的照明系统。自由女神右手拿着象征自由的火炬，左手拿着一本象征法律的书板，书板上写着美国《独立宣言》发表的日期 1776 年 7 月 4 日，底座上镌刻着著名诗篇《新巨人》中的诗句。参观者可以进入铜像内，直达顶部。面对大西洋的自由女神像已成为美利坚民族的标志；希腊塑像：指古希腊塑像，突出表现了人体美，如公元前 4 世纪的大理石雕刻《赫尔克里斯》、公元前 1 世纪左右的雕像《米罗的维纳斯》等，都是表现人体美的代表作。</p>
<p>最后晚餐，创造亚当。</p>
<p>这两句指欧洲文艺复兴时期的两幅著名壁画《最后的晚餐》和《创造亚当》。欧洲 15 至 16 世纪，在文艺复兴的发源地意大利出现三位伟大的艺术家——达·芬奇、米开朗琪勒和拉斐尔，被称为“文艺复兴三杰”。列奥纳多·达·芬奇（1452<del>1519）在美术上的重要贡献是把美术和科学结合起来，他画的人都合乎人体解剖的比例结构，所画环境人物都符合透视现象。《最后的晚餐》是其代表作，内容取自圣经故事，画面上 13 个人物形态表情生动传神；米开朗琪勒·波纳罗蒂（1475</del>1564）是《创造亚当》的作者，这是他为西斯廷教堂拱形屋顶画的九幅壁画中的一幅，总称为《创世纪》，内容取自圣经故事。《创造亚当》表现的主题是“人类的觉醒和渴望着人的力量获得解放”；拉斐尔·桑奇（1483~1520）的作品具有幽雅、秀美的风格，代表作是壁画《西斯廷圣母》。</p>
<h2 id="科技（8）"><a href="#科技（8）" class="headerlink" title="科技（8）"></a><strong>科技（8）</strong></h2><p>试管婴儿，克隆遗传。</p>
<p>试管婴儿：由体外受精后移植到同步化子宫内膜发育成长而分娩的婴儿。要求体外受精成功并能在试管中培育受精卵，于适合胚胎生长的培养液中加入母血清，然后移植到相当于受精卵成熟天数的同步化子宫内膜中，即能发育长大；克隆：译自英文 clone。作名词解，即“无性繁殖系”，作动词解，则指克隆技术，即无性繁殖技术。即不经过生殖细胞的结合由亲体直接产生子代的生殖方式。天然的或人工合成的脱氧核糖核酸分子，在体外与载体拼接成重组分子后引入受体细胞中，然后通过随同重组分子在细胞内复制而获得大量的该种脱氧核糖核酸。无性繁殖复制的动物个体，其外形和生理性状与细胞核的供体相同。1952 年在两栖类动物中取得成功。1975 年成功将蛙的体细胞核移植到去核蛙卵中使之发育为蝌蚪。1983 年至 1989 年，使哺乳动物小鼠、牛、兔等的合子的原核或卵裂球的核，在植入去核合子或去核并活化的卵细胞中，成功的发育为个体。1997 年用六岁母羊的乳腺上皮细胞与去核并活化的卵细胞融合，发育而产下名为“多利”的羊羔，这是哺乳动物已分化的体细胞成功地发育为个体的首例；遗传：一般指亲代的性状又在下代表现的现象，但在遗传学上，指遗传物质从上代传给下代的现象。</p>
<p>细胞速冷，脱氧核酸。</p>
<p>细胞：生物体的结构和功能的基本单位。一般由细胞核、细胞质和细胞膜组成。在细胞质中还有许多小器官，称细胞器。植物细胞在细胞膜之外还有一层较厚的细胞壁。细胞通常很微小，须用显微镜才能见到，但大型的卵细胞，肉眼可见，有的神经细胞的突起可长达一米以上。细胞以分裂法繁殖，有些细胞器也能分生繁殖。在多细胞生物中，细胞的形状随其生长、分化和功能而有很大的变化，有卵圆形、柱形、鳞形、梭形或树枝形等；速冷：即迅速冷冻，采用冻结装置，使物体在低温下迅速冻结；酸：酸、甜、苦、辣、咸五种味道之一。脱氧核酸：即脱氧核糖核酸，核酸的一类，因分子中含有脱氧核糖而得名，简称 DNA。分子极为庞大（分子量一般至少在百万以上），其主要的组成核苷酸为脱氧腺酸、脱氧鸟苷酸、脱氧胞苷酸和脱氧胸苷酸。存在于细胞核、线粒体、叶绿体中，也可以游离状态存在于某些细胞的细胞质中，大多数已知噬菌体、部分动物病毒和少数植物病毒中也含有脱氧核糖核酸，是储藏、复制和传递遗传信息的主要物质基础。脱氧核糖核酸重组技术也就是基因工程。</p>
<p>脉冲数码，几何规范。</p>
<p>脉冲：“电脉冲”的简称。电子技术中电流或电压的短暂起伏。常用脉冲形状有矩形、梯形、三角形、锯齿形等。脉冲所能达到的最大值称“脉冲幅度”，脉冲的持续时间称“脉冲宽度”。形状、幅度和宽度是脉冲的主要参数。周期性重复的脉冲每秒出现的个数称“脉冲频率”，其倒数称“脉冲周期”；数码：指数码技术。……？几何： 指几何学。研究空间和图形性质的一门数学分科。古代埃及为兴建尼罗河水利工程，曾进行测地工作，后逐渐发展为几何学。公元前约 300 年，古希腊数学家欧几里得把前人生产实践中长期积累的几何知识整理总结为演绎体系，写成《几何原本》。中国对几何学的研究也有悠久的历史，早在上古时期，中国人就已利用规矩来制作方圆，秦汉间成书的《周髀算经》和《九章算术》中，已记载有勾股定理和图形面积的计算等。17 世纪欧洲的笛卡儿利用代数方法研究几何问题，建立了解析几何，18、19 世纪产生了画法几何、射影几何和微分几何。19 世纪 20 年代产生了非欧几何，50 年代又建立了黎曼几何。20 世纪中期以来，随着数学其它分支如拓朴学、微分方程和抽象代数的发展，整体几何已成为现代几何学的主要内容，在理论物理中有重大的应用；规范：标准、法式。这里指规范场，物理学术语。规范场要求粒子体系具有定域规范不变性而必须存在的某一矢量场。荷电粒子体系的规范场即电磁场，它是电磁作用的媒介。</p>
<p>网络通讯，程控遥感。</p>
<p>网络：由若干元件（如电元件、机械元件、光学元件、计算机等）连接而成的一个系统。一般指由电子元件、真空电子器件或固态电子器件等连接成的系统。20 世纪 60 年代以来，人们把由许多单机连接成的系统、甚至把许多非电气设施的非电连接的系统，也通称为网络。前者如通信网络、计算机网络、输电配电网络等，后者如农田灌溉网络、交通运输网络等；通讯：即通信。通过媒体将信息由一点传送至另一点的过程。早先以邮件作为媒体，后采用电、电子和光的手段，由电信号或光信号借助信道传送语言、文字、数据和图像等信息。按信号特征，分模拟通信和数字通信。按媒体，分有线电通信和无线电通信。按电信业务，分电报、电话、可视电话、传真、电子函件、语音信箱等。按所用波段，分长波、中波、短波、超短波、微波、毫米波和光通信等。按多路模式，分时分复用、频分复用和码分复用。按通信点位置，有蜂窝式移动通信、集群通信和个人通信。按网络，可通过因特网、综合业务网、数学数据网、帧中继以及卫星通信网进行通信；程控：即程序控制。按事先规定的程序，对生产过程进行控制的一种自动控制方式；遥感：不直接接触目标物（物体或现象）而探测其性质、形态和变化规律的综合技术。一般在高空或远距离处，利用传感器（包括照相机）接收物体辐射的电磁波信息，经处理、判读和分析后实现。有航空遥感和航天遥感之分。遥感技术在气象、地质、农业、林业、海洋、测绘、环境监测和军事等部门得到广泛应用。</p>
<p>驱逐舰艇，洲际导弹。</p>
<p>驱逐舰：具有多种作战能力，主要在中远海活动的中型军舰。满载排水量 2000<del>8500 吨，最大航速 30</del>37 节。装备多种导弹、舰炮、鱼雷、反潜兵器，有的还配备舰载直升机。主要任务是攻击潜艇和水面舰船，担负舰船编队的反潜和防空，支援登陆和抗登陆作战、袭击岸上目标以及护航、侦察、巡逻、警戒等；洲际导弹：导弹的一种。导弹是依靠自身动力装置推进，由制导系统控制飞行并导向目标的武器。由弹头、弹体、推进系统、制导系统和电源等组成。在武器发展史中，导弹的出现和发展是质的飞跃。最早用于战争的，是第二次世界大战末期德国的 V-1 巡航式导弹和 V-2 弹道式导弹。导弹按发射点分类和目标位置分，有攻击地面目标的导弹、攻击空中目标的导弹、攻击水域目标的导弹，按作战使用分有战术导弹和战略导弹，按飞行方式分有巡航导弹和弹道导弹，按射程分有近程导弹、中程导弹、远程导弹和洲际导弹。洲际导弹是射程 8000 公里以上的导弹，携带单弹头或多弹头，打击纵深内的战略目标。</p>
<p>激光辐射，捆绑火箭。</p>
<p>激光：受激发射产生的光，利用受激发射实现光波放大或振荡的器件称为激光器。1960 年美国 T·H·梅曼制成第一台红宝石激光器，标志了激光技术的诞生。激光具有亮度极高（比太阳的亮度可高几十亿倍）、单色性好、方向性好三个特点。光束的发散角可达毫弧度。激光束可用于加工高熔点的材料，也可用于医疗、精密计量、测距、农作物育种、大气污染监测和科学研究等；辐射：波动（机械波或电磁波）或大量微观粒子（如质子或α粒子）从它们的发射体出发，在空间或媒质中向各个方向传播的过程。也可以指波动能量或大量微观粒子本身；捆绑火箭：火箭是依靠火箭发动机产生的反作用力推进的飞行器，主要由箭体、推进系统和有效载荷等组成。捆绑火箭为捆绑式运载火箭的简称，是在多级运载火箭第一级外围捆绑助推器的运载火箭。助推器为固体火箭或液体火箭，捆绑数量取决于所需运载能力。火箭垂直起飞后不久，助推火箭首先熄火并被抛掉。运载火箭由串联组合发展为串联与并联组合。</p>
<p>声纳测距，信号还原。</p>
<p>声纳：声纳为英文 sonar 的音译，原意是“声音导航和测距”。利用水下声能来探测水中目标及其状态的仪器，分主动式和被动式两种。前者指能辐射水下声能并利用其反射波的仪器，后者指仅能接收远距离水下声能的仪器。已广泛使用于各种潜艇、水下作业及渔业勘测等；信号：适于信道传输的一种信息载体。是消息的基本组成部分。通信系统中，载负信息的电流、电压与无线电波等电信号，也简称信号。任何通信方式均须由信号载负信息，用不同的频率变换，调制或编码成适当形式，以适于各种不同信道的传输。</p>
<p>谍报跟踪，贫铀污染。</p>
<p>谍报：向侦察对象内部秘密派遣人员或在其内部就地发展人员，以获取机密情报；跟踪：紧紧跟在后面（追赶、监视）；贫铀：指贫铀弹。用核废料制造的炸弹，爆炸后对环境有污染；污染：有害物质的散布对正常生活造成的危害，如环境污染。</p>
<h2 id="体育（6）"><a href="#体育（6）" class="headerlink" title="体育（6）"></a><strong>体育（6）</strong></h2><p>奥运竞技，淘汰筛选。</p>
<p>奥运竞技：指古希腊的奥林匹亚竞技会，也指现代的奥林匹克运动会，简称奥运会。原来的运动会是为祭祀宙斯神而办，仅限希腊人参加，在雅典西南 360 公里的奥林匹亚村举行。始于公元前 776 年，每四年举行一次，到公元 393 年，共举行了 293 次，后由于罗马皇帝的禁止而停止。1888 年，由法国教育家顾拜旦建议恢复了奥林匹克运动会，参加的运动员可以是世界任何国籍、种族、肤色的选手。1894 年，巴黎国际体育会议决定成立国际奥林匹克委员会，并于 1896 年在雅典举行了第一届现代奥运会，此后奥运会每四年举行一次。这四年的周期称为“奥林匹亚特”。运动会在每年 6 月底 7 月初举行，起初赛期仅一天，自公元前 472 年起改为 5 天，第一天和第 5 天用于献祭活动，中间 3 天为体育比赛。现代奥运会包括开幕式不得超过 16 天。现代奥运会的比赛项目有：田径、足球、游泳、篮球、排球、曲棍球、体操、举重、自行车、摔跤、柔道、射击、射箭、击剑、皮划艇（独木舟）、赛艇、帆船、马术、拳击、手球、网球、乒乓球、羽毛球、现代五项以及冬季奥运会项目的冬季两项（滑雪 + 射击）、滑冰、滑雪、冰球、有舵雪橇和无舵雪橇。奥运会如果因故不能举行，但届数仍连续计算，2000 年举行了第 27 届奥运会，中间因两次世界大战而中断 3 届，实际只举行了 24 届。1896 年~2000 年奥林匹克旗帜为象征世界五大洲团结的五环旗。每届奥运会前夕，在奥林匹克发源地奥林匹亚希腊女神赫拉庙旁，用凹面镜聚集日光点燃火炬，然后通过长途接力，于奥运会开幕前一天将火炬送达举办城市；淘汰：除去差的，保留好的。这里指运动中的淘汰赛，采用逐步淘汰参加者以决定有限名次的方法。参加者按一定的组合进行比赛，负者被淘汰，胜者继续比赛，争夺冠亚军；筛选：筛是一种用以分离粗细颗粒的设备。筛选是作物或树木选种方法之一，用筛孔大小和形状不同的种子筛，筛除种子中夹杂物、秕粒和小粒种子，以选出粒大饱满的优质种子。这里指在体育运动中通过比赛筛选出优秀的选手。</p>
<p>跨跃短跑，蹦跳撑竿。</p>
<p>跨跃：跨栏，田径运动项目之一，在规定的竞赛距离内每隔一定距离摆设栏架，运动员要跨过栏架跑到终点；短跑：短距离赛跑，赛跑分短跑、中跑、长跑和超长距离赛跑。短跑包括男女各 100 米、200 米、400 米，少年 60 米，比赛时分道进行，通常用蹲踞式起跑，对发展速度有良好作用；蹦跳：指田径运动项目中的跳高、跳远等。跳高有立定跳高和和急行跳高之分，急行跳高有跨跃式、剪式、滚式、俯卧式和背越式等过竿姿势，由助跑、起跳、腾空和落地四个部分组成，技术的关键在于正确而迅速的起跳，跳高可发展弹跳力和灵活性。跳远有立定跳远和急行跳远之分，急行跳远有蹲踞式、挺身式、剪式（走步式）等空中姿势，均由助跑、起跳、腾空和落地四个部分组成，技术的关键在于快速助跑结合正确有力的起跳，跳远可以发展弹跳力和速度；撑竿：即撑竿跳高，田径运动项目之一，运动员双手握住一根竿子，经过快速的助跑后，借助竿子反弹的力量，使身体腾起，跃过横竿。这两句泛指各种走、跑、跳等田径运动项目。</p>
<p>铁饼标枪，垒足排篮。</p>
<p>铁饼、标枪为两项投掷类的田径运动项目。垒足排篮：指垒球、足球、排球、篮球四项球类体育运动项目。铁饼：运动员一手平挽铁饼，转动身体，然后投出；标枪：运动员经过助跑后，把标枪投掷出去；垒球：球场呈直角扇形，设有四个垒位，分两队比赛，每队 9 人，比赛分七局进行。垒球运动适合在女子和少年中开展；足球：球用皮制，内装橡皮胆，圆周 68～71 厘米，重 396～453 克。球场长 90～120 米，宽 45～90 米，两端中央装有球门。比赛分两队，每队 11 人，其中前锋、前卫、后卫 10 人，守门员 1 人。除守门员在规定的区域内可以用手外，其他运动员主要用足踢球或做其它动作。比赛 90 分钟，分上下两半时，以将球射入对方球门多者为胜；排球：球用皮制，内橡皮胆，圆周 65～67 厘米，重 250～280 克。球场长 18 米，宽 9 米，中间横球网，网高男 2.43 米，女 2.24 米。比赛分两队，每队 6 人，各占半个场区，运用发球、垫球、传球、扣球、拦网等技术和战术，相互攻守。以球在对方区域内落地而得分；篮球：球用皮制，内装橡皮胆，圆周 75～80 厘米，重 600～650 克。球场长 26 米，宽 14 米，两端中央装有球架，在遮板上装铁圈，离地 3.05 米，圈上挂线网，作球篮。比赛分两队，每队五人，中锋一，前锋、后卫各二。运用传球、运球、投篮及抢截等技术和战术，相互攻守，把球投入对方球篮得分。比赛 40 分钟，分上下两半时，以得分多者为胜。</p>
<p>汽车拉力，驾舢驶帆。</p>
<p>汽车拉力：即汽车拉力比赛项目；舢：舢舨，近海或江河上用桨划的小船，一般只能坐两三个人；帆：挂在桅杆上的布篷，可以利用风力使船前进。帆在这里指帆船、帆板等。驾舢驶帆指各种船、艇、帆船、帆板等比赛项目。 刀锤棍棒，钩爪杖鞭。 刀、锤、棍、棒、钩、爪、杖、鞭：均为中国传统武器，这里以此代表中国武术的几项传统比赛项目，各以使用器具的不同而分为不同的类项。</p>
<p>动静迂回，摔跤击拳。</p>
<p>迂回：绕向敌人后方的作战行动。目的是攻击敌后方薄弱部位，或断敌退路、阻敌增援，协同正面部队歼敌。这里将军事术语用于体育比赛；摔跤：体育比赛项目。两人徒手相搏，按一定规则，力求摔倒对手。中国古代称为角抵、角力、相扑、争跤等，清代始称“摔跤”；击拳：即拳击，体育比赛项目。运动员双手戴着拳击手套，按一定的姿势、步法和拳法，互相击打对方头部自眉、耳以下的脸面和身体正面的各个部位。</p>
<h2 id="军事（26）"><a href="#军事（26）" class="headerlink" title="军事（26）"></a><strong>军事（26）</strong></h2><p>宿营扎寨，枕戈待旦。</p>
<p>宿营：军队执行任务途中的临时住宿，分为舍营（在房舍住宿）和露营。宿营扎寨就是途中宿营时搭建临时帐篷营寨；戈：古代兵器，横刃，用青铜或铁制成，装有长柄，这里泛指一切兵器。旦：天亮。枕戈待旦就是枕着兵器以待天明，谓杀敌报国心切，一刻不懈。</p>
<p>岗哨戎诫，挎锐披坚。</p>
<p>岗哨：设置岗哨以警戒敌人。戎：军事、军队。岗哨戎诫即站岗放哨以警戒敌人；挎锐披坚：锐指武器，坚指铠甲，挎锐披坚即全副武装。</p>
<p>帅旗挺拔，训士率演。</p>
<p>帅旗：绣着军队主帅姓氏的大旗，这里统指军旗；训士率演：训练士兵，率领士兵操演军事战术。</p>
<p>盘踞较劲，擎帜呼喊。</p>
<p>盘踞：亦作磐踞、蟠据，谓把持据守，势力深固；较劲：双方对峙；擎帜呼喊：擎就是举，帜即旗帜，擎帜呼喊即摇旗呐喊。</p>
<p>更迭撤离，阻挡御拦。</p>
<p>更迭撤离：不断撤离住处，更换营地；阻挡御拦：阻击抵御敌人。</p>
<p>些许骚扰，伪装遮掩。</p>
<p>骚扰：扰乱，使不安宁；伪装：为隐蔽自己和欺骗、迷惑敌人所采取的各种隐真示假措施。包括隐蔽真目标，设置假目标，实施佯动，散布假情报和封锁消息等。主要分天然伪装和人工伪装两种，天然伪装主要是利用地形、天候、气象等自然条件隐蔽军事目标和军事行动。人工伪装手段有迷彩伪装、植物伪装、灯火伪装、音响伪装、烟幕伪装、水声伪装、设置遮障和假目标等；遮掩：遮蔽掩盖。这里遮掩是对伪装的诠释。</p>
<p>稍纵即逝，竟忽瞬暂。</p>
<p>稍：本义为禾末，引伸为小、微意；纵：放纵；即：就；逝：失去，流失；瞬、暂：均形容时间很短。这两句是说应及时抓住有利战机，争取主动；稍稍放纵、大意或犹豫，就会失去有利时机。</p>
<p>迢递驭骑，靶轰州县。</p>
<p>迢递：远貌。驭骑：驾驭战马。迢递驭骑意为远距离骑马作战；靶：靶子、目标。靶轰州县意为以州县为攻击轰炸目标。</p>
<p>耗损酬饲，迈历委艰。</p>
<p>耗损：消耗、损失；酬饲：酬即报酬，饲是喂食、给人吃，酬饲在这里指军队的给养供应；迈：远行、前进；历：经过、越过；委艰：确实很艰难、险恶。这两句是说即使多耗损一些物资给养，经受长途行军的艰难困苦，也要抢占有利位置，掌握军事主动权。</p>
<p>趁却佯攻，构筑壕堑。</p>
<p>佯攻：假装进攻。制造假象以欺骗和迷惑敌人的作战行动；壕堑：即堑壕，沿阵地正面挖掘的供战斗用的壕沟。壕内构筑有射击、观察、掩蔽、排水、路标和进出口等设施。平面形状一般为曲线形或折线形，其深度按人体平均身高确定，分为跪射、立射和加深堑壕三种，用于保障作战部队的射击、观察、隐蔽和行动。</p>
<p>擒敌破阵，调派遣返。</p>
<p>擒：捉拿；破：冲开、攻下；阵：古代战术用语，指作战队伍的行列或组合方式。这里指军事阵地，即为进行战斗，兵力兵器所占领或准备占领的位置。通常构筑各种工事，作为部人作战的依托；调派遣返：即往返调动派遣。</p>
<p>垢卸焚址，盔甩烬焰。</p>
<p>垢卸：即卸垢。垢意为污秽、肮脏，这里指多余、无用之物；焚址：焚，即焚烧。址指营址。焚址即烧掉营寨；盔：盔甲，盔甩即甩盔，甩掉盔甲。&#96;这两句意为丢弃辎重杂物，毁掉营盘兵寨，轻装上阵，与敌人决一死战。</p>
<p>遏追堵截，伏剿全歼。</p>
<p>遏：遏制、阻止；堵截：堵塞、阻断；伏：埋伏、伏击；剿：征剿、灭绝；歼：消灭、杀尽。遏、追、堵、截、伏、剿、歼均为军事战术。</p>
<p>另召崭旅，蜕衰勿厌。</p>
<p>旅：指军旅、军队；蜕：蜕变；衰：衰弱。这两句意为对另召的新军新兵，要不厌其烦地训导操练，促其蜕变，由衰弱变为孔武刚强。</p>
<p>碉堡摧毁，拥挤逃窜。</p>
<p>碉堡：俗称“炮楼”。供观察、射击、驻兵用的建于地面上的多层工事。通常为二到三层的砖石或混凝土结构，有圆形、方形和多角形等；摧毁：用强力破坏、毁坏；拥挤：人或车船等紧紧地挤在一起；逃窜：逃跑流窜、溃散奔逃。这两句意为战斗中一方的碉堡一旦被摧毁，里边的兵员必将拥出逃窜。</p>
<p>俘虏缴械，胜败前沿。</p>
<p>俘虏：战争中活捉的敌方从事战争的人员。即战俘；缴械：解除武装、把武器交给敌方；胜败：胜利或失败；前沿：防御阵地最前面的边沿。通常指防御阵地第一道堑壕和最前面的诸火力点的连线。一般选择在利于我防守而不利于敌进攻的有利地形上。被敌人捕获就只好交出枪械武器当俘虏，胜败都由双方在前沿阵地的决战来决定。</p>
<p>枉允肯否，咀嚼凯宴。</p>
<p>惨遭牺牲，素裹席卷。</p>
<p>枉：徒然、白费；允：公平；肯否：肯定或否定；咀嚼：含在嘴里细细嚼以使烂，这里指吃喝；凯：凯旋，打仗得胜后返回；宴：宴席，有许多人出席,常常为宴请某人或为纪念某事而举行的酒席；惨：悲痛、伤心；遭：受到、遭受，多指碰到不幸的事；牺牲：原意指供祭祀用的纯色整体牲畜和供盟誓、宴享用的牲畜，引申为坚持信仰而死；素：没有染色的白色丝绸绢布；席：用芦苇、席草和竹子、高粱杆篾片编织的铺垫用具。这几句意为旁人评价战争，不论是肯定或否定，都是枉然。凯旋的一方一定会摆设宴席庆贺胜利。那些在战斗中牺牲的人或白布裹或草席卷，埋葬在刚结束战斗的地方。</p>
<p>坟棺尸闹，魂魄寝眠。</p>
<p>坟：坟墓，安葬死者的坟头与墓穴；棺：棺材，盛载尸体以备埋葬的箱匣；魂魄：旧指附于人体的精神灵气，俗称人体有三魂七魄。</p>
<p>活着祈祷，死则祭奠。</p>
<p>活着：这里指还活着的人；祈祷：向神祈告求福；祭奠：为追念死者并安抚其在天之灵而举行仪式。这两句是说活着的人祈祷求福，祭奠死者，让死者安息，活者平安。</p>
<p>您保阀阅，我佑殡殓。</p>
<p>阀阅：即仕官人家自序功状而树立在门外左边的柱子，以此代指有权势的贵族和官宦人家；殡殓：为死者更衣下棺，准备埋葬。这里代指盛殓殡葬诸项事谊。</p>
<p>檄悼撰讫，佛陀绎传。</p>
<p>檄：檄文，用于晓谕、征召、声讨，特指声讨的文告；悼：悼文，哀悼死者的文章；撰：写作；讫：终了、完毕；佛陀：佛教的创始人，姓乔答摩，名悉达多。佛陀简称为佛,其意为“觉悟者”，因此，佛陀变为对悉达多的称呼。佛陀生于释迦族，故又名释迦牟尼。这里泛指一切佛教徒；绎：本义为抽丝，引申为演绎著述。这两句意为征讨敌人要写檄文，纪念战友要写悼文。求佛陀念经祝福，让世人著书传颂。</p>
<p>廉奉殉职，奖功颁衔。</p>
<p>组织筹备，抚恤申签。</p>
<p>廉：正直、刚直、品行方正；奉：奉公，遵守法度；殉职：在职人员为公务而献身；奖功：奖励有功之人；衔：指军衔，区别军人等级、表明军人身份的称号及标志。古今中外的军队都设军衔，现代一般分为元帅 (大主帅)，将官 (大将、上将、中将、少将、准将)，校官 (大校、上校、中校、少校)，尉官 (大尉、上尉、中尉、少尉、准尉)，军士 (上士、中士、下士)，兵 (上等兵、列兵或一等兵、二等兵)；组织：按照一定的目的、任务安排事物使有系统或构成整体；筹备：筹措预备；抚恤：对因战或因公致伤、致残和牺牲以及病故人员的家属给予物质上的帮助和精神上的安抚；申：申请。这几句意为对那些廉洁奉公、为国为公而殉职的将士官兵，要论功行赏、褒奖鼓励，并追认授衔。还要组织筹备对其亲属的抚恤慰问，做好申请签发等事宜。</p>
<p>部属僚员，涕泪潸然。</p>
<p>部属：部下、下属；僚员：一起作官的人，也指贵族或大官的随员或职员；涕泪：眼泪；潸然：泪流貌。这两句意为那些牺牲将士的部属僚员面对他们的亲属，面对悲伤的场面，都会黯然神伤，涕泪交流。</p>
<p>彪炳铭册，炫烁灿烂。</p>
<p>彪炳：照耀、文彩焕发的样子；铭：。本义为在器物上雕刻文字，也泛用于为着确立持久的或公开的记载而刻写或题写的文辞；册：古时称编串好的许多竹简，现在指装订好的各种书本；炫烁：。发光的样子，闪亮、艳丽；灿烂：在这里与炫烁同义，光彩鲜明耀眼。这两句意为死者的功绩英名将铭碑刻记，彪炳史册，使之流芳千古，光耀万世。</p>
<h2 id="名人（4）"><a href="#名人（4）" class="headerlink" title="名人（4）"></a><strong>名人（4）</strong></h2><p>格林童话，伊索寓言。</p>
<p>格林童话：德国民间童话集，作者是德国人雅科布·格林（1785<del>1863）和威廉·格林（1786</del>1859）兄弟俩。格林兄弟同在马尔堡大学学习法律，后又一起在图书馆工作，都任格根廷大学教授。1841 年二人同时成为柏林科学院院士。格林兄弟从 1806 年开始深入民间搜集传说和童话，后来将这些长年累月搜集到的材料经过整理、研究，合编成《儿童与家庭童话集》，俗称《格林童话》，共收童话 216 篇，如《灰姑娘》、《白雪公主》、《勇敢的小裁缝》、《不来梅城的乐师》等都是其中的名篇。格林童话是欧洲各国中搜集、编写最早，篇幅最多，系统性最强的一部童话集。其中不少故事反映了日尔曼民族的质朴、幽默、机智和勇敢，揭示了人民美好的内心世界和崇高的道德境界。故事情节曲折，但不离奇，叙述朴素，却不单调，不少故事富于诗意；伊索寓言：古希腊的寓言故事集，在公元前 6 世纪左右，古代希腊曾流传着几百则短小的寓言故事，相传作者为伊索。伊索原是奴隶，由于才智出众，善讲寓言故事，受到主人的赏识，被解放为自由民，但今天的《伊索寓言》是经过后人改写而成的。《伊索寓言》共收集三四百个小故事，主角大多是拟人化的动物。作者通过描写动物之间和人与动物之间的相互关系，反映当时的社会生活，揭示一些道理，给人以启迪和警示。《伊索寓言》在中国流传很早，在明代就有了中译本，当时的译名叫作《况义》，清代又有英汉对照本《意拾蒙引》，清末翻译家林纾第一个使用《伊索寓言》的译名。《伊索寓言》在中国的流传也很广，如《狼和小羊》、《狮子和狐狸》、《农夫和蛇》、《猫和鸡》、《农夫的儿子们》、《龟兔赛跑》等名篇几乎家喻户晓。</p>
<p>莎翁托氏，福摩探案。</p>
<p>莎翁：即英国的剧作家莎士比亚。莎士比亚（1564<del>1616）生于英国一个富裕市民家庭，从小对戏剧有兴趣，在学校里接触到古罗马的诗歌和戏剧。后因家庭破产，曾到剧院门前为看戏的绅士管马匹，不久他当了地位很低的剧院杂役，进而成为演员和剧院股东。随着生活和舞台经验日益丰富，他开始了戏剧创作活动。凭着非凡才华和不懈努力，他一生创作了 37 部戏剧、两部长诗、154 首十四行诗，特别是悲剧和喜剧，是世界文苑中少有的艺术珍品，马克思曾把莎士比亚与古希腊悲剧作家埃斯库罗斯并称为“人类两个最伟大的戏剧天才”。莎士比亚的作品中，足以代表他最高成就的是四大悲剧：《哈姆莱特》写丹麦王子哈姆莱特为父复仇而遭毁灭的故事。《奥赛罗》写摩尔人贵族奥赛罗由于多疑和嫉妒，听信谗言，掐死妻子后又悔恨自杀。《李尔王》描写一个专制独裁的昏君，由于刚愎自用遭受一场悲剧的故事。《麦克白》则揭示了个人野心对人所起的腐蚀作用。另外悲喜剧《罗密欧与朱丽叶》、喜剧《威尼斯商人》等也很负盛名；托氏：指俄国的伟大作家列夫·托尔斯泰。托尔斯泰（1828</del>1910）生于一个伯爵家庭，后承袭爵位。16 岁进喀山大学东方系学习，后转法律系，受到法国启蒙思想的影响，对沙皇专制制度产生不满，退学回乡经营田庄，1851 年去高加索服役并开始创作。晚年放弃贵族生活，却与夫人产生矛盾，后离家出走，病逝于一个小火车站。托尔斯泰著作等身，《托尔斯泰全集》共 90 卷，约 1000 万字，囊括了 19 世纪以前人类创造的一切文学体裁。其创作数量之多，体裁之丰富，是文学史上所罕见的。他的创作是 19 世纪俄国社会生活的百科全书，像镜子一样真实反映了 1861 年农奴制改革到 1905 年俄国社会中的一切矛盾和巨大的社会变动，既表现了革命农民的力量和威力，也表现了农民的弱点和局限。《战争与和平》、《安娜·卡列尼娜》、《复活》这三部长篇小说最负盛名，《战争与和平》以 1812 年俄国卫国战争为中心，以四大贵族家庭在战争与和平年代里的生活为情节线索，反映了 1805 年至 1820 年的重大历史事件，被公认为“世界上最伟大的小说”。《安娜·卡列尼娜》通过安娜的悲剧和列文的经历，反映俄国农奴制改革后的社会政治、经济、道德等方面的矛盾，其心理分析和景物描写的技巧，“在欧洲文学中没有一部同类的东西可以与它相比”；福摩探案：即英国作家柯南道尔（1859～1930）的系列侦探小说集——《福尔摩斯探案》。福尔摩斯全名是歇洛克·福尔摩斯，为其小说中虚构的人物，如《血字研究》、《回忆录》、《四签名》、《冒险史》、《巴斯克维尔的猎犬》、《归来记》、《恐怖谷》、《最后致意》、《新探案》等，都是以福尔摩斯为主角，以华生作陪衬，解决各种疑案。柯南道尔由于受过高等医学教育，他把自己所学的化学、解剖学和其它科学知识，运用于福尔摩斯这一艺术形象塑造上，小说情节曲折复杂，场面紧张惊险，以逻辑推理而破案，创立了推理侦探小说的流派。</p>
<p>但丁歌德，伽丘十谈。</p>
<p>但丁：中世纪末的意大利诗人。但丁（1265<del>1321）生于意大利佛罗伦萨的一个小贵族家庭，早年学习拉丁文、诗学、修辞学，并潜心研究古典文学，同时对绘画、音乐、哲学等也颇有造诣，是当时最博学的人之一。曾因政治上受排挤而被判处终身流放，至死没有能回到故乡。在流放地，但丁完成了长诗《神曲》的创作。《神曲》是欧洲文学史上具有划时代意义的巨著，共有一万四千多行，分《地狱》、《炼狱》、《天堂》三部。诗人采用中世纪流行的梦幻文学形式，自叙在人生旅程的中途，陷入一片黑色森林之中，迷失了方向。正想往上攀登一座秀美的山峰时，忽然被象征淫欲、强权和贪婪的豹、狮、狼拦住去路。危难之际，古罗马诗人维吉尔前来援救，引导但丁游历了地狱、炼狱和天堂。全诗的情节充满寓意，表现人类从迷惘和错误中经过苦难、考验，达到真、美、善境界的历程。《神曲》是用意大利俗语写成的，对解决意大利文学用语问题和促进意大利民族语音的统一起了很大的作用，后人把但丁誉为意大利第一位民族诗人；歌德：（1749</del>1832）德国诗人、剧作家、思想家。生于美因河畔法兰克福一个富裕市民家庭，曾获法国斯特拉斯堡大学法学博士学位。政治上反对封建割据，渴望德意志统一，主张自上而下的社会改革。他从少年时代就爱好文艺，早期重要作品有历史剧《葛兹·冯·伯利欣根》，书信体小说《少年维特之烦恼》。他延续近 60 年时间写成的长篇诗剧《浮士德》，取材于德国 16 世纪的民间传说，主人公浮士德原是一个跑江湖的魔法师，懂得炼金术、星相术。诗剧描写中世纪的博士浮士德外出交游时遇到了魔鬼靡非斯特，两人订下契约，魔鬼 甘愿做他的仆人，帮助他享尽人间乐趣，如果浮士德一旦感到满足，便是魔鬼的胜利。在魔鬼的帮助下，浮士德返老还童，开始了奇特的经历。但浮士德始终不为个人的幸福而满足，即使双目失明，成了百岁老人之后，仍然认为人应当不断地去开拓生活和自由。塑造了一个在人间不断追求最丰富的知识、最美好的事物、最崇高的理想的人物形象，体现了新兴资产阶级追求真理、自强不息的精神，使作品成为 18 世纪末 19 世纪初整个欧洲的艺术缩影。作品构思宏伟、内容复杂，古往今来，人物众多，组成一幅千变万化的历史画卷。与荷马的史诗、但丁的《神曲》、莎士比亚的《哈姆莱特》并列为欧洲文学的四大名著；伽丘十谈：指意大利文艺复兴的先驱、文学家乔万尼·薄伽丘（1313～1375）和他的作品《十日谈》。薄伽丘年轻时曾学习法律，并出入宫廷，反对封建专制，拥护共和政体。在文学上，写下了一系列传奇故事、史诗、叙事诗、十四行诗、短篇小说、论文等，同中世纪的禁欲主义和天主教会进行了无畏的斗争。《十日谈》是他最出色的作品，是一部别具风格的现实主义短篇小说集。作品以 1348 年佛罗伦萨鼠疫大流行为背景，叙述 10 个男女青年来到郊外别墅避难，他们每天每人讲一个故事，10 天共讲了 100 个故事，所以书名题为《十日谈》。书中的许多故事取材于历史事件、中世纪的传说和东方故事，也有的是当时的真人真事。大胆揭露了天主教会僧侣的伪善、奸诈、堕落，鲜明提出反教会、反神权的主张，提出“人类是天生一律平等”，否定了中世纪的禁欲主义，倡导人性的解放。《十日谈》为意大利散文艺术奠定了基础，同时开创了短篇小说的形式。</p>
<p>培根牛顿，爱因斯坦。</p>
<p>培根：即英国哲学家，英国唯物主义和现代实验科学的始祖弗兰西斯·培根（1561～1626）。剑桥大学毕业，历任律师、下院议员、掌玺大臣、大法官，受子爵。提出“假相”说，认为经院哲学使人与自然隔绝，束缚于教条和权威之下，不能获得真正的知识。主张打破“假相”，铲除各种幻想和偏见。主张“双重真理说”，提出“知识就是力量”。认为掌握知识的目的是认识自然，以便征服自然。指出自然界是物质的，物质与运动不可分离，一切知识来源于感觉。在美学上，强调想像虚构、理想化、动态美与艺术家的灵心妙运，开浪漫主义的先河。在教育上，强调学校应传授百科全书式的知识。主要著作有《论科学的价值和发展》、《新工具》、《新大西岛》等；牛顿：(1642～1727) 英国物理学家和数学家，被誉为“力学之父”，是世界历史上对人类文明作出划时代贡献的少数科学家之一。他出生于英国林肯郡农村，剑桥大学毕业。在数学、光学、天文学、力学等领域都有划时代的发现，并写出《自然哲学的数学原理》等巨著。在牛顿之前，人们普遍认为天上物体的运动规律和地上物体的运动规律是不同的，一个做圆运动，一个做直线运动。但牛顿证明，不论是天上还是地上的物体，都要遵循惯性定律、质点运动定律和作用与反作用定律，即所谓的“牛顿三定律”运动。他还明确指出，推动行星绕日运动的是天体之间存在的万有引力。运用牛顿三定律不仅计算出了行星围绕太阳的运动，卫星围绕行星的运动，还说明了地面上物体的降落运动和抛射运动，以及海洋潮汐发生的原理，并能确定慧星的轨道和运转周期。牛顿还最早提出发射人造卫星的设想。这些成就标志着牛顿成功建立了近代力学和天文学。在数学上，牛顿和莱布尼兹同时发明了微积分，并且把微积分和力学结合起来，用微分方程的形式来表示运动物体受力和所产生的加速度之间的原因—结果关系。牛顿还发现了光的本性，他利用一只玻璃三棱镜证明了白色光线实际上是由红、橙、黄、绿、蓝、靛、紫七种不同颜色的光线混合而成的，而且因为不同颜色光线具有不同的折射率，所以形成了雨后美丽的彩虹。牛顿还提出光是高速前进的粒子流的学说，引起科学界热烈的讨论；爱因斯坦：（1879～1955）自伽利略、牛顿以来 20 世纪最伟大的科学家、思想家，美籍德国犹太人。出生于德国乌耳姆市，父母都是犹太人。16 岁就开始思索空间、时间的本质，并写出一篇论文。1905 年，26 岁的爱因斯坦在瑞士专利局当职员，这一年他连续发表五篇论文，其中关于测定分子大小的论文使他获得博士学位。关于光电效应的论文指出光不仅有众所周知的波动性，还有粒子性，这一发现成为量子力学的主要依据之一，他因此获得 1921 年的诺贝尔奖金。关于质量和能量具有相当性的论文预示着利用原子核巨大能量的可能。而最重要的是那篇关于时间、空间都要随运动状态发生变化的论文，它冲破牛顿时代以来形成的时间、空间绝对不变的旧观念，宣告象征科学新时代的狭义相对论的诞生。1916 年，爱因斯坦又提出广义相对论，这一理论认为在像太阳那样的巨大天体附近，空间—时间会发生弯曲。1919 年一支科学考察队证实了广义相对论关于星光偏折的大胆预言。爱因斯坦一生在宇宙学、统一场论、物理学哲学问题等许多方面开展了深入研究，他的思想至今仍指导着前沿学科前进的方向。</p>
<h2 id="品行（12）"><a href="#品行（12）" class="headerlink" title="品行（12）"></a><strong>品行（12）</strong></h2><p>推贤荐材，睹貌辨行。 推、荐：介绍好的人或事物希望被任用或接受；贤：有德行、多才能；材：本义指木材、木料， 泛指原料、材料，这里通“才”，即才能、能力；睹：本义为见、看见，也作察看；貌：指面容、相貌、容貌，即外表的形象、外观，也指神态、面部神情；辨：判别、区分、辨别；行：本义为走路、行走，这里指人的行为、举动、动作、举止，即人物的行止、踪迹和底细等。 觉悟先知，圣色从容。 觉悟：由迷惑而明白，由模糊而清楚，也指对道理的认识；先知：指认识事物在众人之前，觉悟早于别人的人，宗教中指受神启示而传达神的意旨或预言未来的人；圣：聪明、才智胜人；色：本义为脸色、面色，这里指神色、神态；从容：从容不迫，行止舒缓得度，无急迫之态，从容自若，进退举止自然冷静、错落有致。 纯朴宽厚，侠烈尽忠。 纯朴：纯正朴素；宽厚：宽容厚道；侠：指见义勇为、肯舍己助人的性格、气质或行为；烈：刚直、坚贞、光明、显赫，也指美好、优美；尽忠：忠于国家，为国家尽心竭力，不惜牺牲一切。 耿直肃仪，襟怀袒诚。 耿直：刚毅正直；肃：庄重、严肃；仪：容止仪表；襟怀：胸襟、胸怀、心胸；袒诚：即坦诚，坦白真诚，喻人心地正直、心胸开阔，诚实无诈。 谄媚狡猾，机敏慧颖。 诌媚：用卑贱的态度向人讨好；狡猾：也作狡滑，诡诈不可信，狡诈刁钻；机敏：机警敏锐，对情况的变化觉察得快；慧：聪明，有才智；颖：聪敏。慧颖即颖慧，指人聪颖，聪慧，聪明而有天才 (多指少年)。 懈怠懒惰，拙笨碌庸。 懈怠：松懈懒惰；懒惰：偷懒，不喜欢费体力或脑力；拙笨：笨拙，手脚不灵活；碌庸：即庸碌，平庸而无所作为。 愚昧糊涂，偏才至聪。 愚昧：愚蠢而不明事理；糊涂：人头脑不清楚或不明事理。也指事物混乱不清；偏才： 指在某方面有才能的人；至聪：至意为极、最，聪为聪明、有才智。至聪就是极为聪明，非常聪明。 羞涩拘束，杰健悍雄。 羞涩：心里害羞而举动拘束不自然；拘束：不自在，拘谨而显得不自然；杰：杰出，才智出众的人；健：强有力、勇猛，也指人敏捷、高明、有才能；悍：勇猛，强劲、坚实；雄：强健有力，威武，杰出，也指杰出的人物。 恭畏惧怕，缄默持重。 恭：恭敬，谦逊有礼；畏：害怕，敬服；惧怕：恐惧，害怕；缄默：闭口不言；持重：行事慎重，谨慎稳重，不轻浮。 骄奢傲慢，怯懦惶恐。 骄奢：即骄奢淫逸，荒淫无度、骄狂专横；傲慢：看不起人，对人怠慢没有礼貌；怯懦：胆小懦弱；惶恐：惶惧惊恐。 猜疑诡秘，威严毅勇。 猜疑：没有根据地怀疑别人，或怀疑别人做事针对自己；诡秘：隐秘不为人知；威严：威武而严肃；毅勇：坚毅勇敢。 超逸独居，恬淡匀宁 超逸：超然脱俗，俊逸高雅；独居：长期的、独身一人居留；恬淡：指人的性格恬静，恬静淡泊；匀宁：长期安宁、平安。</p>
<h2 id="休闲（8）"><a href="#休闲（8）" class="headerlink" title="休闲（8）"></a><strong>休闲（8）</strong></h2><p>休闲退优，涣虑受逍。 休闲：余暇时的休息和娱乐；退：旧时指为官者辞去官职，退隐。现在一般指各行各业的干部职工到一定年龄时，退职休养；优：原意为充足、富裕或优良、美好。这里意为安闲、悠闲、安逸，如优游、优逸、优容、优悠；涣虑：排散忧虑；逍：逍遥，优游自得。 拒宾疏客，忧谢欢招。 拒宾疏客：拒绝疏远宾客；忧谢欢招：意为心情不好的时候就谢绝来客打扰，高兴的时候就招来朋友欢聚。 把盏讲趣，倚床读晓。 盏：小杯子；晓：天亮。这两句意为端着酒杯谈讲趣事，靠在床上读书到天亮。 游景筏渡，迹绝喧嚣。 游景筏渡：游览风景泛舟划船。筏，小船；喧嚣：声音嘈杂。迹绝喧嚣是说居住到偏僻安静之处，踪迹远离热闹嘈杂之地。 茂冠蔽枝，莽园出条。 茂冠蔽枝：树冠茂盛枝条繁密；莽：草木密生之状。莽园出条就是高大树木的枝条或葛藤伸出了园外。 碧岭滴翠，落叶飘摇。 碧岭：青绿色的山岭；滴翠：极言翠绿的程度，像要滴下水来的样子；飘摇：飘荡摇摆。 心澄空透，雅座去燥。 澄：清澈。空透：空灵透澈。心澄空透意即心灵纯净得一眼可以看到底；雅座：比较文雅、精致而舒适的房间及其座位。燥：干燥，这里指人体的燥邪之病，即民间常说的“上火”。雅座去燥意为精神愉快可以清除体内的邪火。 挥毫主就，佳句抒了。 挥毫：即挥笔；主：预示；就：完成，成功；佳句：诗文中精辟的语句；抒：发出、表达、倾吐；了：完毕、结束。这句是说提笔著文，用奇妙的文词、精辟的语句来表达、抒发自己的思想和情感。</p>
<h2 id="治学（6）"><a href="#治学（6）" class="headerlink" title="治学（6）"></a><strong>治学（6）</strong></h2><p>谣决淆或，是非确断。 谣：谣传。淆：混淆。谣决淆或意为决疑谣传，澄清混淆；是非：对与错，正确和谬误。确：明确。断：论断。是非确断即辨别是非，明确论断。 翻译授课，考究钻研。 翻译：用一种语言文字来表达另一种语言文字；授课：教课，传授学业、技艺和知识；考究：查考研究；钻研：深入研究。 误错耽搁，犹豫岂敢。 误错：即错误，不正确，与客观实际不符合；耽搁：耽误、拖延；犹豫：迟疑不决；岂敢：怎么敢，不敢。犹豫岂敢意为办事怎么敢犹豫不决呢！ 校讹编辑，页稿汇篇。 校讹：订正、改正文字中的错误；编辑：收集资料，整理成书；页稿：一页一页的文稿；汇篇：收集资料，编辑成篇。 故谜梗概，版载登刊。 故谜：故事与谜语，故事指文艺作品中用来体现主题的情节，谜语是暗射文字、事物让人根据字面说出答案的隐语；梗概：粗略、大概、大略的内容、要点或讨论题的主要原则；版：即版面，报刊、书籍的页面；刊：指出版物，各种杂志的总称。 专题删节，普遍浏览。 专题：特定的专项论题；删节：删去文字中次要的或不必要的部分，使文字缩短；普遍：全面，广泛；浏览：粗略地看一遍。</p>
<h2 id="形数（6）"><a href="#形数（6）" class="headerlink" title="形数（6）"></a><strong>形数（6）</strong></h2><p>点线面段，球弧椭圆。 点线面段：点、线、面、段在这里均为几何名词。点是某一位置的标志，没有大小之分。线指一个点任意移动所构成的图形，只研究它的长短，不考虑其宽窄、厚度，但分粗、细、实、虚，有直线和曲线两种。面是体的界限，有长短、宽窄，不考虑其厚度，有平面和曲面。段即线段，线上两点间的有限部分。面和面相交于线，线和线相交于点。点动成线，线动成面，面动成体；球弧椭圆：球、弧、椭、圆在这里均为几何名词，也是几何图形。球是以半圆的直径为轴，使半圆旋转一周而成的立体，这个半圆的圆心叫做球心，连接球心和球面上任一点的线段叫球的半径，连接球面上两点且经过球心的线段叫做球的直径。圆是平面内到定点的距离等于定长的点的集合，定点就是圆心，定长就是半径。圆上任意两点的部分叫做弧，也叫圆弧，大于半圆的弧叫优弧，小于半圆的弧叫劣弧，任何一个从直线或水平上的偏离或弯曲，都可表现为一个弧。椭即椭圆，一种规则的卵形线，特指平面两定点 (焦点) 的距离之和为一常数的所有点的轨迹。 菱锥棱角，凸凹顶尖。 菱锥棱角：菱、锥、棱、角均为几何名词，也是几何图形。菱形是由四条相等的直线构造两个锐角和两个钝角组成的四边形。锥体是由圆的或其它封闭平面基底以及由此基底边界上各点连向一公共顶点的线段所形成的面所限定的立体。棱柱是一种多面体，其中有两个面彼此平行，其余诸面则为平行四边形。角是两条直线相交于一点所形成的形状或所夹的空间，如锐角、钝角、直角；凸凹顶尖：均为几何图形。凸是高出周围的形状。凹是周围高、中间低的形状。顶是最上端、高峰点。尖是物体的末端，细削而锐利地方。 竖撇捺折，陡拱侧弦。 竖撇捺折：竖、撇、捺、折皆为汉字笔画名称，也是笔画的形状，加上横，是汉字的五种基本笔画。横是水平直笔画，形状为“一”。竖是直笔画，从上一直向下，形状为“|”。撇是向左斜下，形状为“丿”。 捺是由上向右斜下，近末端微有波折，形状为“ ”。折有横折和竖折，横折包括横折、横折钩、横折弯钩、横折提、横折折撇、横折折折钩、横折弯，写时先横后折。竖折包括竖折、竖折折钩、竖折撇，写时先竖后折； 陡：形容地形斜度很大，近于垂直；拱：形容形状耸起、隆起，弯曲成弧形，如建筑物呈弧形的拱桥、拱坝等；侧：形容物体倾斜的形状；弦：系在弓背两端的、能发箭的绳状物，中国古代称不等腰直三角形的斜边，连接曲线两端的直线。 冈洼型槽，窄路绰圈。 冈：山脊、山岭；洼：深池，低凹的地方；型：本义为铸造器物的模子，引申为类型、样式；槽：本义指四边高起、中间凹入的器物，表面上比较大比较长的凹痕也称槽，水流流经的水道也称槽；窄：狭小；绰：宽大、舒缓。 亩吨钧斤，个拾佰仟。 亩：中国土地面积市亩的通称，一亩约等于 667 平方米；吨：重量单位，公制 1 吨为 1000 公斤，2000 市斤；钧：中国古代重量单位，一钧等于 30 斤；斤：中国重量单位，现代规定一斤等于 500 克；个：通用个体量词，表示单独的人或物；拾：中国数词，玖加壹所得为拾，汉字数目“十”的大写 ，如: 陆柒捌玖拾；佰：中国数词，百的大写。十个十为一百；仟：中国数词，千的大写。十百为千。 尺寸厘秒，每只亿半。 尺寸：尺、寸均是量词，中国市制长度单位。尺亦称“市尺”，一尺等于十寸，西汉时一尺等于 0.231 米，今三尺等于一米。十分之一为一寸，30 寸等于一米。中国古代各个时期计量长度单位的标准不同，尺和寸的具体数值也有差异；厘：．长度单位，中国一市尺的千分之一。重量单位，中国一市两的千分之一。地积单位，中国一市亩的百分之一。利率单位，年利一厘按百分之一计，月利一厘按千分之一计；秒：多种计算单位。作为时间的计算单位，一分钟的六十分之一。作为弧和角的计算单位，一分的六十分之一。作为经纬度的计算单位，一分的六十分之一。作为古代的长度单位，一寸的万分之一。作为古代的容量单位，十撮为一秒；每：代词，各个；只：量词。也代表单数、奇数；亿：数目的名称，古代有时把十万叫亿，今以万万为亿，即以阿拉伯数字 100000000 标记的可数量；半：一半，二分之一。</p>
<h2 id="体态（8）"><a href="#体态（8）" class="headerlink" title="体态（8）"></a><strong>体态（8）</strong></h2><p>龙睛凤眼，秀眉斜弯。 龙睛凤眼：像龙形凤形的眼睛；秀眉斜弯：美丽秀气的、窄窄弯弯的眉毛。 樱口怡笑，胭脂隐现。 樱口怡笑：樱桃似的小嘴笑起来很和悦甜美。樱即樱桃，一种落叶小乔木，开粉红或白色小花，果实可食，味甘美适口，有俗语“樱桃好吃树难栽”。 樱桃果成熟时红色，很小，很好看，以此喻美女的口娇小而红润；胭脂：这里代指女性用的化妆品；隐现：不清晰地显现，隐隐约约显现出来。胭脂隐现是说女子脸上化的妆或浓或淡。 舒额弹腮，惺眸镶嵌。 舒额：舒即舒展，额是额头，人脸头发以下、眉毛以上的部分。舒额就是额头舒展，形容人兴奋、高兴时的神态；弹腮：弹，弹性。腮，脸颊、面容。弹腮是说脸蛋滋润好看；惺眸：惺即惺松，眸指瞳仁、眼珠，泛指眼睛。惺眸形容人刚睡醒时眼睛半睁半闭的样子，也形容少女因羞涩而眼睛微闭的模样；镶嵌：以物嵌入，作为装饰。这里说脸上因有眼睛而更加美丽好看。 嫦妞妩睫，炯奕幌辫。 嫦妞：即嫦娥，又作“姮娥”。传说中后羿的妻子，从人间飞升到月亮。后比喻美女；妩：即妩媚，姿态美好可爱；睫：即睫毛，眼睑边缘上的毛发；炯：光明、光亮，多形容眼睛明亮，如炯炯有神；奕：形容眼睛有神采；幌：挥动，摇晃；辫：指女孩子的发辫。 敖鼻单翘，坠耳双环。 敖鼻单翘：鼻子有点翘，显出很有个性；坠耳双环：双耳上坠着耳环。 纤手藕臂，软颈削肩。 纤手：指女子细而柔嫩的手；藕臂：像藕节一样的白嫩手臂；软颈：柔软的脖颈；削肩：即“溜肩”， 指人双肩向下垂斜的体态。古代女性以溜肩为美，平肩为丑。 乌发比臀，酥胸腰间。 乌发比臀：乌黑的头发垂至臀部。乌，乌黑。臀，屁股；酥胸：洁白润泽的胸脯；腰间：腰部，即人体或四足动物的胯上肋下的部分，分布在脊柱的两侧，介于髋骨和假肋之间。 修腿负躯，弓脚婷站。 修腿负躯：修长的双腿承负着健美的身躯。修，长；弓脚：即弓步，是丁字步的一种变形和发展，它是将丁字步的前腿向旁伸出后弯曲，后腿绷直，即前腿弓，后腿直。婷：美好貌，如娉婷、婷婷。</p>
<h2 id="妆扮（8）"><a href="#妆扮（8）" class="headerlink" title="妆扮（8）"></a><strong>妆扮（8）</strong></h2><p>沐浴洁身，梳妆乔扮。 沐浴洁身：洗澡沐浴，使身子清洁。沐浴，洗澡、洗头；梳妆：妇女梳洗打扮；乔扮：乔装打扮。 薄黛轻施，靓耀矫莲。 黛：青黑色的颜料，古代女子用以画眉。这里代指女子用的化妆品；靓：美丽、漂亮；矫：矫健、矫捷， 动作迅速、灵活，强壮有力；莲：金莲，旧指缠足妇女的小脚，这里代指女子的脚。 服绢饰佩，缤绫绣缎。 服绢饰佩：穿绢质衣服，佩戴各样首饰。绢，一种薄而坚韧的丝织物；缤绫：五彩缤纷的绫子。绫是一种细薄而有花纹的丝织品，一面光，像缎子，采用斜纹组织或以斜纹为底的提花组织,以桑蚕丝或与人造丝交织而成；绣缎：绣花的锦缎。绣是用彩色线在布帛上刺成花、鸟、图案等。缎是中国特产的质地厚密、一面光滑的丝织品。 雉翎并勃，婀娜妮曼。 雉翎：短尾鸟翅膀和尾巴上的长羽毛，可以用来装饰巾帽；勃：即勃勃，精神饱满、兴致勃勃；婀娜妮曼：轻盈柔美貌。 私恋旧侣，好娃阿丹。 恋：留恋，依依不舍；旧侣：旧时伴侣；好娃：美女；阿丹：英俊的小伙子。 赞叹称颂，宛若娥仙。 宛若：宛如，仿佛；娥仙：嫦娥与天上仙女。 情投系姻，欲静见缘。 情投：情投意合，双方思想感情融洽，心意相合；系：拴，系结；姻：姻缘，男女嫁娶。 转识迷性，苦乐恼烦。 转识：感觉、认识改变；迷性：本性迷失，失去了辨别、判断的能力；苦乐恼烦：痛苦、烦恼、高兴、快乐等情感。</p>
<h2 id="嫁娶（8）"><a href="#嫁娶（8）" class="headerlink" title="嫁娶（8）"></a><strong>嫁娶（8）</strong></h2><p>嘉偶婚配，衷恳悦己。 嘉偶：互敬互爱、和睦相处的夫妻；婚配：结婚、结亲；衷恳：无保留地、忠实的、热情的、真诚的；悦己：喜欢、爱慕自己的人。 做媒介绍，卿获娇媳。 做媒：介绍男女双方使其成婚；介绍：沟通使双方相识或发生联系；卿：古时夫妻或好朋友之间表示亲爱的称呼；娇媳：美丽可爱的媳妇。 哥嫂咨询，伙伴参议。 咨询：就某个问题跟别人商量；伙伴：也称“火伴”。古代兵制十人为一火，火长一人管炊事，同火者称为火伴。现在统称关系密切的同龄人；参议：参与议论，发表意见、看法。 爸妈恩准，爷奶评批。 恩准：开恩准许；评批：评价、判定。 叙述绵延，缓迟寻觅。 叙述：记载或讲述事情的经过；绵延：一个连着一个，接连不断；缓迟：徐缓、缓慢；寻觅：寻找、索求。 担抬扛搬，槌簧串艺。 槌：槌子，敲击工具，这里指鼓槌。簧：乐器中用以发声的薄片。这里以鼓、簧代指各种乐器；串艺：各种艺术形式串接在一起上演。这两句是说结婚时搬运嫁妆，请鼓乐、演艺班子演奏助兴。 炮震房宅，宣沸弄里。 炮：指爆竹，又叫鞭炮、炮仗；宣：通喧，喧闹；沸：声音喧闹或嘈杂、吵闹；弄里：即里弄，方言，指小巷、胡同。 铙钹咚呛，乐吹轿娶。 铙：铜质圆形的打击乐器，比钹大；钹：铜质圆形的打击乐器，两个圆铜片，中心鼓起成半球形，正中有孔，可以穿绸条等用以持握，两片相击作声；咚呛：象声词，形容锣鼓等打击乐器发出的声音；乐吹轿娶：是说男性娶亲时，喜乐吹奏，车轿迎娶。</p>
<h2 id="建筑（6）"><a href="#建筑（6）" class="headerlink" title="建筑（6）"></a><strong>建筑（6）</strong></h2><p>亭榭楼阁，寺庙殿廊。 亭、榭、楼、阁、寺、庙、殿、廊：是中国几种不同的传统建筑。亭，一种开敞的小型建筑物；榭，建在高土台上的敞屋，如水榭、舞榭，没有房间的庙堂也称榭；楼，即两层以上的房屋，建筑物的上层部分或有上层结构的也是楼，如城楼、钟楼等；阁，是传统楼房的一种；寺庙，佛、道等宗教活动之地，寺庙建筑不同于民间建筑，都有各自的特色；殿，古代泛指高大的堂屋；廊，屋檐下的过道或独立有顶的通道，如走廊、游廊。 蓬门荜户，丈室绿窗。 蓬门荜户，丈室绿窗：指下层百姓的房子住所。蓬与荜都是野草，蓬即飞蓬。蓬门荜户即用草编盖的房子门户；丈是中国市制长度单位，一丈等于十尺，丈室是说屋子不大；绿窗指窗户上爬满绿色藤类植物。 府第别墅，画栋雕梁。 府第别墅，画栋雕梁指富贵人家的豪华住宅。府第：上等房屋，为大住宅之称；别墅：指住宅外另置的园林游息处及其建筑物；画栋雕梁：也作雕梁画栋，指用彩绘装饰的很华丽的房屋。 庭院踏步，影屏幕障。 庭院：旧式建筑物阶前的空地；踏步：即台阶；影屏幕障：指建筑物中或庭院内作为屏障而设置的砖或木做的墙壁。 承尘藻井，篱笆柱桩。 承尘：室内床上的帐幕，也指屋内天花板，与藻井同意；藻井：中国传统建筑中顶棚上的一种装饰处理，做成各种形状，上有各种花纹、雕刻和彩画；篱笆：用竹、木、芦苇等编成的围墙或屏障；柱：建筑中竖立的用以支承梁、桁架、楼板等的柱形建材，一般为木材、石材，现在多用钢筋混凝土、钢材、砖等；桩：打入地中以固基础或资维系的木石，如桥桩、栓马桩。 舷舵扶靠，凭栏眺望。 舷舵：即舷梯，船上供人们上下船用的活动扶梯；栏：由扶手和支柱构成的栅杆护围；眺望：从高处往远处看。</p>
<h2 id="山水（8）"><a href="#山水（8）" class="headerlink" title="山水（8）"></a><strong>山水（8）</strong></h2><p>悬崖峭壁，峰峦叠嶂。 悬崖：高而陡的山崖；峭壁：象墙壁一样陡的山崖；峰峦叠嶂：山峰重叠如屏障一样。 泉喷岚罩，湍急瀑宕。 泉：从地下流出的水源；岚：林中的雾气；湍：急流的水；瀑：瀑布，从山崖上直流下来像悬挂着的布匹似的水；宕：放荡，不受拘束。 峡沟潭渊，溪涧流淌。 峡：两山夹水的地方；沟：田间水道，也指一切通水道，如山沟、阴沟；潭：深水坑；渊：深潭；溪：山间的流水；涧：两山相夹的流水。 池渠堰坝，沼泽泥塘。 池：水塘；渠：人工开凿的水道；堰：较低的挡水并能溢流的建筑物，横截河中，用以抬高水位，以便引水利用，有固定堰和活动堰两种；坝：建筑在河谷或河流中拦截水流的水工建筑物，用以抬高水位，积蓄水量，在上游形成水库；沼泽：地表过度潮湿，其上长有湿生植被，并有泥炭积累的地方；泥塘：烂泥淤积的洼地。 灾涝溢泻，汛潮浮涨。 灾：自然发生的灾害，如水、火、旱造成的祸害；涝：雨水过多，淹没庄稼；溢：水满外流；泻：水往下直注；汛：江河中由于流域内季节性降雨或融冰、化雪等而发生的定期涨水现象；潮：定时涨落的海水。 淮泄滞沽，溅渗汀潢。 淮：即淮河，中国大河之一，源出河南省桐柏山，东流经河南、安徽等省到江苏省入洪泽湖。河长 845 公里，流域面积 16.4 平方公里；泄：排泄洪水；滞：水流不畅；沽：古水名，在河北省境内；溅：水急速流动的样子；渗：水往下渗透；汀：水中或水边的平地；潢：积水池。 汹涌澎湃，惊涛骇浪。 汹涌：水奔腾上涌貌；澎湃：波涛冲击声；惊涛骇浪：浪大涛急，惊天动地。 漩涡带波，礁屿连江。 漩涡：水流遇低洼处所激成的螺旋形水涡；礁：海洋中隐现水面的岩石；屿：小岛。</p>
<h2 id="果木（6）"><a href="#果木（6）" class="headerlink" title="果木（6）"></a><strong>果木（6）</strong></h2><p>桃李杏柿，汁鲜味爽。 桃：木名，即桃树。蔷薇科，落叶小乔木。春季开花，花淡红、粉红或白色。果实略呈球形，表面有茸毛；李：李树，落叶乔木，春天开白色花，果实叫李子，熟时黄色或紫红色；杏：木名，即杏树，一种落叶乔木，叶子宽卵形，花单性，白色或粉红色，果实圆形，成熟时黄红色，味酸甜；柿：柿树，落叶乔木，品种很多，叶子椭圆形或倒卵形，背面有绒毛，花黄白色。结浆果，扁圆形或圆锥形，橙黄色或红色，可以吃；汁鲜味爽：味道鲜美爽口。 椰柚橙桔，渴饮品尝。 椰：果树名，即椰子树，一种常绿乔木，树干直立，不分枝，叶子丛生顶部。核果椭圆形，外果皮黄褐色，内果皮为角质的硬壳，果肉白色多汁，含脂肪，果肉可吃，也可榨油。果肉内的汁可做饮料，外果皮和中果皮的纤维可制船缆和刷子，叶子可编席和盖棚；柚：果树名，一种圆头柑桔属植物，常绿乔木，叶大而阔，花白色，果实大，圆形或扁圆形，皮厚，果味酸甜。产于我国南部地区。木材暗褐色，坚硬耐腐蚀，适于制造船舰、车辆等，亦供建筑用；橙：果树名，果实叫橙子。常绿乔木，叶子椭圆形，果实叫橙子。其果球形，皮黄赤色，味甜，皮可入药；桔：即橘，又称柑橘。品尝：细致地辨别滋味。 菠萝柑橘，橄榄槟榔。 菠萝：亦称黄梨、凤梨。凤梨科，多年生常绿草本，茎短，基部生吸芽，叶剑状，密生，螺旋状排列，边缘有刺或无刺为区别品种之重要特征。花无柄，紫红色，复果肉质，果顶有冠芽。性喜温暖，中国主产于台湾、广东、广西、福建等地。果供生食或加工，叶纤维可制绳或作纺织和造纸原料；柑橘：果木名。芸香科，柑橘亚科，常绿灌木或小乔木，春末夏初开白色花。果实扁圆形，红或橙黄色。果供生食或加工，果皮、叶、核供药用；橄榄：一种橄榄属常绿乔木，原产中国。种子可榨油，树脂供药用。果实绿色，长圆形，亦称“青果”， 可生食，可制蜜饯，亦可入药。欧美用它的枝叶作为和平的象征；槟榔：一种常绿乔木，树干很高，羽状复叶。果实可以吃，也供药用，能助消化，又有驱除绦虫的作用。生长在热带地方。 梨枣苹楂，荔栗榴棠。 梨：落叶乔木，叶子卵形。花多白色，果子多汁，可食；枣：落叶乔木，有直立或钩状刺，叶长卵形，基部广而偏斜，三出脉，托叶呈刺状，永存枝上。聚伞花序，生于叶腋内，花小，黄绿色，有花盘，多蜜。核果长圆形，鲜嫩时黄绿色，成熟后紫红色。用分株、嫁接等法繁殖。原产中国，以河北、山东、河南、陕西、甘肃、山西等地最多。果供食用，亦入药。木材坚硬，可供雕刻，或做车船和家具等；苹：苹果，苹果属落叶乔木，叶椭圆形，花白色带红晕。果实圆形，有红、黄或淡绿等色，味甜或略酸；楂：山楂，落叶乔木，叶子近于卵形，有三至五裂片。花白色，果实球形，比山里红略小，深红色，有小斑点，味酸，可生吃或加工，亦可入药；荔：荔枝，常绿乔木，偶数羽状复叶，花小，无花瓣，呈绿白或淡黄色，果实熟时紫红色，果味甘美，营养丰富，中国南方特产；栗：落叶乔木，果实叫栗子或毛栗子，果仁味甜，可以吃。木材坚实，供建筑和制器具用。树皮可供鞣皮及染色用。叶子可喂柞蚕；榴：石榴，落叶灌木或小乔木，叶子长圆形，花红色、白色或黄色。果实球形，内有很多种子，种子的外种皮多汁，可生食。根皮和树皮可入药，有驱虫之功效；棠：棠梨，落叶乔木，高约十米，叶子长圆形或菱形，叶柄、叶背和花序有绒毛。花白色，果实小，略呈球形，有褐色斑点。可以做嫁接各种梨树的砧木。 苍松寿柏，垂柳毛杨。 苍：草色，引申为青黑色；松：一般为常绿乔木，很少为灌木，树皮多为鳞片状，叶子针形，花单性，雌雄同株，结球果，卵圆形或圆锥形，有木质的鳞片，木材和树脂都可利用；寿：长寿；柏：常绿乔木，叶鳞片状，结球果，有扁柏、侧柏、圆柏、罗汉柏等多种。木质坚硬，纹理致密，可供建筑及制造器物之用。苍松寿柏意为青郁长寿的松柏树；垂柳：乔木，雌雄异体，树枝细长，柔软下垂，叶子基部宽，前端渐尖。也叫“垂杨柳”；毛杨：杨树的一种，也叫大叶杨、响杨、白杨。落叶乔木，叶互生，卵形或卵状披针形，柔荑花序，木材可做器物。 槐椿榆桦，杉桂榕樟。 槐：落叶乔木，羽状复叶，花淡黄色，结荚果，圆筒形。花、果可制黄色染料。花、果及根皮可入药；椿：落叶乔木。有香椿和臭椿之分，香椿的叶可做菜肴食用，臭椿的根皮可入药；榆：落叶乔木，叶卵形，花有短梗，果扁圆，形似古铜钱，俗称榆钱儿。木材可供建筑或制器械、家具等；桦：双子叶植物的一属，落叶乔木或灌木。树皮容易剥离，木材致密，可制器具。有白桦、黑桦等；杉：杉科，常绿乔木。冠塔状，叶长披针形，果实球形。木直且高，高可达三十米以上。木色白或淡黄，木纹平直，结构细致，易加工，能耐朽，供建筑、桥梁、造纸、造船等用；桂：常绿小乔木或灌木，叶椭圆形，对生。开白色或暗黄色小花，有特殊的香气，供观赏，亦可做香料。果黑色。通称木犀，简称桂；榕：常绿乔木，树干分枝多，枝上又长出许多气生根，其向下长入土中形成一支柱，树冠大，叶互生，椭圆形或卵形，花黄色或淡红色，果实倒卵形，黄色或赤褐色，生于叶腋。生长在热带和亚热带，木材可制器具；樟：常绿乔木，叶卵形，夏季开黄白色小花，果实黑色，大如豌豆。木质坚固细致，有香气，做成箱柜，可以防蠹虫。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>于是你幻想去旅行</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E9%98%85%E8%AF%BB-%E4%BA%8E%E6%98%AF%E4%BD%A0%E5%B9%BB%E6%83%B3%E5%8E%BB%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="于是你幻想去旅行（比目鱼）"><a href="#于是你幻想去旅行（比目鱼）" class="headerlink" title="于是你幻想去旅行（比目鱼）"></a>于是你幻想去旅行（比目鱼）</h1><p><strong>你是地铁上的一个乘客。</strong></p>
<p>你在下午六点被散发着汗味和香水味的陌生人的身体挤压在车厢中央一个狭小的空隙里。</p>
<p>你的两只手都够不到任何一只扶手吊环，于是你只好依靠双脚保持平衡。</p>
<p>在你头顶上方空调正送出冷风，但你的后背却开始不断渗出汗珠。</p>
<p>你的视线越过此起彼伏的头颅看见车窗外闪过一幅巨大的灯箱广告，画面上是一片宁静、碧蓝、似乎没有边际的海水。</p>
<p>于是你幻想去旅行。</p>
<p>你幻想这列地铁驶离此地，开往一处不知名的远方。</p>
<p>它穿山越岭，走过许多陌生的城市。当车身终于停稳，你看见左侧的车窗里有一条平坦的海岸线，右侧的车门打开，海风扑面而来，你的眼前是一座几乎看不见人的海边小渔村。</p>
<p><strong>你是渔村里的一位小学教员。</strong></p>
<p>你在一个宁静的午后坐在天花板上悬挂着一只吊扇的办公室里用双色铅笔批改学生的作业。</p>
<p>你偶然抬头，发现办公室里现在只有你一个人。透过敞开的木窗你看见小操场上只有一个戴着草帽的校工正在阳光下弯着腰清除杂草。</p>
<p>当你把目光投向更远处那条朦胧而闪烁的海平线，你忽然意识到那条海平线你已经坐在同一张办公桌后面看了整整两年。</p>
<p>于是你幻想去旅行。</p>
<p>你幻想自己骑上自行车沿着校门口那条水泥路来到一公里外的海边，然后顶着腥味十足的海风登上一艘马达隆隆作响的机帆船。你站在船尾看着学校操场上的旗杆离你越来越远。</p>
<p>当你越过那条海平线，你来到一座叫做纽约的城市。</p>
<p><strong>你是纽约曼哈顿金融区一家连锁咖啡店里的服务员，但你的真正志向是成为一名作家。</strong></p>
<p>你在每周一晚上乘地铁去二十三街的一间酒吧坐在角落里听文学朗诵会，你在每周六的下午去东村第四街另一间文人出没的酒吧希望在那里碰到愿意阅读你小说手稿的出版商或者经纪人。</p>
<p>现在，你正俯下身子手持一把笤帚清扫一位刚刚离去的顾客撒落在桌子下面的蛋糕屑，你身旁的座位上有三个身穿闪亮白衬衫的华尔街职员正在高声谈笑，他们谈到私人游艇、欧洲假期，还有意大利女人。</p>
<p>你走到店门外从口袋里掏出一支香烟，你的手在另一只口袋里搜寻打火机时碰到了那封从昨晚开始一直塞在那里的寄自《纽约客》的退稿信。</p>
<p>于是你幻想去旅行。</p>
<p>你幻想自己拦住正从你眼前开过的那辆黄色计程车，告诉司机你要去肯尼迪机场。</p>
<p>你在机场大厅掏出你那张还没有透支的信用卡，对柜台后面那个身穿航空公司制服的女孩说你要去巴黎。</p>
<p><strong>你是巴黎左岸圣日耳曼德佩区一位独居的老妇人。</strong></p>
<p>每天下午三点你穿戴整齐、略施淡妆，走出你那间位于六楼的小公寓。</p>
<p>你手扶楼梯缓缓下楼，穿过静得出奇的小天井，推门来到阳光温暖的街上。</p>
<p>你走过咖啡馆外面手持酒杯、面向大街翘腿而坐的优雅男女，走过门前聚集着外国游客的墙壁斑驳的老教堂，走过出售可丽饼和冰激凌的街边售货车，走过门脸不大的时装店和小画廊。</p>
<p>你转入一条小街，推门走进 “不二价”超市。</p>
<p>你手推购物车，在货架前认真地挑选蔬菜和奶酪，然后手提购物袋沿原路返回你的小公寓。</p>
<p>在动手准备晚餐之前你像往常一样坐在沙发里看电视。</p>
<p>你按动遥控器变换着频道，不知不觉地睡了过去。你醒来的时候窗外和屋内都是一片昏黑，电视机里闪烁着微光。</p>
<p>你看见屏幕上有三只大象和一只小象正晃动着鼻子缓慢而稳重地在草原上行走，在它们和远处的地平线之间只有一棵细长的小树，像一颗孤零零的钉子。</p>
<p>于是你幻想去旅行。</p>
<p>你幻想你五十年前的情人在门外按响你的门铃。</p>
<p>你们带上红酒和水果坐上他那辆雪铁龙敞篷车，然后你们一路哼着约翰尼.哈里戴的歌开车去非洲。</p>
<p><strong>你是南非首都开普敦一家五星级酒店的老板。</strong></p>
<p>每周二下午两点你会准时驾车离开你的酒店。</p>
<p>你会沿着 M6 海滨公路一直向南开去，你的左边是散布着棕榈树和私人别墅的低矮的山岩，你的右侧是细浪拍打着岸边礁石的南大西洋。</p>
<p>你会在十五分钟后抵达坎普斯海滩附近一家装潢别致的小旅馆。</p>
<p>你会在那里停好车，直奔 117 房间。你会熟练地掏出门卡打开房门，然后你会在房间里看见一个躺在床上（有时是坐在椅子上）的裸体女人。</p>
<p>你不能确定每次和你云雨的女人叫什么名字、芳龄几何，你不能确定你的朋友肖恩（这家旅馆的老板）是从哪里源源不断地为你弄来这么多小妞，你更不能确定那些肤色不同、身材各异的妙龄女子是否认得出你是开普敦那家著名酒店的老板（或许她们更加熟悉你那位身为国会议员、经常在电视上出现的老婆？）。</p>
<p>但你从来不为这些不能确定的事耗费脑筋。</p>
<p>现在，在一番剧烈运动之后，你习惯性地闭着眼睛仰面躺在床上，一只手懒懒地抚摸着身边那条褐色的长腿。</p>
<p>这时你忽然听见开门的声音，这时你忽然闻到一种你熟悉的香水味道。</p>
<p>你听见一个熟悉的女声在尖声喊叫，你睁开眼睛，有几秒钟你竟然无法分清那张愤怒的脸此刻是出现在电视机里还是真的横在你的床头。</p>
<p>于是你幻想去旅行。</p>
<p>你幻想你根本没有开车驶上 M6 公路，根本没有停在这间旅馆门前，根本没有打开过这个房间的大门。</p>
<p>你幻想你此时此刻正在一个离此地非常遥远的国家。于是你想到了印度。</p>
<p><strong>你是印度德里旧城的一位街头流浪汉。</strong></p>
<p>你在一个圆月高悬的夜晚斜靠在路边的墙角左手夹着一支烟头右手握着一听罐装啤酒。</p>
<p>你的头发和胡须粘连在一起，你从头到脚套着 11 件捡来的衬衫和 5 条捡来的裤子。</p>
<p>你在每个白天弯着腰走街串巷仔细研究这座城市里每一只垃圾筒的内容，你在每个夜晚坐在你固定的角落里看着这座破旧的老城变得越来越安静。</p>
<p>今晚你感到幸福，因为你刚刚在两条街以外的公共厕所里洗了一个凉水澡，因为你路过你朋友库什的角落时他扔给你一听还没有过期太久的灌装啤酒，也因为你听说抓乞丐的囚车已经从这条街上开走，至少今晚你不再需要担心被抓去坐上两年大牢。</p>
<p>于是你感觉到一种放松，于是你哼起了小曲，于是你让自己的思绪飘散开去，于是你幻想去旅行。</p>
<p>旅行，会是一件有趣的事情——你在心里对自己说。但是此时此刻你实在想不出除了这个舒服的街角以外还有其它任何地方值得你挪动身躯。</p>
<p>这时，你抬起头，看见了悬挂在街对面大楼顶上的那轮硕大无比的白色的月亮。你幻想去那里走上一趟。</p>
<p><strong>你是人类历史上第十三位登上月球的宇航员。</strong></p>
<p>147 个小时以前，你和另外三名宇航员乘坐“牛郎星”号登月舱平稳地降落在月球表面，你第一个走下扶梯，你的宇航靴激起的尘土像慢动作镜头一样缓缓地升起，又缓缓地落下。</p>
<p>123 个小时以前，你和你的同伴驾驶一辆月球车在坑坑洼洼的月球表面颠簸着前进，你意识到登月 24 小时以来你看到的景象几乎没有任何变化：头顶上方永远是漆黑一片的无尽苍穹，脚下永远是像在海底世界一样沉睡着的尘土和碎石。</p>
<p>84 个小时以前，你躺在登月舱里的吊床上做梦，你梦见了你家门口 A&amp;P 超市货架上那些颜色鲜红的番茄。</p>
<p>47 个小时以前，你在一座低矮的山坡上滑了一跤，尘土和石屑如丝巾一般飞舞，当你终于像从游泳池底爬起一样重新站直了身子，你又看到了低低地悬挂在黑色天幕上的那个只露出半个脸庞的蓝色的星球。</p>
<p>24 小时之前，你收到休斯顿总部的通知：停留在近月轨道上的“猎户”号指令舱出现电脑故障，总部的工程师正在全力远程抢修。</p>
<p>5 分钟之前，你收到最新通知：指令舱彻底瘫痪，无法按原计划在 23 小时之后完成与登月舱的对接。</p>
<p>1 分钟以前，你的助手罗斯通过对讲机告诉你：休斯顿将紧急发射一架小型火箭为你们提供补给，但登月舱上的氧气储备仅够维持 31 个小时。</p>
<p>现在，你站在月球表面，手里握着一块矿石标本，身体一动不动。</p>
<p>你忽然感觉这里如此荒芜、如此死静，如此丑陋不堪。</p>
<p>你于是你幻想去旅行。</p>
<p>你幻想回到远处那个蓝色星球上的任何一个角落。</p>
<p>你不在乎风景，你只想把自己包围在人群之中，让自己可以闻到人的味道。</p>
<p>毫无缘由地，你想到了一列拥挤的地铁。</p>
<p><strong>你是地铁上的一个乘客。</strong></p>
<p>你在下午六点被散发着汗味和香水味的陌生人的身体挤压在车厢中央一个狭小的空隙里。</p>
<p>你的两只手都够不到任何一只扶手吊环，于是你只好依靠双脚保持平衡。</p>
<p>在你头顶上方空调正送出冷风，但你的后背却开始不断渗出汗珠。</p>
<p>你的视线越过此起彼伏的头颅看见车窗外闪过一幅巨大的灯箱广告，画面上是一片宁静、碧蓝、似乎没有边际的海水。</p>
<p>于是你幻想去旅行。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>太阳的寿命</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E9%98%85%E8%AF%BB-%E5%A4%AA%E9%98%B3%E7%9A%84%E5%AF%BF%E5%91%BD/</url>
    <content><![CDATA[<p>小时候的我曾在课外书上看到，太阳的寿命还有 50 亿年。</p>
<p>现在的我长大了，大家告诉我太阳的寿命还是有 50 亿年，只是我身边的人却有些已经永远地离开了。 那时候我心里的想法是:“啊，原来真的会有世界末日啊”。</p>
<p>我从来没有清楚的感受过时间在自己身上留下多少痕迹，也不了解今天的太阳和昨天的太阳有什么不同，</p>
<p>但却知道身边的人在慢慢地变老甚至悄然离去。</p>
<p>哀吾生之须臾，羡长江之无穷，我突然理解到妈妈跟我说的活在当下的意义。</p>
<p>去做我此刻想做的事，爱我此刻想爱的人，不要为过去所悔恨，更不因未来而担忧。</p>
<p>我抬头看了看太阳，太阳笑着对我说: 还是 50 亿。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>换了三份工作</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E9%98%85%E8%AF%BB-%E6%8D%A2%E4%BA%86%E4%B8%89%E4%BB%BD%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>王伟今年已经换了三份工作。</p>
<p>王伟说：“一个方案要改十三次， 你说过分不过分？”</p>
<p>方丈笑而不语。</p>
<p>王伟说：“一个设计一天变六次， 你说夸张不夸张？”</p>
<p>方丈笑而不语。</p>
<p>王伟说：“做着不喜欢的工作， 每分钟都是在浪费生命， 我现在就打电话辞职！”</p>
<p>方丈笑而不语。</p>
<p>王伟说：“你倒是表个态啊，方丈。” 方丈说：“你去给我接杯水，我表给你听。”</p>
<p>王伟拿起水杯，走出禅堂。</p>
<p>——</p>
<p>刚出门，老板来电， 王伟叹了口气，按下接听键。</p>
<p>老板说：“小王，没打扰你休息吧。 下午有个客户过来，你尽快到公司准备一下， 给客户做方案演示！”</p>
<p>挂掉电话， 王伟已经气得忘记了接水这件事。</p>
<p>到公司， 王伟给客户演示方案， 客户对王伟大加赞赏， 当场就签了合同。</p>
<p>客户离开之前， 偷偷要了王伟的电话， 说以后还要多多指教。</p>
<p>晚上到家， 王伟接到客户电话， 问是否考虑新的工作机会， 王伟开开心心地答应了。</p>
<p>——</p>
<p>到了新公司，王伟受到重用。</p>
<p>独立办公室，超大落地窗， 起身眺望，整个城市尽收眼底。</p>
<p>每天早晨，都有助理冲好咖啡放到面前， 网络购物，自己再也不用打开手机下单。</p>
<p>原来需要改上十三次的方案， 现在自己一个人就可以拍板。</p>
<p>原来一天变上六次的设计稿， 现在王伟说不能变就不能变。</p>
<p>做方案、谈客户， 带着团队攻克难关， 代表公司出去演讲。</p>
<p>王伟似乎找到了合适的工作， 王伟似乎找到了人生的目标。</p>
<p>——</p>
<p>半年过去了， 王伟被升为部门经理， 做事开始变得束手束脚。</p>
<p>想做件事， 先咨询部门员工的看法， 费劲心思统一各种观点， 然后又向上级申请资源， 审批终于通过准备开干， 其他部门又有反对意见。</p>
<p>开会变成主要工作， 白天开，晚上开， 公司开，家里开， 高速公路上还在开。</p>
<p>开完之后还往往没什么结果， 即使有结果又通常难以执行。</p>
<p>王伟觉得产品配色巨丑无比， 但一想到改个颜色需要开上十几次会， 就安慰自己说配色并不重要。</p>
<p>原来踏踏实实做事， 现在整天勾心斗角。</p>
<p>原来加班到深夜调整方案， 能换来自己内心的成就感， 现在百般妥协达成的共识， 第二天就有可能不了了之。</p>
<p>王伟觉得， 做着这样的工作， 每分钟都是在浪费生命。</p>
<p>——</p>
<p>一天， 王伟决定辞职， 大步走向老板办公室。</p>
<p>老板还没来， 王伟坐下等待， 心里有些犹豫，想着： “下一份工作会好吗？”</p>
<p>忽然，面前传来一个声音： “水接回来了吗？”</p>
<p>王伟抬头，看见方丈， 喃喃地说：“水？”</p>
<p>方丈说：“对啊，半小时前要你去接水， 现在你回来了，我想知道，水接回来了吗？”</p>
<p>王伟低头，看到手里的水杯。</p>
<p>方丈微笑着， 阳光透过窗户照进禅堂。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>生之意义</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E9%98%85%E8%AF%BB-%E7%94%9F%E4%B9%8B%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>如果死亡终止一切，如果我既无死后有福的希望，又不怕祸患，那么我必须问自己，我到这个世界上 来干什么，既来了，应该如何为人。 这些问题中，有一个问题的回答很简单，可是这回答太令人扫兴了，大多数人都不愿承认。那就是： 人生没有道理，人生没有意义。我们在这里，是在一颗小行星上作短暂的居留，这颗小行星绕着另一 颗小星旋转，而那颗小星又是无数星系中的一颗。也许只有我们这颗行星上能有生命。或者在这宇宙 的其他地方，别的行星可能已经在形成一种适合于某种物体生存的环境，可能正是这种物体经过亿万 年漫长的时间逐渐生成了今天的我们这些人。 倘若天文学家们告诉我们的是真的，这个行星有一天会变成这样一种情况：到时候所有生物都不能在 它上面生存，最后宇宙将到达那终极平衡阶段，一切归于静止。而人，在这情况到来的亿万年以前早 已不复存在了。那个时候，他是否曾经存在过，可能设想有什么意义吗？他将成为宇宙史上的一章， 犹如记述原始时代地球上生存过的奇形巨兽的生活故事的一章，同样毫无意义。 于是我必须问我自己，这一切与我有什么关系？这不是我在说话，这是我心中的渴望在说话，这是每 个人心中都有的，渴望坚持自己的存在。这就是自我主义。我们大家从来不知多少年以前开始使一切 活动起来的那种古远的能力是从哪里继承下来的。它是每种生物保持生存的自我执著所必需的，它使 它们活着。这是人的根本。它的满足就是斯宾诺莎所说，我们所能希望达到的最高极限——自我满 足，“因为人们保存自己，并没有任何目的”。我们可以设想，精神在人体内发光，是让人用以应付 周围环境的。经过千秋万代，它还只发展到仅能应付实际生活的一些主要问题。可是在那漫长的岁月 中它似乎终于超越了他的直接需要，随着想像力的发展，人将他的环境扩大到了肉眼看不见的事物。 我们知道他当时是用什么回答来满足他给自己提出的问题的。在他体内燃烧的能力是那么强烈，他不 可能怀疑自己的巨大力量。他的自我主义是无所不包的，因而他无从设想自己毁灭的可能性。这些回 答至今使许多人感到满意。它们使人生有意义，给人的虚荣心带来安慰。 善于思考的人思想急速转变，不会思考的人晕头转向。要记着，幸福并不是依存于你是什么人或拥有 什么，它只取决于你想的是什么。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>被15张假钞打落的人生</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E9%98%85%E8%AF%BB-%E8%A2%AB15%E5%BC%A0%E5%81%87%E9%92%9E%E6%89%93%E8%90%BD%E7%9A%84%E4%BA%BA%E7%94%9F/</url>
    <content><![CDATA[<p>2020 年 4 月，我在医院精神科见到了雁姐。40 岁不到的她很显老，有点驼背，有白发，还能认出我，说话很慢，“你来了啊，我现在不喂猪了……有人给你做蛋饺吃吗？” 听到她的这句话，我难过极了。好好的日子，怎么就过不下去了。 </p>
<p>雁姐比我大 4 岁，住在我家后面的山上。 小时候，我们俩都是要喂猪的小孩。不同的是，我讨厌喂猪，雁姐却将喂猪看得比自己的性命还重要，“喂猪能改变我的命运。” 那时，村里家家户户都喂猪，大人有时忙不过来，就让孩子顶上。而我与其说是讨厌喂猪，其实是讨厌不负责任的母亲，自从父亲在我 5 岁那年离世后，她时常自己出去潇洒，让我包揽家务。久而久之，家里人不像人，猪不像猪，成了村里的一大笑话。 总有人跑到家里来，或是大笑，或是叱责：“你家的猪又跃过栏板跑出去，吃我们的庄稼和菜叶了。”我只得连声给人道歉，自己提着棍子去寻猪，好不容易寻到了，它也是极不听话的——只顾着自己吃，用棍子抽也不怕疼，让它往东，它偏要往西，很气人。 我经常被猪气得坐在地上哭，认定了猪是最无情的动物——蛇知道报恩，牛会流泪，狗念家，猪就知道吃——直到有一天，我在寻猪的路上遇到了雁姐，她告诉我，“猪只是笨了点，但喂好了，是家里出力最大的，你家的猪经常往外面跑，是因为饿得慌，人饿了也得跑的。” 这一年我才 7 岁，雁姐不过 11 岁。她父母双亡，跟奶奶相依为命，奶奶偶尔会挑一些菜去 10 公里外的镇上卖，家里的主要收入还是靠她们喂的那两头猪。 雁姐在学校一直是年级第一，懂事得体，嘴巴又甜，村里好多大人都夸她，说自家孩子若有她一半就好了。不过说归说，他们从未伸出过援手。 雁姐相信自己能改变命运，“我有聪明的头脑，能吃苦耐劳，熬过这几年，等上了大学，一切就都改变了。贫穷啊什么的，还有奶奶的晚年生活，就都迎刃而解了。这一切的前提，只需要我把猪喂好就行了，多简单。” 那时候，即便自己饿着肚子，雁姐也不会让猪挨饿。她经常一个人清理猪栏，挑猪粪。她家的猪也从来不会跑出去，吃饱了就睡在一旁，很乖巧。</p>
<p>一开始我和雁姐不熟，我们院子附近的小孩很多，雁姐住在山上，很少下来玩。 后来还是因为我家的猪经常跑出去糟蹋别人家的东西，村里人忍无可忍，上门让母亲赔钱。母亲就转头要求我，无论去不去上学，每天必须割满一篮子猪草才能回家，我犯了难——当年家家户户都养猪，田埂上、菜地里都是光秃秃的，几乎见不到杂草。经常是眼看着天黑了，我还在提着空篮子满山游荡，虫子“呜呜”地叫，听了瘆人。 有时为了能早点回家，我只得在猪草下面垫一些树枝，再将它们尽量弄蓬松些，看着勉强也有一篮子。母亲总是一眼看出我的心虚，双手往篮子里一按，下去老大半，我就免不了一顿揍，还没晚饭吃，“下次再这样，你给我死外面得了”。 直到有一次，我下午放学后满山找不到猪草，坐在原地哭了起来，雁姐闻声赶过来，问清原委后，说包在她身上。从此以后，一放学我就背着篮子跟着雁姐去后山。 </p>
<p>一开始在雁姐面前，我说的最多的就是各种抱怨。 比如我把猪草割回家还要剁碎，一不留神就把自己的手剁伤了，来不及止血，就要先挨母亲一顿骂。雁姐却说：“你就是为了躲懒，故意的。” 又比如，煮猪食也很难熬，外面小孩在吵闹，隔壁的武侠片放得正起劲，我却要蹲在灶台前，等着烧几个小时的火，将一大锅红薯和猪草煮烂，“猪真的是蠢透了，明明看着我端着一大盆猪食过去了，偏偏要跳上来将猪食拱掉”；还有更难过的，每次猪贩子来，钱总是被母亲全部拿走，我央求她给我做一碗猪肉蛋饺，她就推说要等过年，我只能眼睁睁地看着猪圈里新来的两头小猪，感叹何时是个头…… 每次我抱怨个没完，雁姐总会微微一笑，“我只要有书读，什么苦都愿意吃。” 雁姐说她喂了好几年猪，也从来没有吃上一口肉——“卖猪的钱除了给奶奶买药，剩下的全部都要拿来读书，一分钱都不能用的。我从来都不怕吃苦，就怕没有改变。” 相处久了我才知道，雁姐根本不用奶奶管，每次自己都会主动将篮子里的猪草压紧，篮子底部坏了，也舍不得换新的，缝上蛇皮袋继续用。她每天晚上只有红薯吃，手上的疤比我多多了，“你喊妈妈还有人应答，我呢？对着这大山喊，只有空荡荡的回声。” 雁姐在家自己煮饭炒菜，晚上还要帮奶奶洗脚，等晚上 10 点后才有时间做作业。但她却从来不抱怨，还总会劝我，“要快乐。你不要想太多，不要管别人怎么看你，快乐不需要钱的，别人见你快乐了，说不定还会羡慕你，因为你做到了对自己好。”</p>
<p>自从和雁姐在一起割猪草，我开朗了很多。 她喜欢唱歌，也喜欢讲故事，《新白娘子传奇》就是她讲给我的，“我也要像许仕林一样，有朝一日考中状元，也许我爸妈也在天上做神仙看着我。” 还有《猎人海力布》，“我以前一个人割猪草也有些孤单，想听鸟儿说话，当然我也愿意为了救全村人的性命而变成石头，无怨无悔，只要大家帮我把奶奶照顾好就行了。”后来学到这篇课文时，我脑子里一直想着雁姐，她真是厉害，比老师讲得好太多。 雁姐爱笑，笑着笑着就像唱歌，雁姐有时会教我唱流行歌曲，“天不下雨天不刮风天上有太阳，妹不开口妹不说话妹心怎么想。”我觉得太拗口了，她就一字一句地先教我读，再一起唱。 最重要的，就着满山青草和花香，雁姐一路教我认各种猪草——“油麻草到处都是容易割，可如果不搭配烂草（牛筋草），猪基本上不长膘，还不如多花时间割好一点的草。” 之前偶尔和其他小伙伴一起割猪草，他们经常会和我抢肥沃的地方，有时他们割满了，就把我一个人丢在一旁。雁姐却从来不这样，自己割满了，也一定会帮我割满。 若这天两人早早完成了任务，就一起在山上疯跑、玩游戏，有时咬住两根马尾草的中间，用两头将眼睑支起扮鬼脸；有时将红薯杆折成一截一截做项链。天边夕阳点缀着云海，一阵山风掠过雁姐的发梢，锁骨上的“项链”闪着金光，比风景还要好看。 </p>
<p>不割猪草时，雁姐常带我去河里玩，她和奶奶很少买荤菜吃，除了青菜就是豆腐，想开荤，只能去河里捞鱼。 从前村里河水清澈、水草丰盛，偶尔见鱼儿成群结队地跑出来；翻开石头，下面准有螃蟹。不过也有为难的时候，有一次在河里抓螃蟹时，雁姐的凉鞋不小心被河水冲走了，她不要命了似的往河里扑，即便水流湍急，也不管不顾，最后碰的鼻青脸肿才捡到鞋子。 那时候，我们丢不起任何东西，雁姐说自己若是把凉鞋丢了，一整个夏天都只能打赤脚了，平时她的凉鞋坏了，都是把烧火钳烧红，将坏了的地方烙好。 我也一样，赶鸭子时发现少了一只，整晚不敢回家。找鸭子时，母亲也不准我用手电筒，只能就着月光，走过田埂跨过河岸。直到听到“嘎嘎嘎”的叫声，才松了一口气。这件事，雁姐也安慰了我，“在妈妈那里不是鸭子比你重要，是属于我们穷人的本就只有这么多。” 总是这样，每当我绝望时，雁姐总会“发现”我的幸福—— “你爷爷家有那么多的书，我好羡慕。你想吃冰棒，爷爷就会给你买。有次我抓到一条蛇，卖了 10 块钱，才敢给自己买根牛奶雪糕，故意吃得满嘴都是，显得自己好富有，还能在嘴角浪费一些。” 有一天，为了买一本参考书，她将自己的头发卖了，毕竟是女孩子，剪头发的时候一边求阿姨一边哭，“我也想漂亮……给我稍微留长一点。”过了一会却又说，“也没事，春风吹又生，头发剪了还能长，等我上了大学，就能留的住自己的头发了，现在丑一点也没关系。” 像是一种如何熬过苦难经验的传授，雁姐告诉我，自己难熬时就盼着过生日，“不为别的，早一天长大，就能早一点脱离苦难，等完全长大成人，就不要这么小心翼翼地活了。” 后来，我人生中的第一份生日礼物就来自雁姐：一个印着“奖”的笔记本，还有一支英雄钢笔，都是学校奖励给她成绩优异的奖品，笔记本上面写着：“这支笔可以写天下呢。”</p>
<p>童年的时光一晃而过，雁姐都读初三了，出落得越发漂亮了，即使生活那么苦，也没耽误学习。那时已经有男生给她递情书，村里大人知道了就说，“这个妹子以后大有出息，你们留不住的。” 雁姐喂的猪总是长得快，眨眼就 200 多斤了，那一年，卖猪那天刚好是雁姐生日，见她一直是背着自己缝的书包，我送了她一个印有《还珠格格》的红色双肩书包，她很高兴，“以后上高中书应该挺多的，我要背到上大学。” 那天的猪贩子是从市里来的陌生面孔，但价格比以前每斤高出 3 毛钱，3 块 3 一斤，雁姐和奶奶在笔记本上算了又算，两头猪可以多卖 100 块钱，为此她们还打了酒，热情招待了猪贩子，怕菜不够，自己不敢先上桌，只吃他们剩下的残羹冷炙。 两头猪总共 1600 块，拿着钱雁姐兴奋地对我说：“这次我想奢侈一回，明天逛集市我要带够钱，想吃水果就吃个饱，要买一双小白鞋，一条荷叶裙，再买个风铃挂在家里……”过了一会，她又看着我说，“我还要买点肉回来，给你做蛋饺吃，让你吃个够。” 可等到第二天，我没有吃到蛋饺，雁姐来找我时，还是穿着那双破波鞋，不停地说“对不起”，“我要食言了……而且，我以后都没办法带你去割猪草了……” 那一次，猪贩子见雁姐家是山上的独门独户，只有一老一小，给的 16 张百元大钞票里有 15 张是假的，对于雁姐和奶奶来说，这简直是晴天霹雳。 当年没有人记得他们的车牌号，没有监控，即便报了警也无济于事。村里人骂归骂，可也基本都是自身难保，没有人出头为雁姐做打算，包括村委会，尽管大家都知道她爱读书，会读书。 几天后，雁姐就退了学。</p>
<p>那时候，学校老师几次来家里，可是当雁姐问学校，能不能借钱给她上学时，老师又都沉默了，说只能走一步看一步。雁姐便说：“不要再让奶奶为难了”。 有人趁此上门给雁姐说媒，说她有一副好皮囊，还能找个人嫁了过好日子。雁姐用棍子将他们赶了出去，“我就算出去打工，自学也要把书读出来的。” 我劝雁姐不要这么早就出去打工，她就像往常一样对我笑，“你说不去，那就不去，继续喂猪、读书、唱歌，好不好？”然后，就像往常一样背着篮子，带上镰刀，扎着马尾，拉着我走到山上，“这块地是我的家的，你来割没有人说你；那几块是一位奶奶的，她很凶，拔她一根草都能骂上半天；落水洞旁有很多野生猕猴桃，茅根和映山红要少吃……” 在小河边，她又唱起了歌，“朝花夕拾杯中酒，寂寞的人在风雨后，醉人的笑容你有没有，大雁飞过菊花插满头……”可是等歌儿唱完，天色暗了，雁姐却将割来的猪草一点一点地扔了下去，最后连篮子也扔了，“猪真的是蠢哦，人家给假钱它们也不吭声，枉我对它们那么好。” 那天晚上，雁姐让我陪她去外村看唱戏，“我最爱看电影，见你们搬着凳子到处跑，我好羡慕，今天也想去瞧个热闹。”我记得很清楚，那晚表演者在装有土壤的盆里种下一粒种子，给它浇水施肥，5 分钟不到，就能看到开花结果了，最后“长”出一根小黄瓜，主持人将黄瓜丢往人群中，最终落在雁姐手上，大家都夸她好运气，让她咬一口。雁姐转头给我分了一半，对我说，“我真的会有好运气吗？若是我也长得这么快就好了。”然后笑着告诉其他人，“是真的。” 回家的路上，雁姐不停地对我碎碎念，“你要吃饭，割猪草时先捏个饭团在路上吃也好……那种绿色的胖胖的毛毛虫你不要捉，很痒……若是有人欺负你，你就给我打回去……” 我知道，雁姐这是要走了。</p>
<p>第二天凌晨 4 点，去县里的班车响起了喇叭声，车子通常会在村里跑两个来回。我隐约觉得雁姐要走了，连忙爬起来追到马路上去，追着车子喊——“你才 15 岁，要去哪里？”车子一直没停，我追得头发都湿了，瘫在地上哭。过了几分钟，车子又响着喇叭回来了，在我面前停了，雁姐背着我送她的书包走了下来，摸了摸我的头，“我见过你追着车子喊妈妈的样子，知道你倔，才不想告诉你的。” 我拉住雁姐的手，不让走，也不说话。这时，售票员从窗口探出头对我说，“你养得活这个姐姐吗？能供她上学吗？”我这才松开手，雁姐理了理我的衣领转身上了车。 望着驶离的车子，我突然明白了课文里那首诗，“昨日入城市，归来泪满巾，遍身罗绮者，不是养蚕人。”雁姐喂了那么多猪，很少能吃上猪肉，还要背井离乡。</p>
<p>雁姐走了以后，我好一段时间都习惯性地背着篮子来到她家门口，每当准备喊她出来时，才恍然想起，雁姐已经去外面闯荡了。有时见到奶奶，她会主动告诉我雁姐的一些消息，“她托人带信回来，说进了厂，千叮咛万嘱咐，让我再也不要喂猪了。” 我总是在心里默念，雁姐这么好，肯定能赚到钱，继续读书，再也不要喂猪了。 2 年后，17 岁的雁姐带回来一个男人，为了不让奶奶担心，她准备结婚了。 其实，雁姐去广东的第 3 个月，奶奶就又开始喂猪了，说接到雁姐的汇款心里很惭愧，没能给雁姐攒到钱读书，总要给她攒点嫁妆，“攒一分算一分，总比什么都没有好。” 奶奶本来就身体不好，在一次喂猪的时候不小心摔了一跤，从此卧床不起。雁姐回来一趟又匆匆走了，说自己再不想读书的事了。 奶奶生病后，要请人照顾，还要买药，雁姐一个月的工资根本不够用，只能选择两班倒，有段时间一天只睡两三个小时。奶奶在床上自怨自艾，“我这个要死不死的，没一点用，就知道祸害孙女。”后来病情越来越重了，又整天念叨着雁姐还没有成家。 雁姐的老师看不下去，劝雁姐说奶奶病入膏肓，说胡话了，让她不要听，以后奶奶不会拖累她了，还想读书的话，攒点钱就回来。 雁姐却说，她在外面混了 1 年多时间，知道权衡利弊，“但绝不会把奶奶算进去，任何东西都不能跟奶奶相比，奶奶没有了，就真没有了，我想最后听她一回话。”</p>
<p>雁姐结婚时，主事的人安排我和她坐一桌，由我送她出门。 那天雁姐一直在和我说话，说她在广东的生活。说奶奶生病前，她一直会买书和试卷自学，周末还会去大学校园逛逛，“大学真的很好，学生们懒洋洋的样子都好可爱，我经常梦见自己也在里面上学，醒来才发现自己趴在流水线上，再后来奶奶病了，我只能把书都丢了。” 我跟雁姐生闷气，说她哪里都好，就是不该就这么把自己嫁了，那个男人比她大 8 岁，满脸络腮胡，再说了，如果他真的爱雁姐，就该供她上学。 雁姐说她看上了那个男人有学问，上进又踏实，“他曾经考上过大学，也是因为妈妈生病才被迫辍学，他会唱好多英文歌，尤其是那首《昨日重现》，唱的特别好听。” 由于奶奶时日不多，雁姐出嫁后也没有远走，穿着一身红裳，我和新郎领着她在村里转了一圈就回来了，路上有很多小鸟在树上叽叽喳喳，我又想起了海力布，捡起路上一粒好看的石子含在嘴里，想听那些小精灵告诉我，雁姐以后一定会幸福的。 我问那个男人，“我雁姐很聪明的，你会供他继续上学吗？”男人支支吾吾，说什么“小孩有小孩的想法，大人有大人的打算”。我还想继续逼问，雁姐打断了我，“他是老实人，不要欺负他。” 喜事办完第 4 天，奶奶走了。男方给的 1 万礼金雁姐全拿来给奶奶办事了，守灵的时候雁姐才告诉我，奶奶后面几年，只要哪家有白喜事，就会去守灵，回来就念叨，说吹吹打打好热闹，她中年守寡，后来儿子儿媳又走了，一个人冷清了几十年。她就想让奶奶瞧个热闹，也不管值不值了。 奶奶走了，雁姐就和男人一起走了。 </p>
<p>再见雁姐已是 6 年后，而雁姐孑然一身，身上只有 500 块钱。那时候我已经读了大学，雁姐来学校看我时，硬要塞给我 200，我没要，只让她告诉我那个男的在哪里。 这些年来，雁姐把打工省下的钱都给了那个男人，却从未去过他老家，男人总是说家里没有房子，爸妈都是寄居在亲戚家，所以才要攒钱盖房子，雁姐就说是得有个家。 男的把家里的房子盖起来以后，雁姐提出要去领证，男的又百般推诿，最终在民政局的门口跑开了，在雁姐的一再逼问之下，男人才承认自己在老家有妻儿。 雁姐没有哭闹，只是说，那我和奶奶欠你的人情还了，然后跳了河，被人救起。</p>
<p>无论我怎么劝说，雁姐一直守口如瓶。我说去查他户籍资料，让我老师帮忙打官司把钱要回来，然后申请来我们学校自考部上学，雁姐就生气了，说如果这样，“你就再也见不到我了”。 “毕竟最难熬的那几年，是那个人在身边，好不好另说了，我最需要的时候他在身边。读书的事，是伤心事，我不会再想了。”</p>
<p>“娘家是真的没人了，我来看看你就安心，就是这样。” 我拧不过她，没几天她又走了。几个月后，雁姐打电话说，她要结婚了，“这次有红本本，是救我的那个男人，对方人很好，他没有结过婚的，家里我也去过了，父母是老实人。”消息来得突然，我有点担心，劝她慎重考虑，“反正你总是爱替别人说好话。” 雁姐却说她依然相信，“不能因为受过一次伤，就怕了，自从跳河被救后，我就想啊，不能停留在这里，要往前走，才能看得到前方，定格在这里，就真没以后了。”还是像小时候那样，雁姐总是往幸福处看。 领证那天，雁姐什么都没有操办，说踏实过日子才实在，没有戒指，甚至连新衣服都没有换，就穿了件旧 T 恤，请我和几个朋友在出租屋里吃了一顿便饭，桌子上有一大碗蛋饺，“外面的猪都是饲料养大的，没有家里的猪肉好吃。剁肉馅时我不由地就想起了从前，是苦了一点，但日子总是好日子，过来了……” 雁姐那天喝了一点小酒，不停地跟在场的每一个人保证，“我一定要万分努力地经营好一个家，过上幸福的小康生活，自己的孩子只要想读书，就一直供他到底。” 我终于知道雁姐的真实想法，她已经没有家了——曾经和奶奶住过的木房子塌了，那块地被他们那里已经出了五服的叔叔霸占了，还振振有词地说，他家里有几个儿子——她好想要一个家。 散场以后，雁姐特地叫住了我，往红包里加了 500 块钱还给我。我拒不接受，两人一直推搡，最后她眼泪掉了下来：“要不你带我回家看看吧，我们去看看奶奶。” 我答应了，雁姐却在临行前改变了主意，“村里人现在个个有点钱了，就这样回去有点难堪，我不要闹这个笑话。”看着雁姐尴尬的笑容，我莫名心酸，曾经无所畏惧的姑娘认清了生活的面貌，开始在意人情与面子，渴盼着衣锦还乡了。 不过，本该如此吧。我们都是俗人，这个世界本就俗不可耐，大家朝着世俗的方向奔波，追求有脸有面的成功理所当然，只不过生活不是菩萨，没法有求必应。</p>
<p>又过了一年，雁姐生下一个男孩，给我发消息，“果然幸福总是要来的。”我真心替雁姐开心，该轮到她好好体味一下生活的甜了，喂猪的我们也该学着去喂饱自己了。 有了孩子以后，雁姐觉得打工不是长久之计，想开一家属于自己的小店。为此她干劲十足，没出月子便执意跟着丈夫去了工地，两口子一起刷墙，工地上没有活干的时候，便去外面摆地摊，还做过家政，最终因遇到一些心怀不轨的雇主而作罢。 只要手头现金超过 500 块，雁姐就要去银行存起来，她认为老话是没错的，“勤劳便能发家致富，奶奶到死都在干活，积少成多，日子总会由量变到质变好起来的。” 知道雁姐虽然过得辛苦，却有奔头后，我放心了，渐渐的我们联系便少了，再后来她电话便打不通了。</p>
<p>一晃就到了 2014 年。元旦，一个陌生号码发来消息，祝我“新年快乐，步步高升”。我直接问，是不是雁姐。雁姐马上打来电话，问我怎么知道是她。我告诉她，已经 4 年没有她的消息了，这期间也没听说她回老家给奶奶扫墓，今天刚好想起她。 雁姐没说话，气氛有点尴尬，雁姐东西一句西一句地问，一下提到村里都传说我买房了，一下又问我收入如何，然后说她的小孩很可爱，不过够折磨人，接下来就全是抱怨，“日子真难过啊”。 我问她到底怎么了，是不是有难处。雁姐叹了叹气，问我能不能借 600 块钱给她。我说没问题，她赶紧又说，600 块钱其实也解决不了什么问题，问我有没有 2000 块，我说有的。 我给雁姐打了 3000 块钱过去，雁姐收到后问我为什么不问她缘由，我说只要是在过生活，总会有难处，她不说我就不去问了。雁姐夸了我好一会儿，“还是要读书，你现在说话都有底气了，从容了很多，不再是那个找不到猪草的孩子了，你能不能再帮我一个忙，成功了你的钱也能还了。”这一次，雁姐说，希望我能陪她去前任那里把钱要回来，我终于忍不住问她出什么事了。 雁姐带着哭腔说，小孩出生后一直生病，不是心脏有问题，就是肺部出了毛病，为了治疗花了好几万，差不多都是借的。她换号码是有人催债，她拿不出，觉得没脸见人，心理压力很大，只能赚一点还一点，这才知道钱很重要，她后悔自己以前故作大方了。 我告诉雁姐，走诉讼程序是不大可能了，不说诉讼时效，眼下已经没法取证了，只能看他是否会顾及情面多少退回一点。雁姐点头，“我们去吧，要回来一点是一点，不过你千万不要打他，不然理亏一分都要不到。” </p>
<p>我终于还是见到了那个男人，尽管他看着像个小老头了，我也还是恨他糟蹋了雁姐 6 年青春。 雁姐异常冷静，说当年工资 600 块钱一个月，后来涨了也不过 1000 块，她省吃俭用，给了那个男人 3 万多。 男人叫苦连天，说老婆跟着别人跑了，儿子进了监狱，房子还是当年那个架子，要钱没有，我们实在要逼他的话，就把那些砖块拆了搬走。 雁姐还是面无表情，“你哪怕拿几千块钱给我也行。” 扯皮到最后，男人也只给车费钱。在火车上，雁姐终于止不住地掉眼泪，“原来真正的苦是从长大了才有的，现在才发现从前的日子有多好，有奶奶在身边，有书读，去山上随便溜一圈就会有收获……” 我安慰雁姐，说我这里还有点钱，如果她要的话，可以先拿去用。雁姐拒绝了，“再怎么不知趣，也不该再麻烦你了。你没有靠别人走过来了，我会把债还了的。”</p>
<p>2016 年下半年，雁姐打电话问我要卡号，说要还钱给我，我没有理会。她一再坚持，说她的日子又好过了，债务基本还完了，还托关系在银行贷了 10 万块钱，打算自己创业，“干老本行，办个小型养猪场，现在喂猪不比我们那个时候了，市场火爆，还能卖得上价钱，我算了一下，能喂 20 多头猪，没两年就回本了。” 见雁姐又恢复了力气，我便说，“这最好不过了，那点钱就当我给雁姐的红包了，等我结婚的时候你给我准备一头大肥猪。”雁姐在那边哈哈大笑，说给我单独喂头肥猪，吃猪草的那种。 那时的我怎么也想不到，再次见到雁姐会是在医院里。</p>
<p>2020 年 4 月，我去医院路过精神科，很偶然的，碰到了雁姐。 她说了好多话，先说只是来做个检查，“我犯病了去县城的精神病院，不用交钱，现在倒也好多了，政府还是好的……” 我才知道，2017 年，雁姐费大力将小型养猪场建好，刚买好了母猪和猪崽，村干部忽然来通知她，养猪场必须要拆除，会有补贴，不过为了响应政策，个人总是要亏一点的。雁姐老公气不过，和村里带来的那些人打了一架，被拘留了 10 天，回来后便意志消沉，一次酒后走路不小心摔断了小腿。 雁姐终于受不了这一连串的打击，精神失常了，好一段时间都把自己锁在拆掉的猪圈那里，一动不肯动，说着各种胡话。本来为了办那些贷款，才在酒桌上打通好了村干部们的关系，想不到他们转头就要令行禁止。 雁姐思维还算清晰，说自己没有生在好时代，“你看现在几乎不用现金了，若是那时候扫个码钱就能进来，就不会有假钱了，那我可能就上了大学……还有啊，现在网络那么方便，我做个直播或许就有学费，有人会帮我吧……” 我满心惭愧，这么多年了，每当雁姐站在人生的岔路口，我都没能帮到她。我们都是一样，历经满目疮痍终于熬到了中年，生活它想要吃蛋饺时，从不事先通知的，冷不丁地就将我们剁碎给包了。 这次我仍然是事后才问，能为她做点什么。雁姐连连挥手，说不用，“我要回家了，你再也不用喂猪了，我也不用喂猪了，我和猪没有缘分，还好你也没缘分。” 雁姐挽着她夫家嫂子的手走的时候，转过身来对我笑，嘴里唱的是她小时候自己编的曲，“裁缝铺里哟，烂裤脚；木匠厅堂里呀，没凳坐；还有那和尚庙里呢，鬼唱歌呐……”</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>鹰和人</title>
    <url>/2024/05/22/%E5%85%B6%E4%BB%96-%E9%98%85%E8%AF%BB-%E9%B9%B0%E5%92%8C%E4%BA%BA/</url>
    <content><![CDATA[<p>高高的天空中有一只鹰在飞翔。她远远地就看见下面有一只鸽子，她决定要抓住那只鸽子。鹰俯冲下 去，但当她接近地面的时候，发现那只鸽子已经躲藏到一个在树下坐着休息的人手里。 “请把我的猎物还给我吧。”鹰恳求那个人说。 “你再去寻找其他猎物吧。既然这只鸽子到我这儿来寻求保护，我就不能不帮它。”人回答。 “我已经没有时间再去寻找其他猎物了。天马上就要黑了。我的孩子们已经饥肠辘辘，正等着我带吃 的回去呢。我四处寻找，找了一天才找到这么一只鸽子，可你还不打算把它给我。” “我绝对不能给你。”人仍不为所动。 “我真的很不理解。你又不想吃它，我知道人不吃鸽子，所以这只鸽子对你来说一点儿用处也没有。 可你为什么还要做这种损人不利己的事呢？” 鹰和人争论不休。最后人建议说：“这样吧，我们俩暂时交换一下角色，我当鹰，你来当人，也许这 样我们才能更好地彼此理解。” 人变成了鹰，他马上就感到一阵阵疲劳和饥饿感向他袭来。他知道在那座高高的山上，在他的窝里， 他的孩子们正焦急地等着他回去。这时他发现了一只肥肥的鸽子。他兴奋得甚至都听见了自己剧烈的 心跳声，他恨不得马上就扑过去把鸽子撕碎，用它温热的鲜血湿润自己干渴的喉咙。他已经筋疲力 尽。如果抓不到这只鸽子，他和他的孩子们今天就得挨饿。也许明天也还是一无所获。可这个人是从 哪儿冒出来的呢？他为什么要保护这只弱小的鸽子呢？ 等他们恢复原形的时候，一阵突然刮起的大风把人吹倒了，鸽子从人手里滑出去，飞了起来，但鹰原 地未动。 于是人问鹰：“你为什么不去追呢？现在这只鸽子是你的了。” “因为我曾经当过人。”鹰若有所思地回答。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>Docker下将已部署的wordpress备份及迁移</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Docker-Docker%E4%B8%8B%E5%B0%86%E5%B7%B2%E9%83%A8%E7%BD%B2%E7%9A%84wordpress%E5%A4%87%E4%BB%BD%E5%8F%8A%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p><del># Docker 镜像备份 在已经部署好 wordpress 的机器上，使用 <code>docker save</code> 命令将 <code>Docker</code> 镜像保存到本地文件中。</del></p>
<p>使用以下命令将名为 <code>wordpress</code> 和 <code>mysql</code> 的 <code>Docker</code> 镜像分别保存到名为 <code>wordpress_image.tar</code> 和 <code>mysql_image.tar</code> 的本地文件中：</p>
<pre><code>docker save wordpress &gt; wordpress_image.tar #保存wordpress

docker save mysql &gt; mysql_image.tar #保存mysql
</code></pre>
<p><del># Docker 镜像读取 将 <code>wordpress_image.tar</code> 和 <code>mysql_image.tar</code> 文件复制到目标机器上。在目标机器上，使用 <code>docker load</code> 命令将本地文件中的 <code>Docker</code> 镜像加载到 <code>Docker</code> 中。</del></p>
<p>使用以下命令将名为 <code>wordpress_image.tar</code> 和 <code>mysql_image.tar</code> 的本地文件中的 <code>Docker</code> 镜像加载到 <code>Docker</code> 中：</p>
<pre><code>docker load &lt; wordpress_image.tar

docker load &lt; mysql_image.tar
</code></pre>
<h1 id="Docker-文件系统备份"><a href="#Docker-文件系统备份" class="headerlink" title="Docker 文件系统备份"></a>Docker 文件系统备份</h1><p>要将 <code>Docker</code> 中的整个 <code>WordPress</code> 应用程序打包并部署到另一个地方，可以使用 <code>Docker</code> 的导入和导出功能，具体步骤如下： 在运行 <code>WordPress</code> 应用程序的 <code>Docker</code> 容器上执行以下命令，将容器中的 <code>WordPress</code> 应用程序导出为 <code>tar</code> 文件：</p>
<pre><code>docker export &lt;container_id&gt; &gt; wordpress.tar
</code></pre>
<p>这将在当前目录下创建一个名为 <code>wordpress.tar</code> 的文件，其中包含 <code>Docker</code> 容器中的整个 <code>WordPress</code> 应用程序。</p>
<h1 id="Docker-文件系统读取"><a href="#Docker-文件系统读取" class="headerlink" title="Docker 文件系统读取"></a>Docker 文件系统读取</h1><p>将 <code>wordpress.tar</code> 文件传输到要部署 <code>WordPress</code> 应用程序的目标服务器上。</p>
<p>在目标服务器上执行以下命令，将 <code>wordpress.tar</code> 文件导入到 <code>Docker</code> 中：</p>
<pre><code>cat wordpress.tar | docker import - &lt;image_name&gt;:&lt;tag&gt;
</code></pre>
<p>其中，<code>&lt;image_name&gt;</code> 是你为导入的 <code>Docker</code> 镜像指定的名称，<code>&lt;tag&gt;</code> 是你为该镜像指定的标签。</p>
<p>运行导入的 <code>Docker</code> 镜像，启动 <code>WordPress</code> 应用程序的容器：</p>
<pre><code>docker run -p &lt;host_port&gt;:&lt;container_port&gt; -d &lt;image_name&gt;:&lt;tag&gt;
</code></pre>
<p>其中，<code>&lt;host_port&gt;</code> 是你要将容器的端口映射到主机上的端口号，<code>&lt;container_port&gt;</code> 是容器内运行 <code>WordPress</code> 应用程序的端口号。</p>
<p>这样，你就可以将 <code>Docker</code> 中的整个 <code>WordPress</code> 应用程序打包并部署到另一个地方了。</p>
<h1 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h1><ol>
<li><p>按照之前的 docker-compose 的方法启动 dokcer 使用 <code>docker ps -a --no-trunc</code></p>
<blockquote>
<p>需要修改并添加 command</p>
<ol>
<li><code>wordpress</code> 是 <code>docker-entrypoint.sh apache2-foreground</code></li>
<li><code>mysql</code> 是 <code>docker-entrypoint.sh mysqld</code></li>
</ol>
</blockquote>
</li>
<li><p>使用 <code>docker run</code> 命令在目标机器上启动该 <code>Docker</code> 镜像。例如，使用以下命令在目标机器上启动名为 <code>wordpress</code> 的 <code>Docker</code> 镜像：</p>
<p>#启动mysql</p>
<p>docker run -d <br>–name mysql <br>-v mysql_data:&#x2F;var&#x2F;lib&#x2F;mysql <br>-e MYSQL_ROOT_PASSWORD&#x3D;liuluhua <br>-e MYSQL_DATABASE&#x3D;wordpress <br>-e MYSQL_USER&#x3D;liuluhua <br>-e MYSQL_PASSWORD&#x3D;liuluhua <br>mysql:latest docker-entrypoint.sh mysqld</p>
<p>#启动wordpress</p>
<p>docker run -d <br>–name wordpress <br>–link mysql <br>-p 80:80 <br>-e WORDPRESS_DB_HOST&#x3D;mysql:3306 <br>-e WORDPRESS_DB_USER&#x3D;liuluhua <br>-e WORDPRESS_DB_PASSWORD&#x3D;liuluhua <br>-e WORDPRESS_DB_NAME&#x3D;wordpress <br>-v .&#x2F;wp-content:&#x2F;var&#x2F;www&#x2F;html&#x2F;wp-content <br>-v .&#x2F;uploads.ini:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;uploads.ini <br>wordpress:latest docker-entrypoint.sh apache2-foreground</p>
</li>
</ol>
<blockquote>
<p>启动参数： **<code>-d</code>**：表示以“后台模式”运行容器，即使容器的主进程退出也不会停止容器。 **<code>--name</code>**：表示为容器指定一个名称，这样可以方便地对容器进行管理。 **<code>-v</code>**：表示将主机的目录或文件与容器内的目录或文件进行挂载，即数据卷。例如，<code>-v mysql_data:/var/lib/mysql</code> 表示将主机的 mysql_data 目录挂载到容器内的 <code>/var/lib/mysql</code> 目录，这样容器内的 <code>MySQL</code> 数据就可以持久化存储在主机上。 **<code>-e</code>**：表示设置容器内的环境变量。例如，<code>-e MYSQL_ROOT_PASSWORD=liuluhua</code> 表示设置容器内的 <code>MYSQL_ROOT_PASSWORD</code> 环境变量为 <code>liuluhua</code>。 **<code>--link</code>**：表示将一个容器链接到另一个容器，使得容器之间可以进行通信。例如，<code>--link mysql</code> 表示将容器链接到名为 mysql 的容器。 **<code>-p</code>**：表示将容器的端口映射到主机的端口。例如，<code>-p 80:80</code> 表示将容器的 <code>80</code> 端口映射到主机的 <code>80</code> 端口，使得可以通过主机的 <code>IP</code> 地址访问容器内的服务。 **<code>wordpress:latest</code> 和 <code>mysql:latest</code>**：表示使用 wordpress 和 mysql 镜像的最新版本来创建容器。 **<code>./wp-content:/var/www/html/wp-content</code> 和 <code>./uploads.ini:/usr/local/etc/php/conf.d/uploads.ini</code>**：表示将主机上的 <code>wp-content</code> 目录和 <code>uploads.ini</code> 文件挂载到容器内的 <code>/var/www/html/wp-content</code> 目录和 <code>/usr/local/etc/php/conf.d/uploads.ini</code> 文件，使得容器内的 <code>WordPress</code> 网站可以访问这些文件。</p>
</blockquote>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker介绍</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Docker-Docker%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Docker 是一种流行的容器化平台，它可以帮助开发人员和运维人员更轻松地构建、交付和运行应用程序。</p>
<h1 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h1><p>Docker 的架构包括以下组件：</p>
<ul>
<li><strong>Docker 守护进程</strong>：运行在主机上的后台进程，负责管理 Docker 对象，如镜像、容器、网络和数据卷。</li>
<li><strong>Docker 客户端</strong>：通过 Docker API 与 Docker 守护进程通信。</li>
<li><strong>Docker 镜像</strong>：包含应用程序和其依赖项的只读文件系统。</li>
<li><strong>Docker 容器</strong>：Docker 镜像的可运行实例。</li>
<li><strong>Docker 仓库</strong>：用于存储 Docker 镜像的地方。</li>
</ul>
<p>主要需要注意的是镜像<strong>IMAGE</strong>和容器<strong>CONTAINER</strong></p>
<ul>
<li>可以将镜像视为虚拟机的一个快照，镜像是容器的基础，定义了容器的基本配置和内容</li>
<li>容器，即为镜像的实例化内容，当启动一个容器时，Docker 会从镜像创建一个只读的文件系统层，并在其上添加一个可写层，容器中的所有更改和数据都存储在这个可写层上。</li>
</ul>
<h1 id="Docker-基本命令"><a href="#Docker-基本命令" class="headerlink" title="Docker 基本命令"></a>Docker 基本命令</h1><p>Docker 提供了一系列命令行工具，用于管理 Docker 容器和镜像，以及执行与容器相关的操作</p>
<p>以下是一些常用的 Docker 命令：</p>
<ul>
<li><code>docker images</code>：列出本地所有的镜像。</li>
<li><code>docker rmi &lt;image&gt;</code>：删除一个镜像。</li>
<li><code>docker pull &lt;image&gt;</code>：从仓库中拉取一个镜像。</li>
<li><code>docker build -t &lt;image_name&gt; &lt;path_to_dockerfile&gt;</code>：根据 Dockerfile 构建新的自定义镜像。</li>
<li><code>docker push &lt;image&gt;</code>：将一个镜像推送到仓库中。</li>
<li><code>docker run &lt;image&gt;</code>：根据指定的镜像创建并启动一个新的容器。</li>
<li><code>docker ps</code>：列出当前正在运行的容器。加 <code>-a</code> 列出所有，包括运行中的和已经停止的</li>
<li><code>docker start &lt;container_id/container_name&gt;</code>：启动已停止的容器。</li>
<li><code>docker stop &lt;container_id/container_name&gt;</code>：停止运行中的容器。</li>
<li><code>docker restart &lt;container_id/container_name&gt;</code>：重启容器。</li>
<li><code>docker rm &lt;container_id/container_name&gt;</code>：删除指定容器。</li>
<li><code>docker logs &lt;container_id/container_name&gt;</code>：查看容器的日志输出。</li>
<li><code>docker exec -it &lt;container_id/container_name&gt; &lt;command&gt;</code>：在正在运行的容器中执行特定命令。</li>
<li><code>docker exec -it container /bin/bash</code> 进入 container 容器中的命令行</li>
<li><code>docker inspect &lt;container_id/container_name&gt;</code>：查看容器的详细信息，包括 IP 地址、端口映射等。</li>
<li><code>docker network ls</code>：列出所有 Docker 网络。</li>
<li><code>docker volume ls</code>：列出所有 Docker 卷。</li>
</ul>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Dockerfile 是一种文本文件，用于定义如何<strong>构建 Docker 镜像</strong>。包含了一系列的指令和参数，用于指导 Docker 引擎在基础镜像上添加应用程序代码、运行时环境、依赖项和配置文件等，最终生成一个新的 Docker 镜像。</p>
<p>以下是一个简单的 Dockerfile 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    FROM ubuntu:latest</span><br><span class="line">    RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">    CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>

<p>该 Dockerfile 使用最新版本的 Ubuntu 镜像作为基础镜像，并在其中安装了 nginx。</p>
<p>一些 dockerfile 中的指令：</p>
<p><code>FROM</code>： 指定基础镜像。每个 Docker 镜像都是基于一个基础镜像构建的，这个指令用于设置构建的起点。</p>
<p><code>MAINTAINER</code>： 设置镜像的作者信息，通常是作者的名字和电子邮件。</p>
<p><code>RUN</code>： 在镜像<strong>构建过程中</strong>执行的命令。可以用于安装软件包、更新系统、设置环境等操作。</p>
<p><code>CMD</code>： 设置容器<strong>启动</strong>时要执行的命令。如果在运行镜像时没有指定要执行的命令，则将执行这里设置的默认命令。</p>
<p><code>ENTRYPOINT</code>： 设置容器启动时要执行的固定命令。与 CMD 类似，但可以将参数传递给 ENTRYPOINT 指定的命令。</p>
<p><code>COPY</code>： 将本地文件复制到镜像中。</p>
<p><code>ADD</code>： 类似于 COPY，但它还支持复制网络资源和自动解压缩压缩文件。</p>
<p><code>WORKDIR</code>： 设置容器的工作目录，后续的指令将在这个目录下执行。</p>
<p><code>EXPOSE</code>： 指定容器运行时监听的端口号，但并不会自动将端口映射到宿主机。</p>
<p><code>ENV</code>： 设置环境变量，可以在容器内部访问。</p>
<p><code>ARG</code>： 声明构建时的参数，构建时可以通过 –build-arg 参数传递。</p>
<p><code>VOLUM</code>E： 创建一个可以从宿主机或其他容器挂载的挂载点。</p>
<p><code>USER</code>： 设置运行镜像的用户。</p>
<p><code>ONBUILD</code>： 定义一个触发器，在子镜像构建时执行特定的操作。</p>
<h1 id="Docker-Compose（重点）"><a href="#Docker-Compose（重点）" class="headerlink" title="Docker Compose（重点）"></a>Docker Compose（重点）</h1><p>Docker Compose 是一个工具，用于定义和运行多个 Docker 容器的应用程序。</p>
<ul>
<li>docker-compose 需要编写 yml 脚本，定义配置以及多个容器之间的依赖关系和网络连接<br>  * 注意：yml 文件对缩进有严格要求</li>
<li>通过命令控制 docker-compose<br>以下是一个简单的 docker-compose.yml 文件示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.9&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    volumes:</span><br><span class="line">      - ./db_data:/var/lib/mysql</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: somewordpress</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">      MYSQL_USER: wordpress</span><br><span class="line">      MYSQL_PASSWORD: wordpress</span><br><span class="line">  wordpress:</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    image: wordpress:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - ./wordpress_data:/var/www/html</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">      - &quot;443:443&quot;</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: db</span><br><span class="line">      WORDPRESS_DB_USER: wordpress</span><br><span class="line">      WORDPRESS_DB_PASSWORD: wordpress</span><br><span class="line">      WORDPRESS_DB_NAME: wordpress</span><br><span class="line">volumes:</span><br><span class="line">  db_data: &#123;&#125;</span><br><span class="line">  wordpress_data: &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里用到了 mysql:5.7 和 wordpress:latest 两个 Docker 镜像，WordPress 镜像依赖 <code>depends_on</code> 于 MySQL 镜像。</li>
<li>restart: always 参数表明容器服务宕机后会自动重启。</li>
<li>MYSQL_ROOT_PASSWORD 为数据库的 root 密码，MYSQL_PASSWORD 为数据库的普通用户密码，请自行修改，对应的 WORDPRESS_DB_PASSWORD 也要同时修改。MYSQL_USER 为数据库普通用户的用户名，如果有需要也可以修改，对应的 WORDPRESS_DB_USER 也要同时修改。</li>
<li>80:80 的意思是把宿主机的 80 端口映射到容器内部的 80 端口。如需通过其他端口访问，只需修改前面的 80。比如，我要通过 8080 端口访问 WordPress，填写 8080:80 即可。</li>
<li>volumes 会将主机中指定的目录 <code>./wordpress_data</code> 和容器中的指定目录 <code>/var/www/html</code> 共享，类似于虚拟机中的共享文件夹。并且在容器销毁后目录中的文件依旧存在。</li>
</ul>
<p>在 Docker Compose 版本 3 及以上的配置中，不再使用 links 字段来定义容器之间的连接。取而代之的是使用 Docker 网络来实现容器之间的通信。现在，Docker Compose 默认创建一个项目级别的默认网络，其中每个服务（service）都可以使用它。</p>
<p>只需保证 db 和 wordpress 属于同一个项目（即在同一个 docker-compose.yml 文件中定义），它们将自动连接到默认网络，并可以通过服务名称（db 和 wordpress）相互访问。</p>
<h2 id="docker-compose-脚本"><a href="#docker-compose-脚本" class="headerlink" title="docker-compose 脚本"></a>docker-compose 脚本</h2><p><a href="https://docs.docker.com/compose/compose-file/">Docker Compose官方文档</a></p>
<h2 id="docker-compose-命令"><a href="#docker-compose-命令" class="headerlink" title="docker-compose 命令"></a>docker-compose 命令</h2><p><code>docker-compose up -d</code>：根据当前目录的 yml 文件配置启动容器，<code>-d</code> 参数代表在后台运行</p>
<p><code>docker-compose ps</code>：查看运行状态</p>
<p><code>docker-compose stop</code>：停止运行</p>
<p><code>docker-compose restart</code>：重启</p>
<p><code>docker-compose restart service-name</code>：重启单个服务</p>
<p><code>docker-compose exec service-name sh</code>：进入容器命令行</p>
<p><code>docker-compose logs [service-name]</code>：查看容器运行 log</p>
<h1 id="Docker-安装及使用"><a href="#Docker-安装及使用" class="headerlink" title="Docker 安装及使用"></a>Docker 安装及使用</h1><h2 id="利用-docker-配置-wordpress-个人博客"><a href="#利用-docker-配置-wordpress-个人博客" class="headerlink" title="利用 docker 配置 wordpress 个人博客"></a>利用 docker 配置 wordpress 个人博客</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在安装 docker 时，发现 docker 有多个版本：</p>
<ul>
<li><strong>docker.io</strong>：debian&#x2F;ubuntu 官方基于 docker 社区源码封装的版本，将 docker 的依赖直接转接到主系统上</li>
<li>docker-ce：docker.com 放出来的社区版，使用 golang 将依赖封装在一个包中</li>
<li>docker-ee：docker.com 维护的商业版<br>一般使用<strong>docker.io</strong></li>
<li>安装 docker.io：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 docker-compose：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install docker-compose</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>创建一个文件夹用于存储 volume 以及 yml 文件：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir wordpress &amp;&amp; cd wordpress</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑 yml 文件（yml 文件内容参照 <a href="http://124.222.246.202:8080/2023/07/19/docker%E4%BB%8B%E7%BB%8D/">Docker介绍</a>）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi myBlog.yml</span><br></pre></td></tr></table></figure>

<ul>
<li>启动容器（初次启动时会下载镜像，速度较慢）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure>

<ul>
<li>如果有错误，查看启动日志：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker-compose logs</span><br></pre></td></tr></table></figure>

<ul>
<li>如果需要进入容器内命令行：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker-compose exec -it &lt;容器名称&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>停止并删除容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker-compose down</span><br></pre></td></tr></table></figure>

<h1 id="Docker-镜像和容器的构建、导出"><a href="#Docker-镜像和容器的构建、导出" class="headerlink" title="Docker 镜像和容器的构建、导出"></a>Docker 镜像和容器的构建、导出</h1><p><code>docker build</code>、<code>docker export</code>、<code>docker save</code> 和 <code>docker commit</code> 是 Docker 的一些常用命令，它们在 Docker 镜像和容器的构建、导出和保存等方面有不同的作用。</p>
<h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p>作用：使用 Dockerfile 定义构建规则，构建一个新的 Docker 镜像。</p>
<p>描述：docker build 命令是用于根据 Dockerfile 创建一个新的 Docker 镜像。</p>
<p>Dockerfile 中包含了构建镜像所需的指令，例如安装软件、配置环境等。</p>
<p>docker build 命令会根据 Dockerfile 的指令逐步构建镜像的不同层，最终生成一个可执行的镜像。</p>
<h2 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export"></a>docker export</h2><p>作用：导出 Docker 容器的文件系统作为一个 tar 归档文件。</p>
<p>描述：docker export 命令允许你导出一个正在运行的容器的文件系统，生成一个 tar 归档文件。这个归档文件将包含容器的文件系统，但不包含 Docker 镜像的元数据和历史记录。所以，使用 docker export 导出的内容不能用于还原容器。</p>
<p>使用 <code>docker export</code> 命令导出的文件<strong>无法用作 <code>Docker</code> 镜像的源文件</strong>，只能用于将<strong>容器迁移</strong>到另一个 <code>Docker</code> 主机或将容器中的文件系统导出到本地</p>
<p>例如，如果你想要将一个正在运行的 <code>WordPress</code> 容器迁移到另一个 <code>Docker</code> 主机，可以使用 <code>docker export</code> 命令将容器导出为一个 <code>tar</code> 文件，然后将该文件传输到目标主机并使用 <code>docker import</code> 命令导入为一个新的 <code>Docker</code> 镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker export &lt;container_id&gt; &gt; wordpress.tar</span><br></pre></td></tr></table></figure>

<h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p>作用：将 Docker 镜像保存为 tar 归档文件。</p>
<p>描述：docker save 命令用于将 Docker 镜像保存为一个 tar 归档文件，包含了镜像的元数据和文件系统。你可以使用 docker load 命令将这个 tar 文件导入到 Docker 中，还原成一个可运行的镜像。</p>
<p>可以用于在不同的 <code>Docker</code> 主机之间共享镜像或备份到本地。</p>
<p>例如，如果你想要将一个名为 <code>wordpress:latest</code> 的 <code>Docker</code> 镜像备份到本地，可以使用 <code>docker save</code> 命令将镜像导出为一个 tar 文件。</p>
<blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o wordpress.tar wordpress:latest</span><br></pre></td></tr></table></figure>

<h2 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h2><p>作用：将容器的变更保存为新的 Docker 镜像。</p>
<p>描述：docker commit 命令允许你将一个正在运行的容器的变更保存为一个新的 Docker 镜像。它会创建一个新的镜像层，将容器中的变更添加到这个层中，最终生成一个新的镜像。</p>
<p>例如：遇到了一个 docker 环境，需要带回来自己调试，打包正在运行的容器，快速拖环境跑路</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker ps   //获取正在运行的容器,找到ID</span><br><span class="line">docker commit -a <span class="string">&quot;test&quot;</span> -m <span class="string">&quot;wordpress&quot;</span> &lt;容器名称或ID&gt;  //将容器打包成镜像</span><br><span class="line">docker save -o ./wordpress.tar &lt;容器名称或ID&gt;  //拖到本地</span><br><span class="line">docker load -i hackgod-demo.tar             //导入镜像</span><br></pre></td></tr></table></figure>

<h1 id="Docker-将容器打包成镜像以及导入导出"><a href="#Docker-将容器打包成镜像以及导入导出" class="headerlink" title="Docker 将容器打包成镜像以及导入导出"></a>Docker 将容器打包成镜像以及导入导出</h1><p>可以使用 <code>docker commit</code> 命令来完成，<code>docker commit</code> 可以从容器创建一个新的镜像。</p>
<h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>-a : 提交的镜像作者；<br>-c : 使用 Dockerfile 指令来创建镜像；<br>-m : 提交时的说明文字；<br>-p : 在 commit 时，将容器暂停</p>
<h2 id="容器打包成镜像："><a href="#容器打包成镜像：" class="headerlink" title="容器打包成镜像："></a>容器打包成镜像：</h2><p>将容器 a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 2a2a11e2c043</span><br><span class="line">docker commit -a &quot;alway.com&quot; -m &quot;socks5&quot; 2a2a11e2c043  alway.com/wangwei/socks5:v1</span><br></pre></td></tr></table></figure>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><h3 id="在镜像包所在的文件夹下操作"><a href="#在镜像包所在的文件夹下操作" class="headerlink" title="在镜像包所在的文件夹下操作"></a>在镜像包所在的文件夹下操作</h3><p><code>docker load --input  uu.tar(也可以使用docker load -i uu.tar或者 docker load &lt; uu.tar)</code></p>
<p>或</p>
<p><code>docker load &lt; uu.tar</code></p>
<p>导出（镜像打包）</p>
<p><code>docker save &gt; /root/docker_images/uu.tar ubuntu:latest</code></p>
<p>或</p>
<p><code>docker save /root/docker_images/ubuntu:latest &gt; uu.tar</code></p>
<p>或</p>
<p><code>docker save -o /root/docker_images/[镜像名].tar [镜像名]:latest</code></p>
<p>启动镜像</p>
<p><code>docker run -it -d --name container-name -pp1:p1-pp2:p2new-image-name</code></p>
<p><code>docker run -it -d --name qinglong -p 5700:5700 alway.com/wangwei/qinglong:v1</code></p>
<h1 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h1><p><code>docker build</code> 和 <code>docker commit</code> 都用于构建 Docker 镜像，但它们的方式不同。</p>
<p>*docker build 是通过 Dockerfile 定义构建规则，逐步构建镜像，而 docker commit 是将容器的变更直接保存为新的镜像。</p>
<p>docker export 和 docker save 都用于导出 Docker 镜像或容器的文件系统，但它们导出的内容不同。</p>
<p>*docker export 导出容器的文件系统作为归档文件，但不包含镜像的元数据和历史记录，不能用于还原容器。而 docker save 导出完整的 Docker 镜像，包含了元数据和文件系统，可以用于还原镜像。</p>
<p>docker build 和 docker save 都用于创建 Docker 镜像</p>
<p>docker export 用于导出容器的文件系统，而 docker commit 用于将容器的变更保存为新的镜像。</p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Linux环境下终端的使用</title>
    <url>/2024/05/17/%E5%B9%B3%E5%8F%B0Platform-Linux-Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BB%88%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p>一个基于文本的交互界面</p>
<blockquote>
<p><strong>快捷键</strong></p>
<p>打开命令行终端 <code>Ctrl+Alt+t</code></p>
<p>放大终端 <code>Ctrl Shirft +</code></p>
<p>缩小终端 <code>Ctrl -</code></p>
</blockquote>
<p><strong>终端提示符含义</strong><br><code>lemonade@ubuntu:~$</code> 对应<br>用户名 (lemonade)@主机名 (ubuntu): 工作目录 (~) 提示符 ($)</p>
<blockquote>
<p>~：家目录</p>
</blockquote>
<blockquote>
<p>$: 普通用户<br>#: 超级用户 (root)</p>
</blockquote>
<p><strong>命令</strong>— 在终端中用于告诉计算机去执行一个动作</p>
<p><strong>参数</strong>—</p>
<p><strong>选项</strong>— 选项通常用一个连接号（<code>-</code>）或两个连接号（<code>--</code>）来划分</p>
<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><ul>
<li><code>ls</code>: 列出当前目录内容</li>
<li><code>cd ~</code>: 进入当前用户的家目录</li>
<li><code>./</code> 当前目录 (可省略)</li>
<li><code>../</code> 上一层目录</li>
<li><code>../../ </code> 上一层的上一层</li>
</ul>
<p><strong>文件操作指令</strong></p>
<ul>
<li><code>mkdir</code> 创建文件夹 <code>mkdir  mydir</code></li>
<li><code>touch</code> 创建空文件 <code>touch myfile</code></li>
<li><code>rmdir</code> 删除一个空文件夹</li>
<li><code>rm</code> 删除一个文件或文件夹,默认删除文件</li>
<li><code>rm -r</code> 	删除文件夹</li>
</ul>
<p><strong>打印定向指令</strong></p>
<ul>
<li><code>echo</code> 打印一串字符 <code>echo  hello world</code></li>
<li>&gt; 输出重定向&#x2F;指定输出的目标文件</li>
<li>&gt;&gt; 向指定文件中追加内容</li>
<li><code>cat</code> 读文件内容并打印 <code>cat readme</code></li>
</ul>
<p><strong>root&amp;sudo</strong></p>
<ul>
<li><code>sudo passwd</code> 通过普通用户修改超级用户 (root) 的密码.</li>
<li><code>su  root</code> 切换用户为 root 用户 (超级用户)</li>
<li><code>su  lemonade</code> 切换为 lemonade 用户.</li>
<li><code>sudo</code> 用普通用户权限执行 root 的功能</li>
</ul>
<blockquote>
<p>普通用户权限执行 root 的功能需注意用户环境下的环境变量和 root 用户环境的下环境变量是否一致</p>
</blockquote>
<p><strong>移动拷贝指令</strong></p>
<ul>
<li><code>mv</code> 移动命令 <code>mv   source  dest``mv   source  dir</code></li>
<li><code>cp</code> 拷贝命令</li>
</ul>
<p><strong>man 用户帮助手册</strong></p>
<p><code>man ls </code></p>
<blockquote>
<p><code>ls  [options]...    [file]... </code></p>
<p><code>options</code> 选项或参数</p>
<p><code>file</code> 目标文件或文件夹</p>
<p><code>[]</code> 可选标志</p>
<p><code>...</code> 多参机制</p>
</blockquote>
<p><strong>改变权值的命令</strong></p>
<ul>
<li><code>chmod  777 readme.sh </code> 所有用户可读可写可执行</li>
</ul>
<blockquote>
<p>文件类型:</p>
<p>- ：普通文件<br>d : 文件夹&#x2F;目录<br>l : 链接 (快捷方式)<br>s : 网络套接字<br>p: 管道<br>b : 块设备, 磁盘 c : 字符设备, 键盘</p>
</blockquote>
<p><strong>关机</strong></p>
<ul>
<li><code>halt</code> 关机</li>
<li><code>reboot</code> 重启</li>
<li><code>sudo shutdown  -h  now</code> 加上关机时间</li>
<li><code>sudo shutdown  -h  +1 &quot;See You la la&quot;</code> 加上关机备注</li>
</ul>
<h1 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h1><h2 id="设置服务"><a href="#设置服务" class="headerlink" title="设置服务"></a>设置服务</h2><p>编辑或创建 <code>/usr/lib/systemd/system/startmyapp.service</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]    #服务的说明</span><br><span class="line">Description=nginx    #描述服务</span><br><span class="line">After=network.target    #描述服务类别</span><br><span class="line"></span><br><span class="line">[Service]    #服务运行参数的设置</span><br><span class="line">Type=forking    #是后台运行的形式</span><br><span class="line">PIDFile=/var/run/nginx.pid</span><br><span class="line">ExecStartPre=/usr/bin/nginx -t -c ./nginx.conf</span><br><span class="line">ExecStart=/usr/bin/nginx -c ./nginx.conf    #服务的具体运行命令</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID    #重启命令</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID    #停止命令</span><br><span class="line">PrivateTmp=true    #给服务分配独立的临时空间</span><br><span class="line"></span><br><span class="line">[Install]    #运行级别下服务安装的相关设置</span><br><span class="line">WantedBy=multi-user.target    #设置为多用户，系统运行级别为3</span><br></pre></td></tr></table></figure>

<p><strong>操作服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置开机自启动</span><br><span class="line">systemctl enable startmyapp.service</span><br><span class="line"># 停止开机自启动</span><br><span class="line">systemctl disable startmyapp.service</span><br><span class="line"># 启动服务</span><br><span class="line">systemctl start startmyapp.service</span><br><span class="line"># 关闭服务</span><br><span class="line">systemctl stop startmyapp.service</span><br><span class="line"># 重新启动服务</span><br><span class="line">systemctl restart startmyapp.service</span><br><span class="line"># 重新加载服务配置文件</span><br><span class="line">systemctl reload startmyapp.service</span><br><span class="line"># 查看服务当前状态</span><br><span class="line">systemctl status startmyapp.service</span><br><span class="line"># 查看所有已启动的服务</span><br><span class="line">systemctl list-units --type=services</span><br><span class="line"># 查询服务是否开机启动</span><br><span class="line">systemctl is-enabled startmyapp.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="设置脚本"><a href="#设置脚本" class="headerlink" title="设置脚本"></a>设置脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.local</span><br><span class="line"></span><br><span class="line"># 添加启动脚本</span><br><span class="line">/usr/bin/nginx start</span><br><span class="line"></span><br><span class="line">chmod +x /etc/rc.d/rc.local</span><br><span class="line"># /etc/rc.d/rc.local是/etc/rc.local的软连接</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux自启动脚本</title>
    <url>/2024/05/21/%E5%B9%B3%E5%8F%B0Platform-Linux-Linux%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="Adding-as-a-startup-service-recommended"><a href="#Adding-as-a-startup-service-recommended" class="headerlink" title="Adding as a startup service (recommended)"></a>Adding as a startup service (recommended)</h3><p>Create a service file in <code>/etc/systemd/system/my_startup.service</code>:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=myStartUp Service</span><br><span class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/start/bash/path </span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=default.target</span><br></pre></td></tr></table></figure>

<p>Then start the service:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> my_startup</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>时间编程</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h1><p><strong>Coordinated Unicersal Time（UTC）</strong>：世界标准时间，也就是大家所熟知的格林威治标准时间（Greenwich Mean Time 吗 GMT）</p>
<p><strong>Calendar Time</strong>：日历时间，是用“从一个标准时间点（如：1970 年 1 月 1 日 0 点）到此时经过的秒数”来表示时间</p>
<h1 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h1><p><strong>获取日历时间，即从 1970 年 1 月 1 日 0 点到现在所经历的秒数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line">time_t time(time_t*tloc);</span><br></pre></td></tr></table></figure>

<p><strong>将日历时间转化为格林威治标准时间，并保存至 TM 结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct tm *gmtime(const time_t*timep);</span><br></pre></td></tr></table></figure>

<p><strong>将日历时间转化为本地时间，并保存至 TM 结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct tm *localtime(const time_t*timep);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct tm &#123;</span><br><span class="line">int tm_sec; /* Seconds(0-60) */</span><br><span class="line">int tm_min; /* Minutes(0-59) */</span><br><span class="line">int tm_hour; /* Hours(0-23) */</span><br><span class="line">int tm_mday; /* Day of the month (1-31) */</span><br><span class="line">int tm_mon; /* Month (0-11) */</span><br><span class="line">int tm_year; /* Year - 1900 */</span><br><span class="line">int tm_wday; /* Day of the week (0-6, Sunday = 0) */</span><br><span class="line">int tm_yday; /* Dayin the year (0-365, 1 Jan = 0) */</span><br><span class="line">int tm_isdst; /* Daylightsaving time */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>将 tm 格式的时间转化为字符串，如：Sat Jul 30 08：43：03：2005</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char*asctime(conststruct tm *tm);</span><br></pre></td></tr></table></figure>

<p><strong>将日历时间转化为本地时间的字符串形式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char*ctime(const time_t*timep);</span><br></pre></td></tr></table></figure>

<p><strong>获取从今日凌晨到现在的时间差，常用于计算事件耗时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">int gettimeofday(struct timeval *tv,struct timezone *tz);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct timeval &#123;</span><br><span class="line">time_t tv_sec; /*seconds*/ 秒数</span><br><span class="line">suseconds_t tv_usec; /* microseconds*/ 微秒</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h1><p><strong>使程序睡眠 seconds</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned intsleep(unsigned intseconds);</span><br></pre></td></tr></table></figure>

<p><strong>使程序睡眠 usec 微秒</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int usleep(useconds_t usec);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>机器大小端校验</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="大小端字节序"><a href="#大小端字节序" class="headerlink" title="大小端字节序"></a>大小端字节序</h1><p>大端字节序（Big-Endian）和小端字节序（Little-Endian）是两种不同的字节存储顺序方式，用于在多字节数据类型（如整数、浮点数）在内存中的表示。</p>
<p>在大端字节序中，较高字节（最高有效字节）保存在较低的存储地址，而较低字节（最低有效字节）保存在较高的存储地址。换句话说，数据的高位字节存储在低地址位置，低位字节存储在高地址位置。</p>
<p>例如，整数值 0x12345678 在大端字节序中的存储顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址： 0x1000   0x1001   0x1002   0x1003</span><br><span class="line">数据：  0x12     0x34     0x56     0x78</span><br></pre></td></tr></table></figure>

<p>相比之下，在小端字节序中，较低字节保存在较低的存储地址，而较高字节保存在较高的存储地址。数据的低位字节存储在低地址位置，高位字节存储在高地址位置。</p>
<p>使用同样的示例值 0x12345678，小端字节序的存储顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址： 0x1000   0x1001   0x1002   0x1003</span><br><span class="line">数据：  0x78     0x56     0x34     0x12</span><br></pre></td></tr></table></figure>

<h1 id="64-位和-32-位的不同"><a href="#64-位和-32-位的不同" class="headerlink" title="64 位和 32 位的不同"></a>64 位和 32 位的不同</h1><p>64 位和 32 位的大小端情况是类似的，但存在一些细微差异。</p>
<p>在 64 位系统中，数据被划分为 8 字节（64 位），而在 32 位系统中，数据被划分为 4 字节（32 位）。因此，字节的顺序和对齐方式在这两种情况下可能会有所不同。</p>
<p>例如，考虑一个 64 位整数值 0x1122334455667788。</p>
<p>在大端字节序中，存储顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址： 0x1000   0x1001   0x1002   0x1003   0x1004   0x1005   0x1006   0x1007</span><br><span class="line">数据：  0x11     0x22     0x33     0x44     0x55     0x66     0x77     0x88</span><br></pre></td></tr></table></figure>

<p>而在小端字节序中，存储顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址： 0x1000   0x1001   0x1002   0x1003   0x1004   0x1005   0x1006   0x1007</span><br><span class="line">数据：  0x88     0x77     0x66     0x55     0x44     0x33     0x22     0x11</span><br></pre></td></tr></table></figure>

<p>尽管在 64 位和 32 位系统上字节顺序的原理相同，但具体的存储布局和访问方式可能有所不同。因此，在跨平台开发或数据交换中，需要注意字节序的差异，并采取适当的转换方法以确保数据的正确解释和传输。</p>
<h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>字节序的选择对于不同的计算机体系结构和通信协议至关重要。它主要影响以下方面：</p>
<p>数据传输：在网络通信和数据交换中，如果通信双方使用不同的字节序，就需要进行字节序的转换，以确保正确解释和传输数据。</p>
<p>文件格式：某些文件格式（如图像、音频、视频）可能使用特定的字节序来存储数据，因此读取和解析这些文件时需要考虑字节序。</p>
<p>处理器架构：不同的处理器架构可能采用不同的字节序。例如，x86 架构使用小端字节序，而 PowerPC 架构使用大端字节序。在开发软件时，需要根据目标处理器架构的字节序选择适当的数据处理方式。</p>
<p>正确地处理字节序是确保跨平台兼容性和数据一致性的重要方面，特别是在网络通信和数据交换的情况下。</p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>整数值 0x12345678 在 64 位和 32 位系统上，以大端字节序和小端字节序存储的示例：</p>
<p>64 位系统大端字节序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址： 0x1000   0x1001   0x1002   0x1003   0x1004   0x1005   0x1006   0x1007</span><br><span class="line">数据：  0x12     0x34     0x56     0x78     0x00     0x00     0x00     0x00</span><br></pre></td></tr></table></figure>

<p>64 位系统小端字节序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址： 0x1000   0x1001   0x1002   0x1003   0x1004   0x1005   0x1006   0x1007</span><br><span class="line">数据：  0x00     0x00     0x00     0x00     0x78     0x56     0x34     0x12</span><br></pre></td></tr></table></figure>

<p>32 位系统大端字节序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址： 0x1000   0x1001   0x1002   0x1003</span><br><span class="line">数据：  0x12     0x34     0x56     0x78</span><br></pre></td></tr></table></figure>

<p>32 位系统小端字节序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址： 0x1000   0x1001   0x1002   0x1003</span><br><span class="line">数据：  0x78     0x56     0x34     0x12</span><br></pre></td></tr></table></figure>

<h1 id="校验方法"><a href="#校验方法" class="headerlink" title="校验方法"></a>校验方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned int num = 0x01020304;</span><br><span class="line">    unsigned char *ptr = (unsigned char*)&amp;num;</span><br><span class="line"></span><br><span class="line">    if (*ptr == 0x01) &#123;</span><br><span class="line">        printf(&quot;大端字节序\n&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;小端字节序\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>管理员口令丢失</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-%E7%AE%A1%E7%90%86%E5%91%98%E5%8F%A3%E4%BB%A4%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<h1 id="管理员口令丢失解决办法"><a href="#管理员口令丢失解决办法" class="headerlink" title="管理员口令丢失解决办法"></a>管理员口令丢失解决办法</h1><ul>
<li>开机从 LILO 或 GRUB 中选择进入单用户模式（运行级别 1）</li>
<li>使用 passwd 命令修改 root 口令</li>
<li>重新切换为运行级别 3 或 5</li>
</ul>
<h1 id="切换到-root-用户，但是不切换用户环境"><a href="#切换到-root-用户，但是不切换用户环境" class="headerlink" title="切换到 root 用户，但是不切换用户环境"></a>切换到 root 用户，但是不切换用户环境</h1><p>sudo –s</p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Vmware共享文件夹</title>
    <url>/2024/05/21/%E5%B9%B3%E5%8F%B0Platform-VMware-Vmware%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<h1 id="查看共享的文件夹"><a href="#查看共享的文件夹" class="headerlink" title="查看共享的文件夹"></a>查看共享的文件夹</h1><p>使用 vmware-hgfsclient 命令</p>
<p>输入 <code>vmware-hgfsclient</code> 显示共享文件夹名称</p>
<h1 id="挂载共享文件夹"><a href="#挂载共享文件夹" class="headerlink" title="挂载共享文件夹"></a>挂载共享文件夹</h1><p>使用 vmhgfs-fuse 命令</p>
<p><code>vmhgfs-fuse .host:/ShareDir /home/forlinx/ShareDir -o subtype=vmhgfs-fuse,allow_other</code></p>
<p>将主机下的 ShareDir 挂载到虚拟机的&#x2F;home&#x2F;forlinx&#x2F;ShareDir 文件夹下</p>
<p>在虚拟机中设置共享文件夹完成后，发现共享文件夹没有出现，执行</p>
<p><code>vmhgfs-fuse .host:/ /home/forlinx/ShareDir文件夹下</code></p>
<p>如果没有其他显示报错，就可以认为挂载成功了。</p>
<ul>
<li>注意：&#x2F;mnt 文件夹下的 hgfs 是自己创建的，如果没有，可以用 <code>mkdir /mnt/hgfs</code> 命令创建。</li>
</ul>
<p>直接用 ls 命令查看 <code>ls /home/forlinx/ShareDir</code> 显示挂载的共享文件夹内的文件内容已经同步，表示成功挂载。</p>
<h1 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h1><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>创建一个 <code>startShare.sh</code></p>
<p>写入</p>
<p><code>vmhgfs-fuse .host:/ /home/forlinx/ShareDir</code></p>
<p>加权限</p>
<p><code>chmod a+x startShare.sh</code></p>
<p>添加该脚本到自启中</p>
<h2 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h2><p>另：如果不想每次重启后都挂载一遍的话，建议直接把挂载放入启动文件 首先，备份 <code>/etc/fstab</code> 文件 <code>cp fstab  fstab_bak</code> 其次，编辑 <code>fstab``vim fstab</code> 在最后一句添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mount hgfs</span><br><span class="line">.host:/kali_share       /mnt/hgfs        fuse.vmhgfs-fuse       allow_other     0       0</span><br></pre></td></tr></table></figure>

<p>然后就能够不用每次重启挂载一遍。</p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>VMware</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟机磁盘收缩</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-VMware-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%94%B6%E7%BC%A9/</url>
    <content><![CDATA[<h1 id="1-删除快照"><a href="#1-删除快照" class="headerlink" title="1. 删除快照"></a>1. 删除快照</h1><p>打开 VMware，选择工具栏的虚拟机，选择快照，选择快照管理器，删除不用的快照</p>
<h1 id="2-1-删除缓存文件"><a href="#2-1-删除缓存文件" class="headerlink" title="2.1 删除缓存文件"></a>2.1 删除缓存文件</h1><p>打开虚拟机，删除虚拟机中的缓存文件目录：</p>
<pre><code>/home/xxxx/.cache/vmware/drag_and_drop
</code></pre>
<blockquote>
<p>df -h 指令可查找到磁盘真实占据的磁盘空间</p>
</blockquote>
<h1 id="2-2-压缩磁盘空间"><a href="#2-2-压缩磁盘空间" class="headerlink" title="2.2 压缩磁盘空间"></a>2.2 压缩磁盘空间</h1><p>当虚拟机安装盘所剩余的空间大于.vmdk 文件的大小时，强烈推荐使用以下方式 在你的终端输入</p>
<pre><code>sudo /usr/bin/vmware-toolbox-cmd disk list
</code></pre>
<p>一般会有 <code>&quot;/&quot;</code> 目录 再输入</p>
<pre><code>sudo /usr/bin/vmware-toolbox-cmd disk shrink /
</code></pre>
<p>即压缩根目录 <code>&quot;/&quot;</code></p>
<h1 id="3-导出-OVF-重新建立新-vmdk"><a href="#3-导出-OVF-重新建立新-vmdk" class="headerlink" title="3. 导出 OVF 重新建立新 vmdk"></a>3. 导出 OVF 重新建立新 vmdk</h1><p>有时候删除虚拟机快照出现错误，但快照图标已消失，导致无法再次删除，造成文件残留，就这样越堆越多，无法清理。</p>
<blockquote>
<p>优点是可以释放大量空间，缺点是只能保留 VMware 虚拟机当前的状态和文件，丢失其他快照（可以按需先转到某个快照再导出 OVF，这样就可以保留快照时的状态了。同样，会丢失其他状态）。<br>步骤如下：</p>
</blockquote>
<ul>
<li>点击要清理的虚拟机，然后左上角点击文件，导出为 OVF（只存了虚拟机当前的状态，大概有十几个 G），存到其他空闲的磁盘下。</li>
<li>将上述步骤导出的 ovf 再部署出来，看看虚拟机是否正常。</li>
<li>如果正常可用，就可以把虚拟机原来占用的磁盘清空了，快速释放大量空间。</li>
</ul>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>VMware</category>
      </categories>
  </entry>
  <entry>
    <title>USB设备连接到WSL</title>
    <url>/2024/05/21/%E5%B9%B3%E5%8F%B0Platform-WSL-USB%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E5%88%B0WSL/</url>
    <content><![CDATA[<p>在 WSL2 中连接 3D 打印机的 USB 端口，须将该设备从 windows 中挂载至 Linux 中，需要在 windows 环境中安装 usbipd</p>
<p>usbipd GitHub 地址 <a href="https://github.com/dorssel/usbipd-win">https://github.com/dorssel/usbipd-win</a></p>
<p>安装 usbipd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在win命令行中执行</span><br><span class="line">winget install usbipd</span><br></pre></td></tr></table></figure>

<p>安装环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##在你的wsl中执行</span><br><span class="line">sudo apt install linux-tools-virtual hwdata</span><br><span class="line">sudo update-alternatives --install /usr/local/bin/usbip usbip `ls /usr/lib/linux-tools/*/usbip | tail -n1` 20</span><br></pre></td></tr></table></figure>

<p>*usbipd: error: WSL ‘usbip’ client not correctly installed.<br>重新执行此步骤</p>
<p>列出并挂载 win 中的设备到 linux 环境下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在win终端中执行</span><br><span class="line">usbipd wsl list</span><br><span class="line">usbipd wsl attach --busid=4-1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>WSL</category>
      </categories>
  </entry>
  <entry>
    <title>LNMP环境部署wordpress</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-LNMP%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2wordpress/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于在利用 Docker 部署 wordpress 时发现，很多需要修改的文件都需要通过 docker-compose 的脚本映射到本地，不好修改，另外由于 docker 的属性，导致 docker 在关闭并重启后，数据会丢失，必须利用 volume 或者“data container”来实现数据持久化</p>
<p>在容器关闭之后可以利用“-v”或者“–volumes-from”重新使用以前的数据，docker 也可挂载宿主机磁盘目录，用来永久存储数据。</p>
<p>所以还是通过自己配置 LNMP 的基础运行环境，能够看到并修改所有文件的方式才比较放心。 目前 LNMP 环境的配置，可以通过多种方法：</p>
<ol>
<li> 通过宝塔面板，可视化配置</li>
<li> 通过脚本，一键配置所有软件</li>
<li> 各软件环境自己手动安装，手动配置 这次我们通过脚本配置，之后导入原来的 docker 中搭建的 wordpress 的所有数据。</li>
</ol>
<h1 id="LNMP-介绍"><a href="#LNMP-介绍" class="headerlink" title="LNMP 介绍"></a>LNMP 介绍</h1><p>LNMP 只是 wordpress 运行的基础环境，LNMP 是一种常用的 Web 服务器架构，它的名字代表了其中的四个组件：Linux、Nginx、MySQL&#x2F;MariaDB 和 PHP。这些组件分别扮演了不同的角色：</p>
<p><strong>Linux</strong>：操作系统，提供了基本的系统服务和资源管理； <strong>Nginx</strong>：Web 服务器，处理客户端请求并将其转发给后端的应用程序； <strong>MySQL&#x2F;MariaDB</strong>：关系型数据库，用于存储和管理应用程序的数据； <strong>PHP</strong>：服务器端编程语言，用于编写应用程序的业务逻辑。<br>LNMP 架构的优点在于：<br><strong>高性能</strong>：Nginx 是一个高性能的 Web 服务器，能够处理大量并发请求；<br><strong>稳定可靠</strong>：Linux 是一个稳定可靠的操作系统，能够提供良好的系统服务和资源管理；<br><strong>易于扩展</strong>：MySQL&#x2F;MariaDB 是一个成熟的关系型数据库，支持高可用和分布式架构；<br><strong>灵活可定制</strong>：PHP 是一种灵活可定制的服务器端编程语言，能够满足不同的业务需求。</p>
<p>LNMP 架构被广泛应用于 Web 开发和运维领域，特别是在高并发和大数据场景下，具有良好的性能表现和可扩展性。</p>
<p>还有其余的诸如： LAMP 的全称是 Linux + Apache + MySQL + PHP LNAMP 的全称是 Linux + Nginx + Apache + MySQL + PHP 其中 Apache 是世界使用排名第一的 Web 服务器软件。 它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。</p>
<h1 id="安装-LNMP"><a href="#安装-LNMP" class="headerlink" title="安装 LNMP"></a>安装 LNMP</h1><p><a href="https://lnmp.org/install.html">源项目地址</a> 下载 LNMP 安装脚本（指定版本为 1.5）</p>
<p><code>wget http://soft.vpser.net/lnmp/lnmp1.9.tar.gz</code></p>
<p>解压并执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar zxf lnmp1.9.tar.gz</span><br><span class="line">cd lnmp1.9</span><br><span class="line">./install.sh lnmp</span><br></pre></td></tr></table></figure>

<ol>
<li> 运行脚本后，首先会让你选择数据库的版本： MYSQL&#x2F;MariaDB</li>
<li> 选好数据库，会让你设置数据库 root 用户的密码:<ul>
<li>如果输入有错误需要删除，需要按住 Ctrl 再%</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>云服务器</category>
      </categories>
  </entry>
  <entry>
    <title>微信公众号后端配置</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/wechat&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wechat_signature</span>():</span><br><span class="line">    data = request.args</span><br><span class="line">    echostr = data.get(<span class="string">&#x27;echostr&#x27;</span>)</span><br><span class="line">    signature = data.get(<span class="string">&#x27;signature&#x27;</span>)</span><br><span class="line">    timestamp = data.get(<span class="string">&#x27;timestamp&#x27;</span>)</span><br><span class="line">    nonce = data.get(<span class="string">&quot;nonce&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> signature <span class="keyword">or</span> <span class="keyword">not</span> timestamp <span class="keyword">or</span> <span class="keyword">not</span> nonce:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    tmp_str = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>([<span class="string">&#x27;liuluhua&#x27;</span>, timestamp, nonce]))</span><br><span class="line">    tmp_str = hashlib.sha1(tmp_str.encode(<span class="string">&#x27;UTF-8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> tmp_str == signature:</span><br><span class="line">        <span class="keyword">return</span> echostr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Failed&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/wechat&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wechat_communication</span>():</span><br><span class="line">    <span class="comment">#获取微信服务器post过来的xml数据</span></span><br><span class="line">    xml = request.data</span><br><span class="line">    <span class="comment"># 把xml格式的数据进行处理，转换成字典进行取值</span></span><br><span class="line">​    req = xmltodict.parse(xml)[<span class="string">&#x27;xml&#x27;</span>]</span><br><span class="line">    <span class="comment"># 判断post过来的数据中数据类型是不是文本</span></span><br><span class="line">​    <span class="keyword">if</span> <span class="string">&#x27;text&#x27;</span> == req.get(<span class="string">&#x27;MsgType&#x27;</span>):</span><br><span class="line">    <span class="comment"># 获取用户的信息，开始构造返回数据，把用户发送的信息原封不动的返回过去，字典格式</span></span><br><span class="line">​        resp = &#123;</span><br><span class="line">​            <span class="string">&#x27;ToUserName&#x27;</span>:req.get(<span class="string">&#x27;FromUserName&#x27;</span>),</span><br><span class="line">​            <span class="string">&#x27;FromUserName&#x27;</span>:req.get(<span class="string">&#x27;ToUserName&#x27;</span>),</span><br><span class="line">​            <span class="string">&#x27;CreateTime&#x27;</span>:<span class="built_in">int</span>(time.time()),</span><br><span class="line">​            <span class="string">&#x27;MsgType&#x27;</span>:<span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">​            <span class="string">&#x27;Content&#x27;</span>:req.get(<span class="string">&#x27;Content&#x27;</span>)</span><br><span class="line">​        &#125;</span><br><span class="line">        <span class="comment"># 把构造的字典转换成xml格式</span></span><br><span class="line">​        xml = xmltodict.unparse(&#123;<span class="string">&#x27;xml&#x27;</span>:resp&#125;)</span><br><span class="line">        <span class="comment"># print(req.get(&#x27;Content&#x27;))</span></span><br><span class="line">        <span class="comment"># 返回数据</span></span><br><span class="line">​        <span class="keyword">return</span> xml</span><br><span class="line">​    <span class="keyword">else</span>:</span><br><span class="line">​        resp = &#123;</span><br><span class="line">​            <span class="string">&#x27;ToUserName&#x27;</span>: req.get(<span class="string">&#x27;FromUserName&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">​            <span class="string">&#x27;FromUserName&#x27;</span>: req.get(<span class="string">&#x27;ToUserName&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">​            <span class="string">&#x27;CreateTime&#x27;</span>: <span class="built_in">int</span>(time.time()),</span><br><span class="line">​            <span class="string">&#x27;MsgType&#x27;</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">​            <span class="string">&#x27;Content&#x27;</span>: <span class="string">&#x27;I LOVE ITCAST&#x27;</span></span><br><span class="line">​        &#125;</span><br><span class="line">​        xml = xmltodict.unparse(&#123;<span class="string">&#x27;xml&#x27;</span>:resp&#125;)</span><br><span class="line">​        <span class="keyword">return</span> xml</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>云服务器</category>
      </categories>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2024/05/21/%E8%AF%AD%E8%A8%80-Python-Python/</url>
    <content><![CDATA[<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><p>打开终端，使用以下命令更新软件包列表：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>安装编译 Python 3.10 所需的依赖项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev wget</span><br></pre></td></tr></table></figure>

<p>下载 Python 3.10 的源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz</span><br></pre></td></tr></table></figure>

<p>解压源代码并进入解压后的目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xf Python-3.10.0.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.10.0</span><br></pre></td></tr></table></figure>

<p>配置 Python 3.10 的编译选项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --enable-optimizations</span><br></pre></td></tr></table></figure>

<p>编译并安装 Python 3.10：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make -j 8</span><br><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure>

<p>确认 Python 3.10 是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3.10 --version</span><br></pre></td></tr></table></figure>

<p>如果输出了 Python 3.10 的版本号，则说明安装成功。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python返回前端请求IP地址</title>
    <url>/2024/05/22/%E8%AF%AD%E8%A8%80-Python-Python%E8%BF%94%E5%9B%9E%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82IP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="前端-js-代码"><a href="#前端-js-代码" class="headerlink" title="前端 js 代码"></a>前端 js 代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="title function_">fetch</span>(<span class="string">&#x27;/get_ip&#x27;</span>,</span><br><span class="line">    &#123;<span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,<span class="attr">headers</span>: &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;,&#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;ip_addr&quot;</span>).<span class="property">innerHTML</span>=data&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>pip下载网络问题</title>
    <url>/2024/05/21/%E8%AF%AD%E8%A8%80-Python-pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在使用 Python 安装包工具 pip 时经常会出现下载很慢的情况，这其中有很大一部分原因和 pip 的源有关，在我们安装 python 后，通常 python 解释器自带 pip 这个工具，但是这里 pip 是设置的默认源，也就是官方源：<code>https://pypi.org/simple</code>，这个源在国内的下载速度是很慢的，所以我们为了提高包的下载速度我们可以通过换源来实现。</p>
<h1 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>可以在使用 pip 的时候加参数 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple markdown</span><br></pre></td></tr></table></figure>

<p>这样就会从清华这边的镜像去安装 markdown。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 清华源</span><br><span class="line">pip install markdown -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"># 阿里源</span><br><span class="line">pip install markdown -i https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"># 腾讯源</span><br><span class="line">pip install markdown -i http://mirrors.cloud.tencent.com/pypi/simple</span><br><span class="line"># 豆瓣源</span><br><span class="line">pip install markdown -i http://pypi.douban.com/simple/</span><br><span class="line"># 中国科学技术大学</span><br><span class="line">pip install markdown -i http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure>

<h2 id="报错未添加信任源"><a href="#报错未添加信任源" class="headerlink" title="报错未添加信任源"></a>报错未添加信任源</h2><p><code>pip install beautifulsoup4 --trusted-host mirrors.aliyun.com</code></p>
<h1 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 清华源</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"># 阿里源</span><br><span class="line">pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"># 腾讯源</span><br><span class="line">pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple</span><br><span class="line"># 豆瓣源</span><br><span class="line">pip config set global.index-url http://pypi.douban.com/simple/</span><br><span class="line"># 换回默认源</span><br><span class="line">pip config unset global.index-url</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>Linux 下 <code>~/.pip/pip.conf</code></li>
<li>Windows 下 &#96;&#96;%HOMEPATH%\pip\pip.ini&#96;<br>内容如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h2 id="报错未添加信任源-1"><a href="#报错未添加信任源-1" class="headerlink" title="报错未添加信任源"></a>报错未添加信任源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[install]</span><br><span class="line">trusted-host=pypi.douban.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>pythonWeb部署方案</title>
    <url>/2024/05/22/%E8%AF%AD%E8%A8%80-Python-pythonWeb%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><p>首先，确认系统安装的 Python 版本是 3.7.x：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 --version</span><br><span class="line">Python 3.7.0</span><br></pre></td></tr></table></figure>

<p>然后，用 <code>pip</code> 安装开发 Web App 需要的第三方库：</p>
<p>异步框架 aiohttp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$pip3 install aiohttp</span><br></pre></td></tr></table></figure>

<p>前端模板引擎 jinja2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip3 install jinja2</span><br></pre></td></tr></table></figure>

<p>MySQL 5.x 数据库，从 <a href="http://dev.mysql.com/downloads/mysql/5.6.html">官方网站</a> 下载并安装，安装完毕后，请务必牢记 root 口令。为避免遗忘口令，建议直接把 root 口令设置为 <code>password</code>；</p>
<p>MySQL 的 Python 异步驱动程序 aiomysql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip3 install aiomysql</span><br></pre></td></tr></table></figure>

<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>选择一个工作目录，然后，我们建立如下的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awesome-python3-webapp/  &lt;-- 根目录</span><br><span class="line">|</span><br><span class="line">+- backup/               &lt;-- 备份目录</span><br><span class="line">|</span><br><span class="line">+- conf/                 &lt;-- 配置文件</span><br><span class="line">|</span><br><span class="line">+- dist/                 &lt;-- 打包目录</span><br><span class="line">|</span><br><span class="line">+- www/                  &lt;-- Web目录，存放.py文件</span><br><span class="line">|  |</span><br><span class="line">|  +- static/            &lt;-- 存放静态文件</span><br><span class="line">|  |</span><br><span class="line">|  +- templates/         &lt;-- 存放模板文件</span><br><span class="line">|</span><br><span class="line">+- ios/                  &lt;-- 存放iOS App工程</span><br><span class="line">|</span><br><span class="line">+- LICENSE               &lt;-- 代码LICENSE</span><br></pre></td></tr></table></figure>

<p>创建好项目的目录结构后，建议同时建立 git 仓库并同步至 GitHub，保证代码修改的安全。</p>
<h3 id="Web-骨架"><a href="#Web-骨架" class="headerlink" title="Web 骨架"></a>Web 骨架</h3><p>由于我们的 Web App 建立在 asyncio 的基础上，因此用 aiohttp 写一个基本的 <code>app.py</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import logging; logging.basicConfig(level=logging.INFO)</span><br><span class="line">import asyncio, os, json, time</span><br><span class="line">from datetime import datetime</span><br><span class="line">from aiohttp import web</span><br><span class="line">def index(request):</span><br><span class="line">    return web.Response(body=b&#x27;&lt;h1&gt;Awesome&lt;/h1&gt;&#x27;)</span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def init(loop):</span><br><span class="line">    app = web.Application(loop=loop)</span><br><span class="line">    app.router.add_route(&#x27;GET&#x27;, &#x27;/&#x27;, index)</span><br><span class="line">    srv = yield from loop.create_server(app.make_handler(), &#x27;127.0.0.1&#x27;, 9000)</span><br><span class="line">    logging.info(&#x27;server started at http://127.0.0.1:9000...&#x27;)</span><br><span class="line">    return srv</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(init(loop))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure>

<p>运行 <code>python app.py</code>，Web App 将在 <code>9000</code> 端口监听 HTTP 请求，并且对首页 <code>/</code> 进行响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 app.py</span><br><span class="line">INFO:root:server started at http://127.0.0.1:9000...</span><br></pre></td></tr></table></figure>

<p>这里我们简单地返回一个 <code>Awesome</code> 字符串，在浏览器中可以看到效果</p>
<p>这说明我们的 Web App 骨架已经搭好了，可以进一步往里面添加更多的东西。</p>
<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM 全称是：Object Relational Mapping(对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录。</p>
<p>在一个 Web App 中，所有数据，包括用户信息、发布的日志、评论等，都存储在数据库中。在 awesome-python3-webapp 中，我们选择 MySQL 作为数据库。</p>
<p>Web App 里面有很多地方都要访问数据库。访问数据库需要创建数据库连接、游标对象，然后执行 SQL 语句，最后处理异常，清理资源。这些访问数据库的代码如果分散到各个函数中，势必无法维护，也不利于代码复用。</p>
<p>所以，我们要首先把常用的 SELECT、INSERT、UPDATE 和 DELETE 操作用函数封装起来。</p>
<p>由于 Web 框架使用了基于 asyncio 的 aiohttp，这是基于协程的异步模型。在协程中，不能调用普通的同步 IO 操作，因为所有用户都是由一个线程服务的，协程的执行速度必须非常快，才能处理大量用户的请求。而耗时的 IO 操作不能在协程中以同步的方式调用，否则，等待一个 IO 操作时，系统无法响应任何其他用户。</p>
<p>这就是异步编程的一个原则：一旦决定使用异步，则系统每一层都必须是异步，“开弓没有回头箭”。</p>
<p>幸运的是 <code>aiomysql</code> 为 MySQL 数据库提供了异步 IO 的驱动。</p>
<h3 id="创建连接池"><a href="#创建连接池" class="headerlink" title="创建连接池"></a>创建连接池</h3><p>我们需要创建一个全局的连接池，每个 HTTP 请求都可以从连接池中直接获取数据库连接。使用连接池的好处是不必频繁地打开和关闭数据库连接，而是能复用就尽量复用。</p>
<p>连接池由全局变量 <code>__pool</code> 存储，缺省情况下将编码设置为 <code>utf8</code>，自动提交事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def create_pool(loop, **kw):</span><br><span class="line">    logging.info(&#x27;create database connection pool...&#x27;)</span><br><span class="line">    global __pool</span><br><span class="line">    __pool = yield from aiomysql.create_pool(</span><br><span class="line">        host=kw.get(&#x27;host&#x27;, &#x27;localhost&#x27;),</span><br><span class="line">        port=kw.get(&#x27;port&#x27;, 3306),</span><br><span class="line">        user=kw[&#x27;user&#x27;],</span><br><span class="line">        password=kw[&#x27;password&#x27;],</span><br><span class="line">        db=kw[&#x27;db&#x27;],</span><br><span class="line">        charset=kw.get(&#x27;charset&#x27;, &#x27;utf8&#x27;),</span><br><span class="line">        autocommit=kw.get(&#x27;autocommit&#x27;, True),</span><br><span class="line">        maxsize=kw.get(&#x27;maxsize&#x27;, 10),</span><br><span class="line">        minsize=kw.get(&#x27;minsize&#x27;, 1),</span><br><span class="line">        loop=loop</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>要执行 SELECT 语句，我们用 <code>select</code> 函数执行，需要传入 SQL 语句和 SQL 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def select(sql, args, size=None):</span><br><span class="line">    log(sql, args)</span><br><span class="line">    global __pool</span><br><span class="line">    with (yield from __pool) as conn:</span><br><span class="line">        cur = yield from conn.cursor(aiomysql.DictCursor)</span><br><span class="line">        yield from cur.execute(sql.replace(&#x27;?&#x27;, &#x27;%s&#x27;), args or ())</span><br><span class="line">        if size:</span><br><span class="line">            rs = yield from cur.fetchmany(size)</span><br><span class="line">        else:</span><br><span class="line">            rs = yield from cur.fetchall()</span><br><span class="line">        yield from cur.close()</span><br><span class="line">        logging.info(&#x27;rows returned: %s&#x27; % len(rs))</span><br><span class="line">        return rs</span><br></pre></td></tr></table></figure>

<p>SQL 语句的占位符是 <code>?</code>，而 MySQL 的占位符是 <code>%s</code>，<code>select()</code> 函数在内部自动替换。注意要始终坚持使用带参数的 SQL，而不是自己拼接 SQL 字符串，这样可以防止 SQL 注入攻击。</p>
<p>注意到 <code>yield from</code> 将调用一个子协程（也就是在一个协程中调用另一个协程）并直接获得子协程的返回结果。</p>
<p>如果传入 <code>size</code> 参数，就通过 <code>fetchmany()</code> 获取最多指定数量的记录，否则，通过 <code>fetchall()</code> 获取所有记录。</p>
<h3 id="Insert-Update-Delete"><a href="#Insert-Update-Delete" class="headerlink" title="Insert, Update, Delete"></a>Insert, Update, Delete</h3><p>要执行 INSERT、UPDATE、DELETE 语句，可以定义一个通用的 <code>execute()</code> 函数，因为这 3 种 SQL 的执行都需要相同的参数，以及返回一个整数表示影响的行数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def execute(sql, args):</span><br><span class="line">    log(sql)</span><br><span class="line">    with (yield from __pool) as conn:</span><br><span class="line">        try:</span><br><span class="line">            cur = yield from conn.cursor()</span><br><span class="line">            yield from cur.execute(sql.replace(&#x27;?&#x27;, &#x27;%s&#x27;), args)</span><br><span class="line">            affected = cur.rowcount</span><br><span class="line">            yield from cur.close()</span><br><span class="line">        except BaseException as e:</span><br><span class="line">            raise</span><br><span class="line">        return affected</span><br></pre></td></tr></table></figure>

<p><code>execute()</code> 函数和 <code>select()</code> 函数所不同的是，cursor 对象不返回结果集，而是通过 <code>rowcount</code> 返回结果数。</p>
<h3 id="ORM-1"><a href="#ORM-1" class="headerlink" title="ORM"></a>ORM</h3><p>有了基本的 <code>select()</code> 和 <code>execute()</code> 函数，我们就可以开始编写一个简单的 ORM 了。</p>
<p>设计 ORM 需要从上层调用者角度来设计。</p>
<p>我们先考虑如何定义一个 <code>User</code> 对象，然后把数据库表 <code>users</code> 和它关联起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from orm import Model, StringField, IntegerField</span><br><span class="line">class User(Model):</span><br><span class="line">    __table__ = &#x27;users&#x27;</span><br><span class="line">    id = IntegerField(primary_key=True)</span><br><span class="line">    name = StringField()</span><br></pre></td></tr></table></figure>

<p>注意到定义在 <code>User</code> 类中的 <code>__table__</code>、<code>id</code> 和 <code>name</code> 是类的属性，不是实例的属性。所以，在类级别上定义的属性用来描述 <code>User</code> 对象和表的映射关系，而实例属性必须通过 <code>__init__()</code> 方法去初始化，所以两者互不干扰：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建实例:</span><br><span class="line">user = User(id=123, name=&#x27;Michael&#x27;)</span><br><span class="line"># 存入数据库:</span><br><span class="line">user.insert()</span><br><span class="line"># 查询所有User对象:</span><br><span class="line">users = User.findAll()</span><br></pre></td></tr></table></figure>

<h3 id="定义-Model"><a href="#定义-Model" class="headerlink" title="定义 Model"></a>定义 Model</h3><p>首先要定义的是所有 ORM 映射的基类 <code>Model</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Model(dict, metaclass=ModelMetaclass):</span><br><span class="line">    def __init__(self, **kw):</span><br><span class="line">        super(Model, self).__init__(**kw)</span><br><span class="line">    def __getattr__(self, key):</span><br><span class="line">        try:</span><br><span class="line">            return self[key]</span><br><span class="line">        except KeyError:</span><br><span class="line">            raise AttributeError(r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot; % key)</span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        self[key] = value</span><br><span class="line">    def getValue(self, key):</span><br><span class="line">        return getattr(self, key, None)</span><br><span class="line">    def getValueOrDefault(self, key):</span><br><span class="line">        value = getattr(self, key, None)</span><br><span class="line">        if value is None:</span><br><span class="line">            field = self.__mappings__[key]</span><br><span class="line">            if field.default is not None:</span><br><span class="line">                value = field.default() if callable(field.default) else field.default</span><br><span class="line">                logging.debug(&#x27;using default value for %s: %s&#x27; % (key, str(value)))</span><br><span class="line">                setattr(self, key, value)</span><br><span class="line">        return value</span><br></pre></td></tr></table></figure>

<p><code>Model</code> 从 <code>dict</code> 继承，所以具备所有 <code>dict</code> 的功能，同时又实现了特殊方法 <code>__getattr__()</code> 和 <code>__setattr__()</code>，因此又可以像引用普通字段那样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; user[&#x27;id&#x27;]</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; user.id</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>以及 <code>Field</code> 和各种 <code>Field</code> 子类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Field(object):</span><br><span class="line">    def __init__(self, name, column_type, primary_key, default):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.column_type = column_type</span><br><span class="line">        self.primary_key = primary_key</span><br><span class="line">        self.default = default</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &#x27;&lt;%s, %s:%s&gt;&#x27; % (self.__class__.__name__, self.column_type, self.name)</span><br></pre></td></tr></table></figure>

<p>映射 <code>varchar</code> 的 <code>StringField</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class StringField(Field):</span><br><span class="line">    def __init__(self, name=None, primary_key=False, default=None, ddl=&#x27;varchar(100)&#x27;):</span><br><span class="line">        super().__init__(name, ddl, primary_key, default)</span><br></pre></td></tr></table></figure>

<p>注意到 <code>Model</code> 只是一个基类，如何将具体的子类如 <code>User</code> 的映射信息读取出来呢？答案就是通过 metaclass：<code>ModelMetaclass</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ModelMetaclass(type):</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        # 排除Model类本身:</span><br><span class="line">        if name==&#x27;Model&#x27;:</span><br><span class="line">            return type.__new__(cls, name, bases, attrs)</span><br><span class="line">        # 获取table名称:</span><br><span class="line">        tableName = attrs.get(&#x27;__table__&#x27;, None) or name</span><br><span class="line">        logging.info(&#x27;found model: %s (table: %s)&#x27; % (name, tableName))</span><br><span class="line">        # 获取所有的Field和主键名:</span><br><span class="line">        mappings = dict()</span><br><span class="line">        fields = []</span><br><span class="line">        primaryKey = None</span><br><span class="line">        for k, v in attrs.items():</span><br><span class="line">            if isinstance(v, Field):</span><br><span class="line">                logging.info(&#x27;  found mapping: %s ==&gt; %s&#x27; % (k, v))</span><br><span class="line">                mappings[k] = v</span><br><span class="line">                if v.primary_key:</span><br><span class="line">                    # 找到主键:</span><br><span class="line">                    if primaryKey:</span><br><span class="line">                        raise RuntimeError(&#x27;Duplicate primary key for field: %s&#x27; % k)</span><br><span class="line">                    primaryKey = k</span><br><span class="line">                else:</span><br><span class="line">                    fields.append(k)</span><br><span class="line">        if not primaryKey:</span><br><span class="line">            raise RuntimeError(&#x27;Primary key not found.&#x27;)</span><br><span class="line">        for k in mappings.keys():</span><br><span class="line">            attrs.pop(k)</span><br><span class="line">        escaped_fields = list(map(lambda f: &#x27;`%s`&#x27; % f, fields))</span><br><span class="line">        attrs[&#x27;__mappings__&#x27;] = mappings # 保存属性和列的映射关系</span><br><span class="line">        attrs[&#x27;__table__&#x27;] = tableName</span><br><span class="line">        attrs[&#x27;__primary_key__&#x27;] = primaryKey # 主键属性名</span><br><span class="line">        attrs[&#x27;__fields__&#x27;] = fields # 除主键外的属性名</span><br><span class="line">        # 构造默认的SELECT, INSERT, UPDATE和DELETE语句:</span><br><span class="line">        attrs[&#x27;__select__&#x27;] = &#x27;select `%s`, %s from `%s`&#x27; % (primaryKey, &#x27;, &#x27;.join(escaped_fields), tableName)</span><br><span class="line">        attrs[&#x27;__insert__&#x27;] = &#x27;insert into `%s` (%s, `%s`) values (%s)&#x27; % (tableName, &#x27;, &#x27;.join(escaped_fields), primaryKey, create_args_string(len(escaped_fields) + 1))</span><br><span class="line">        attrs[&#x27;__update__&#x27;] = &#x27;update `%s` set %s where `%s`=?&#x27; % (tableName, &#x27;, &#x27;.join(map(lambda f: &#x27;`%s`=?&#x27; % (mappings.get(f).name or f), fields)), primaryKey)</span><br><span class="line">        attrs[&#x27;__delete__&#x27;] = &#x27;delete from `%s` where `%s`=?&#x27; % (tableName, primaryKey)</span><br><span class="line">        return type.__new__(cls, name, bases, attrs)</span><br></pre></td></tr></table></figure>

<p>这样，任何继承自 Model 的类（比如 User），会自动通过 ModelMetaclass 扫描映射关系，并存储到自身的类属性如 <code>__table__</code>、<code>__mappings__</code> 中。</p>
<p>然后，我们往 Model 类添加 class 方法，就可以让所有子类调用 class 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Model(dict):</span><br><span class="line">    ...</span><br><span class="line">    @classmethod</span><br><span class="line">    @asyncio.coroutine</span><br><span class="line">    def find(cls, pk):</span><br><span class="line">        &#x27; find object by primary key. &#x27;</span><br><span class="line">        rs = yield from select(&#x27;%s where `%s`=?&#x27; % (cls.__select__, cls.__primary_key__), [pk], 1)</span><br><span class="line">        if len(rs) == 0:</span><br><span class="line">            return None</span><br><span class="line">        return cls(**rs[0])</span><br></pre></td></tr></table></figure>

<p>User 类现在就可以通过类方法实现主键查找：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user = yield from User.find(&#x27;123&#x27;)</span><br></pre></td></tr></table></figure>

<p>往 Model 类添加实例方法，就可以让所有子类调用实例方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Model(dict):</span><br><span class="line">    ...</span><br><span class="line">    @asyncio.coroutine</span><br><span class="line">    def save(self):</span><br><span class="line">        args = list(map(self.getValueOrDefault, self.__fields__))</span><br><span class="line">        args.append(self.getValueOrDefault(self.__primary_key__))</span><br><span class="line">        rows = yield from execute(self.__insert__, args)</span><br><span class="line">        if rows != 1:</span><br><span class="line">            logging.warn(&#x27;failed to insert record: affected rows: %s&#x27; % rows)</span><br></pre></td></tr></table></figure>

<p>这样，就可以把一个 User 实例存入数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user = User(id=123, name=&#x27;Michael&#x27;)</span><br><span class="line">yield from user.save()</span><br></pre></td></tr></table></figure>

<p>最后一步是完善 ORM，对于查找，我们可以实现以下方法：</p>
<ul>
<li>findAll() - 根据 WHERE 条件查找；</li>
<li>findNumber() - 根据 WHERE 条件查找，但返回的是整数，适用于 <code>select count(*)</code> 类型的 SQL。<br>以及 <code>update()</code> 和 <code>remove()</code> 方法。<br>所有这些方法都必须用 <code>@asyncio.coroutine</code> 装饰，变成一个协程。<br>调用时需要特别注意：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user.save()</span><br></pre></td></tr></table></figure>

<p>没有任何效果，因为调用 <code>save()</code> 仅仅是创建了一个协程，并没有执行它。一定要用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yield from user.save()</span><br></pre></td></tr></table></figure>

<p>才真正执行了 INSERT 操作。</p>
<h3 id="编写-Model"><a href="#编写-Model" class="headerlink" title="编写 Model"></a>编写 Model</h3><p>有了 ORM，我们就可以把 Web App 需要的 3 个表用 <code>Model</code> 表示出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time, uuid</span><br><span class="line">from orm import Model, StringField, BooleanField, FloatField, TextField</span><br><span class="line">def next_id():</span><br><span class="line">    return &#x27;%015d%s000&#x27; % (int(time.time() * 1000), uuid.uuid4().hex)</span><br><span class="line">class User(Model):</span><br><span class="line">    __table__ = &#x27;users&#x27;</span><br><span class="line">    id = StringField(primary_key=True, default=next_id, ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    email = StringField(ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    passwd = StringField(ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    admin = BooleanField()</span><br><span class="line">    name = StringField(ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    image = StringField(ddl=&#x27;varchar(500)&#x27;)</span><br><span class="line">    created_at = FloatField(default=time.time)</span><br><span class="line">class Blog(Model):</span><br><span class="line">    __table__ = &#x27;blogs&#x27;</span><br><span class="line">    id = StringField(primary_key=True, default=next_id, ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    user_id = StringField(ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    user_name = StringField(ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    user_image = StringField(ddl=&#x27;varchar(500)&#x27;)</span><br><span class="line">    name = StringField(ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    summary = StringField(ddl=&#x27;varchar(200)&#x27;)</span><br><span class="line">    content = TextField()</span><br><span class="line">    created_at = FloatField(default=time.time)</span><br><span class="line">class Comment(Model):</span><br><span class="line">    __table__ = &#x27;comments&#x27;</span><br><span class="line">    id = StringField(primary_key=True, default=next_id, ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    blog_id = StringField(ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    user_id = StringField(ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    user_name = StringField(ddl=&#x27;varchar(50)&#x27;)</span><br><span class="line">    user_image = StringField(ddl=&#x27;varchar(500)&#x27;)</span><br><span class="line">    content = TextField()</span><br><span class="line">    created_at = FloatField(default=time.time)</span><br></pre></td></tr></table></figure>

<p>在编写 ORM 时，给一个 Field 增加一个 <code>default</code> 参数可以让 ORM 自己填入缺省值，非常方便。并且，缺省值可以作为函数对象传入，在调用 <code>save()</code> 时自动计算。</p>
<p>例如，主键 <code>id</code> 的缺省值是函数 <code>next_id</code>，创建时间 <code>created_at</code> 的缺省值是函数 <code>time.time</code>，可以自动设置当前日期和时间。</p>
<p>日期和时间用 <code>float</code> 类型存储在数据库中，而不是 <code>datetime</code> 类型，这么做的好处是不必关心数据库的时区以及时区转换问题，排序非常简单，显示的时候，只需要做一个 <code>float</code> 到 <code>str</code> 的转换，也非常容易。</p>
<h3 id="初始化数据库表"><a href="#初始化数据库表" class="headerlink" title="初始化数据库表"></a>初始化数据库表</h3><p>如果表的数量很少，可以手写创建表的 SQL 脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- schema.sql</span><br><span class="line">drop database if exists awesome;</span><br><span class="line">create database awesome;</span><br><span class="line">use awesome;</span><br><span class="line">grant select, insert, update, delete on awesome.* to &#x27;www-data&#x27;@&#x27;localhost&#x27; identified by &#x27;www-data&#x27;;</span><br><span class="line">create table users (</span><br><span class="line">    `id` varchar(50) not null,</span><br><span class="line">    `email` varchar(50) not null,</span><br><span class="line">    `passwd` varchar(50) not null,</span><br><span class="line">    `admin` bool not null,</span><br><span class="line">    `name` varchar(50) not null,</span><br><span class="line">    `image` varchar(500) not null,</span><br><span class="line">    `created_at` real not null,</span><br><span class="line">    unique key `idx_email` (`email`),</span><br><span class="line">    key `idx_created_at` (`created_at`),</span><br><span class="line">    primary key (`id`)</span><br><span class="line">) engine=innodb default charset=utf8;</span><br><span class="line">create table blogs (</span><br><span class="line">    `id` varchar(50) not null,</span><br><span class="line">    `user_id` varchar(50) not null,</span><br><span class="line">    `user_name` varchar(50) not null,</span><br><span class="line">    `user_image` varchar(500) not null,</span><br><span class="line">    `name` varchar(50) not null,</span><br><span class="line">    `summary` varchar(200) not null,</span><br><span class="line">    `content` mediumtext not null,</span><br><span class="line">    `created_at` real not null,</span><br><span class="line">    key `idx_created_at` (`created_at`),</span><br><span class="line">    primary key (`id`)</span><br><span class="line">) engine=innodb default charset=utf8;</span><br><span class="line">create table comments (</span><br><span class="line">    `id` varchar(50) not null,</span><br><span class="line">    `blog_id` varchar(50) not null,</span><br><span class="line">    `user_id` varchar(50) not null,</span><br><span class="line">    `user_name` varchar(50) not null,</span><br><span class="line">    `user_image` varchar(500) not null,</span><br><span class="line">    `content` mediumtext not null,</span><br><span class="line">    `created_at` real not null,</span><br><span class="line">    key `idx_created_at` (`created_at`),</span><br><span class="line">    primary key (`id`)</span><br><span class="line">) engine=innodb default charset=utf8;</span><br></pre></td></tr></table></figure>

<p>如果表的数量很多，可以从 <code>Model</code> 对象直接通过脚本自动生成 SQL 脚本，使用更简单。</p>
<p>把 SQL 脚本放到 MySQL 命令行里执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p &lt; schema.sql</span><br></pre></td></tr></table></figure>

<p>我们就完成了数据库表的初始化。</p>
<h3 id="编写数据访问代码"><a href="#编写数据访问代码" class="headerlink" title="编写数据访问代码"></a>编写数据访问代码</h3><p>接下来，就可以真正开始编写代码操作对象了。比如，对于 <code>User</code> 对象，我们就可以做如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import orm</span><br><span class="line">from models import User, Blog, Comment</span><br><span class="line">def test():</span><br><span class="line">    yield from orm.create_pool(user=&#x27;www-data&#x27;, password=&#x27;www-data&#x27;, database=&#x27;awesome&#x27;)</span><br><span class="line">    u = User(name=&#x27;Test&#x27;, email=&#x27;test@example.com&#x27;, passwd=&#x27;1234567890&#x27;, image=&#x27;about:blank&#x27;)</span><br><span class="line">    yield from u.save()</span><br><span class="line">for x in test():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>可以在 MySQL 客户端命令行查询，看看数据是不是正常存储到 MySQL 里面了。</p>
<h3 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h3><p>在正式开始 Web 开发前，我们需要编写一个 Web 框架。</p>
<p><code>aiohttp</code> 已经是一个 Web 框架了，为什么我们还需要自己封装一个？</p>
<p>原因是从使用者的角度来说，<code>aiohttp</code> 相对比较底层，编写一个 URL 的处理函数需要这么几步：</p>
<p>第一步，编写一个用 <code>@asyncio.coroutine</code> 装饰的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def handle_url_xxx(request):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>第二步，传入的参数需要自己从 <code>request</code> 中获取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url_param = request.match_info[&#x27;key&#x27;]</span><br><span class="line">query_params = parse_qs(request.query_string)</span><br></pre></td></tr></table></figure>

<p>最后，需要自己构造 <code>Response</code> 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text = render(&#x27;template&#x27;, data)</span><br><span class="line">return web.Response(text.encode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>

<p>这些重复的工作可以由框架完成。例如，处理带参数的 URL<code>/blog/&#123;id&#125;</code> 可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@get(&#x27;/blog/&#123;id&#125;&#x27;)</span><br><span class="line">def get_blog(id):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>处理 <code>query_string</code> 参数可以通过关键字参数 <code>**kw</code> 或者命名关键字参数接收：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@get(&#x27;/api/comments&#x27;)</span><br><span class="line">def api_comments(*, page=&#x27;1&#x27;):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>对于函数的返回值，不一定是 <code>web.Response</code> 对象，可以是 <code>str</code>、<code>bytes</code> 或 <code>dict</code>。</p>
<p>如果希望渲染模板，我们可以这么返回一个 <code>dict</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return &#123;</span><br><span class="line">    &#x27;__template__&#x27;: &#x27;index.html&#x27;,</span><br><span class="line">    &#x27;data&#x27;: &#x27;...&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，Web 框架的设计是完全从使用者出发，目的是让使用者编写尽可能少的代码。</p>
<p>编写简单的函数而非引入 <code>request</code> 和 <code>web.Response</code> 还有一个额外的好处，就是可以单独测试，否则，需要模拟一个 <code>request</code> 才能测试。</p>
<h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="@get 和@post"></a>@get 和@post</h3><p>要把一个函数映射为一个 URL 处理函数，我们先定义 <code>@get()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def get(path):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Define decorator @get(&#x27;/path&#x27;)</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        wrapper.__method__ = &#x27;GET&#x27;</span><br><span class="line">        wrapper.__route__ = path</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure>

<p>这样，一个函数通过 <code>@get()</code> 的装饰就附带了 URL 信息。</p>
<p><code>@post</code> 与 <code>@get</code> 定义类似。</p>
<h3 id="定义-RequestHandler"><a href="#定义-RequestHandler" class="headerlink" title="定义 RequestHandler"></a>定义 RequestHandler</h3><p>URL 处理函数不一定是一个 <code>coroutine</code>，因此我们用 <code>RequestHandler()</code> 来封装一个 URL 处理函数。</p>
<p><code>RequestHandler</code> 是一个类，由于定义了 <code>__call__()</code> 方法，因此可以将其实例视为函数。</p>
<p><code>RequestHandler</code> 目的就是从 URL 函数中分析其需要接收的参数，从 <code>request</code> 中获取必要的参数，调用 URL 函数，然后把结果转换为 <code>web.Response</code> 对象，这样，就完全符合 <code>aiohttp</code> 框架的要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class RequestHandler(object):</span><br><span class="line">    def __init__(self, app, fn):</span><br><span class="line">        self._app = app</span><br><span class="line">        self._func = fn</span><br><span class="line">        ...</span><br><span class="line">    @asyncio.coroutine</span><br><span class="line">    def __call__(self, request):</span><br><span class="line">        kw = ... 获取参数</span><br><span class="line">        r = yield from self._func(**kw)</span><br><span class="line">        return r</span><br></pre></td></tr></table></figure>

<p>再编写一个 <code>add_route</code> 函数，用来注册一个 URL 处理函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def add_route(app, fn):</span><br><span class="line">    method = getattr(fn, &#x27;__method__&#x27;, None)</span><br><span class="line">    path = getattr(fn, &#x27;__route__&#x27;, None)</span><br><span class="line">    if path is None or method is None:</span><br><span class="line">        raise ValueError(&#x27;@get or @post not defined in %s.&#x27; % str(fn))</span><br><span class="line">    if not asyncio.iscoroutinefunction(fn) and not inspect.isgeneratorfunction(fn):</span><br><span class="line">        fn = asyncio.coroutine(fn)</span><br><span class="line">    logging.info(&#x27;add route %s %s =&gt; %s(%s)&#x27; % (method, path, fn.__name__, &#x27;, &#x27;.join(inspect.signature(fn).parameters.keys())))</span><br><span class="line">    app.router.add_route(method, path, RequestHandler(app, fn))</span><br></pre></td></tr></table></figure>

<p>最后一步，把很多次 <code>add_route()</code> 注册的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_route(app, handles.index)</span><br><span class="line">add_route(app, handles.blog)</span><br><span class="line">add_route(app, handles.create_comment)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>变成自动扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自动把handler模块的所有符合条件的函数注册了:</span><br><span class="line">add_routes(app, &#x27;handlers&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>add_routes()</code> 定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def add_routes(app, module_name):</span><br><span class="line">    n = module_name.rfind(&#x27;.&#x27;)</span><br><span class="line">    if n == (-1):</span><br><span class="line">        mod = __import__(module_name, globals(), locals())</span><br><span class="line">    else:</span><br><span class="line">        name = module_name[n+1:]</span><br><span class="line">        mod = getattr(__import__(module_name[:n], globals(), locals(), [name]), name)</span><br><span class="line">    for attr in dir(mod):</span><br><span class="line">        if attr.startswith(&#x27;_&#x27;):</span><br><span class="line">            continue</span><br><span class="line">        fn = getattr(mod, attr)</span><br><span class="line">        if callable(fn):</span><br><span class="line">            method = getattr(fn, &#x27;__method__&#x27;, None)</span><br><span class="line">            path = getattr(fn, &#x27;__route__&#x27;, None)</span><br><span class="line">            if method and path:</span><br><span class="line">                add_route(app, fn)</span><br></pre></td></tr></table></figure>

<p>最后，在 <code>app.py</code> 中加入 <code>middleware</code>、<code>jinja2</code> 模板和自注册的支持：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app = web.Application(loop=loop, middlewares=[</span><br><span class="line">    logger_factory, response_factory</span><br><span class="line">])</span><br><span class="line">init_jinja2(app, filters=dict(datetime=datetime_filter))</span><br><span class="line">add_routes(app, &#x27;handlers&#x27;)</span><br><span class="line">add_static(app)</span><br></pre></td></tr></table></figure>

<h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p><code>middleware</code> 是一种拦截器，一个 URL 在被某个函数处理前，可以经过一系列的 <code>middleware</code> 的处理。</p>
<p>一个 <code>middleware</code> 可以改变 URL 的输入、输出，甚至可以决定不继续处理而直接返回。middleware 的用处就在于把通用的功能从每个 URL 处理函数中拿出来，集中放到一个地方。例如，一个记录 URL 日志的 <code>logger</code> 可以简单定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def logger_factory(app, handler):</span><br><span class="line">    @asyncio.coroutine</span><br><span class="line">    def logger(request):</span><br><span class="line">        # 记录日志:</span><br><span class="line">        logging.info(&#x27;Request: %s %s&#x27; % (request.method, request.path))</span><br><span class="line">        # 继续处理请求:</span><br><span class="line">        return (yield from handler(request))</span><br><span class="line">    return logger</span><br></pre></td></tr></table></figure>

<p>而 <code>response</code> 这个 <code>middleware</code> 把返回值转换为 <code>web.Response</code> 对象再返回，以保证满足 <code>aiohttp</code> 的要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def response_factory(app, handler):</span><br><span class="line">    @asyncio.coroutine</span><br><span class="line">    def response(request):</span><br><span class="line">        # 结果:</span><br><span class="line">        r = yield from handler(request)</span><br><span class="line">        if isinstance(r, web.StreamResponse):</span><br><span class="line">            return r</span><br><span class="line">        if isinstance(r, bytes):</span><br><span class="line">            resp = web.Response(body=r)</span><br><span class="line">            resp.content_type = &#x27;application/octet-stream&#x27;</span><br><span class="line">            return resp</span><br><span class="line">        if isinstance(r, str):</span><br><span class="line">            resp = web.Response(body=r.encode(&#x27;utf-8&#x27;))</span><br><span class="line">            resp.content_type = &#x27;text/html;charset=utf-8&#x27;</span><br><span class="line">            return resp</span><br><span class="line">        if isinstance(r, dict):</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>有了这些基础设施，我们就可以专注地往 <code>handlers</code> 模块不断添加 URL 处理函数了，可以极大地提高开发效率。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>有了 Web 框架和 ORM 框架，我们就可以开始装配 App 了。</p>
<p>通常，一个 Web App 在运行时都需要读取配置文件，比如数据库的用户名、口令等，在不同的环境中运行时，Web App 可以通过读取不同的配置文件来获得正确的配置。</p>
<p>由于 Python 本身语法简单，完全可以直接用 Python 源代码来实现配置，而不需要再解析一个单独的 <code>.properties</code> 或者 <code>.yaml</code> 等配置文件。</p>
<p>默认的配置文件应该完全符合本地开发环境，这样，无需任何设置，就可以立刻启动服务器。</p>
<p>我们把默认的配置文件命名为 <code>config_default.py</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># config_default.py</span><br><span class="line">configs = &#123;</span><br><span class="line">    &#x27;db&#x27;: &#123;</span><br><span class="line">        &#x27;host&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">        &#x27;port&#x27;: 3306,</span><br><span class="line">        &#x27;user&#x27;: &#x27;www-data&#x27;,</span><br><span class="line">        &#x27;password&#x27;: &#x27;www-data&#x27;,</span><br><span class="line">        &#x27;database&#x27;: &#x27;awesome&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;session&#x27;: &#123;</span><br><span class="line">        &#x27;secret&#x27;: &#x27;AwEsOmE&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述配置文件简单明了。但是，如果要部署到服务器时，通常需要修改数据库的 host 等信息，直接修改 <code>config_default.py</code> 不是一个好办法，更好的方法是编写一个 <code>config_override.py</code>，用来覆盖某些默认设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># config_override.py</span><br><span class="line">configs = &#123;</span><br><span class="line">    &#x27;db&#x27;: &#123;</span><br><span class="line">        &#x27;host&#x27;: &#x27;192.168.0.100&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>config_default.py</code> 作为开发环境的标准配置，把 <code>config_override.py</code> 作为生产环境的标准配置，我们就可以既方便地在本地开发，又可以随时把应用部署到服务器上。</p>
<p>应用程序读取配置文件需要优先从 <code>config_override.py</code> 读取。为了简化读取配置文件，可以把所有配置读取到统一的 <code>config.py</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># config.py</span><br><span class="line">configs = config_default.configs</span><br><span class="line">try:</span><br><span class="line">    import config_override</span><br><span class="line">    configs = merge(configs, config_override.configs)</span><br><span class="line">except ImportError:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>这样，我们就完成了 App 的配置。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>现在，ORM 框架、Web 框架和配置都已就绪，我们可以开始编写一个最简单的 MVC，把它们全部启动起来。</p>
<p>通过 Web 框架的 <code>@get</code> 和 ORM 框架的 Model 支持，可以很容易地编写一个处理首页 URL 的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@get(&#x27;/&#x27;)</span><br><span class="line">def index(request):</span><br><span class="line">    users = yield from User.findAll()</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x27;__template__&#x27;: &#x27;test.html&#x27;,</span><br><span class="line">        &#x27;users&#x27;: users</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>&#39;__template__&#39;</code> 指定的模板文件是 <code>test.html</code>，其他参数是传递给模板的数据，所以我们在模板的根目录 <code>templates</code> 下创建 <code>test.html</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Test users - Awesome Python Webapp&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;All users&lt;/h1&gt;</span><br><span class="line">    &#123;% for u in users %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; u.name &#125;&#125; / &#123;&#123; u.email &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，如果一切顺利，可以用命令行启动 Web 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 app.py</span><br></pre></td></tr></table></figure>

<p>然后，在浏览器中访问 <code>http://localhost:9000/</code>。</p>
<p>如果数据库的 <code>users</code> 表什么内容也没有，你就无法在浏览器中看到循环输出的内容。可以自己在 MySQL 的命令行里给 <code>users</code> 表添加几条记录，然后再访问</p>
<h3 id="构建前端"><a href="#构建前端" class="headerlink" title="构建前端"></a>构建前端</h3><p>对于复杂的 HTML 前端页面来说，我们需要一套基础的 CSS 框架来完成页面布局和基本样式。另外，jQuery 作为操作 DOM 的 JavaScript 库也必不可少。</p>
<p>从零开始写 CSS 不如直接从一个已有的功能完善的 CSS 框架开始。有很多 CSS 框架可供选择。我们这次选择 <a href="http://getuikit.com/">uikit</a> 这个强大的 CSS 框架。它具备完善的响应式布局，漂亮的 UI，以及丰富的 HTML 组件，让我们能轻松设计出美观而简洁的页面。</p>
<p>可以从 <a href="http://getuikit.com/">uikit首页</a> 下载打包的资源文件。</p>
<p>所有的静态资源文件我们统一放到 <code>www/static</code> 目录下，并按照类别归类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static/</span><br><span class="line">+- css/</span><br><span class="line">|  +- addons/</span><br><span class="line">|  |  +- uikit.addons.min.css</span><br><span class="line">|  |  +- uikit.almost-flat.addons.min.css</span><br><span class="line">|  |  +- uikit.gradient.addons.min.css</span><br><span class="line">|  +- awesome.css</span><br><span class="line">|  +- uikit.almost-flat.addons.min.css</span><br><span class="line">|  +- uikit.gradient.addons.min.css</span><br><span class="line">|  +- uikit.min.css</span><br><span class="line">+- fonts/</span><br><span class="line">|  +- fontawesome-webfont.eot</span><br><span class="line">|  +- fontawesome-webfont.ttf</span><br><span class="line">|  +- fontawesome-webfont.woff</span><br><span class="line">|  +- FontAwesome.otf</span><br><span class="line">+- js/</span><br><span class="line">   +- awesome.js</span><br><span class="line">   +- html5.js</span><br><span class="line">   +- jquery.min.js</span><br><span class="line">   +- uikit.min.js</span><br></pre></td></tr></table></figure>

<p>由于前端页面肯定不止首页一个页面，每个页面都有相同的页眉和页脚。如果每个页面都是独立的 HTML 模板，那么我们在修改页眉和页脚的时候，就需要把每个模板都改一遍，这显然是没有效率的。</p>
<p>常见的模板引擎已经考虑到了页面上重复的 HTML 部分的复用问题。有的模板通过 include 把页面拆成三部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;% include file=&quot;inc_header.html&quot; %&gt;</span><br><span class="line">    &lt;% include file=&quot;index_body.html&quot; %&gt;</span><br><span class="line">    &lt;% include file=&quot;inc_footer.html&quot; %&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这样，相同的部分 <code>inc_header.html</code> 和 <code>inc_footer.html</code> 就可以共享。</p>
<p>但是 include 方法不利于页面整体结构的维护。jinjia2 的模板还有另一种“继承”方式，实现模板的复用更简单。</p>
<p>“继承”模板的方式是通过编写一个“父模板”，在父模板中定义一些可替换的 block（块）。然后，编写多个“子模板”，每个子模板都可以只替换父模板定义的 block。比如，定义一个最简单的父模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- base.html --&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;&#123;% block title%&#125; 这里定义了一个名为title的block &#123;% endblock %&#125;&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &#123;% block content %&#125; 这里定义了一个名为content的block &#123;% endblock %&#125;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>对于子模板 <code>a.html</code>，只需要把父模板的 <code>title</code> 和 <code>content</code> 替换掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;</span><br><span class="line">&#123;% block title %&#125; A &#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;h1&gt;Chapter A&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;blablabla...&lt;/p&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>对于子模板 <code>b.html</code>，如法炮制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;</span><br><span class="line">&#123;% block title %&#125; B &#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;h1&gt;Chapter B&lt;/h1&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">       &lt;li&gt;list 1&lt;/li&gt;</span><br><span class="line">       &lt;li&gt;list 2&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一旦定义好父模板的整体布局和 CSS 样式，编写子模板就会非常容易。</p>
<p>让我们通过 uikit 这个 CSS 框架来完成父模板 <code>__base__.html</code> 的编写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &#123;% block meta %&#125;&lt;!-- block meta  --&gt;&#123;% endblock %&#125;</span><br><span class="line">    &lt;title&gt;&#123;% block title %&#125; ? &#123;% endblock %&#125; - Awesome Python Webapp&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/uikit.min.css&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/uikit.gradient.min.css&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/awesome.css&quot; /&gt;</span><br><span class="line">    &lt;script src=&quot;/static/js/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;/static/js/md5.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;/static/js/uikit.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;/static/js/awesome.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &#123;% block beforehead %&#125;&lt;!-- before head  --&gt;&#123;% endblock %&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;nav class=&quot;uk-navbar uk-navbar-attached uk-margin-bottom&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;uk-container uk-container-center&quot;&gt;</span><br><span class="line">            &lt;a href=&quot;/&quot; class=&quot;uk-navbar-brand&quot;&gt;Awesome&lt;/a&gt;</span><br><span class="line">            &lt;ul class=&quot;uk-navbar-nav&quot;&gt;</span><br><span class="line">                &lt;li data-url=&quot;blogs&quot;&gt;&lt;a href=&quot;/&quot;&gt;&lt;i class=&quot;uk-icon-home&quot;&gt;&lt;/i&gt; 日志&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;uk-icon-book&quot;&gt;&lt;/i&gt; 教程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;uk-icon-code&quot;&gt;&lt;/i&gt; 源码&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;div class=&quot;uk-navbar-flip&quot;&gt;</span><br><span class="line">                &lt;ul class=&quot;uk-navbar-nav&quot;&gt;</span><br><span class="line">                &#123;% if user %&#125;</span><br><span class="line">                    &lt;li class=&quot;uk-parent&quot; data-uk-dropdown&gt;</span><br><span class="line">                        &lt;a href=&quot;#0&quot;&gt;&lt;i class=&quot;uk-icon-user&quot;&gt;&lt;/i&gt; &#123;&#123; user.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">                        &lt;div class=&quot;uk-dropdown uk-dropdown-navbar&quot;&gt;</span><br><span class="line">                            &lt;ul class=&quot;uk-nav uk-nav-navbar&quot;&gt;</span><br><span class="line">                                &lt;li&gt;&lt;a href=&quot;/signout&quot;&gt;&lt;i class=&quot;uk-icon-sign-out&quot;&gt;&lt;/i&gt; 登出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                            &lt;/ul&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/li&gt;</span><br><span class="line">                &#123;% else %&#125;</span><br><span class="line">                    &lt;li&gt;&lt;a href=&quot;/signin&quot;&gt;&lt;i class=&quot;uk-icon-sign-in&quot;&gt;&lt;/i&gt; 登陆&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&lt;a href=&quot;/register&quot;&gt;&lt;i class=&quot;uk-icon-edit&quot;&gt;&lt;/i&gt; 注册&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &#123;% endif %&#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">    &lt;div class=&quot;uk-container uk-container-center&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;uk-grid&quot;&gt;</span><br><span class="line">            &lt;!-- content --&gt;</span><br><span class="line">            &#123;% block content %&#125;</span><br><span class="line">            &#123;% endblock %&#125;</span><br><span class="line">            &lt;!-- // content --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;uk-margin-large-top&quot; style=&quot;background-color:#eee; border-top:1px solid #ccc;&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;uk-container uk-container-center uk-text-center&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;uk-panel uk-margin-top uk-margin-bottom&quot;&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;a target=&quot;_blank&quot; href=&quot;#&quot; class=&quot;uk-icon-button uk-icon-weibo&quot;&gt;&lt;/a&gt;</span><br><span class="line">                    &lt;a target=&quot;_blank&quot; href=&quot;#&quot; class=&quot;uk-icon-button uk-icon-github&quot;&gt;&lt;/a&gt;</span><br><span class="line">                    &lt;a target=&quot;_blank&quot; href=&quot;#&quot; class=&quot;uk-icon-button uk-icon-linkedin-square&quot;&gt;&lt;/a&gt;</span><br><span class="line">                    &lt;a target=&quot;_blank&quot; href=&quot;#&quot; class=&quot;uk-icon-button uk-icon-twitter&quot;&gt;&lt;/a&gt;</span><br><span class="line">                &lt;/p&gt;</span><br><span class="line">                &lt;p&gt;Powered by &lt;a href=&quot;#&quot;&gt;Awesome Python Webapp&lt;/a&gt;. Copyright &amp;copy; 2014. [&lt;a href=&quot;/manage/&quot; target=&quot;_blank&quot;&gt;Manage&lt;/a&gt;]&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/&quot; target=&quot;_blank&quot;&gt;www.liaoxuefeng.com&lt;/a&gt;. All rights reserved.&lt;/p&gt;</span><br><span class="line">                &lt;a target=&quot;_blank&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;uk-icon-html5&quot; style=&quot;font-size:64px; color: #444;&quot;&gt;&lt;/i&gt;&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>__base__.html</code> 定义的几个 block 作用如下：</p>
<p>用于子页面定义一些 meta，例如 rss feed：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block meta %&#125; ... &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖页面的标题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; ... &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>子页面可以在 <code>&lt;head&gt;</code> 标签关闭前插入 JavaScript 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block beforehead %&#125; ... &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>子页面的 content 布局和内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">    ...</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>我们把首页改造一下，从 <code>__base__.html</code> 继承一个 <code>blogs.html</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;__base__.html&#x27; %&#125;</span><br><span class="line">&#123;% block title %&#125;日志&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;div class=&quot;uk-width-medium-3-4&quot;&gt;</span><br><span class="line">        &#123;% for blog in blogs %&#125;</span><br><span class="line">            &lt;article class=&quot;uk-article&quot;&gt;</span><br><span class="line">                &lt;h2&gt;&lt;a href=&quot;/blog/&#123;&#123; blog.id &#125;&#125;&quot;&gt;&#123;&#123; blog.name &#125;&#125;&lt;/a&gt;&lt;/h2&gt;</span><br><span class="line">                &lt;p class=&quot;uk-article-meta&quot;&gt;发表于&#123;&#123; blog.created_at&#125;&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;&#123;&#123; blog.summary &#125;&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;&lt;a href=&quot;/blog/&#123;&#123; blog.id &#125;&#125;&quot;&gt;继续阅读 &lt;i class=&quot;uk-icon-angle-double-right&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">            &lt;/article&gt;</span><br><span class="line">            &lt;hr class=&quot;uk-article-divider&quot;&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;uk-width-medium-1-4&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;uk-panel uk-panel-header&quot;&gt;</span><br><span class="line">            &lt;h3 class=&quot;uk-panel-title&quot;&gt;友情链接&lt;/h3&gt;</span><br><span class="line">            &lt;ul class=&quot;uk-list uk-list-line&quot;&gt;</span><br><span class="line">                &lt;li&gt;&lt;i class=&quot;uk-icon-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;a target=&quot;_blank&quot; href=&quot;#&quot;&gt;编程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;i class=&quot;uk-icon-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;a target=&quot;_blank&quot; href=&quot;#&quot;&gt;读书&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;i class=&quot;uk-icon-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;a target=&quot;_blank&quot; href=&quot;#&quot;&gt;Python教程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;i class=&quot;uk-icon-thumbs-o-up&quot;&gt;&lt;/i&gt; &lt;a target=&quot;_blank&quot; href=&quot;#&quot;&gt;Git教程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>相应地，首页 URL 的处理函数更新如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@get(&#x27;/&#x27;)</span><br><span class="line">def index(request):</span><br><span class="line">    summary = &#x27;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&#x27;</span><br><span class="line">    blogs = [</span><br><span class="line">        Blog(id=&#x27;1&#x27;, name=&#x27;Test Blog&#x27;, summary=summary, created_at=time.time()-120),</span><br><span class="line">        Blog(id=&#x27;2&#x27;, name=&#x27;Something New&#x27;, summary=summary, created_at=time.time()-3600),</span><br><span class="line">        Blog(id=&#x27;3&#x27;, name=&#x27;Learn Swift&#x27;, summary=summary, created_at=time.time()-7200)</span><br><span class="line">    ]</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x27;__template__&#x27;: &#x27;blogs.html&#x27;,</span><br><span class="line">        &#x27;blogs&#x27;: blogs</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Blog 的创建日期显示的是一个浮点数，因为它是由这段模板渲染出来的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p class=&quot;uk-article-meta&quot;&gt;发表于&#123;&#123; blog.created_at &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>解决方法是通过 jinja2 的 filter（过滤器），把一个浮点数转换成日期字符串。我们来编写一个 <code>datetime</code> 的 filter，在模板里用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p class=&quot;uk-article-meta&quot;&gt;发表于&#123;&#123; blog.created_at|datetime &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>filter 需要在初始化 jinja2 时设置。相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def datetime_filter(t):</span><br><span class="line">    delta = int(time.time() - t)</span><br><span class="line">    if delta &lt; 60:</span><br><span class="line">        return &#x27;1分钟前&#x27;</span><br><span class="line">    if delta &lt; 3600:</span><br><span class="line">        return &#x27;%s分钟前&#x27; % (delta // 60)</span><br><span class="line">    if delta &lt; 86400:</span><br><span class="line">        return &#x27;%s小时前&#x27; % (delta // 3600)</span><br><span class="line">    if delta &lt; 604800:</span><br><span class="line">        return &#x27;%s天前&#x27; % (delta // 86400)</span><br><span class="line">    dt = datetime.fromtimestamp(t)</span><br><span class="line">    return &#x27;%s年%s月%s日&#x27; % (dt.year, dt.month, dt.day)</span><br><span class="line">...</span><br><span class="line">init_jinja2(app, filters=dict(datetime=datetime_filter))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在，完善的首页显示如下</p>
<h3 id="编写-API"><a href="#编写-API" class="headerlink" title="编写 API"></a>编写 API</h3><p>什么是 Web API 呢？</p>
<p>如果我们想要获取一篇 Blog，输入 <code>http://localhost:9000/blog/123</code>，就可以看到 id 为 <code>123</code> 的 Blog 页面，但这个结果是 HTML 页面，它同时混合包含了 Blog 的数据和 Blog 的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从 HTML 中解析出 Blog 的数据。</p>
<p>如果一个 URL 返回的不是 HTML，而是机器能直接解析的数据，这个 URL 就可以看成是一个 Web API。比如，读取 <code>http://localhost:9000/api/blogs/123</code>，如果能直接返回 Blog 的数据，那么机器就可以直接读取。</p>
<p>REST 就是一种设计 API 的模式。最常用的数据格式是 JSON。由于 JSON 能直接被 JavaScript 读取，所以，以 JSON 格式编写的 REST 风格的 API 具有简单、易读、易用的特点。</p>
<p>编写 API 有什么好处呢？由于 API 就是把 Web App 的功能全部封装了，所以，通过 API 操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。</p>
<p>一个 API 也是一个 URL 的处理函数，我们希望能直接通过一个 <code>@api</code> 来把函数变成 JSON 格式的 REST API，这样，获取注册用户可以用一个 API 实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@get(&#x27;/api/users&#x27;)</span><br><span class="line">def api_get_users(*, page=&#x27;1&#x27;):</span><br><span class="line">    page_index = get_page_index(page)</span><br><span class="line">    num = yield from User.findNumber(&#x27;count(id)&#x27;)</span><br><span class="line">    p = Page(num, page_index)</span><br><span class="line">    if num == 0:</span><br><span class="line">        return dict(page=p, users=())</span><br><span class="line">    users = yield from User.findAll(orderBy=&#x27;created_at desc&#x27;, limit=(p.offset, p.limit))</span><br><span class="line">    for u in users:</span><br><span class="line">        u.passwd = &#x27;******&#x27;</span><br><span class="line">    return dict(page=p, users=users)</span><br></pre></td></tr></table></figure>

<p>只要返回一个 <code>dict</code>，后续的 <code>response</code> 这个 <code>middleware</code> 就可以把结果序列化为 JSON 并返回。</p>
<p>我们需要对 Error 进行处理，因此定义一个 <code>APIError</code>，这种 Error 是指 API 调用时发生了逻辑错误（比如用户不存在），其他的 Error 视为 Bug，返回的错误代码为 <code>internalerror</code>。</p>
<p>客户端调用 API 时，必须通过错误代码来区分 API 调用是否成功。错误代码是用来告诉调用者出错的原因。很多 API 用一个整数表示错误码，这种方式很难维护错误码，客户端拿到错误码还需要查表得知错误信息。更好的方式是用字符串表示错误代码，不需要看文档也能猜到错误原因。</p>
<p>可以在浏览器直接测试 API，例如，输入 <code>http://localhost:9000/api/users</code>，就可以看到返回的 JSON：</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="注册和登录"><a href="#注册和登录" class="headerlink" title="注册和登录"></a>注册和登录</h2><p>用户管理是绝大部分 Web 网站都需要解决的问题。用户管理涉及到用户注册和登录。</p>
<p>用户注册相对简单，我们可以先通过 API 把用户注册这个功能实现了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_RE_EMAIL = re.compile(r&#x27;^[a-z0-9\.\-\_]+\@[a-z0-9\-\_]+(\.[a-z0-9\-\_]+)&#123;1,4&#125;$&#x27;)</span><br><span class="line">_RE_SHA1 = re.compile(r&#x27;^[0-9a-f]&#123;40&#125;$&#x27;)</span><br><span class="line">@post(&#x27;/api/users&#x27;)</span><br><span class="line">def api_register_user(*, email, name, passwd):</span><br><span class="line">    if not name or not name.strip():</span><br><span class="line">        raise APIValueError(&#x27;name&#x27;)</span><br><span class="line">    if not email or not _RE_EMAIL.match(email):</span><br><span class="line">        raise APIValueError(&#x27;email&#x27;)</span><br><span class="line">    if not passwd or not _RE_SHA1.match(passwd):</span><br><span class="line">        raise APIValueError(&#x27;passwd&#x27;)</span><br><span class="line">    users = yield from User.findAll(&#x27;email=?&#x27;, [email])</span><br><span class="line">    if len(users) &gt; 0:</span><br><span class="line">        raise APIError(&#x27;register:failed&#x27;, &#x27;email&#x27;, &#x27;Email is already in use.&#x27;)</span><br><span class="line">    uid = next_id()</span><br><span class="line">    sha1_passwd = &#x27;%s:%s&#x27; % (uid, passwd)</span><br><span class="line">    user = User(id=uid, name=name.strip(), email=email, passwd=hashlib.sha1(sha1_passwd.encode(&#x27;utf-8&#x27;)).hexdigest(), image=&#x27;http://www.gravatar.com/avatar/%s?d=mm&amp;s=120&#x27; % hashlib.md5(email.encode(&#x27;utf-8&#x27;)).hexdigest())</span><br><span class="line">    yield from user.save()</span><br><span class="line">    # make session cookie:</span><br><span class="line">    r = web.Response()</span><br><span class="line">    r.set_cookie(COOKIE_NAME, user2cookie(user, 86400), max_age=86400, httponly=True)</span><br><span class="line">    user.passwd = &#x27;******&#x27;</span><br><span class="line">    r.content_type = &#x27;application/json&#x27;</span><br><span class="line">    r.body = json.dumps(user, ensure_ascii=False).encode(&#x27;utf-8&#x27;)</span><br><span class="line">    return r</span><br></pre></td></tr></table></figure>

<p>注意用户口令是客户端传递的经过 SHA1 计算后的 40 位 Hash 字符串，所以服务器端并不知道用户的原始口令。</p>
<p>接下来可以创建一个注册页面，让用户填写注册表单，然后，提交数据到注册用户的 API：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;__base__.html&#x27; %&#125;</span><br><span class="line">&#123;% block title %&#125;注册&#123;% endblock %&#125;</span><br><span class="line">&#123;% block beforehead %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function validateEmail(email) &#123;</span><br><span class="line">    var re = /^[a-z0-9\.\-\_]+\@[a-z0-9\-\_]+(\.[a-z0-9\-\_]+)&#123;1,4&#125;$/;</span><br><span class="line">    return re.test(email.toLowerCase());</span><br><span class="line">&#125;</span><br><span class="line">$(function () &#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &#x27;#vm&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: &#x27;&#x27;,</span><br><span class="line">            email: &#x27;&#x27;,</span><br><span class="line">            password1: &#x27;&#x27;,</span><br><span class="line">            password2: &#x27;&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            submit: function (event) &#123;</span><br><span class="line">                event.preventDefault();</span><br><span class="line">                var $form = $(&#x27;#vm&#x27;);</span><br><span class="line">                if (! this.name.trim()) &#123;</span><br><span class="line">                    return $form.showFormError(&#x27;请输入名字&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line">                if (! validateEmail(this.email.trim().toLowerCase())) &#123;</span><br><span class="line">                    return $form.showFormError(&#x27;请输入正确的Email地址&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line">                if (this.password1.length &lt; 6) &#123;</span><br><span class="line">                    return $form.showFormError(&#x27;口令长度至少为6个字符&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line">                if (this.password1 !== this.password2) &#123;</span><br><span class="line">                    return $form.showFormError(&#x27;两次输入的口令不一致&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line">                var email = this.email.trim().toLowerCase();</span><br><span class="line">                $form.postJSON(&#x27;/api/users&#x27;, &#123;</span><br><span class="line">                    name: this.name.trim(),</span><br><span class="line">                    email: email,</span><br><span class="line">                    passwd: CryptoJS.SHA1(email + &#x27;:&#x27; + this.password1).toString()</span><br><span class="line">                &#125;, function (err, r) &#123;</span><br><span class="line">                    if (err) &#123;</span><br><span class="line">                        return $form.showFormError(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return location.assign(&#x27;/&#x27;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(&#x27;#vm&#x27;).show();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;div class=&quot;uk-width-2-3&quot;&gt;</span><br><span class="line">        &lt;h1&gt;欢迎注册！&lt;/h1&gt;</span><br><span class="line">        &lt;form id=&quot;vm&quot; v-on=&quot;submit: submit&quot; class=&quot;uk-form uk-form-stacked&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;uk-alert uk-alert-danger uk-hidden&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;uk-form-row&quot;&gt;</span><br><span class="line">                &lt;label class=&quot;uk-form-label&quot;&gt;名字:&lt;/label&gt;</span><br><span class="line">                &lt;div class=&quot;uk-form-controls&quot;&gt;</span><br><span class="line">                    &lt;input v-model=&quot;name&quot; type=&quot;text&quot; maxlength=&quot;50&quot; placeholder=&quot;名字&quot; class=&quot;uk-width-1-1&quot;&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;uk-form-row&quot;&gt;</span><br><span class="line">                &lt;label class=&quot;uk-form-label&quot;&gt;电子邮件:&lt;/label&gt;</span><br><span class="line">                &lt;div class=&quot;uk-form-controls&quot;&gt;</span><br><span class="line">                    &lt;input v-model=&quot;email&quot; type=&quot;text&quot; maxlength=&quot;50&quot; placeholder=&quot;your-name@example.com&quot; class=&quot;uk-width-1-1&quot;&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;uk-form-row&quot;&gt;</span><br><span class="line">                &lt;label class=&quot;uk-form-label&quot;&gt;输入口令:&lt;/label&gt;</span><br><span class="line">                &lt;div class=&quot;uk-form-controls&quot;&gt;</span><br><span class="line">                    &lt;input v-model=&quot;password1&quot; type=&quot;password&quot; maxlength=&quot;50&quot; placeholder=&quot;输入口令&quot; class=&quot;uk-width-1-1&quot;&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;uk-form-row&quot;&gt;</span><br><span class="line">                &lt;label class=&quot;uk-form-label&quot;&gt;重复口令:&lt;/label&gt;</span><br><span class="line">                &lt;div class=&quot;uk-form-controls&quot;&gt;</span><br><span class="line">                    &lt;input v-model=&quot;password2&quot; type=&quot;password&quot; maxlength=&quot;50&quot; placeholder=&quot;重复口令&quot; class=&quot;uk-width-1-1&quot;&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;uk-form-row&quot;&gt;</span><br><span class="line">                &lt;button type=&quot;submit&quot; class=&quot;uk-button uk-button-primary&quot;&gt;&lt;i class=&quot;uk-icon-user&quot;&gt;&lt;/i&gt; 注册&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就把用户注册的功能完成了</p>
<p>用户登录比用户注册复杂。由于 HTTP 协议是一种无状态协议，而服务器要跟踪用户状态，就只能通过 cookie 实现。大多数 Web 框架提供了 Session 功能来封装保存用户状态的 cookie。</p>
<p>Session 的优点是简单易用，可以直接从 Session 中取出用户登录信息。</p>
<p>Session 的缺点是服务器需要在内存中维护一个映射表来存储用户登录信息，如果有两台以上服务器，就需要对 Session 做集群，因此，使用 Session 的 Web App 很难扩展。</p>
<p>我们采用直接读取 cookie 的方式来验证用户登录，每次用户访问任意 URL，都会对 cookie 进行验证，这种方式的好处是保证服务器处理任意的 URL 都是无状态的，可以扩展到多台服务器。</p>
<p>由于登录成功后是由服务器生成一个 cookie 发送给浏览器，所以，要保证这个 cookie 不会被客户端伪造出来。</p>
<p>实现防伪造 cookie 的关键是通过一个单向算法（例如 SHA1），举例如下：</p>
<p>当用户输入了正确的口令登录成功后，服务器可以从数据库取到用户的 id，并按照如下方式计算出一个字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;用户id&quot; + &quot;过期时间&quot; + SHA1(&quot;用户id&quot; + &quot;用户口令&quot; + &quot;过期时间&quot; + &quot;SecretKey&quot;)</span><br></pre></td></tr></table></figure>

<p>当浏览器发送 cookie 到服务器端后，服务器可以拿到的信息包括：</p>
<ul>
<li>用户 id</li>
<li>过期时间</li>
<li>SHA1 值<br>如果未到过期时间，服务器就根据用户 id 查找用户口令，并计算：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHA1(&quot;用户id&quot; + &quot;用户口令&quot; + &quot;过期时间&quot; + &quot;SecretKey&quot;)</span><br></pre></td></tr></table></figure>

<p>并与浏览器 cookie 中的哈希进行比较，如果相等，则说明用户已登录，否则，cookie 就是伪造的。</p>
<p>这个算法的关键在于 SHA1 是一种单向算法，即可以通过原始字符串计算出 SHA1 结果，但无法通过 SHA1 结果反推出原始字符串。</p>
<p>所以登录 API 可以实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@post(&#x27;/api/authenticate&#x27;)</span><br><span class="line">def authenticate(*, email, passwd):</span><br><span class="line">    if not email:</span><br><span class="line">        raise APIValueError(&#x27;email&#x27;, &#x27;Invalid email.&#x27;)</span><br><span class="line">    if not passwd:</span><br><span class="line">        raise APIValueError(&#x27;passwd&#x27;, &#x27;Invalid password.&#x27;)</span><br><span class="line">    users = yield from User.findAll(&#x27;email=?&#x27;, [email])</span><br><span class="line">    if len(users) == 0:</span><br><span class="line">        raise APIValueError(&#x27;email&#x27;, &#x27;Email not exist.&#x27;)</span><br><span class="line">    user = users[0]</span><br><span class="line">    # check passwd:</span><br><span class="line">    sha1 = hashlib.sha1()</span><br><span class="line">    sha1.update(user.id.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    sha1.update(b&#x27;:&#x27;)</span><br><span class="line">    sha1.update(passwd.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    if user.passwd != sha1.hexdigest():</span><br><span class="line">        raise APIValueError(&#x27;passwd&#x27;, &#x27;Invalid password.&#x27;)</span><br><span class="line">    # authenticate ok, set cookie:</span><br><span class="line">    r = web.Response()</span><br><span class="line">    r.set_cookie(COOKIE_NAME, user2cookie(user, 86400), max_age=86400, httponly=True)</span><br><span class="line">    user.passwd = &#x27;******&#x27;</span><br><span class="line">    r.content_type = &#x27;application/json&#x27;</span><br><span class="line">    r.body = json.dumps(user, ensure_ascii=False).encode(&#x27;utf-8&#x27;)</span><br><span class="line">    return r</span><br><span class="line">    </span><br><span class="line"># 计算加密cookie:</span><br><span class="line">def user2cookie(user, max_age):</span><br><span class="line">    # build cookie string by: id-expires-sha1</span><br><span class="line">    expires = str(int(time.time() + max_age))</span><br><span class="line">    s = &#x27;%s-%s-%s-%s&#x27; % (user.id, user.passwd, expires, _COOKIE_KEY)</span><br><span class="line">    L = [user.id, expires, hashlib.sha1(s.encode(&#x27;utf-8&#x27;)).hexdigest()]</span><br><span class="line">    return &#x27;-&#x27;.join(L)</span><br></pre></td></tr></table></figure>

<p>对于每个 URL 处理函数，如果我们都去写解析 cookie 的代码，那会导致代码重复很多次。</p>
<p>利用 middle 在处理 URL 之前，把 cookie 解析出来，并将登录用户绑定到 <code>request</code> 对象上，这样，后续的 URL 处理函数就可以直接拿到登录用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def auth_factory(app, handler):</span><br><span class="line">    @asyncio.coroutine</span><br><span class="line">    def auth(request):</span><br><span class="line">        logging.info(&#x27;check user: %s %s&#x27; % (request.method, request.path))</span><br><span class="line">        request.__user__ = None</span><br><span class="line">        cookie_str = request.cookies.get(COOKIE_NAME)</span><br><span class="line">        if cookie_str:</span><br><span class="line">            user = yield from cookie2user(cookie_str)</span><br><span class="line">            if user:</span><br><span class="line">                logging.info(&#x27;set current user: %s&#x27; % user.email)</span><br><span class="line">                request.__user__ = user</span><br><span class="line">        return (yield from handler(request))</span><br><span class="line">    return auth</span><br><span class="line">    </span><br><span class="line"># 解密cookie:</span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def cookie2user(cookie_str):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Parse cookie and load user if cookie is valid.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    if not cookie_str:</span><br><span class="line">        return None</span><br><span class="line">    try:</span><br><span class="line">        L = cookie_str.split(&#x27;-&#x27;)</span><br><span class="line">        if len(L) != 3:</span><br><span class="line">            return None</span><br><span class="line">        uid, expires, sha1 = L</span><br><span class="line">        if int(expires) &lt; time.time():</span><br><span class="line">            return None</span><br><span class="line">        user = yield from User.find(uid)</span><br><span class="line">        if user is None:</span><br><span class="line">            return None</span><br><span class="line">        s = &#x27;%s-%s-%s-%s&#x27; % (uid, user.passwd, expires, _COOKIE_KEY)</span><br><span class="line">        if sha1 != hashlib.sha1(s.encode(&#x27;utf-8&#x27;)).hexdigest():</span><br><span class="line">            logging.info(&#x27;invalid sha1&#x27;)</span><br><span class="line">            return None</span><br><span class="line">        user.passwd = &#x27;******&#x27;</span><br><span class="line">        return user</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<p>这样，我们就完成了用户注册和登录的功能。</p>
<h2 id="编写日志创建页"><a href="#编写日志创建页" class="headerlink" title="编写日志创建页"></a>编写日志创建页</h2><p>在 Web 开发中，后端代码写起来其实是相当容易的。</p>
<p>例如，我们编写一个 REST API，用于创建一个 Blog：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@post(&#x27;/api/blogs&#x27;)</span><br><span class="line">def api_create_blog(request, *, name, summary, content):</span><br><span class="line">    check_admin(request)</span><br><span class="line">    if not name or not name.strip():</span><br><span class="line">        raise APIValueError(&#x27;name&#x27;, &#x27;name cannot be empty.&#x27;)</span><br><span class="line">    if not summary or not summary.strip():</span><br><span class="line">        raise APIValueError(&#x27;summary&#x27;, &#x27;summary cannot be empty.&#x27;)</span><br><span class="line">    if not content or not content.strip():</span><br><span class="line">        raise APIValueError(&#x27;content&#x27;, &#x27;content cannot be empty.&#x27;)</span><br><span class="line">    blog = Blog(user_id=request.__user__.id, user_name=request.__user__.name, user_image=request.__user__.image, name=name.strip(), summary=summary.strip(), content=content.strip())</span><br><span class="line">    yield from blog.save()</span><br><span class="line">    return blog</span><br></pre></td></tr></table></figure>

<p>编写后端 Python 代码不但很简单，而且非常容易测试，上面的 API：<code>api_create_blog()</code> 本身只是一个普通函数。</p>
<p>Web 开发真正困难的地方在于编写前端页面。前端页面需要混合 HTML、CSS 和 JavaScript，如果对这三者没有深入地掌握，编写的前端页面将很快难以维护。</p>
<p>更大的问题在于，前端页面通常是动态页面，也就是说，前端页面往往是由后端代码生成的。</p>
<p>生成前端页面最早的方式是拼接字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&#x27;</span><br><span class="line">    + title</span><br><span class="line">    + &#x27;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#x27;</span><br><span class="line">    + body</span><br><span class="line">    + &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>显然这种方式完全不具备可维护性。所以有第二种模板方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123; body &#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>ASP、JSP、PHP 等都是用这种模板方式生成前端页面。</p>
<p>如果在页面上大量使用 JavaScript（事实上大部分页面都会），模板方式仍然会导致 JavaScript 代码与后端代码绑得非常紧密，以至于难以维护。其根本原因在于负责显示的 HTML DOM 模型与负责数据和交互的 JavaScript 代码没有分割清楚。</p>
<p>要编写可维护的前端代码绝非易事。和后端结合的 MVC 模式已经无法满足复杂页面逻辑的需要了，所以，新的 <a href="http://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a>：Model View ViewModel 模式应运而生。</p>
<p>MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var blog = &#123;</span><br><span class="line">        name: &#x27;hello&#x27;,</span><br><span class="line">        summary: &#x27;this is summary&#x27;,</span><br><span class="line">        content: &#x27;this is content...&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>View 是纯 HTML：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/api/blogs&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;name&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;summary&quot;&gt;</span><br><span class="line">    &lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;OK&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>由于 Model 表示数据，View 负责显示，两者做到了最大限度的分离。</p>
<p>把 Model 和 View 关联起来的就是 ViewModel。ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model。</p>
<p>ViewModel 如何编写？需要用 JavaScript 编写一个通用的 ViewModel，这样，就可以复用整个 MVVM 模型了。</p>
<p>好消息是已有许多成熟的 MVVM 框架，例如 AngularJS，KnockoutJS 等。我们选择 <a href="http://vuejs.org/">Vue</a> 这个简单易用的 MVVM 框架来实现创建 Blog 的页面 <code>templates/manage_blog_edit.html</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;__base__.html&#x27; %&#125;</span><br><span class="line">&#123;% block title %&#125;编辑日志&#123;% endblock %&#125;</span><br><span class="line">&#123;% block beforehead %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var</span><br><span class="line">    ID = &#x27;&#123;&#123; id &#125;&#125;&#x27;,</span><br><span class="line">    action = &#x27;&#123;&#123; action &#125;&#125;&#x27;;</span><br><span class="line">function initVM(blog) &#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &#x27;#vm&#x27;,</span><br><span class="line">        data: blog,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            submit: function (event) &#123;</span><br><span class="line">                event.preventDefault();</span><br><span class="line">                var $form = $(&#x27;#vm&#x27;).find(&#x27;form&#x27;);</span><br><span class="line">                $form.postJSON(action, this.$data, function (err, r) &#123;</span><br><span class="line">                    if (err) &#123;</span><br><span class="line">                        $form.showFormError(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        return location.assign(&#x27;/api/blogs/&#x27; + r.id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(&#x27;#vm&#x27;).show();</span><br><span class="line">&#125;</span><br><span class="line">$(function () &#123;</span><br><span class="line">    if (ID) &#123;</span><br><span class="line">        getJSON(&#x27;/api/blogs/&#x27; + ID, function (err, blog) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                return fatal(err);</span><br><span class="line">            &#125;</span><br><span class="line">            $(&#x27;#loading&#x27;).hide();</span><br><span class="line">            initVM(blog);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        $(&#x27;#loading&#x27;).hide();</span><br><span class="line">        initVM(&#123;</span><br><span class="line">            name: &#x27;&#x27;,</span><br><span class="line">            summary: &#x27;&#x27;,</span><br><span class="line">            content: &#x27;&#x27;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;div class=&quot;uk-width-1-1 uk-margin-bottom&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;uk-panel uk-panel-box&quot;&gt;</span><br><span class="line">            &lt;ul class=&quot;uk-breadcrumb&quot;&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;/manage/comments&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;/manage/blogs&quot;&gt;日志&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;/manage/users&quot;&gt;用户&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;error&quot; class=&quot;uk-width-1-1&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;loading&quot; class=&quot;uk-width-1-1 uk-text-center&quot;&gt;</span><br><span class="line">        &lt;span&gt;&lt;i class=&quot;uk-icon-spinner uk-icon-medium uk-icon-spin&quot;&gt;&lt;/i&gt; 正在加载...&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;vm&quot; class=&quot;uk-width-2-3&quot;&gt;</span><br><span class="line">        &lt;form v-on=&quot;submit: submit&quot; class=&quot;uk-form uk-form-stacked&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;uk-alert uk-alert-danger uk-hidden&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;uk-form-row&quot;&gt;</span><br><span class="line">                &lt;label class=&quot;uk-form-label&quot;&gt;标题:&lt;/label&gt;</span><br><span class="line">                &lt;div class=&quot;uk-form-controls&quot;&gt;</span><br><span class="line">                    &lt;input v-model=&quot;name&quot; name=&quot;name&quot; type=&quot;text&quot; placeholder=&quot;标题&quot; class=&quot;uk-width-1-1&quot;&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;uk-form-row&quot;&gt;</span><br><span class="line">                &lt;label class=&quot;uk-form-label&quot;&gt;摘要:&lt;/label&gt;</span><br><span class="line">                &lt;div class=&quot;uk-form-controls&quot;&gt;</span><br><span class="line">                    &lt;textarea v-model=&quot;summary&quot; rows=&quot;4&quot; name=&quot;summary&quot; placeholder=&quot;摘要&quot; class=&quot;uk-width-1-1&quot; style=&quot;resize:none;&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;uk-form-row&quot;&gt;</span><br><span class="line">                &lt;label class=&quot;uk-form-label&quot;&gt;内容:&lt;/label&gt;</span><br><span class="line">                &lt;div class=&quot;uk-form-controls&quot;&gt;</span><br><span class="line">                    &lt;textarea v-model=&quot;content&quot; rows=&quot;16&quot; name=&quot;content&quot; placeholder=&quot;内容&quot; class=&quot;uk-width-1-1&quot; style=&quot;resize:none;&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;uk-form-row&quot;&gt;</span><br><span class="line">                &lt;button type=&quot;submit&quot; class=&quot;uk-button uk-button-primary&quot;&gt;&lt;i class=&quot;uk-icon-save&quot;&gt;&lt;/i&gt; 保存&lt;/button&gt;</span><br><span class="line">                &lt;a href=&quot;/manage/blogs&quot; class=&quot;uk-button&quot;&gt;&lt;i class=&quot;uk-icon-times&quot;&gt;&lt;/i&gt; 取消&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>初始化 Vue 时，我们指定 3 个参数：</p>
<p>el：根据选择器查找绑定的 View，这里是 <code>#vm</code>，就是 id 为 <code>vm</code> 的 DOM，对应的是一个 <code>&lt;div&gt;</code> 标签；</p>
<p>data：JavaScript 对象表示的 Model，我们初始化为 <code>&#123; name: &#39;&#39;, summary: &#39;&#39;, content: &#39;&#39;&#125;</code>；</p>
<p>methods：View 可以触发的 JavaScript 函数，<code>submit</code> 就是提交表单时触发的函数。</p>
<p>接下来，我们在 <code>&lt;form&gt;</code> 标签中，用几个简单的 <code>v-model</code>，就可以让 Vue 把 Model 和 View 关联起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- input的value和Model的name关联起来了 --&gt;</span><br><span class="line">&lt;input v-model=&quot;name&quot; class=&quot;uk-width-1-1&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>Form 表单通过 <code>&lt;form v-on=&quot;submit: submit&quot;&gt;</code> 把提交表单的事件关联到 <code>submit</code> 方法。</p>
<p>需要特别注意的是，在 MVVM 中，Model 和 View 是双向绑定的。如果我们在 Form 中修改了文本框的值，可以在 Model 中立刻拿到新的值。试试在表单中输入文本，然后在 Chrome 浏览器中打开 JavaScript 控制台，可以通过 <code>vm.name</code> 访问单个属性，或者通过 <code>vm.$data</code> 访问整个 Model</p>
<p>如果我们在 JavaScript 逻辑中修改了 Model，这个修改会立刻反映到 View 上。试试在 JavaScript 控制台输入 <code>vm.name = &#39;MVVM简介&#39;</code>，可以看到文本框的内容自动被同步了</p>
<p>双向绑定是 MVVM 框架最大的作用。借助于 MVVM，我们把复杂的显示逻辑交给框架完成。由于后端编写了独立的 REST API，所以，前端用 AJAX 提交表单非常容易，前后端分离得非常彻底。</p>
<h2 id="日志列表页"><a href="#日志列表页" class="headerlink" title="日志列表页"></a>日志列表页</h2><p>MVVM 模式不但可用于 Form 表单，在复杂的管理页面中也能大显身手。例如，分页显示 Blog 的功能，我们先把后端代码写出来：</p>
<p>在 <code>apis.py</code> 中定义一个 <code>Page</code> 类用于存储分页信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Page(object):</span><br><span class="line">    def __init__(self, item_count, page_index=1, page_size=10):</span><br><span class="line">        self.item_count = item_count</span><br><span class="line">        self.page_size = page_size</span><br><span class="line">        self.page_count = item_count // page_size + (1 if item_count % page_size &gt; 0 else 0)</span><br><span class="line">        if (item_count == 0) or (page_index &gt; self.page_count):</span><br><span class="line">            self.offset = 0</span><br><span class="line">            self.limit = 0</span><br><span class="line">            self.page_index = 1</span><br><span class="line">        else:</span><br><span class="line">            self.page_index = page_index</span><br><span class="line">            self.offset = self.page_size * (page_index - 1)</span><br><span class="line">            self.limit = self.page_size</span><br><span class="line">        self.has_next = self.page_index &lt; self.page_count</span><br><span class="line">        self.has_previous = self.page_index &gt; 1</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &#x27;item_count: %s, page_count: %s, page_index: %s, page_size: %s, offset: %s, limit: %s&#x27; % (self.item_count, self.page_count, self.page_index, self.page_size, self.offset, self.limit)</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>

<p>在 <code>handlers.py</code> 中实现 API：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@get(&#x27;/api/blogs&#x27;)</span><br><span class="line">def api_blogs(*, page=&#x27;1&#x27;):</span><br><span class="line">    page_index = get_page_index(page)</span><br><span class="line">    num = yield from Blog.findNumber(&#x27;count(id)&#x27;)</span><br><span class="line">    p = Page(num, page_index)</span><br><span class="line">    if num == 0:</span><br><span class="line">        return dict(page=p, blogs=())</span><br><span class="line">    blogs = yield from Blog.findAll(orderBy=&#x27;created_at desc&#x27;, limit=(p.offset, p.limit))</span><br><span class="line">    return dict(page=p, blogs=blogs)</span><br></pre></td></tr></table></figure>

<p>管理页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@get(&#x27;/manage/blogs&#x27;)</span><br><span class="line">def manage_blogs(*, page=&#x27;1&#x27;):</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x27;__template__&#x27;: &#x27;manage_blogs.html&#x27;,</span><br><span class="line">        &#x27;page_index&#x27;: get_page_index(page)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>模板页面首先通过 API：<code>GET /api/blogs?page=?</code> 拿到 Model：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;page&quot;: &#123;</span><br><span class="line">        &quot;has_next&quot;: true,</span><br><span class="line">        &quot;page_index&quot;: 1,</span><br><span class="line">        &quot;page_count&quot;: 2,</span><br><span class="line">        &quot;has_previous&quot;: false,</span><br><span class="line">        &quot;item_count&quot;: 12</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;blogs&quot;: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，通过 Vue 初始化 MVVM：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function initVM(data) &#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &#x27;#vm&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            blogs: data.blogs,</span><br><span class="line">            page: data.page</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            edit_blog: function (blog) &#123;</span><br><span class="line">                location.assign(&#x27;/manage/blogs/edit?id=&#x27; + blog.id);</span><br><span class="line">            &#125;,</span><br><span class="line">            delete_blog: function (blog) &#123;</span><br><span class="line">                if (confirm(&#x27;确认要删除“&#x27; + blog.name + &#x27;”？删除后不可恢复！&#x27;)) &#123;</span><br><span class="line">                    postJSON(&#x27;/api/blogs/&#x27; + blog.id + &#x27;/delete&#x27;, function (err, r) &#123;</span><br><span class="line">                        if (err) &#123;</span><br><span class="line">                            return alert(err.message || err.error || err);</span><br><span class="line">                        &#125;</span><br><span class="line">                        refresh();</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(&#x27;#vm&#x27;).show();</span><br><span class="line">&#125;</span><br><span class="line">$(function() &#123;</span><br><span class="line">    getJSON(&#x27;/api/blogs&#x27;, &#123;</span><br><span class="line">        page: &#123;&#123; page_index &#125;&#125;</span><br><span class="line">    &#125;, function (err, results) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return fatal(err);</span><br><span class="line">        &#125;</span><br><span class="line">        $(&#x27;#loading&#x27;).hide();</span><br><span class="line">        initVM(results);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>View 的容器是 <code>#vm</code>，包含一个 table，我们用 <code>v-repeat</code> 可以把 Model 的数组 <code>blogs</code> 直接变成多行的 <code>&lt;tr&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;vm&quot; class=&quot;uk-width-1-1&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;/manage/blogs/create&quot; class=&quot;uk-button uk-button-primary&quot;&gt;&lt;i class=&quot;uk-icon-plus&quot;&gt;&lt;/i&gt; 新日志&lt;/a&gt;</span><br><span class="line">    &lt;table class=&quot;uk-table uk-table-hover&quot;&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;th class=&quot;uk-width-5-10&quot;&gt;标题 / 摘要&lt;/th&gt;</span><br><span class="line">                &lt;th class=&quot;uk-width-2-10&quot;&gt;作者&lt;/th&gt;</span><br><span class="line">                &lt;th class=&quot;uk-width-2-10&quot;&gt;创建时间&lt;/th&gt;</span><br><span class="line">                &lt;th class=&quot;uk-width-1-10&quot;&gt;操作&lt;/th&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">            &lt;tr v-repeat=&quot;blog: blogs&quot; &gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a target=&quot;_blank&quot; v-attr=&quot;href: &#x27;/blog/&#x27;+blog.id&quot; v-text=&quot;blog.name&quot;&gt;&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a target=&quot;_blank&quot; v-attr=&quot;href: &#x27;/user/&#x27;+blog.user_id&quot; v-text=&quot;blog.user_name&quot;&gt;&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;span v-text=&quot;blog.created_at.toDateTime()&quot;&gt;&lt;/span&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a href=&quot;#0&quot; v-on=&quot;click: edit_blog(blog)&quot;&gt;&lt;i class=&quot;uk-icon-edit&quot;&gt;&lt;/i&gt;</span><br><span class="line">                    &lt;a href=&quot;#0&quot; v-on=&quot;click: delete_blog(blog)&quot;&gt;&lt;i class=&quot;uk-icon-trash-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/tbody&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;div v-component=&quot;pagination&quot; v-with=&quot;page&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>往 Model 的 <code>blogs</code> 数组中增加一个 Blog 元素，table 就神奇地增加了一行；把 <code>blogs</code> 数组的某个元素删除，table 就神奇地减少了一行。所有复杂的 Model-View 的映射逻辑全部由 MVVM 框架完成，我们只需要在 HTML 中写上 <code>v-repeat</code> 指令，就什么都不用管了。</p>
<p>可以把 <code>v-repeat=&quot;blog: blogs&quot;</code> 看成循环代码，所以，可以在一个 <code>&lt;tr&gt;</code> 内部引用循环变量 <code>blog</code>。<code>v-text</code> 和 <code>v-attr</code> 指令分别用于生成文本和 DOM 节点属性。</p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>现在，我们已经把一个 Web App 的框架完全搭建好了，从后端的 API 到前端的 MVVM，流程已经跑通了。</p>
<p>在继续工作前，注意到每次修改 Python 代码，都必须在命令行先 Ctrl-C 停止服务器，再重启，改动才能生效。</p>
<p>在开发阶段，每天都要修改、保存几十次代码，每次保存都手动来这么一下非常麻烦，严重地降低了我们的开发效率。有没有办法让服务器检测到代码修改后自动重新加载呢？</p>
<p>Django 的开发环境在 Debug 模式下就可以做到自动重新加载，如果我们编写的服务器也能实现这个功能，就能大大提升开发效率。</p>
<p>可惜的是，Django 没把这个功能独立出来，不用 Django 就享受不到，怎么办？</p>
<p>其实 Python 本身提供了重新载入模块的功能，但不是所有模块都能被重新载入。另一种思路是检测 <code>www</code> 目录下的代码改动，一旦有改动，就自动重启服务器。</p>
<p>按照这个思路，我们可以编写一个辅助程序 <code>pymonitor.py</code>，让它启动 <code>wsgiapp.py</code>，并时刻监控 <code>www</code> 目录下的代码改动，有改动时，先把当前 <code>wsgiapp.py</code> 进程杀掉，再重启，就完成了服务器进程的自动重启。</p>
<p>要监控目录文件的变化，我们也无需自己手动定时扫描，Python 的第三方库 <code>watchdog</code> 可以利用操作系统的 API 来监控目录文件的变化，并发送通知。我们先用 <code>pip</code> 安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip3 install watchdog</span><br></pre></td></tr></table></figure>

<p>利用 <code>watchdog</code> 接收文件变化的通知，如果是 <code>.py</code> 文件，就自动重启 <code>wsgiapp.py</code> 进程。</p>
<p>利用 Python 自带的 <code>subprocess</code> 实现进程的启动和终止，并把输入输出重定向到当前进程的输入输出中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__author__ = &#x27;Michael Liao&#x27;</span><br><span class="line">import os, sys, time, subprocess</span><br><span class="line">from watchdog.observers import Observer</span><br><span class="line">from watchdog.events import FileSystemEventHandler</span><br><span class="line">def log(s):</span><br><span class="line">    print(&#x27;[Monitor] %s&#x27; % s)</span><br><span class="line">class MyFileSystemEventHander(FileSystemEventHandler):</span><br><span class="line">    def __init__(self, fn):</span><br><span class="line">        super(MyFileSystemEventHander, self).__init__()</span><br><span class="line">        self.restart = fn</span><br><span class="line">    def on_any_event(self, event):</span><br><span class="line">        if event.src_path.endswith(&#x27;.py&#x27;):</span><br><span class="line">            log(&#x27;Python source file changed: %s&#x27; % event.src_path)</span><br><span class="line">            self.restart()</span><br><span class="line">command = [&#x27;echo&#x27;, &#x27;ok&#x27;]</span><br><span class="line">process = None</span><br><span class="line">def kill_process():</span><br><span class="line">    global process</span><br><span class="line">    if process:</span><br><span class="line">        log(&#x27;Kill process [%s]...&#x27; % process.pid)</span><br><span class="line">        process.kill()</span><br><span class="line">        process.wait()</span><br><span class="line">        log(&#x27;Process ended with code %s.&#x27; % process.returncode)</span><br><span class="line">        process = None</span><br><span class="line">def start_process():</span><br><span class="line">    global process, command</span><br><span class="line">    log(&#x27;Start process %s...&#x27; % &#x27; &#x27;.join(command))</span><br><span class="line">    process = subprocess.Popen(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)</span><br><span class="line">def restart_process():</span><br><span class="line">    kill_process()</span><br><span class="line">    start_process()</span><br><span class="line">def start_watch(path, callback):</span><br><span class="line">    observer = Observer()</span><br><span class="line">    observer.schedule(MyFileSystemEventHander(restart_process), path, recursive=True)</span><br><span class="line">    observer.start()</span><br><span class="line">    log(&#x27;Watching directory %s...&#x27; % path)</span><br><span class="line">    start_process()</span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        observer.stop()</span><br><span class="line">    observer.join()</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    argv = sys.argv[1:]</span><br><span class="line">    if not argv:</span><br><span class="line">        print(&#x27;Usage: ./pymonitor your-script.py&#x27;)</span><br><span class="line">        exit(0)</span><br><span class="line">    if argv[0] != &#x27;python3&#x27;:</span><br><span class="line">        argv.insert(0, &#x27;python3&#x27;)</span><br><span class="line">    command = argv</span><br><span class="line">    path = os.path.abspath(&#x27;.&#x27;)</span><br><span class="line">    start_watch(path, None)</span><br></pre></td></tr></table></figure>

<p>一共 70 行左右的代码，就实现了 Debug 模式的自动重新加载。用下面的命令启动服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 pymonitor.py wsgiapp.py</span><br></pre></td></tr></table></figure>

<p>或者给 <code>pymonitor.py</code> 加上可执行权限，启动服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./pymonitor.py app.py</span><br></pre></td></tr></table></figure>

<p>在编辑器中打开一个 <code>.py</code> 文件，修改后保存，看看命令行输出，是不是自动重启了服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./pymonitor.py app.py </span><br><span class="line">[Monitor] Watching directory /Users/michael/Github/awesome-python3-webapp/www...</span><br><span class="line">[Monitor] Start process python app.py...</span><br><span class="line">...</span><br><span class="line">INFO:root:application (/Users/michael/Github/awesome-python3-webapp/www) will start at 0.0.0.0:9000...</span><br><span class="line">[Monitor] Python source file changed: /Users/michael/Github/awesome-python-webapp/www/handlers.py</span><br><span class="line">[Monitor] Kill process [2747]...</span><br><span class="line">[Monitor] Process ended with code -9.</span><br><span class="line">[Monitor] Start process python app.py...</span><br><span class="line">...</span><br><span class="line">INFO:root:application (/Users/michael/Github/awesome-python3-webapp/www) will start at 0.0.0.0:9000...</span><br></pre></td></tr></table></figure>

<p>现在，只要一保存代码，就可以刷新浏览器看到效果，大大提升了开发效率。</p>
<h2 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h2><p>在 Web App 框架和基本流程跑通后，剩下的工作全部是体力活了：在 Debug 开发模式下完成后端所有 API、前端所有页面。我们需要做的事情包括：</p>
<p>把当前用户绑定到 <code>request</code> 上，并对 URL<code>/manage/</code> 进行拦截，检查当前用户是否是管理员身份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def auth_factory(app, handler):</span><br><span class="line">    @asyncio.coroutine</span><br><span class="line">    def auth(request):</span><br><span class="line">        logging.info(&#x27;check user: %s %s&#x27; % (request.method, request.path))</span><br><span class="line">        request.__user__ = None</span><br><span class="line">        cookie_str = request.cookies.get(COOKIE_NAME)</span><br><span class="line">        if cookie_str:</span><br><span class="line">            user = yield from cookie2user(cookie_str)</span><br><span class="line">            if user:</span><br><span class="line">                logging.info(&#x27;set current user: %s&#x27; % user.email)</span><br><span class="line">                request.__user__ = user</span><br><span class="line">        if request.path.startswith(&#x27;/manage/&#x27;) and (request.__user__ is None or not request.__user__.admin):</span><br><span class="line">            return web.HTTPFound(&#x27;/signin&#x27;)</span><br><span class="line">        return (yield from handler(request))</span><br><span class="line">    return auth</span><br></pre></td></tr></table></figure>

<p>后端 API 包括：</p>
<ul>
<li>获取日志：GET &#x2F;api&#x2F;blogs</li>
<li>创建日志：POST &#x2F;api&#x2F;blogs</li>
<li>修改日志：POST &#x2F;api&#x2F;blogs&#x2F;:blog_id</li>
<li>删除日志：POST &#x2F;api&#x2F;blogs&#x2F;:blog_id&#x2F;delete</li>
<li>获取评论：GET &#x2F;api&#x2F;comments</li>
<li>创建评论：POST &#x2F;api&#x2F;blogs&#x2F;:blog_id&#x2F;comments</li>
<li>删除评论：POST &#x2F;api&#x2F;comments&#x2F;:comment_id&#x2F;delete</li>
<li>创建新用户：POST &#x2F;api&#x2F;users</li>
<li>获取用户：GET &#x2F;api&#x2F;users<br>管理页面包括：</li>
<li>评论列表页：GET &#x2F;manage&#x2F;comments</li>
<li>日志列表页：GET &#x2F;manage&#x2F;blogs</li>
<li>创建日志页：GET &#x2F;manage&#x2F;blogs&#x2F;create</li>
<li>修改日志页：GET &#x2F;manage&#x2F;blogs&#x2F;</li>
<li>用户列表页：GET &#x2F;manage&#x2F;users<br>用户浏览页面包括：</li>
<li>注册页：GET &#x2F;register</li>
<li>登录页：GET &#x2F;signin</li>
<li>注销页：GET &#x2F;signout</li>
<li>首页：GET &#x2F;</li>
<li>日志详情页：GET &#x2F;blog&#x2F;:blog_id<br>把所有的功能实现，我们第一个 Web App 就宣告完成！</li>
</ul>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>很多做开发的同学把部署这件事情看成是运维同学的工作，这种看法是完全错误的。首先，最近流行 <a href="http://zh.wikipedia.org/wiki/DevOps">DevOps</a> 理念，就是说，开发和运维要变成一个整体。其次，运维的难度，其实跟开发质量有很大的关系。代码写得垃圾，运维再好也架不住天天挂掉。最后，DevOps 理念需要把运维、监控等功能融入到开发中。你想服务器升级时不中断用户服务？那就得在开发时考虑到这一点。</p>
<p>下面，我们就来把 awesome-python3-webapp 部署到 Linux 服务器。</p>
<h3 id="搭建-Linux-服务器"><a href="#搭建-Linux-服务器" class="headerlink" title="搭建 Linux 服务器"></a>搭建 Linux 服务器</h3><p>要部署到 Linux，首先得有一台 Linux 服务器。要在公网上体验的同学，可以在 Amazon 的 <a href="http://aws.amazon.com/">AWS</a> 申请一台 EC2 虚拟机（免费使用 1 年），或者使用国内的一些云服务器，一般都提供 Ubuntu Server 的镜像。想在本地部署的同学，请安装虚拟机，推荐使用 <a href="https://www.virtualbox.org/">VirtualBox</a>。</p>
<p>我们选择的 Linux 服务器版本是 <a href="http://www.ubuntu.com/download/server">Ubuntu Server 14.04 LTS</a>，原因是 apt 太简单了。如果你准备使用其他 Linux 版本，也没有问题。</p>
<p>Linux 安装完成后，请确保 ssh 服务正在运行，否则，需要通过 apt 安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>有了 ssh 服务，就可以从本地连接到服务器上。建议把公钥复制到服务器端用户的 <code>.ssh/authorized_keys</code> 中，这样，就可以通过证书实现无密码连接。</p>
<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>利用 Python 自带的 asyncio，我们已经编写了一个异步高性能服务器。但是，我们还需要一个高性能的 Web 服务器，这里选择 Nginx，它可以处理静态资源，同时作为反向代理把动态请求交给 Python 代码处理。这个模型如下</p>
<p>Nginx 负责分发请求</p>
<p>在服务器端，我们需要定义好部署的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">+- srv/</span><br><span class="line">   +- awesome/       &lt;-- Web App根目录</span><br><span class="line">      +- www/        &lt;-- 存放Python源码</span><br><span class="line">      |  +- static/  &lt;-- 存放静态资源文件</span><br><span class="line">      +- log/        &lt;-- 存放log</span><br></pre></td></tr></table></figure>

<p>在服务器上部署，要考虑到新版本如果运行不正常，需要回退到旧版本时怎么办。每次用新的代码覆盖掉旧的文件是不行的，需要一个类似版本控制的机制。由于 Linux 系统提供了软链接功能，所以，我们把 <code>www</code> 作为一个软链接，它指向哪个目录，哪个目录就是当前运行的版本</p>
<p>而 Nginx 和 python 代码的配置文件只需要指向 <code>www</code> 目录即可。</p>
<p>Nginx 可以作为服务进程直接启动，但 <code>app.py</code> 还不行，所以，<a href="http://supervisord.org/">Supervisor</a> 登场！Supervisor 是一个管理进程的工具，可以随系统启动而启动服务，它还时刻监控服务进程，如果服务进程意外退出，Supervisor 可以自动重启服务。</p>
<p>总结一下我们需要用到的服务有：</p>
<ul>
<li>Nginx：高性能 Web 服务器 + 负责反向代理；</li>
<li>Supervisor：监控服务进程的工具；</li>
<li>MySQL：数据库服务。<br>在 Linux 服务器上用 apt 可以直接安装上述服务：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install nginx supervisor python3 mysql-server</span><br></pre></td></tr></table></figure>

<p>然后，再把我们自己的 Web App 用到的 Python 库安装了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo pip3 install jinja2 aiomysql aiohttp</span><br></pre></td></tr></table></figure>

<p>在服务器上创建目录 <code>/srv/awesome/</code> 以及相应的子目录。</p>
<p>在服务器上初始化 MySQL 数据库，把数据库初始化脚本 <code>schema.sql</code> 复制到服务器上执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p &lt; schema.sql</span><br></pre></td></tr></table></figure>

<p>服务器端准备就绪。</p>
<h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><p>用 FTP 还是 SCP 还是 rsync 复制文件？如果你需要手动复制，用一次两次还行，一天如果部署 50 次不但慢、效率低，而且容易出错。</p>
<p>正确的部署方式是使用工具配合脚本完成自动化部署。<a href="http://www.fabfile.org/">Fabric</a> 就是一个自动化部署工具。由于 Fabric 是用 Python 2.x 开发的，所以，部署脚本要用 Python 2.7 来编写，本机还必须安装 Python 2.7 版本。</p>
<p>要用 Fabric 部署，需要在本机（是开发机器，不是 Linux 服务器）安装 Fabric：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ easy_install fabric</span><br></pre></td></tr></table></figure>

<p>Linux 服务器上不需要安装 Fabric，Fabric 使用 SSH 直接登录服务器并执行部署命令。</p>
<p>下一步是编写部署脚本。Fabric 的部署脚本叫 <code>fabfile.py</code>，我们把它放到 <code>awesome-python-webapp</code> 的目录下，与 <code>www</code> 目录平级：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awesome-python-webapp/</span><br><span class="line">+- fabfile.py</span><br><span class="line">+- www/</span><br><span class="line">+- ...</span><br></pre></td></tr></table></figure>

<p>Fabric 的脚本编写很简单，首先导入 Fabric 的 API，设置部署时的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># fabfile.py</span><br><span class="line">import os, re</span><br><span class="line">from datetime import datetime</span><br><span class="line"># 导入Fabric API:</span><br><span class="line">from fabric.api import *</span><br><span class="line"># 服务器登录用户名:</span><br><span class="line">env.user = &#x27;michael&#x27;</span><br><span class="line"># sudo用户为root:</span><br><span class="line">env.sudo_user = &#x27;root&#x27;</span><br><span class="line"># 服务器地址，可以有多个，依次部署:</span><br><span class="line">env.hosts = [&#x27;192.168.0.3&#x27;]</span><br><span class="line"># 服务器MySQL用户名和口令:</span><br><span class="line">db_user = &#x27;www-data&#x27;</span><br><span class="line">db_password = &#x27;www-data&#x27;</span><br></pre></td></tr></table></figure>

<p>然后，每个 Python 函数都是一个任务。我们先编写一个打包的任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_TAR_FILE = &#x27;dist-awesome.tar.gz&#x27;</span><br><span class="line">def build():</span><br><span class="line">    includes = [&#x27;static&#x27;, &#x27;templates&#x27;, &#x27;transwarp&#x27;, &#x27;favicon.ico&#x27;, &#x27;*.py&#x27;]</span><br><span class="line">    excludes = [&#x27;test&#x27;, &#x27;.*&#x27;, &#x27;*.pyc&#x27;, &#x27;*.pyo&#x27;]</span><br><span class="line">    local(&#x27;rm -f dist/%s&#x27; % _TAR_FILE)</span><br><span class="line">    with lcd(os.path.join(os.path.abspath(&#x27;.&#x27;), &#x27;www&#x27;)):</span><br><span class="line">        cmd = [&#x27;tar&#x27;, &#x27;--dereference&#x27;, &#x27;-czvf&#x27;, &#x27;../dist/%s&#x27; % _TAR_FILE]</span><br><span class="line">        cmd.extend([&#x27;--exclude=\&#x27;%s\&#x27;&#x27; % ex for ex in excludes])</span><br><span class="line">        cmd.extend(includes)</span><br><span class="line">        local(&#x27; &#x27;.join(cmd))</span><br></pre></td></tr></table></figure>

<p>Fabric 提供 <code>local(&#39;...&#39;)</code> 来运行本地命令，<code>with lcd(path)</code> 可以把当前命令的目录设定为 <code>lcd()</code> 指定的目录，注意 Fabric 只能运行命令行命令，Windows 下可能需要 <a href="http://cygwin.com/">Cgywin</a> 环境。</p>
<p>在 <code>awesome-python-webapp</code> 目录下运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fab build</span><br></pre></td></tr></table></figure>

<p>看看是否在 <code>dist</code> 目录下创建了 <code>dist-awesome.tar.gz</code> 的文件。</p>
<p>打包后，我们就可以继续编写 <code>deploy</code> 任务，把打包文件上传至服务器，解压，重置 <code>www</code> 软链接，重启相关服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_REMOTE_TMP_TAR = &#x27;/tmp/%s&#x27; % _TAR_FILE</span><br><span class="line">_REMOTE_BASE_DIR = &#x27;/srv/awesome&#x27;</span><br><span class="line">def deploy():</span><br><span class="line">    newdir = &#x27;www-%s&#x27; % datetime.now().strftime(&#x27;%y-%m-%d_%H.%M.%S&#x27;)</span><br><span class="line">    # 删除已有的tar文件:</span><br><span class="line">    run(&#x27;rm -f %s&#x27; % _REMOTE_TMP_TAR)</span><br><span class="line">    # 上传新的tar文件:</span><br><span class="line">    put(&#x27;dist/%s&#x27; % _TAR_FILE, _REMOTE_TMP_TAR)</span><br><span class="line">    # 创建新目录:</span><br><span class="line">    with cd(_REMOTE_BASE_DIR):</span><br><span class="line">        sudo(&#x27;mkdir %s&#x27; % newdir)</span><br><span class="line">    # 解压到新目录:</span><br><span class="line">    with cd(&#x27;%s/%s&#x27; % (_REMOTE_BASE_DIR, newdir)):</span><br><span class="line">        sudo(&#x27;tar -xzvf %s&#x27; % _REMOTE_TMP_TAR)</span><br><span class="line">    # 重置软链接:</span><br><span class="line">    with cd(_REMOTE_BASE_DIR):</span><br><span class="line">        sudo(&#x27;rm -f www&#x27;)</span><br><span class="line">        sudo(&#x27;ln -s %s www&#x27; % newdir)</span><br><span class="line">        sudo(&#x27;chown www-data:www-data www&#x27;)</span><br><span class="line">        sudo(&#x27;chown -R www-data:www-data %s&#x27; % newdir)</span><br><span class="line">    # 重启Python服务和nginx服务器:</span><br><span class="line">    with settings(warn_only=True):</span><br><span class="line">        sudo(&#x27;supervisorctl stop awesome&#x27;)</span><br><span class="line">        sudo(&#x27;supervisorctl start awesome&#x27;)</span><br><span class="line">        sudo(&#x27;/etc/init.d/nginx reload&#x27;)</span><br></pre></td></tr></table></figure>

<p>注意 <code>run()</code> 函数执行的命令是在服务器上运行，<code>with cd(path)</code> 和 <code>with lcd(path)</code> 类似，把当前目录在服务器端设置为 <code>cd()</code> 指定的目录。如果一个命令需要 sudo 权限，就不能用 <code>run()</code>，而是用 <code>sudo()</code> 来执行。</p>
<h3 id="配置-Supervisor"><a href="#配置-Supervisor" class="headerlink" title="配置 Supervisor"></a>配置 Supervisor</h3><p>上面让 Supervisor 重启 awesome 的命令会失败，因为我们还没有配置 Supervisor 呢。</p>
<p>编写一个 Supervisor 的配置文件 <code>awesome.conf</code>，存放到 <code>/etc/supervisor/conf.d/</code> 目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[program:awesome]</span><br><span class="line">command     = /srv/awesome/www/app.py</span><br><span class="line">directory   = /srv/awesome/www</span><br><span class="line">user        = www-data</span><br><span class="line">startsecs   = 3</span><br><span class="line">redirect_stderr         = true</span><br><span class="line">stdout_logfile_maxbytes = 50MB</span><br><span class="line">stdout_logfile_backups  = 10</span><br><span class="line">stdout_logfile          = /srv/awesome/log/app.log</span><br></pre></td></tr></table></figure>

<p>配置文件通过 <code>[program:awesome]</code> 指定服务名为 <code>awesome</code>，<code>command</code> 指定启动 <code>app.py</code>。</p>
<p>然后重启 Supervisor 后，就可以随时启动和停止 Supervisor 管理的服务了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo supervisorctl reload</span><br><span class="line">$ sudo supervisorctl start awesome</span><br><span class="line">$ sudo supervisorctl status</span><br><span class="line">awesome                RUNNING    pid 1401, uptime 5:01:34</span><br></pre></td></tr></table></figure>

<h3 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3><p>Supervisor 只负责运行 <code>app.py</code>，我们还需要配置 Nginx。把配置文件 <code>awesome</code> 放到 <code>/etc/nginx/sites-available/</code> 目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80; # 监听80端口</span><br><span class="line">    root       /srv/awesome/www;</span><br><span class="line">    access_log /srv/awesome/log/access_log;</span><br><span class="line">    error_log  /srv/awesome/log/error_log;</span><br><span class="line">    # server_name awesome.liaoxuefeng.com; # 配置域名</span><br><span class="line">    # 处理静态文件/favicon.ico:</span><br><span class="line">    location /favicon.ico &#123;</span><br><span class="line">        root /srv/awesome/www;</span><br><span class="line">    &#125;</span><br><span class="line">    # 处理静态资源:</span><br><span class="line">    location ~ ^\/static\/.*$ &#123;</span><br><span class="line">        root /srv/awesome/www;</span><br><span class="line">    &#125;</span><br><span class="line">    # 动态请求转发到9000端口:</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass       http://127.0.0.1:9000;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>/etc/nginx/sites-enabled/</code> 目录下创建软链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/etc/nginx/sites-enabled</span><br><span class="line">$ sudo ln -s /etc/nginx/sites-available/awesome .</span><br></pre></td></tr></table></figure>

<p>让 Nginx 重新加载配置文件，不出意外，我们的 <code>awesome-python3-webapp</code> 应该正常运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo /etc/init.d/nginx reload</span><br></pre></td></tr></table></figure>

<p>如果有任何错误，都可以在 <code>/srv/awesome/log</code> 下查找 Nginx 和 App 本身的 log。如果 Supervisor 启动时报错，可以在 <code>/var/log/supervisor</code> 下查看 Supervisor 的 log。</p>
<p>如果一切顺利，你可以在浏览器中访问 Linux 服务器上的 <code>awesome-python3-webapp</code> 了</p>
<p>如果在开发环境更新了代码，只需要在命令行执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ fab build</span><br><span class="line">$ fab deploy</span><br></pre></td></tr></table></figure>

<p>自动部署完成！刷新浏览器就可以看到服务器代码更新后的效果。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>设置flask后端CORS跨域访问</title>
    <url>/2024/05/22/%E8%AF%AD%E8%A8%80-Python-%E8%AE%BE%E7%BD%AEflask%E5%90%8E%E7%AB%AFCORS%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>设置前后端分离</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>flask 项目地址 <a href="https://tutorial.helloflask.com/">https://tutorial.helloflask.com/</a></p>
<p>安装 flask 和 flask-cors</p>
<p>cors 用于允许服务器进行跨域访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install flask</span><br><span class="line">pip install flask-cors</span><br></pre></td></tr></table></figure>

<h1 id="浏览器-js-前端代码"><a href="#浏览器-js-前端代码" class="headerlink" title="浏览器 js 前端代码"></a>浏览器 js 前端代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SendUrlToServer</span>(<span class="params">url, method</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> requestUrl = <span class="string">&#x27;http://124.222.246.202:8081/fetch-sub-url?url=&#x27;</span>+url;</span><br><span class="line">	<span class="comment">/*let requestUrl = ?url=&#x27;http://127.0.0.1:8081/fetch-sub-url*/</span></span><br><span class="line">	<span class="title function_">fetch</span>(requestUrl, &#123;</span><br><span class="line">	<span class="attr">method</span>: method,</span><br><span class="line">	<span class="attr">headers</span>: &#123;</span><br><span class="line">	<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">/*body: JSON.stringify(&#123; url: url &#125;)*/</span></span><br><span class="line">	&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Response from server:&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error sending data:&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">RSS</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title class_">SendUrlToServer</span>(<span class="string">&quot;https://rsshub.app/bilibili/ranking/0/3/1&quot;</span>, <span class="string">&#x27;GET&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="服务器端-python-代码"><a href="#服务器端-python-代码" class="headerlink" title="服务器端 python 代码"></a>服务器端 python 代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="comment">##get python path</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">python_path = os.environ.get(<span class="string">&quot;PYTHONPATH&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PYTHONPATH:&quot;</span>, python_path)</span><br><span class="line"><span class="comment">##get end</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment">#CORS(app, resources=&#123;r&quot;/*&quot;: &#123;&quot;origins&quot;: &quot;http://127.0.0.1:80&quot;&#125;&#125;)  # 允许指定的来源访问</span></span><br><span class="line">CORS(app)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/fetch-sub-url&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_sub_url</span>():</span><br><span class="line">    <span class="comment">#data = request.get_json()</span></span><br><span class="line">    <span class="comment">#url = data.get(&#x27;url&#x27;)</span></span><br><span class="line">    <span class="comment">#url = &#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    url = request.args.get(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;current url is ===&gt;&quot;</span>+url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        response_text = response.text</span><br><span class="line">        <span class="keyword">return</span> response_text</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;error&#x27;</span>: <span class="built_in">str</span>(e)&#125;)</span><br><span class="line">    <span class="comment"># 解析RSS feed</span></span><br><span class="line">    <span class="comment">#feed = feedparser.parse(url)</span></span><br><span class="line">    <span class="comment"># 打印feed的标题</span></span><br><span class="line">    <span class="comment">#print(&quot;Feed Title:&quot;, feed.feed.title)</span></span><br><span class="line">    <span class="comment"># 打印feed中的条目</span></span><br><span class="line">    <span class="comment">#for entry in feed.entries:</span></span><br><span class="line">    <span class="comment">#    print(&quot;\nTitle:&quot;, entry.title)</span></span><br><span class="line">    <span class="comment">#    print(&quot;Link:&quot;, entry.link)</span></span><br><span class="line">    <span class="comment">#    print(&quot;description:&quot;, entry.description)</span></span><br><span class="line">    <span class="comment">#return feed</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8081</span>)</span><br></pre></td></tr></table></figure>

<h1 id="后端服务开机自启-systemd"><a href="#后端服务开机自启-systemd" class="headerlink" title="后端服务开机自启 systemd"></a>后端服务开机自启 systemd</h1><p>&#x2F;etc&#x2F;systemd&#x2F;system 启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Start Python BackEnd With Html</span><br><span class="line">After=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/home/ubuntu</span><br><span class="line">Type=idle</span><br><span class="line">#ExecStart=/home/ubuntu/html/BackEnd/start_backend.sh</span><br><span class="line">ExecStart=/usr/bin/python3 /home/ubuntu/html/BackEnd/main.py</span><br><span class="line">User=ubuntu</span><br><span class="line">Group=ubuntu</span><br><span class="line">Environment=&quot;PYTHONPATH=/home/ubuntu/.local/lib/python3.10/site-packages&quot;</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>将服务单元文件复制到 systemd 目录： 将您的服务单元文件复制到&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;目录下。您可以使用 sudo 命令进行拷贝，确保文件的权限设置正确。</p>
<p><code>sudo cp your-service-name.service /etc/systemd/system/</code></p>
<p>重新加载 systemd 配置： 您需要重新加载 systemd 配置以使更改生效。</p>
<p><code>sudo systemctl daemon-reload</code></p>
<p>启用服务： 要启用服务，使其在系统启动时自动启动，可以运行以下命令：</p>
<p><code>sudo systemctl enable your-service-name.service</code></p>
<p>这将会在适当的运行级别下创建符号链接，以便服务在系统启动时自动启动。</p>
<p>启动服务： 如果您想立即启动服务，可以运行以下命令：</p>
<p><code>sudo systemctl start your-service-name.service</code></p>
<p>这将启动您的服务。</p>
<p>完整后端处理代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, make_response, jsonify</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"><span class="keyword">from</span> werkzeug.middleware.proxy_fix <span class="keyword">import</span> ProxyFix</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> xmltodict</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"><span class="comment"># root_dir = &#x27;/home/ubuntu/html/&#x27;</span></span><br><span class="line"><span class="comment"># pic_dir = &#x27;0.res/Picture/&#x27;</span></span><br><span class="line"><span class="comment"># name = &#x27;1&#x27;#request.args.get(&#x27;id&#x27;)</span></span><br><span class="line"><span class="comment"># act_addr = os.path.join(root_dir,pic_dir,name);</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fileNameList = &#x27;&#x27;</span></span><br><span class="line"><span class="comment"># for file_name in os.listdir(act_addr):</span></span><br><span class="line"><span class="comment">#     fileNameList += pic_dir+name+&quot;/&quot;+file_name</span></span><br><span class="line"><span class="comment"># print(fileNameList)</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.wsgi_app = ProxyFix(app.wsgi_app)</span><br><span class="line"><span class="comment"># 只允许特定路由支持跨域请求</span></span><br><span class="line">CORS(app, origins=[<span class="string">&quot;http://124.222.246.202&quot;</span>,<span class="string">&quot;http://127.0.0.1&quot;</span>])</span><br><span class="line">HOME_PATH = <span class="string">&quot;/home/ubuntu/BlogData/&quot;</span></span><br><span class="line"><span class="comment">#@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class="line"><span class="comment">#def home_index():</span></span><br><span class="line"><span class="comment">#    index_html = open(&quot;/home/ubuntu/liuluhua.github.io/index.html&quot;, &quot;r&quot;)</span></span><br><span class="line"><span class="comment">#    print (&quot;文件名: &quot;, index_html.name)</span></span><br><span class="line"><span class="comment">#    print (&quot;是否已关闭 : &quot;, index_html.closed)</span></span><br><span class="line"><span class="comment">#    print (&quot;访问模式 : &quot;, index_html.mode)</span></span><br><span class="line"><span class="comment">#    return index_html.read()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/get_ip&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ip_addr</span>():</span><br><span class="line">    ip_addr = request.remote_addr</span><br><span class="line">    api_url = <span class="string">f&#x27;https://ipinfo.io/<span class="subst">&#123;ip_addr&#125;</span>/json&#x27;</span></span><br><span class="line">    response = requests.get(api_url)</span><br><span class="line">    data = response.json()</span><br><span class="line">    ret_data = <span class="string">&quot;来自&quot;</span>+data.get(<span class="string">&#x27;country&#x27;</span>)+<span class="string">&quot; &quot;</span>+data.get(<span class="string">&#x27;region&#x27;</span>)+<span class="string">&quot;的&quot;</span>+data.get(<span class="string">&#x27;ip&#x27;</span>)+<span class="string">&quot;朋友&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret_data</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/get_picture&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">picture_show</span>():</span><br><span class="line">    pic_dir = <span class="string">&#x27;0.res/Picture/&#x27;</span></span><br><span class="line">    name = request.args.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    act_addr = os.path.join(HOME_PATH,pic_dir,name);</span><br><span class="line">    fileNameList = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> os.listdir(act_addr):</span><br><span class="line">        fileNameList += <span class="string">f&#x27;&lt;img src=&quot;<span class="subst">&#123;pic_dir&#125;</span><span class="subst">&#123;name&#125;</span>/<span class="subst">&#123;file_name&#125;</span>&quot; alt=&quot;<span class="subst">&#123;file_name&#125;</span>&quot;&gt;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(file_name)</span><br><span class="line">    <span class="built_in">print</span> (fileNameList)</span><br><span class="line">    <span class="keyword">return</span> (fileNameList)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/getFileContent&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFileContent</span>():</span><br><span class="line">    filePath = request.get_json().get(<span class="string">&#x27;filePos&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(filePath)</span><br><span class="line">    f = <span class="built_in">open</span>(filePath)</span><br><span class="line">    lines = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/getFileList&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFileList</span>():</span><br><span class="line">    <span class="comment">#return  json.dumps(request.get_json()) + getDirList(HOME_PATH+&quot;Python&quot;);</span></span><br><span class="line">    <span class="keyword">return</span>  getDirList(HOME_PATH+<span class="string">&quot;Python&quot;</span>);</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getDirList</span>(<span class="params">dir_path,ret_list=<span class="literal">None</span>,depth=<span class="number">0</span></span>):</span><br><span class="line">    base_list = <span class="built_in">sorted</span>(os.scandir(dir_path),key=<span class="keyword">lambda</span> entry: (<span class="keyword">not</span> entry.is_dir(), entry.name))</span><br><span class="line">    <span class="keyword">if</span> ret_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ret_list = []</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> base_list:</span><br><span class="line">        <span class="keyword">if</span> entry.is_dir():</span><br><span class="line">            ret_list.append(<span class="string">&#x27;&lt;details&gt;&lt;summary&gt;&lt;span class=&quot;tree-item&quot;&gt;&#x27;</span>)</span><br><span class="line">            ret_list.append(entry.name+<span class="string">&#x27;&lt;/span&gt;&lt;/summary&gt;&#x27;</span>)</span><br><span class="line">            getDirList(entry.path, ret_list, depth+<span class="number">1</span>)</span><br><span class="line">            ret_list.append(<span class="string">&#x27;&lt;/details&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            file_pos = dir_path.replace(<span class="string">&quot;/home/ubuntu/html&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">            ret_list.append(<span class="string">f&#x27;&lt;details&gt;&lt;summary&gt; \</span></span><br><span class="line"><span class="string">            &lt;span class=&quot;tree-item&quot; onclick=&quot;openFile(\&#x27;<span class="subst">&#123;file_pos&#125;</span>/<span class="subst">&#123;entry.name&#125;</span>\&#x27;)&quot;&gt;&#x27;</span> + entry.name+<span class="string">&#x27;&lt;/summary&gt;&lt;/details&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(ret_list)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/signin&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signin</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;post signin&quot;</span>)</span><br><span class="line">    username = request.form.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    password = request.form.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    button_clicked = request.form.get(<span class="string">&#x27;signin&#x27;</span>)  <span class="comment"># 或者使用 &#x27;signup&#x27;</span></span><br><span class="line">    <span class="comment">#jsonify(&#123;&quot;response&quot;: &quot;test&quot;&#125;)</span></span><br><span class="line">    <span class="comment"># 确定哪个按钮被点击了</span></span><br><span class="line">    <span class="keyword">if</span> button_clicked == <span class="string">&#x27;signin&#x27;</span>:</span><br><span class="line">        <span class="comment"># 处理登录操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Login: Username=<span class="subst">&#123;username&#125;</span>, Password=<span class="subst">&#123;password&#125;</span>&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> button_clicked == <span class="string">&#x27;signup&#x27;</span>:</span><br><span class="line">        <span class="comment"># 处理注册操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Signup: Username=<span class="subst">&#123;username&#125;</span>, Password=<span class="subst">&#123;password&#125;</span>&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 没有按钮被点击或者未知按钮名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Unknown button pressed&#x27;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/wechat&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wechat_signature</span>():</span><br><span class="line">    data = request.args</span><br><span class="line">    echostr = data.get(<span class="string">&#x27;echostr&#x27;</span>)</span><br><span class="line">    signature = data.get(<span class="string">&#x27;signature&#x27;</span>)</span><br><span class="line">    timestamp = data.get(<span class="string">&#x27;timestamp&#x27;</span>)</span><br><span class="line">    nonce = data.get(<span class="string">&quot;nonce&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> signature <span class="keyword">or</span> <span class="keyword">not</span> timestamp <span class="keyword">or</span> <span class="keyword">not</span> nonce:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    tmp_str = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>([<span class="string">&#x27;******&#x27;</span>, timestamp, nonce]))</span><br><span class="line">    tmp_str = hashlib.sha1(tmp_str.encode(<span class="string">&#x27;UTF-8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> tmp_str == signature:</span><br><span class="line">        <span class="keyword">return</span> echostr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Failed&quot;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/wechat&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wechat_communication</span>():</span><br><span class="line">    <span class="comment">#获取微信服务器post过来的xml数据</span></span><br><span class="line">    xml = request.data</span><br><span class="line">    <span class="comment"># 把xml格式的数据进行处理，转换成字典进行取值</span></span><br><span class="line">    req = xmltodict.parse(xml)[<span class="string">&#x27;xml&#x27;</span>]</span><br><span class="line">    <span class="comment"># 判断post过来的数据中数据类型是不是文本</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;text&#x27;</span> == req.get(<span class="string">&#x27;MsgType&#x27;</span>):</span><br><span class="line">    <span class="comment"># 获取用户的信息，开始构造返回数据，把用户发送的信息原封不动的返回过去，字典格式</span></span><br><span class="line">        resp = &#123;</span><br><span class="line">            <span class="string">&#x27;ToUserName&#x27;</span>:req.get(<span class="string">&#x27;FromUserName&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;FromUserName&#x27;</span>:req.get(<span class="string">&#x27;ToUserName&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;CreateTime&#x27;</span>:<span class="built_in">int</span>(time.time()),</span><br><span class="line">            <span class="string">&#x27;MsgType&#x27;</span>:<span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content&#x27;</span>:req.get(<span class="string">&#x27;Content&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 把构造的字典转换成xml格式</span></span><br><span class="line">        xml = xmltodict.unparse(&#123;<span class="string">&#x27;xml&#x27;</span>:resp&#125;)</span><br><span class="line">        <span class="comment"># print(req.get(&#x27;Content&#x27;))</span></span><br><span class="line">        <span class="comment"># 返回数据</span></span><br><span class="line">        <span class="keyword">return</span> xml</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        resp = &#123;</span><br><span class="line">            <span class="string">&#x27;ToUserName&#x27;</span>: req.get(<span class="string">&#x27;FromUserName&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;FromUserName&#x27;</span>: req.get(<span class="string">&#x27;ToUserName&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;CreateTime&#x27;</span>: <span class="built_in">int</span>(time.time()),</span><br><span class="line">            <span class="string">&#x27;MsgType&#x27;</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content&#x27;</span>: <span class="string">&#x27;I LOVE ITCAST&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        xml = xmltodict.unparse(&#123;<span class="string">&#x27;xml&#x27;</span>:resp&#125;)</span><br><span class="line">        <span class="keyword">return</span> xml</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">9080</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Qt多项目管理</title>
    <url>/2024/03/03/%E8%AF%AD%E8%A8%80-Qt-Qt%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Qt 工程过大或需要将工程分模块编译成库的形式加载时,需要将整体的 Qt 项目拆分各个小模块进行编译。</p>
<h1 id="1-条件编译文件"><a href="#1-条件编译文件" class="headerlink" title="1.条件编译文件"></a>1.条件编译文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unix&#123;</span><br><span class="line">    //执行unix环境下的配置选项</span><br><span class="line">&#125;</span><br><span class="line">win32&#123;</span><br><span class="line">    //执行Windows环境下的配置选项</span><br><span class="line">&#125;</span><br><span class="line">contains(QT_ARCH, arm64)&#123;</span><br><span class="line">    //执行在架构为arm64的环境下的配置选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-子项目-lib"><a href="#2-子项目-lib" class="headerlink" title="2. 子项目 lib"></a>2. 子项目 lib</h1><p>子项目工程文件为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT -= gui</span><br><span class="line">TARGET = printHello</span><br><span class="line">CONFIG   += staticlib</span><br><span class="line">TEMPLATE = lib</span><br><span class="line">DEFINES += printHello_LIBRARY</span><br><span class="line">CONFIG -= debug_and_release</span><br><span class="line">SOURCES += printHello. cpp</span><br><span class="line">HEADERS += printHello. h</span><br></pre></td></tr></table></figure>

<h1 id="3-子项目-dll"><a href="#3-子项目-dll" class="headerlink" title="3. 子项目 dll"></a>3. 子项目 dll</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT -= gui</span><br><span class="line">TARGET = printNice</span><br><span class="line">TEMPLATE = lib</span><br><span class="line">DEFINES += printNice_LIBRARY</span><br><span class="line">CONFIG -= debug_and_release</span><br><span class="line">SOURCES += printNice. cpp</span><br><span class="line">HEADERS += printNice. h</span><br></pre></td></tr></table></figure>

<h1 id="4-可执行程序项目-exe"><a href="#4-可执行程序项目-exe" class="headerlink" title="4.可执行程序项目 exe"></a>4.可执行程序项目 exe</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT += core gui widgets</span><br><span class="line">TARGET = print</span><br><span class="line">TEMPLATE = app</span><br><span class="line">SOURCES += main. cpp printwindow. cpp</span><br><span class="line">LIBS += -LprintHello -lprintHello -LprintNice -lprintNice</span><br><span class="line">FORMS += printwindow. ui</span><br><span class="line">HEADERS += printwindow. h</span><br></pre></td></tr></table></figure>

<h1 id="5-管理项-Dirs"><a href="#5-管理项-Dirs" class="headerlink" title="5.管理项 Dirs"></a>5.管理项 Dirs</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEMPLATE = subdirs</span><br><span class="line">SUBDIRS += printHello/printHello.pro printNice/printNice.pro print.pro</span><br><span class="line">CONFIG += ordered</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt操作Sqlite3</title>
    <url>/2024/05/22/%E8%AF%AD%E8%A8%80-Qt-Qt%E6%93%8D%E4%BD%9CSqlite3/</url>
    <content><![CDATA[<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SqliteOperator::CreatDb()</span><br><span class="line">&#123;</span><br><span class="line">    if(QSqlDatabase::contains(&quot;qt_sql_default_connection&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        db = QSqlDatabase::database(&quot;qt_sql_default_connection&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        db = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);</span><br><span class="line">        db.setDatabaseName(&quot;test.db&quot;);</span><br><span class="line">        db.setUserName(&quot;test&quot;);</span><br><span class="line">        db.setPassword(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打开及关闭数据库"><a href="#打开及关闭数据库" class="headerlink" title="打开及关闭数据库"></a>打开及关闭数据库</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool SqliteOperator::OpenDb()</span><br><span class="line">&#123;</span><br><span class="line">    if(!db.open())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Error: Failed to connect database.&quot; &lt;&lt; db.lastError();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void SqliteOperator::CloseDb()</span><br><span class="line">&#123;</span><br><span class="line">    db.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SqliteOperator::CreateTable()</span><br><span class="line">&#123;</span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    QString creat_sql = &quot;create table student (id int primary key, name varchar(30), age int)&quot;;</span><br><span class="line">    sql_query.prepare(creat_sql);</span><br><span class="line">    if(!sql_query.exec())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Error: Fail to create table.&quot; &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Table created!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SqliteOperator::InsertData()</span><br><span class="line">&#123;</span><br><span class="line">    QString insert_sql = &quot;insert into student values (?, ?, ?)&quot;;</span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    sql_query.prepare(insert_sql);</span><br><span class="line">sql_query.addBindValue(GetMaxId() +1);</span><br><span class="line">    sql_query.addBindValue(&quot;Wang&quot;);</span><br><span class="line">    sql_query.addBindValue(25);</span><br><span class="line">    if(!sql_query.exec())</span><br><span class="line">    &#123;</span><br><span class="line">    qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    qDebug() &lt;&lt; &quot;inserted Wang!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SqliteOperator::QueryAllData()</span><br><span class="line">&#123;</span><br><span class="line">    QString select_all_sql = &quot;select * from student&quot;;</span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    sql_query.prepare(select_all_sql);</span><br><span class="line">    if(!sql_query.exec())</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        while(sql_query.next())</span><br><span class="line">        &#123;</span><br><span class="line">            int id = sql_query.value(0).toInt();</span><br><span class="line">            QString name = sql_query.value(1).toString();</span><br><span class="line">            int age = sql_query.value(2).toInt();</span><br><span class="line">            qDebug()&lt;&lt;QString(&quot;id:%1    name:%2    age:%3&quot;).arg(id).arg(name).arg(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SqliteOperator::QueryData()</span><br><span class="line">&#123;</span><br><span class="line">    QString select_sql = QString(&quot;select * from student where name = &#x27;%1&#x27; and (age = &#x27;%2&#x27; or age = &#x27;%3&#x27;)&quot;)</span><br><span class="line">            .arg(&quot;Wang&quot;)</span><br><span class="line">            .arg(30)</span><br><span class="line">            .arg(25);</span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    if(!sql_query.exec(select_sql))</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        while(sql_query.next())</span><br><span class="line">        &#123;</span><br><span class="line">            int id = sql_query.value(0).toInt();</span><br><span class="line">            QString name = sql_query.value(1).toString();</span><br><span class="line">            qDebug()&lt;&lt;QString(&quot;id:%1    name:%2&quot;).arg(id).arg(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>ffmpeg-m3u8转mp4</title>
    <url>/2024/05/16/%E8%BD%AF%E4%BB%B6-Ffmpeg-ffmpeg-m3u8%E8%BD%ACmp4/</url>
    <content><![CDATA[<h1 id="FFmpeg-命令行工具"><a href="#FFmpeg-命令行工具" class="headerlink" title="FFmpeg 命令行工具"></a>FFmpeg 命令行工具</h1><p>将 m3u8 文件转换为 mp4 格式</p>
<p><strong>下载并安装 FFmpeg</strong><br>您可以从 <a href="https://ffmpeg.org/download.html">官方网站</a> 下载适合您操作系统的版本。</p>
<p><strong>打开命令行工具</strong></p>
<ul>
<li>在 Windows 上，您可以按下 Win + R 键，然后输入 cmd 并按 Enter 键打开命令提示符。</li>
<li>在 Mac OS 或 Linux 上，您可以打开终端应用程序。</li>
</ul>
<p><strong>转换 m3u8 文件</strong><br>在命令行中，导航到包含 m3u8 文件的目录，然后运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.m3u8 -c copy output.mp4</span><br></pre></td></tr></table></figure>

<p><code>input.m3u8</code> 是要转换的 m3u8 文件的名称，<code>output.mp4</code> 是转换后的 mp4 文件的名称。</p>
<p>该命令将使用 FFmpeg 将 m3u8 文件转换为 mp4 格式，并将其保存在相同的目录中。</p>
<p>请注意，此命令只能将 m3u8 文件转换为 mp4 格式，而不能将其中的视频文件下载到本地计算机。</p>
<p>如果您需要下载 m3u8 文件中的视频文件，请使用其他工具或软件。</p>
<h2 id="将分段式-m3u8-文件转换为-MP4-文件"><a href="#将分段式-m3u8-文件转换为-MP4-文件" class="headerlink" title="将分段式 m3u8 文件转换为 MP4 文件"></a>将分段式 m3u8 文件转换为 MP4 文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cd ./m3u8Movie  #分段式m3u8文件所在文件夹</span><br><span class="line">for i in &#123;1..2473&#125;  #轮询所有分段式文件数量</span><br><span class="line">do</span><br><span class="line">    if [ -f &quot;$i&quot; ]; then    #检测文件存在</span><br><span class="line">        mv &quot;$i&quot; &quot;$i.mp4&quot;    #重命名</span><br><span class="line">    fi</span><br><span class="line">    echo &quot;file &#x27;./$i.mp4&#x27;&quot; &gt;&gt; list.txt  #添加到列表中去</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#调用ffmpeg进行视频连接操作</span><br><span class="line">ffmpeg -f concat -safe 0 -i list.txt -c copy ../movie.mp4</span><br><span class="line">#-f 指定输入格式为concat，表示要进行视频文件的连接操作</span><br><span class="line">#-safe 0 设置安全模式为0，允许使用不安全的文件名</span><br><span class="line">#-i 指定文本文件包含了要连接的视频文件的列表及其路径</span><br><span class="line">#-c 直接复制输入视频文件的音视频流，而不进行重新编码。这样可以加快处理速度而不损失质量。</span><br><span class="line">#指定输出文件路径和名称</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
        <category>Ffmpeg</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Git介绍和基本命令</title>
    <url>/2024/05/17/%E8%BD%AF%E4%BB%B6-Git-Git%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理。</p>
<p>Git 是免费、开源的<strong>分布式版本控制系统</strong>。</p>
<h2 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h2><p>集中管理的中央服务器，保存着所有文件的修改历史版本。</p>
<p>协同开发者通过客户端连接到这台服务器，从服务器上同步更新或上传自己的修改。</p>
<h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><p>远程仓库同步所有版本信息到本地的每个用户</p>
<ol>
<li>本地可以查看所有的历史版本信息，偶尔远程更新，查看其他用户修改提交到远程</li>
<li>用户即使离线也可以本地提交，push 推送到远程服务器才需要联网</li>
<li>每个用户都保存了历史版本</li>
</ol>
<h1 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h1><p><strong>Workspace</strong>：电脑本地看到的文件和目录，在 Git 的版本控制下，构成了工作区。</p>
<p><strong>Index&#x2F;Stage</strong>：暂存区，一般存放在.git 目录下，即.git&#x2F;index,它又叫待提交更新区，用于临时存放你未提交的改动。<strong>执行 git add，这些改动就添加到这个区域</strong>。</p>
<p><strong>Repository</strong>：本地仓库，你执行 git clone 地址，就是把远程仓库克隆到本地仓库。它是一个存放在本地的版本库，其中 HEAD 指向最新放入仓库的版本。当你执行 git commit，文件改动就到本地仓库。</p>
<p><strong>Remote</strong>：远程仓库，云端版本库</p>
<h1 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h1><p><strong>Untracked</strong>: 文件未加入到 git 库，未参与版本控制，处于未跟踪状态。通过 git add，可以变为 Staged 状态</p>
<p><strong>Unmodified</strong>：文件已经加入 git 库，版本库中的文件快照内容与文件夹中还完全一致。 Unmodified 的文件如果被修改, 就会变为 Modified。如果使用 git remove 移出版本库，则成为 Untracked 文件。</p>
<p><strong>Modified</strong>：文件被修改进入 modified 状态，文件这个状态通过 stage 命令可以进入 staged 状态</p>
<p><strong>staged</strong>：暂存状态. 执行 git commit 则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为 Unmodified 状态。</p>
<h1 id="正向工作流"><a href="#正向工作流" class="headerlink" title="正向工作流"></a>正向工作流</h1><p>git 的正向工作流程一般就这样：</p>
<ol>
<li>从远程仓库拉取文件代码回来；<code>git pull</code></li>
<li>在工作目录，增删改文件；</li>
<li>把改动的文件放入暂存区；<code>git add</code></li>
<li>将暂存区的文件提交本地仓库；<code>git commit</code></li>
<li>将本地仓库的文件推送到远程仓库；<code>git push</code></li>
</ol>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone [url] #克隆远程仓库</span><br><span class="line">git add [dir/file]#添加目录/文件到暂存区</span><br><span class="line">git commit [--amend] -m [msg] #提交暂存区到仓库区,msg为说明信息(amend用新的commit覆盖提交)</span><br><span class="line">git log [--oneline] [-p [file]]#查看提交历史(online精简模式)(p指定文件)</span><br><span class="line">git blame #列表方式查看指定文件的提交历史</span><br><span class="line">git diff #显示暂存区和工作区的差异</span><br><span class="line">git diff #显示暂存区和工作区的差异</span><br><span class="line">git diff filepath   #filepath路径文件中，工作区与暂存区的比较差异</span><br><span class="line">git diff HEAD filepath #工作区与HEAD ( 当前工作分支)的比较差异</span><br><span class="line">git diff branchName filepath #当前分支文件与branchName分支的文件的比较差异</span><br><span class="line">git diff commitId filepath #与某一次提交的比较差异</span><br><span class="line">git status [-s] [--show-stash] #查看当前工作区暂存区变动(-s概要信息)（show-stash显示暂存文件）</span><br><span class="line">git pull/fetch #拉取远端代码</span><br><span class="line">#git pull = git fetch+ git merge。pull的话，拉取远程分支并与本地分支合并</span><br><span class="line">#fetch只是拉远程分支，怎么合并，可以自己再做选择。</span><br><span class="line">git pull  #拉取远程仓库所有分支更新并合并到本地分支。</span><br><span class="line">git pull origin master #将远程master分支合并到当前本地master分支</span><br><span class="line">git pull origin master:master #将远程master分支合并到当前本地master分支，冒号后面表示本地分支</span><br><span class="line">git fetch --all  #拉取所有远端的最新代码</span><br><span class="line">git fetch origin master #拉取远程最新master分支代码</span><br><span class="line">git push #推送到远端</span><br><span class="line">git push origin master #将本地分支的更新全部推送到远程仓库master分支。</span><br><span class="line">git push origin -d    #删除远程branchname分支</span><br><span class="line">git push --tags #推送所有标签</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># git rebase</span><br><span class="line"></span><br><span class="line">`rebase`又称为衍合，是合并的另外一种选择。 `rebase`好处是： 获得更优雅的提交树，可以线性的看到每一次提交，并且没有增加提交节点。所以很多时候，看到有些伙伴都是这个命令拉代码：`git pull --rebase`</span><br><span class="line"></span><br><span class="line"># git stash</span><br><span class="line"></span><br><span class="line">`stash`命令可用于临时保存和恢复修改</span><br><span class="line"></span><br><span class="line">git stash  把当前的工作隐藏起来 等以后恢复现场后继续工作</span><br><span class="line">git stash list 显示保存的工作进度列表</span><br><span class="line">git stash pop stash@&#123;num&#125; 恢复工作进度到工作区</span><br><span class="line">git stash show ：显示做了哪些改动</span><br><span class="line">git stash drop stash@&#123;num&#125; ：删除一条保存的工作进度</span><br><span class="line">git stash clear 删除所有缓存的stash。</span><br><span class="line"># git reflog</span><br><span class="line"></span><br><span class="line">显示当前分支的最近几次提交</span><br><span class="line"></span><br><span class="line"># git blame</span><br><span class="line"></span><br><span class="line">`git blame filepath`记录了某个文件的更改历史和更改人</span><br><span class="line"></span><br><span class="line"># git remote</span><br><span class="line"></span><br><span class="line">git remote   查看关联的远程仓库的名称</span><br><span class="line">git remote add url   添加一个远程仓库</span><br><span class="line">git remote show [remote] 显示某个远程仓库的信息</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作</title>
    <url>/2024/05/17/%E8%BD%AF%E4%BB%B6-Git-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><h2 id="对于网络项目"><a href="#对于网络项目" class="headerlink" title="对于网络项目"></a>对于网络项目</h2><p><code>git clone [url]</code> 将 GitHub 中的网络项目复制到本地，只需在修改完之后 commit 即可，然后更新仓库代码，就可同步修改。</p>
<h2 id="对于本地项目"><a href="#对于本地项目" class="headerlink" title="对于本地项目"></a>对于本地项目</h2><p>首先要创建一个文件夹用以存放文件，然后使用</p>
<ul>
<li><code>git init</code> 对进行初始化操作</li>
<li><code>git status</code> 得到 git 中文件的状态</li>
<li><code>git add filename</code> 将 filename 文件加入到 git 本地仓库中去（git rm -cached 可移除）</li>
<li><code>git commit -m ‘status’</code> 表示提交信息（status 表示附加信息）</li>
</ul>
<p>之后对本地项目进行关联</p>
<ul>
<li><code>git remote add origin [url]</code> 添加本地到远程 origin 仓库</li>
<li><code>git remote -v</code> 查看当前项目有哪些远程仓库 关联之后可以向远程仓库提交代码（更新仓库代码）</li>
</ul>
<h2 id="日常-push"><a href="#日常-push" class="headerlink" title="日常 push"></a>日常 push</h2><ul>
<li><code>git status</code> #获取状态</li>
<li><code>git add . </code>#添加文件到暂存区</li>
<li><code>git commit -m &quot;20191121 push&quot; </code>#提交文件</li>
<li><code>git push origin master </code>#推送</li>
</ul>
<h2 id="日常-pull"><a href="#日常-pull" class="headerlink" title="日常 pull"></a>日常 pull</h2><ul>
<li><code>git diff</code> <em>比较工作目录和 Index 中的代码。</em></li>
<li><code>git fetch</code> <em>当于从远程获取最新版本到本地，不会自动 merge ，比 Git pull 更安全些</em></li>
<li><code>git checkout app/model/user.rb</code> <em>将 user.rb 文件从上一个已提交的版本中更新回来，未提交的工作目录中的内容全部会被覆盖</em></li>
</ul>
<h2 id="首次使用配置-ssh"><a href="#首次使用配置-ssh" class="headerlink" title="首次使用配置 ssh"></a>首次使用配置 ssh</h2><ul>
<li><code>ssh-keygen -t rsa</code></li>
<li><code>ssh -T &lt;git@github.com&gt;</code></li>
</ul>
<h2 id="首次使用设置用户"><a href="#首次使用设置用户" class="headerlink" title="首次使用设置用户"></a>首次使用设置用户</h2><ul>
<li><code>git config (--global) user.name &quot;username&quot;</code></li>
<li><code>git config (--global) user.email &quot;&lt;username@gmail.com&gt;&quot;</code></li>
</ul>
<h2 id="上传-下载常用命令"><a href="#上传-下载常用命令" class="headerlink" title="上传&#x2F;下载常用命令"></a>上传&#x2F;下载常用命令</h2><ul>
<li><code>git push origin（仓库名） master（分支）</code> <em>更新仓库代码（上传）</em></li>
<li><code>git pull origin（仓库名） master（分支）</code> <em>更新本地代码（下载）</em></li>
</ul>
<h2 id="回退历史版本"><a href="#回退历史版本" class="headerlink" title="回退历史版本"></a>回退历史版本</h2><ul>
<li><code>git log</code></li>
<li><code>git reset --hard \[commit\_id]</code></li>
<li><code>git revert \[commit\_id]</code></li>
</ul>
<h2 id="网络项目"><a href="#网络项目" class="headerlink" title="网络项目"></a>网络项目</h2><ul>
<li><code>git clone \[url]</code></li>
<li><code>git remote add origin \[url]</code> <em>添加本地到远程 origin 仓库</em></li>
<li><code>git remote -v</code> <em>查看当前项目有哪些远程仓库</em></li>
</ul>
<h2 id="版本情况"><a href="#版本情况" class="headerlink" title="版本情况"></a>版本情况</h2><ul>
<li><code>git tag</code> <em>查看版本情况</em></li>
<li><code>git tag V1.0</code> <em>新建版本</em></li>
<li><code>git checkout V1.0</code> <em>切换至版本 V1.0</em></li>
</ul>
<h2 id="分支情况"><a href="#分支情况" class="headerlink" title="分支情况"></a>分支情况</h2><ul>
<li><code>git branch</code> <em>查看当前分支情况</em></li>
<li><code>git checkout a</code> <em>切换到分支 a</em></li>
<li><code>git checkout -b a</code> <em>新建分支 a 并切换到分支 a</em></li>
<li><code>git branch -d a</code> <em>删除 a 分支</em></li>
<li><code>git merge a</code> <em>将 a 分支的代码合并到 master 分支上</em></li>
</ul>
<h2 id="撤销或回退"><a href="#撤销或回退" class="headerlink" title="撤销或回退"></a>撤销或回退</h2><p>在 Git 中，撤销和回退是指<strong>撤销</strong>或<strong>回退</strong>先前的提交或更改。 简单介绍下 Git 中的撤销和回退操作，以及如何使用它们来管理代码库。</p>
<p>#可以把版本库上的提交回退到暂存区，修改记录保留</p>
<p><code>git reset –-soft []</code></p>
<p>#可以把版本库上的提交回退到工作区，修改记录保留</p>
<p><code>git reset –-mixed []</code></p>
<p>#可以把版本库上的提交彻底回退，修改的记录全部revert。</p>
<p><code>git reset –-hard</code></p>
<h2 id="reset-和-revert-的区别"><a href="#reset-和-revert-的区别" class="headerlink" title="reset 和 revert 的区别"></a>reset 和 revert 的区别</h2><p><code>git reset</code> 和 <code> git revert</code> 的主要区别在于它们对历史记录的处理方式。git reset 会删除历史记录并永久删除更改，而 git revert 会创建一个新的提交来撤销更改并保留历史记录。</p>
<p><code>git reset</code> 命令会将 HEAD 指针指向指定的 commit，并将暂存区和工作目录恢复到该 commit 的状态。这意味着在执行 <code>git reset</code> 后，之前的更改将不再存在于工作目录和暂存区中。如果您希望永久删除一些更改并且不再需要它们，可以使用 <code>git reset</code>。</p>
<p><code>git revert</code> 命令会创建一个新的提交来撤销指定的提交。这意味着在执行 <code>git revert</code> 后，之前的更改仍然存在于工作目录和暂存区中，并且您需要提交一个新的撤销提交。如果您想要保留更改历史记录并且不想永久删除更改，可以使用 <code>git revert</code>。</p>
<h2 id="获取-ID"><a href="#获取-ID" class="headerlink" title="获取 ID"></a>获取 ID</h2><p><code>git log</code> 获取到想要回退的 commit_id</p>
<h2 id="撤销-回退未提交的更改"><a href="#撤销-回退未提交的更改" class="headerlink" title="撤销&#x2F;回退未提交的更改"></a>撤销&#x2F;回退未提交的更改</h2><p>**(add 之后，commit 之前)** 要撤销未提交的更改，请使用以下命令： <code>git checkout &lt;file-name&gt;</code> 将名为 file-name 的文件恢复到上一个提交的状态。</p>
<blockquote>
<p>本地本次的更改也不再保存，恢复到上一个提交 (commit) 的状态</p>
</blockquote>
<p><code>git reset HEAD --file </code> 回退暂存区里的某个文件，回退到当前版本工作区状态</p>
<blockquote>
<p>保存工作区的更改，只是撤销 <code>git add</code> 这一步操作</p>
</blockquote>
<p><code>git checkout .</code> 将所有文件恢复到最新提交的状态。请注意，此操作将删除所有未提交的更改。</p>
<h2 id="撤销-回退上一个提交"><a href="#撤销-回退上一个提交" class="headerlink" title="撤销&#x2F;回退上一个提交"></a>撤销&#x2F;回退上一个提交</h2><p>**(commit 之后，push 之前)** 撤销上一个提交 <code>git reset HEAD~1</code> 将 HEAD 指针移动到上一个提交。</p>
<blockquote>
<p>工作区保留先前的更改，需要重新添加到暂存区 (git add)</p>
</blockquote>
<p>回退到上一个提交 <code>git reset --hard HEAD~1</code> 将 HEAD 指针和工作树都重置为上一个提交的状态。</p>
<blockquote>
<p>请注意，此操作将删除所有未提交 (commit) 的更改。</p>
</blockquote>
<h2 id="撤销-回退到特定的提交"><a href="#撤销-回退到特定的提交" class="headerlink" title="撤销&#x2F;回退到特定的提交"></a>撤销&#x2F;回退到特定的提交</h2><p>**(push 之后)** 撤销到特定版本 <code>git revert &lt;commit_id&gt;</code> 这将创建一个新的提交，该提交撤销名为 commit-hash 的提交所做的更改。</p>
<blockquote>
<p>本次撤销操作也会作为一次提交 (push) 进行保存</p>
</blockquote>
<p>回退到特定版本 <code>git reset --hard &lt;commit_id&gt;</code> 将 HEAD 指针和工作树都重置为名为 commit-hash 的提交的状态。</p>
<blockquote>
<p>请注意，此操作将删除所有未提交的更改。</p>
</blockquote>
<p>回退完成后，git push -f 强制提交</p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>Git 是一个流行的分布式版本控制系统，一般都是存在多个分支的，开发分支，回归测试分支以及主干分支等 在 Git 中，分支是指指向 Git 提交历史中某个特定提交的指针。 每个分支都包含在 Git 提交历史中的一系列提交，这些提交构成了分支的历史记录。 分支在 Git 中非常重要，因为它们允许多个开发人员同时在同一个代码库中工作，而不会相互干扰。 通过创建分支，每个开发人员都可以在自己的分支上进行工作，而不会影响其他人的工作。 这样，开发人员可以在不干扰其他人的情况下，独立地开发和测试新功能，最终将这些更改合并到主分支中。</p>
<p>在 Git 中，分支操作非常简单。以下是一些常用的 Git 分支操作：</p>
<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>要创建一个新分支，请使用以下命令： <code>git branch &lt;branch-name&gt;</code> 这将创建一个名为 branch-name 的新分支。</p>
<blockquote>
<p>注意，此时仍然在当前分支上工作。</p>
</blockquote>
<p><code>git checkout -b &lt;branch-name&gt;</code> 新建一个分支，并且切换到新的分支 branch-name</p>
<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>要查看所有分支，请使用以下命令： <code>git branch</code> 这将列出所有分支，当前分支将用一个星号标记。</p>
<blockquote>
<p>git branch -r 查看所有远程的分支 git branch -a 查看所有远程分支和本地分支</p>
</blockquote>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>要删除一个分支，请使用以下命令： <code>git branch -d &lt;branch-name&gt;</code> 这将删除名为的分支。</p>
<blockquote>
<p>注意，如果该分支包含未合并的更改，则必须使用 <code>-D</code> 选项而不是 <code>-d</code> 选项来强制删除该分支。</p>
</blockquote>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>要切换到另一个分支，请使用以下命令： <code>git checkout &lt;branch-name&gt;</code> 这将使您从当前分支切换到名为 branch-name 的分支。</p>
<blockquote>
<p>注意，需要在切换分支之前将所有更改提交或保存。</p>
</blockquote>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>要将一个分支合并到另一个分支，请使用以下命令： <code>git merge &lt;branch-name&gt;</code> 将名为 branch-name 的分支合并到当前分支中。</p>
<blockquote>
<p>注意，如果两个分支上都有对同一文件的更改，则可能会发生冲突。在这种情况下，需要手动解决冲突并提交更改。 git merge –no-ff origin&#x2F;dev 在当前分支上合并远程分支 dev git merge –abort 终止本次 merge，并回到 merge 前的状态</p>
</blockquote>
<p>以上是一些常用的 Git 分支操作。使用这些操作，您可以轻松地创建、切换、合并和删除分支。这些操作使多人协作变得更加容易，因为每个开发人员都可以在自己的分支上进行工作，并将更改合并到主分支中。在实际开发中，分支操作是非常重要的，最好能够熟练掌握并运用这些操作</p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>在 Git 中，tag 是用于标记某个特定提交的名称。它类似于一个<strong>快照</strong>，可以用于标记版本、发布或重要的里程碑。Git 中有两种类型的 tag：轻量级标签和附注标签。</p>
<p>轻量级标签是一个简单的指向某个特定提交的<strong>引用</strong>，类似于一个分支，但不会随着新的提交而移动。创建轻量级标签的方法很简单，只需在命令行中输入 <code>git tag &lt;tag-name&gt; </code> 即可。例如，<code>git tag v1.0</code> 将创建一个名为 v1.0 的轻量级标签。</p>
<p>附注标签是一个包含标签名称、标签创建者、标签创建日期和标签说明的 Git 对象。它们是 Git 中最常用的标签类型，可以用于发布版本、重要的里程碑和其他<strong>重要的提交</strong>。创建附注标签的方法是使用 -a 标志和标签名称，然后输入标签说明。例如，<code>git tag -a v1.0 -m &quot;Release version 1.0&quot;</code> 将创建一个名为 v1.0 的附注标签，并将其说明设置为 “Release version 1.0”。</p>
<p>标签可以使用 <code>git push</code> 命令推送到远程存储库中，以便在其他计算机上使用。例如，要将名为 v1.0 的标签推送到远程存储库，可以使用 <code>git push origin v1.0</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag  #列出所有tag</span><br><span class="line">git tag [tag] #新建一个tag在当前commit</span><br><span class="line">git tag [tag] [commit] #新建一个tag在指定commit</span><br><span class="line">git tag -d [tag] #删除本地tag</span><br><span class="line">git push origin [tag] #推送tag到远程</span><br><span class="line">git show [tag] #查看特定tag</span><br><span class="line">git checkout -b [branch] [tag] #新建一个分支，指向某个tag</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git服务器环境搭建和客户端使用</title>
    <url>/2024/05/17/%E8%BD%AF%E4%BB%B6-Git-Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><del>服务端</del></h1><p>安装 <code>git</code> 和 <code>ssh</code></p>
<p><code>sudo apt-get install git</code></p>
<p><code>sudo apt-get install openssh-server openssh-client</code></p>
<p>增加 git 用户并生成文件夹</p>
<p><code>sudo adduser git</code></p>
<p><code>sudo mkdir /home/git</code></p>
<p>创建 ssh 证书认证文件</p>
<p><code>sudo mkdir /home/git/.ssh</code></p>
<p><code>sudo touch /home/git/.ssh/authorized_keys</code></p>
<p>临时修改 authorized_keys 文件的权限</p>
<p><code>sudo chmod 777 /home/git/.ssh/authorized_keys</code></p>
<p>把需要访问 git 服务器的<strong>客户端公钥 id_rsa.pub</strong>的内容复制到 authorized_keys 文件</p>
<p>修改 authorized_keys 文件的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 700 /home/git</span><br><span class="line">sudo chmod 700 /home/git/.ssh</span><br><span class="line">sudo chmod 600 /home/git/authorized_keys</span><br><span class="line">sudo chown -R git:git /home/git</span><br><span class="line">sudo chown -R git:git /home/git/.ssh</span><br><span class="line">sudo chown -R git:git /home/git/.ssh/authorized_keys</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>为了安全考虑禁止登录 git 服务器的 shell，修改 git 的 shell</p>
<p>用 <code>/usr/bin/git-shell</code> 把 <code>/etc/passwd</code> 的 <code>git:x:1004:1004:,,,:/home/git:/bin/bash</code></p>
<p>改成： <code>git:x:1004:1004:,,,:/home/git:/usr/bin/git-shell</code> 保存</p>
<p>建代码仓库</p>
<p><code>sudo mkdir /home/Repo #创建仓库的目录</code></p>
<p><code>sudo git init --bare /home/Repo/test.git #创建仓库</code></p>
<p><code>sudo chown -R git:git /home/Repo/test.git #修改权限为git</code></p>
<blockquote>
<p>以后每创建一个新的仓库，记得最后一步操作: 修改仓库所属用户为 git。</p>
</blockquote>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>安装 <code>git</code></p>
<p><code>Linux</code> 环境下 <code>sudo apt-get install git</code></p>
<p>Windows 环境下直接安装 <a href="https://git-scm.com/downloads">Git安装包</a></p>
<p>配置连接</p>
<p>通过密钥方式 <code>ssh-keygen -t rsa [-C &quot;你的邮箱地址&quot;]</code> 会生成 <code>id_rsa.pub</code> 文件</p>
<p>添加该公钥到到服务器</p>
<p>Linux 环境下，密钥默认位于 <code>/home/ubuntu/.ssh/id\_rsa</code></p>
<p>Windows 环境下密钥位于 <code>C:\Users\xxx.ssh\id\_rsa.pub</code></p>
<p>通过用户名&#x2F;密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config –global user.name “username”</span><br><span class="line">git config –global user.email “username@gmail.com”</span><br></pre></td></tr></table></figure>

<p>在连接 git 时，会需要输入账号密码，直接输入即可</p>
<h1 id="附注：增量备份-Git-服务器备份"><a href="#附注：增量备份-Git-服务器备份" class="headerlink" title="附注：增量备份 -Git 服务器备份"></a>附注：增量备份 -Git 服务器备份</h1><p><strong>使用 crontab 建立每天凌晨 3 点定时触发的任务</strong><code>crontab -e </code></p>
<p><code>0 3 * * * * rsync -av -e &quot;ssh -i /path/to/id_rsa&quot; /homt/git/ remote_user@X.X.X.X:~/backup</code></p>
]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>版本控制方案</title>
    <url>/2024/05/17/%E8%BD%AF%E4%BB%B6-Git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="Git-方案"><a href="#Git-方案" class="headerlink" title="Git 方案"></a>Git 方案</h1><p>1.      仓库创建</p>
<p>仓库创建基于当前的项目，例如备份仪表项目仓库，LSA 项目等</p>
<p>2.      分支创建</p>
<p>项目主分支保存项目代码及文档，负责发布代码</p>
<p>项目开发分支保存项目源码，分支仅管理员可见</p>
<p>项目运行分支保存项目头文件及库文件代码，分支所有人可见</p>
<p>项目人员开发分支基于运行分支创建，仅该人员有权限，该人员开发任务基于该分支进行修改代码</p>
<p>3.      代码提交</p>
<p>各人员代码仅提交在单独分支，提交完成后，由管理员审核后，同步源代码至开发分支</p>
<p>4.      版本回退</p>
<h1 id="SVN-方案"><a href="#SVN-方案" class="headerlink" title="SVN 方案"></a>SVN 方案</h1>]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx学习笔记</title>
    <url>/2024/05/16/%E8%BD%AF%E4%BB%B6-Nginx-Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>功能：</p>
<ul>
<li>Web 服务器</li>
<li>负载均衡</li>
<li>API 网关</li>
<li>DDoS 防御</li>
<li>反向代理</li>
<li>Web 应用防火墙</li>
<li>缓存</li>
</ul>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><code>sudo apt install nginx -y</code></p>
<h1 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h1><p>nginx 的配置文件位于 <code>/etc/nginx/</code></p>
<p>根据配置文件中的 <code>root</code> 确定根目录位置 <code>/var/www/html</code></p>
<p>链接网页根目录到指定位置</p>
<p><code>ln -s /var/www/html ~/html</code></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>cd /etc/nginx/sites-enable</code></p>
<p>原来的配置为 default（链接到 sites-avaliable），删除并添加自己的页面</p>
<p>输入下列内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen    8080 default_server;# 注意这里，要把默认的那个default_server去掉,因为我们在下面要单独配置域名访问，所以这里不要留default_server，不然会报错。</span><br><span class="line">  #server_name mytest.com; //这里写你想设置的域名，可以写多个，与名之间用空格隔开</span><br><span class="line">  root     /home/ubuntu/html;#  //这里是你虚拟机的根目录，写绝对路径</span><br><span class="line">  # Load configuration files for the default server block.</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    index index.php index.html index.htm;# //这里配置默认访问的页面</span><br><span class="line">  &#125;</span><br><span class="line">  #location ~* \.php$ &#123;  //这里配置php解析.php文件</span><br><span class="line"></span><br><span class="line">  #  fastcgi_index  index.php;</span><br><span class="line">  #  fastcgi_pass  127.0.0.1:9000;</span><br><span class="line">  #  include     fastcgi_params;</span><br><span class="line">  #  fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">  #  fastcgi_param  SCRIPT_NAME    $fastcgi_script_name;</span><br><span class="line">  #&#125;</span><br><span class="line">  #error_page 404 /404.html;  //默认的错误页面</span><br><span class="line">  #  location = /40x.html &#123;</span><br><span class="line">  #&#125;</span><br><span class="line">  #error_page 500 502 503 504 /50x.html;</span><br><span class="line">  #  location = /50x.html &#123;</span><br><span class="line">  #&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入 <code>nginx -t</code> 检查配置文件</p>
<p>之后重新启动 <code>nginx</code> 并访问</p>
<p><code>sudo systemctl start nginx</code></p>
<p><code>sudo systemctl enable nginx</code></p>
<p>直接输入 IP 地址即可访问，根据设置的端口进行访问</p>
<h1 id="修改页面，重载页面"><a href="#修改页面，重载页面" class="headerlink" title="修改页面，重载页面"></a>修改页面，重载页面</h1><p><code>sudo nginx -s reload</code></p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>查看 nginx 版本</p>
<p><code>nginx -v</code></p>
<p>配置文件所在位置 <code>/etc/nginx</code>，文件名 <code>nginx.conf</code></p>
<p>检查配置文件是否有问题</p>
<p><code>nginx -t</code></p>
<p>重新加载 nginx 配置文件</p>
<p><code>nginx -s reload</code></p>
<p>关闭 nginx</p>
<p><code>nginx -s quit</code> 或 <code>nginx -s stop</code></p>
<p><strong>events</strong><br><strong>http</strong><br><strong>server</strong><br><strong>include</strong><br><strong>listen</strong><br><strong>server_name</strong><br><strong>root</strong> 根目录节点<br><strong>index</strong> 指定页面<br><strong>return</strong><br><strong>location</strong> &#x3D;(完全匹配)  ~(启用正则表达式)<br><strong>rewrite</strong>  重写<br><strong>proxy_pass</strong></p>
<h1 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h1><p>是一个功能强大的命令行传输工具，用于发送请求和下载文件。它支持多种协议，如 HTTP、HTTPS、FTP 等，可以设置请求头、请求参数等</p>
<p>-i 参数</p>
<p>打印出服务器回应的 HTTP 标头</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>vim安装</title>
    <url>/2024/05/22/%E8%BD%AF%E4%BB%B6-VIM-vim%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>配置文件 <a href="source/_posts/%E8%BD%AF%E4%BB%B6/VIM/vimrc.cfg">地址</a></p>
<ol>
<li>安装环境</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install git cscope</span><br><span class="line">wget -qO - https://raw.github.com/ma6174/vim/master/setup.sh | sh -x</span><br></pre></td></tr></table></figure>

<blockquote>
<p>wget 是一个用于从网络下载文件的命令行工具。<br>-q 表示静默模式，不显示下载进度和其他信息。<br>-O - 指定输出到标准输出（stdout），而不是保存到文件。这样下载的文件内容就会直接输出到终端。<br><a href="https://raw.github.com/ma6174/vim/master/setup.sh">https://raw.github.com/ma6174/vim/master/setup.sh</a> 是要下载的文件的 URL 地址。<br>| 是管道符号，用于将前一个命令的输出作为后一个命令的输入。<br>sh 是一个用于执行 Shell 脚本的命令。<br>-x 表示在执行脚本时显示详细的调试信息。</p>
</blockquote>
<p><strong>setup.sh 内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;安装将花费一定时间，请耐心等待直到安装完成~~&quot;</span><br><span class="line">if which apt-get &gt;/dev/null; then</span><br><span class="line">	sudo apt-get install -y vim vim-gnome ctags xclip astyle python-setuptools python-dev git</span><br><span class="line">elif which yum &gt;/dev/null; then</span><br><span class="line">	sudo yum install -y gcc vim git ctags xclip astyle python-setuptools python-devel</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">##Add HomeBrew support on Mac OS</span><br><span class="line">if which brew &gt;/dev/null;then</span><br><span class="line">	echo &quot;You are using HomeBrew tool&quot;</span><br><span class="line">	brew install vim ctags git astyle</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">sudo easy_install -ZU autopep8</span><br><span class="line">sudo ln -s /usr/bin/ctags /usr/local/bin/ctags</span><br><span class="line">mv -f ~/vim ~/vim old</span><br><span class="line">cd ~/ &amp;&amp; git clone https://github.com/ma6174/vim.git</span><br><span class="line">mv -f ~/.vim ~/.vim_old </span><br><span class="line">mv -f ~/vim ~/.vim</span><br><span class="line">mv -f ~/.vimrc ~/.vimrc_old</span><br><span class="line">mv -f ~/.vim/.vimrc ~/  </span><br><span class="line"></span><br><span class="line">git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle</span><br><span class="line">echo &quot;ma6174正在努力为您安装bundle程序&quot; &gt; ma6174</span><br><span class="line">echo &quot;安装完毕将自动退出&quot; &gt;&gt; ma6174</span><br><span class="line">echo &quot;请耐心等待&quot; &gt;&gt; ma6174</span><br><span class="line">vim ma6174 -c &quot;BundleInstall&quot; -c &quot;q&quot; -c &quot;q&quot;</span><br><span class="line">rm ma6174</span><br><span class="line">echo &quot;安装完成&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/include</span><br><span class="line">sudo ctags -R</span><br><span class="line">cd -</span><br><span class="line">vim .vimrc</span><br></pre></td></tr></table></figure>

<p>修改最后一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set tags=/usr/include/tags</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装 zsh<br>Zsh 是一种替代默认的命令行 Shell（如 Bash）的 Shell。<br>Zsh（Z Shell）是一种强大的命令行 Shell，它具有许多增强的功能和可定制选项。相较于传统的 Bash Shell，Zsh 提供了更好的自动补全、历史记录管理、拼写修正、主题定制等功能。它还支持丰富的插件和扩展，可以根据用户的需求进行定制和配置。</li>
</ol>
<p>接下来，<code>chsh -s /bin/zsh</code> 是一个用于更改当前用户的默认 Shell 的命令。chsh 是 “change shell” 的缩写，-s 选项指定要更改为的新 Shell，<code>/bin/zsh</code> 是指要更改为 Zsh 的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
        <category>VIM</category>
      </categories>
  </entry>
  <entry>
    <title>WireShark的安装</title>
    <url>/2024/05/22/%E8%BD%AF%E4%BB%B6-WireShark-WireShark%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h1><p>重点演示：</p>
<ol>
<li>如何选择网卡接口</li>
<li>如何设置过滤条件</li>
<li>如何查看抓取的报文</li>
</ol>
<h1 id="Linux-下安装和配置"><a href="#Linux-下安装和配置" class="headerlink" title="Linux 下安装和配置"></a>Linux 下安装和配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wireshark</span><br></pre></td></tr></table></figure>

<h2 id="设置运行权限"><a href="#设置运行权限" class="headerlink" title="设置运行权限"></a>设置运行权限</h2><p>如果您在此阶段以非 root 用户身份运行 wireshark，您将收到消息“没有接口可以用于在当前配置的系统中进行捕获。”</p>
<blockquote>
<p>缺省在非 root 账号下运行会发现看不见 interface 信息</p>
</blockquote>
<ol>
<li>Create the wiresharkgroup.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo groupadd wireshark</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Add your username to the wiresharkgroup</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G wiresharkYOUR_USER_NAME</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Change the group ownership of file dumpcap to wireshark</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chgrp wireshark/usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Change the mode of the file dumpcap to allow execution bythe group wireshark</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 750 /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Grant capabilities with setcap, man capabilities(7), setcap(8), cap_from_text(3) for more info about what are “cap_net_raw”, “cap_net_admin” and “eip”. Anyway, after we grant the capabilities, the dump can perform various network-related operations, use RAW and PACKET sockets; bind to anyaddressfor transparent proxying.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo setcap cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Verifythe change</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo getcap /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<p>Outputshould be like below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/dumpcap = cap_net_admin,cap_net_raw+eip</span><br></pre></td></tr></table></figure>

<p>At this point, you will need to log out, then backinto ubuntu</p>
<p>简单介绍下这个软件的一些常用按钮，简单的说下最常用的按钮，打开软件后，下面红框中的按钮从左到右依次是：</p>
<p>-1 列表显示所有网卡的网络包情况，一般用的很少；</p>
<p><strong>-2 显示抓包选项，一般都是点这个按钮开始抓包；</strong></p>
<p>-3 开始新的抓包，一般用的也很少；</p>
<p><strong>-4 停止抓包，当你抓完包之后，就是点这个停止了；</strong></p>
<p><strong>-5 清空当前已经抓到的数据包，可以防止抓包时间过长机器变卡；</strong></p>
<p>而实际上，一般我们只要知道上面加粗部分的按钮功能，就可以完成抓包了，剩下的就是如何抓你想要的数据包，如何分析的问题了。</p>
<p>接下来说下抓包选项界面，也就是点第二个按钮出来的界面，同样，这里也只介绍最常用的几个功能，首先下图中最上面的红框是选择需要抓的网卡，选择好网卡后会在下面显示这个网卡的 IP 地址。</p>
<p>然后 Capture Filter 中就是要写抓包规则的地方，也叫做“过滤规则”，我们下面要说的很多规则都是要写到这个框里的，规则写好后，点下</p>
<p>面的 Start 就开始抓包了。</p>
<p>当抓包结束之后，如果你需要把抓到的数据包找其他人分析，那么可以点菜单上的 file，然后点 Save As 保存抓到的数据包</p>
<p>使用 Wireshark 时最常见的问题，是当您使用默认设置时，会得到大量冗余信息，以至于很难找到自己需要的部分。这就是为什么过滤器会</p>
<p>如此重要。它们可以帮助我们在庞杂的结果中迅速找到我们需要的信息。</p>
<h1 id="三次握手-Three-way-Handshake"><a href="#三次握手-Three-way-Handshake" class="headerlink" title="三次握手 Three-way Handshake"></a>三次握手 Three-way Handshake</h1><p>一个虚拟连接的建立是通过三次握手来实现的</p>
<ol>
<li><p>(Client) –&gt; [SYN] –&gt; (Server)<br>假如 Client 和 Server 通讯. 当 Client 要和 Server 通信时，Client 首先向 Server 发一个 SYN (Synchronize) 标记的包，告诉 Server 请求建立连接.<br>注意: 一个 SYN 包就是仅 SYN 标记设为 1 的 TCP 包 (参见 TCP 包头 Resources). 认识到这点很重要，只有当 Server 收到 Client 发来的 SYN 包，才可建立连接，除此之外别无他法。因此，如果你的防火墙丢弃所有的发往外网接口的 SYN 包，那么你将不 能让外部任何主机主动建立连接。</p>
</li>
<li><p>(Client) &lt;– [SYN&#x2F;ACK] &lt;–(Server)<br>接着，Server 收到来自 Client 发来的 SYN 包后，会发一个对 SYN 包的确认包 (SYN&#x2F;ACK) 给 Client，表示对第一个 SYN 包的确认，并继续握手操作.<br>注意: SYN&#x2F;ACK 包是仅 SYN 和 ACK 标记为 1 的包.</p>
</li>
<li><p>(Client) –&gt; [ACK] –&gt; (Server)<br>Client 收到来自 Server 的 SYN&#x2F;ACK 包,Client 会再向 Server 发一个确认包 (ACK)，通知 Server 连接已建立。至此，三次握手完成，一个 TCP 连接完成。<br>Note: ACK 包就是仅 ACK 标记设为 1 的 TCP 包. 需要注意的是当三此握手完成、连接建立以后，TCP 连接的每个包都会设置 ACK 位。</p>
</li>
</ol>
<p>这就是为何连接跟踪很重要的原因了. 没有连接跟踪,防火墙将无法判断收到的 ACK 包是否属于一个已经建立的连接.一般的包过滤 (Ipchains) 收到 ACK 包时,会让它通过 (这绝对不是个 好主意). 而当状态型防火墙收到此种包时，它会先在连接表中查找是否属于哪个已建连接，否则丢弃该包。</p>
<h1 id="四次握手-Four-way-Handshake-四次握手用来关闭已建立的-TCP-连接"><a href="#四次握手-Four-way-Handshake-四次握手用来关闭已建立的-TCP-连接" class="headerlink" title="四次握手 Four-way Handshake 四次握手用来关闭已建立的 TCP 连接"></a>四次握手 Four-way Handshake 四次握手用来关闭已建立的 TCP 连接</h1><ol>
<li>(Client) –&gt; ACK&#x2F;FIN –&gt; (Server)</li>
<li>(Client) &lt;– ACK &lt;– (Server)</li>
<li>(Client) &lt;– ACK&#x2F;FIN &lt;– (Server)</li>
<li>(Client) –&gt; ACK –&gt; (Server)<br>注意: 由于 TCP 连接是双向连接, 因此关闭连接需要在两个方向上做。**ACK&#x2F;FIN 包 (ACK 和 FIN 标记设为 1) 通常被认为是 FIN(终结) 包.**然而, 由于连接还没有关闭, FIN 包总是打上 ACK 标记. 没有 ACK 标记而仅有 FIN 标记的包不是合法的包，并且通常被认为是恶意的。</li>
</ol>
<h1 id="连接复位-Resetting-a-connection"><a href="#连接复位-Resetting-a-connection" class="headerlink" title="连接复位 Resetting a connection"></a>连接复位 Resetting a connection</h1><p>四次握手不是关闭 TCP 连接的唯一方法. 有时,如果主机需要尽快关闭连接 (或连接超时,端口或主机不可达),RST(Reset) 包将被发送. 注意在，由于 RST 包不是 TCP 连接中的必须部分, 可以只发送 RST 包 (即不带 ACK 标记). 但在正常的 TCP 连接中 RST 包可以带 ACK 确认标记</p>
<p>请注意 RST 包是可以不要收到方确认的?</p>
<p>无效的 TCP 标记 Invalid TCP Flags</p>
<p>到目前为止，你已经看到了 SYN, ACK, FIN, 和 RST 标记. 另外，还有 PSH (Push) 和 URG (Urgent) 标记.</p>
<p>最常见的非法组合是 SYN&#x2F;FIN 包. 注意: 由于 SYN 包是用来初始化连接的, 它不可能和 FIN 和 RST 标记一起出现. 这也是一个恶意攻击.</p>
<p>由于现在大多数防火墙已知 SYN&#x2F;FIN 包, 别的一些组合,例如 SYN&#x2F;FIN&#x2F;PSH, SYN&#x2F;FIN&#x2F;RST, SYN&#x2F;FIN&#x2F;RST&#x2F;PSH。很明显，当网络中出现这种包时，很你的网络肯定受到攻击了。</p>
<p>别的已知的非法包有 FIN (无 ACK 标记) 和”NULL”包。如同早先讨论的，由于 ACK&#x2F;FIN 包的出现是为了关闭一个 TCP 连接，那么正常的 FIN 包总是带有 ACK 标记。”NULL”包就是没有任何 TCP 标记的包 (URG,ACK,PSH,RST,SYN,FIN 都为 0)。</p>
<p>到目前为止，正常的网络活动下，TCP 协议栈不可能产生带有上面提到的任何一种标记组合的 TCP 包。当你发现这些不正常的包时，肯定有人对你的网络不怀好意。</p>
<h1 id="UDP-用户数据包协议-User-DatagramProtocol"><a href="#UDP-用户数据包协议-User-DatagramProtocol" class="headerlink" title="UDP (用户数据包协议 User DatagramProtocol)"></a>UDP (用户数据包协议 User DatagramProtocol)</h1><p>TCP 是面向连接的，而 UDP 是非连接的协议。UDP 没有对接受进行确认的标记和确认机制。对丢包的处理是在应用层来完成的。(or accidentalarrival).此处需要重点注意的事情是：在正常情况下，当 UDP 包到达一个关闭的端口时，会返回一个 UDP 复位包。由于 UDP 是非面向连接的, 因此没有任何确认信息来确认包是否正确到达目的地。因此如果你的防火墙丢弃 UDP 包，它会开放所有的 UDP 端口 (?)。</p>
<p>由于 Internet 上正常情况下一些包将被丢弃，甚至某些发往已关闭端口 (非防火墙的) 的 UDP 包将不会到达目的，它们将返回一个复位 UDP 包。</p>
<p>因为这个原因，UDP 端口扫描总是不精确、不可靠的。</p>
<p>看起来大 UDP 包的碎片是常见的 DOS(Denial ofService) 攻击的常见形式 (这里有个 DOS 攻击的例子，<a href="http://grc.com/dos/grcdos.htm">http://grc.com/dos/grcdos.htm</a> ).</p>
<h1 id="ICMP-网间控制消息协议-Internet-ControlMessage-Protocol"><a href="#ICMP-网间控制消息协议-Internet-ControlMessage-Protocol" class="headerlink" title="ICMP (网间控制消息协议 Internet ControlMessage Protocol)"></a>ICMP (网间控制消息协议 Internet ControlMessage Protocol)</h1><p>如同名字一样， ICMP 用来在主机&#x2F;路由器之间传递控制信息的协议。 ICMP 包可以包含诊断信息 (ping, traceroute - 注意目前 unix 系统中的 traceroute 用 UDP 包而不是 ICMP)，错误信息 (网络&#x2F;主机&#x2F;端口 不可达 network&#x2F;host&#x2F;port unreachable), 信息 (时间戳 timestamp, 地址掩码 addressmaskrequest, etc.)，或控制信息 (source quench, redirect, etc.) 。</p>
<p>你可以在 <a href="http://www.iana.org/assignments/icmp-parameters">http://www.iana.org/assignments/icmp-parameters</a> 中找到 ICMP 包的类型。</p>
<p>尽管 ICMP 通常是无害的，还是有些类型的 ICMP 信息需要丢弃。</p>
<p>Redirect (5), Alternate Host Address(6), Router Advertisement (9) 能用来转发通讯。</p>
<p>Echo (8), Timestamp (13)and AddressMask Request (17) 能用来分别判断主机是否起来，本地时间 和地址掩码。注意它们是和返回的信息类别有关的。 它们自己本身是不能被利用的，但它们泄露出的信息对攻击者是有用的。</p>
<p>ICMP 消息有时也被用来作为 DOS 攻击的一部分 (例如：洪水 ping flood ping,死 ping ?呵呵，有趣 ping of death)?&#x2F;p&gt;</p>
<p>包碎片注意 A Note About Packet Fragmentation</p>
<p>如果一个包的大小超过了 TCP 的最大段长度 MSS(Maximum Segment Size) 或 MTU (Maximum Transmission Unit)，能够把此包发往目的的唯一</p>
<p>方法是把此包分片。由于包分片是正常的，它可以被利用来做恶意的攻击。</p>
<p>因为分片的包的第一个分片包含一个包头，若没有包分片的重组功能，包过滤器不可能检测附加的包分片。典型的攻击 Typicalattacks involve in overlapping the packet data in which packet header is 典型的攻击 Typicalattacksinvolve in overlapping the packet data in which packet header isnormal until isit overwritten with different destination IP (or port) thereby bypassing firewall rules。包分片能作为 DOS 攻击的一部分，它 可以 crash older IP stacks 或涨死 CPU 连接能力。</p>
<p>Netfilter&#x2F;Iptables 中的连接跟踪代码能自动做分片重组。它仍有弱点，可能受到饱和连接攻击，可以把 CPU 资源耗光。</p>
<p>OK，到此为止，关于 Wireshark 抓包工具的一些小教程已经写完了，而导致我想写这么一个纠结的教程的原因是，前几天通过这个抓包解决了梦幻西游在网维大师无盘上容易掉线的问题，当时捕捉到梦幻西游掉线时的数据包是这样的。</p>
<p>注意下图中的红色数据，123.58.184.241 是梦幻西游的服务器，而 192.168.1.41 是玩梦幻西游的客户机，在掉线时，发现是先有梦幻西游的服务器向客户机发送一个 [FIN,ACK] 数据包，根据上面的解释，FIN 标记的数据包是代表要断开连接的意思，而接着客户机又回给服务器一个确认断 开链接包。当看到这个抓包数据时，就意识到，大家说的在网维大师系统虚拟盘上梦幻爱掉线的问题，并非普通的网络问题，因为通过数据包的信息来看，是梦幻服 务器主动要求断开链接，产生这个情况无非是以下几个原因：</p>
<ol>
<li><p>服务器发现客户端非法，比如有外挂什么的，踢掉了客户机；</p>
</li>
<li><p>服务器压力大，踢掉了客户机；</p>
</li>
<li><p>总之不是客户端问题导致的掉线；</p>
</li>
</ol>
<p>那么既然结论是如此，为什么会有在网维大师系统虚拟盘上容易出现梦幻掉线问题呢？原因是由于网维大师系统虚拟盘是模拟真实硬盘方式来实现的，而在模拟过程 中，将硬盘的序列号设置为固定过的 OSDIY888 了，而梦幻西游刚好后识别客户机硬盘信息，发现大量客户端的硬盘序列号都是一样的，就认为是作弊或者使 用挂机外挂了，结果就导致随机被服务器踢下线的情况发生，后来我们将硬盘序列号设置为空，则没再出现该问题。这个问题在未来的新版本中会解决掉。</p>
<p>说这个案例的目的并不是为了说明抓包多有用，而是想说明一些解决问题的思路和方法，有些人是有思路，但是缺方法，比如不会用工具，而有些人收集了很多工具 却不会用，而我其实就属于后者，几年前就收集了 n 多工具，但是用到的没几个。慢慢的学会用这些工具后，发现思维 + 工具，解决问题是效率暴增，接下来的几天 里，会陆续介绍写小工具给大家，也希望大家有空学习下，有问题先百度，再自己摸索，而不是一味的求助，毕竟求人不如求己！自己能直接搞定，是皆大欢喜的事情</p>
<blockquote>
<p>注意：由于某些系统为了防止 ARP 攻击，都免疫掉了一个 Npptools.dll 文件，这会导致该软件无法正常安装，打下这个补丁就可以了</p>
</blockquote>
]]></content>
      <categories>
        <category>软件</category>
        <category>WireShark</category>
      </categories>
  </entry>
  <entry>
    <title>WireShark过滤器</title>
    <url>/2024/05/22/%E8%BD%AF%E4%BB%B6-WireShark-WireShark%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="什么是-wireshark"><a href="#什么是-wireshark" class="headerlink" title="什么是 wireshark"></a>什么是 wireshark</h1><p>Wireshark 是一款开源的网络封包分析软件。它可以捕获、分析和展示计算机网络中的数据包。Wireshark 支持多种网络协议，包括以太网、无线网络、Internet 协议（IP）、传输控制协议（TCP）、用户数据报协议（UDP）等等。</p>
<p>使用 Wireshark，您可以通过连接到计算机网络上的一个接口来捕获网络数据包。捕获的数据包将被 Wireshark 以可视化的方式显示出来，您可以查看每个数据包的详细信息，例如源 IP 地址、目标 IP 地址、协议类型、数据长度等等。</p>
<p>Wireshark 提供了强大的过滤功能，使您能够根据特定的条件过滤数据包，以便更好地分析网络流量。它还提供了许多分析工具和统计功能，如流量图表、协议分层显示、数据包重组等，帮助用户深入了解网络通信并发现潜在的问题。</p>
<p>Wireshark 是一个广泛应用于网络管理、网络安全和网络协议开发的工具。它能够帮助网络管理员诊断和解决网络故障，分析网络性能问题，检测网络安全事件，以及进行协议开发和调试等任务。由于其功能强大且易于使用，Wireshark 成为了网络分析领域的标准工具之一。</p>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>在 Wireshark 中，过滤器（Filter）是一种机制，用于选择和筛选特定的网络数据包以供分析。过滤器允许您根据特定的条件仅显示感兴趣的数据包，从而减少分析的数据量并集中精力于关注的内容。</p>
<p>Wireshark 使用一种称为 “ 显示过滤器 “（Display Filter）的语法来定义过滤条件。您可以根据多个参数，如源&#x2F;目标 IP 地址、协议类型、端口号、数据包长度、特定字段的值等等，创建过滤器规则。当过滤器应用于数据包捕获或已保存的数据包时，只有符合过滤条件的数据包会被显示，而其他数据包将被隐藏。</p>
<p>通过使用过滤器，您可以根据您的需求来选择显示的数据包，使得分析更加高效和专注。例如，您可以创建一个过滤器来只显示特定源 IP 地址的数据包，或者只显示某个协议类型的数据包，以便更好地关注您感兴趣的通信流量。</p>
<p>Wireshark 提供了广泛的过滤器语法和功能，使您能够根据不同的需求创建复杂的过滤条件。您可以使用比较运算符、逻辑运算符、通配符等来构建更精确的过滤规则，并根据需要组合多个条件来定义更复杂的过滤器。</p>
<p>过滤器在网络分析和故障排除中非常有用，可以帮助您集中注意力于感兴趣的数据包，提供更清晰和有针对性的分析。</p>
<h1 id="过滤器的区别"><a href="#过滤器的区别" class="headerlink" title="过滤器的区别"></a>过滤器的区别</h1><p>捕捉过滤器（CaptureFilters）：用于决定将什么样的信息记录在捕捉结果中。需要在开始捕捉前设置。</p>
<p>显示过滤器（DisplayFilters）：在捕捉结果中进行详细查找。他们可以在得到捕捉结果后随意修改。</p>
<p>两种过滤器的目的是不同的。</p>
<p>捕捉过滤器是数据经过的第一层过滤器，它用于控制捕捉数据的数量，以避免产生过大的日志文件。</p>
<p>显示过滤器是一种更为强大（复杂）的过滤器。它允许您在日志文件中迅速准确地找到所需要的记录。</p>
<p>两种过滤器使用的语法是完全不同的。</p>
<h2 id="捕捉过滤器"><a href="#捕捉过滤器" class="headerlink" title="捕捉过滤器"></a>捕捉过滤器</h2><p>Protocol（协议）:</p>
<p>可能的值: ether, fddi, ip, arp, rarp, decnet, lat, sca, moprc, mopdl, tcp and udp.</p>
<p>如果没有特别指明是什么协议，则默认使用所有支持的协议。</p>
<p>Direction（方向）:</p>
<p>可能的值: src, dst, src and dst, src or dst</p>
<p>如果没有特别指明来源或目的地，则默认使用 “src or dst” 作为关键字。</p>
<p>例如，”host 10.2.2.2″与”src or dst host 10.2.2.2″是一样的。</p>
<p>Host(s):</p>
<p>可能的值： net, port, host, portrange.</p>
<p>如果没有指定此值，则默认使用”host”关键字。</p>
<p>例如，”src 10.1.1.1″与”src host 10.1.1.1″相同。</p>
<p>Logical Operations（逻辑运算）:</p>
<p>可能的值：not, and, or.</p>
<p>否 (“not”) 具有最高的优先级。或 (“or”) 和与 (“and”) 具有相同的优先级，运算时从左至右进行。</p>
<p>例如，</p>
<p>“not tcp port 3128 and tcp port 23″与”(not tcp port 3128) and tcp port 23″相同。</p>
<p>“not tcp port 3128 and tcp port 23″与”not (tcp port 3128 and tcp port 23)”不同。</p>
<p>例子：</p>
<p>tcp dst port 3128  	&#x2F;&#x2F;捕捉目的 TCP 端口为 3128 的封包。</p>
<p>ip src host 10.1.1.1  &#x2F;&#x2F;捕捉来源 IP 地址为 10.1.1.1 的封包。</p>
<p>host 10.1.2.3  &#x2F;&#x2F;捕捉目的或来源 IP 地址为 10.1.2.3 的封包。</p>
<p>ether host e0-05-c5-44-b1-3c &#x2F;&#x2F;捕捉目的或来源 MAC 地址为 e0-05-c5-44-b1-3c 的封包。如果你想抓本机与所有外网通讯的数据包时，可以将这里的 mac 地址换成路由的 mac 地址即可。</p>
<p>src portrange 2000-2500  &#x2F;&#x2F;捕捉来源为 UDP 或 TCP，并且端口号在 2000 至 2500 范围内的封包。</p>
<p>not imcp  &#x2F;&#x2F;显示除了 icmp 以外的所有封包。（icmp 通常被 ping 工具使用）</p>
<p>src host 10.7.2.12 and not dst net 10.200.0.0&#x2F;16 &#x2F;&#x2F;显示来源 IP 地址为 10.7.2.12，但目的地不是 10.200.0.0&#x2F;16 的封包。</p>
<p>(src host 10.4.1.12 or src net 10.6.0.0&#x2F;16) and tcp dst portrange 200-10000 and dst net 10.0.0.0&#x2F;8  &#x2F;&#x2F;捕捉来源 IP 为 10.4.1.12 或者来源网络为 10.6.0.0&#x2F;16，目的地 TCP 端口号在 200 至 10000 之间，并且目的位于网络 10.0.0.0&#x2F;8 内的所有封包。</p>
<p>src net 192.168.0.0&#x2F;24 </p>
<p>src net 192.168.0.0 mask 255.255.255.0  &#x2F;&#x2F;捕捉源地址为 192.168.0.0 网络内的所有封包。</p>
<p>注意事项：</p>
<ol>
<li><p>当使用关键字作为值时，需使用反斜杠“\”。<br>“ether proto \ip” (与关键字”ip”相同).  Ether proto 0x0800<br>这样写将会以 IP 协议作为目标。</p>
</li>
<li><p>“ip proto \icmp” (与关键字”icmp”相同).<br>这样写将会以 ping 工具常用的 icmp 作为目标。</p>
</li>
<li><p>可以在”ip”或”ether”后面使用”multicast”及”broadcast”关键字。<br>当您想排除广播请求时，”no broadcast”就会非常有用。</p>
</li>
<li><p>Protocol（协议）:<br>您可以使用大量位于 OSI 模型第 2 至 7 层的协议。点击”Expression…”按钮后，您可以看到它们。<br>比如：IP，TCP，DNS，SSH</p>
</li>
<li><p>String1, String2 (可选项):</p>
</li>
<li><p>协议的子类。<br>点击相关父类旁的”+”号，然后选择其子类。</p>
</li>
</ol>
<h2 id="显示过滤器"><a href="#显示过滤器" class="headerlink" title="显示过滤器"></a>显示过滤器</h2><p>例子：</p>
<p>snmp || dns || icmp &#x2F;&#x2F;显示 SNMP 或 DNS 或 ICMP 封包。 </p>
<p>ip.addr &#x3D;&#x3D; 10.1.1.1  &#x2F;&#x2F;显示来源或目的 IP 地址为 10.1.1.1 的封包。</p>
<p>ip.src !&#x3D; 10.1.2.3 or ip.dst !&#x3D; 10.4.5.6  &#x2F;&#x2F;显示来源不为 10.1.2.3 或者目的不为 10.4.5.6 的封包。</p>
<p>换句话说，显示的封包将会为：</p>
<p>来源 IP：除了 10.1.2.3 以外任意；目的 IP：任意</p>
<p>以及</p>
<p>来源 IP：任意；目的 IP：除了 10.4.5.6 以外任意</p>
<p>ip.src !&#x3D; 10.1.2.3 and ip.dst !&#x3D; 10.4.5.6  &#x2F;&#x2F;显示来源不为 10.1.2.3 并且目的 IP 不为 10.4.5.6 的封包。</p>
<p>换句话说，显示的封包将会为：</p>
<p>来源 IP：除了 10.1.2.3 以外任意；同时须满足，目的 IP：除了 10.4.5.6 以外任意</p>
<p>tcp.port &#x3D;&#x3D; 25  &#x2F;&#x2F;显示来源或目的 TCP 端口号为 25 的封包。 </p>
<p>tcp.dstport &#x3D;&#x3D; 25  &#x2F;&#x2F;显示目的 TCP 端口号为 25 的封包。 </p>
<p>tcp.flags  &#x2F;&#x2F;显示包含 TCP 标志的封包。 </p>
<p>tcp.flags.syn &#x3D;&#x3D; 0×02  &#x2F;&#x2F;显示包含 TCP SYN 标志的封包。 </p>
<p>如果过滤器的语法是正确的，表达式的背景呈绿色。如果呈红色，说明表达式有误。</p>
<p>更为详细的说明请见：<a href="http://openmaniak.com/cn/wireshark_filters.php">http://openmaniak.com/cn/wireshark_filters.php</a></p>
<p>以上只是抓包和简单的过滤，那么其实如果你要想达到能够分析这些网络包的要求时，还需要了解下一些数据包的标记，比如我们常说的 TCP 三次握手是怎么回事？</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>WireShark</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--help] [--version] fileName </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>把档案串连接后传到基本输出（萤幕或加 &gt; fileName 到另一个档案） </p>
<p>参数： </p>
<ul>
<li>-n 或 –number 由 1 开始对所有输出的行数编号 </li>
<li>-b 或 –number-nonblank 和 -n 相似,只不过对于空白行不编号 </li>
<li>-s 或 –squeeze-blank 当遇到有连续两行以上的空白行,就代换为一行的空白行 </li>
<li>-v 或 –show-nonprinting</li>
</ul>
<p><strong>范例</strong>： </p>
<p><code>cat -n textfile1 &gt; textfile2 </code> 把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里 </p>
<p><code>cat -b textfile1 textfile2 &gt;&gt; textfile3 </code> 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 </p>
<h1 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd [dirName]</span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>变换工作目录至 dirName。 其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略,则变换至使用者的 home directory (也就是刚 login 时所在的目录).</p>
<p>另外,”~” 也表示为 home directory 的意思,”.” 则是表示目前所在的目录,”..” 则表示目前目录位置的上一层目录。 </p>
<p><strong>范例</strong>:<br>跳到 &#x2F;usr&#x2F;bin&#x2F;:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/bin </span><br></pre></td></tr></table></figure>

<p>跳到自己的 home directory:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~ </span><br></pre></td></tr></table></figure>

<p>跳到目前目录的上上两层:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ../.. </span><br></pre></td></tr></table></figure>

<h1 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h1><p><strong>使用方式</strong>:</p>
<p><code>chmod [-cfvR] [--help] [--version] mode file... </code></p>
<p><strong>使用说明</strong>：</p>
<p>Linux&#x2F;Unix 的档案存取权限分为三级: 档案拥有者,群组,其他。利用 chmod 可以藉以控制档案如何被他人所存取。</p>
<p>mode: 权限设定字串,格式如下:[ugoa…][[+-&#x3D;][rwxX]…][,…],其中 u 表示该档案的拥有者,g 表示与该档案的拥有者属于同一个群体 (group) 者,o 表示其他以外的人,a 表示这三者皆是。 </p>
<ul>
<li>+ 表示增加权限,- 表示取消权限,&#x3D; 表示唯一设定权限。 </li>
<li>r 表示可读取,w 表示可写入,x 表示可执行,X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 </li>
<li>-c: 若该档案权限确实已经更改,才显示其更改动作 </li>
<li>-f: 若该档案权限无法被更改也不要显示错误讯息 </li>
<li>-v: 显示权限变更的详细资料 </li>
<li>-R: 对目前目录下的所有档案与子目录进行相同的权限变更 (即以递回的方式逐个变更) </li>
<li>–help: 显示辅助说明 </li>
<li>–version: 显示版本</li>
</ul>
<p><strong>范例</strong> :</p>
<p>将档案 file1.txt 设为所有人皆可读取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod ugo+r file1.txt </span><br></pre></td></tr></table></figure>

<p>将档案 file1.txt 设为所有人皆可读取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a+r file1.txt </span><br></pre></td></tr></table></figure>

<p>将档案 file1.txt 与 file2.txt 设为该档案拥有者,与其所属同一个群体者可写入,但其他以外的人则不可写入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt </span><br></pre></td></tr></table></figure>

<p>将 ex1.py 设定为只有该档案拥有者可以执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod u+x ex1.py </span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有档案与子目录皆设为任何人可读取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod -R a+r * </span><br></pre></td></tr></table></figure>

<p>此外 chmod 也可以用数字来表示权限如 <code>chmod 777 file </code></p>
<p>语法为：chmod abc file </p>
<p>其中 a,b,c 各为一个数字,分别表示 User,Group,及 Other 的权限。</p>
<p>r&#x3D;4,w&#x3D;2,x&#x3D;1 </p>
<ul>
<li>若要 rwx 属性则 4+2+1&#x3D;7； </li>
<li>若要 rw- 属性则 4+2&#x3D;6； </li>
<li>若要 r-x 属性则 4+1&#x3D;7。</li>
</ul>
<p><code>chmod a=rwx file </code> 和 <code>chmod 777 file </code> 效果相同 </p>
<p><code>chmod ug=rwx,o=x file </code> 和 <code>chmod 771 file </code> 效果相同 </p>
<p>若用 chmod 4755 filename 可使此程式具有 root 的权限 </p>
<h1 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h1><p><strong>使用方式</strong>:</p>
<p>chown [-cfhvR] [–help] [–version] user[:group] file… </p>
<p><strong>使用说明</strong>：</p>
<p>Linux&#x2F;Unix 是多人多工作业系统,所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说,这个指令只有是由系统管理者 (root) 所使用,一般使用者没有权限可以改变别人的档案拥有者,也没有权限可以自己的档案拥有者改设为别人。只有系统管理者 (root) 才有这样的权限。 </p>
<ul>
<li>user: 新的档案拥有者的使用者 </li>
<li>IDgroup: 新的档案拥有者的使用者群体 (group)</li>
<li>-c: 若该档案拥有者确实已经更改,才显示其更改动作</li>
<li>-f: 若该档案拥有者无法被更改也不要显示错误讯息</li>
<li>-h: 只对于连结 (link) 进行变更,而非该 link 真正指向的档案</li>
<li>-v: 显示拥有者变更的详细资料</li>
<li>-R: 对目前目录下的所有档案与子目录进行相同的拥有者变更 (即以递回的方式逐个变更)</li>
<li>–help: 显示辅助说明</li>
<li>–version: 显示版本</li>
</ul>
<p><strong>范例</strong>:</p>
<p>将档案 file1.txt 的拥有者设为 users 群体的使用者 jessie:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown jessie:users file1.txt </span><br></pre></td></tr></table></figure>

<p>将目前目录下的所有档案与子目录的拥有者皆设为 users 群体的使用者 lamport:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod -R lamport:users * </span><br></pre></td></tr></table></figure>

<h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp [options] source dest </span><br><span class="line">cp [options] source... directory </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>将一个档案拷贝至另一档案,或将数个档案拷贝至另一目录。</p>
<ul>
<li>-a 尽可能将档案状态,权限等资料都照原状予以复制。 </li>
<li>-r 若 source 中含有目录名,则将目录下之档案亦皆依序拷贝至目的地。 </li>
<li>-f 若目的地已经有相同档名的档案存在,则在复制前先予以删除再行复制。</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将档案 aaa 复制 (已存在),并命名为 bbb:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp aaa bbb </span><br></pre></td></tr></table></figure>

<p>将所有的 C 语言程式拷贝至 Finished 子目录中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp *.c Finished </span><br></pre></td></tr></table></figure>

<h1 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut -cnum1-num2 filename </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>显示每行从开头算起 num1 到 num2 的文字。 </p>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; cat example </span><br><span class="line">test2 </span><br><span class="line">this is test1 </span><br><span class="line">shell&gt;&gt; cut -c0-6 example # print 开头算起前 6 个字元 </span><br><span class="line">test2 </span><br><span class="line">this i </span><br></pre></td></tr></table></figure>

<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find [path] [expression]</span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>将档案系统内符合 expression 的档案列出来。你可以指要档案的名称,类别,时间,大小,权限等不同资讯的组合,只有完全相符的才会被列出来。 </p>
<p>find 根据下列规则判断 path 和 expression,在命令列上第一个 - ( ) , ! 之前的部份为 path,之后的是 expression。</p>
<p>如果 path 是空字串则使用目前路径,如果 expression 是空字串则使用 -print 为预设 expression,expression 中可使用的选项有二三十个之多,在此只介绍最常用的部份。 </p>
<ul>
<li>-mount, -xdev: 只检查和指定目录在同一个档案系统下的档案,避免列出其它档案系统中的档案 </li>
<li>-amin n: 在过去 n 分钟内被读取过 </li>
<li>-anewer file: 比档案 file 更晚被读取过的档案 </li>
<li>-atime n: 在过去 n 天过读取过的档案 </li>
<li>-cmin n: 在过去 n 分钟内被修改过 </li>
<li>-cnewer file : 比档案 file 更新的档案 </li>
<li>-ctime n: 在过去 n 天过修改过的档案 </li>
<li>-empty: 空的档案</li>
<li>-gid n or -group name:gid 是 n 或是 group 名称是 name </li>
<li>-ipath p, -path p: 路径名称符合 p 的档案,ipath 会忽略大小写 </li>
<li>-name name, -iname name: 档案名称符合 name 的档案。iname 会忽略大小写 </li>
<li>-size n: 档案大小 是 n 单位,b 代表 512 位元组的区块,c 表示字元数,k 表示 kilo bytes,w 是二个位元组。</li>
<li>-type c: 档案类型是 c 的档案。 </li>
<li><ul>
<li>d: 目录</li>
</ul>
</li>
<li><ul>
<li>c: 字型装置档案</li>
</ul>
</li>
<li><ul>
<li>b: 区块装置档案</li>
</ul>
</li>
<li><ul>
<li>p: 具名贮列</li>
</ul>
</li>
<li><ul>
<li>f: 一般档案</li>
</ul>
</li>
<li><ul>
<li>l: 符号连结</li>
</ul>
</li>
<li><ul>
<li>s: socket</li>
</ul>
</li>
<li><ul>
<li>-pid n:process id 是 n 的档案</li>
</ul>
</li>
</ul>
<p>你可以使用 ( ) 将运算式分隔,并使用下列运算。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp1 -and exp2 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! expr </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-not expr </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp1 -or exp2 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp1, exp2 </span><br></pre></td></tr></table></figure>

<p><strong>范例</strong>: </p>
<p>将目前目录及其子目录下所有延伸档名是 c 的档案列出来。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`# find . -name &quot;*.c&quot; `</span><br></pre></td></tr></table></figure>

<p>将目前目录其其下子目录中所有一般档案列出 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`# find . -ftype f `</span><br></pre></td></tr></table></figure>

<p>将目前目录及其子目录下所有最近 20 分钟内更新过的档案列出 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`# find . -ctime -20 `</span><br></pre></td></tr></table></figure>

<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less [Option] filename </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>： </p>
<p>less 的作用与 more 十分相似,都可以用来浏览文字档案的内容,不同的是 less 允许使用者往回卷动 以浏览已经看过的部份,同时因为 less 并未在一开始就读入整个档案,因此在遇上大型档案的开启时,会比一般的文书编辑器 (如 vi) 来的快速。</p>
<p><strong>范例</strong>： </p>
<h1 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln [options] source dist</span><br></pre></td></tr></table></figure>

<p>其中 option 的格式为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[-bdfinsvF] [-S backup-suffix] [-V &#123;numbered,existing,simple&#125;]  [--help] [--version] [--] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>Linux&#x2F;Unix 档案系统中,有所谓的连结 (link),我们可以将其视为档案的别名,而连结又可分为两种:</p>
<p>硬连结 (hard link) 与软连结 (symbolic link),</p>
<p>硬连结的意思是一个档案可以有多个名称,而软连结的方式则是产生一个特殊的档案,该档案的内容是指向另一个档案的位置。</p>
<p>硬连结是存在同一个档案系统中,而软连结却可以跨越不同的档案系统。 </p>
<p>ln source dist 是产生一个连结 (dist) 到 source,至于使用硬连结或软链结则由参数决定。 </p>
<p>不论是硬连结或软链结都不会将原本的档案复制一份,只会占用非常少量的磁碟空间。</p>
<ul>
<li>-f: 链结时先将与 dist 同档名的档案删除</li>
<li>-d: 允许系统管理者硬链结自己的目录</li>
<li>-i: 在删除与 dist 同档名的档案时先进行询问</li>
<li>-n: 在进行软连结时,将 dist 视为一般的档案</li>
<li>-s: 进行软链结 (symbolic link)</li>
<li>-v: 在连结之前显示其档名</li>
<li>-b: 将在链结时会被覆写或删除的档案进行备份</li>
<li>-S SUFFIX: 将备份的档案都加上 SUFFIX 的字尾</li>
<li>-V METHOD: 指定备份的方式</li>
<li>–help: 显示辅助说明</li>
<li>–version: 显示版本</li>
</ul>
<p><strong>范例</strong>:</p>
<p>将档案 yy 产生一个 symbolic link:zz </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s yy zz </span><br></pre></td></tr></table></figure>

<p>将档案 yy 产生一个 hard link:zz </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln yy xx </span><br></pre></td></tr></table></figure>

<h1 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate [-q] [-d ] [--database=] </span><br><span class="line">locate [-r ] [--regexp=] </span><br><span class="line">locate [-qv] [-o ] [--output=] </span><br><span class="line">locate [-e ] [-f ] &lt;[-l ] [-c] </span><br><span class="line">&lt;[-U ] [-u]&gt; </span><br><span class="line">locate [-Vh] [--version] [--help] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的资料库,之后当寻找时就只需查询这个资料库,而不必实际深入档案系统之中了。在一般的 distribution 之中,资料库的建立都被放在 contab 中自动执行。</p>
<p>一般使用者在使用时只要用 locate your_file_name 的型式就可以了。 </p>
<ul>
<li>-u U 建立资料库,-u 会由根目录开始,-U 则可以指定开始的位置。</li>
<li>-e 将排除在寻找的范围之外。</li>
<li>-l 如果 是 1．则启动安全模式。在安全模式下,使用者不会看到权限无法看到的档案。这会始速度减慢,因为 locate 必须至实际的档案系统中取得档案的权限资料。 </li>
<li>-f 将特定的档案系统排除在外,例如我们没有到理要把 proc 档案系统中的档案放在资料库中。 </li>
<li>-q 安静模式,不会显示任何错误讯息。</li>
<li>-n 至多显示 个输出。 </li>
<li>-r 使用正规运算式 做寻找的条件。 </li>
<li>-o 指定资料库存的名称。 </li>
<li>-d 指定资料库的路径 </li>
<li>-h 显示辅助讯息 </li>
<li>-v 显示更多的讯息 </li>
<li>-V 显示程式的版本讯息</li>
</ul>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate chdrv:寻找所有叫 chdrv 的档案 </span><br><span class="line">locate -n 100 a.out:寻找所有叫 a.out 的档案,但最多只显示 100 个 </span><br><span class="line">locate -u:建立资料库 </span><br></pre></td></tr></table></figure>

<h1 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls [-alrtAFR] [name...] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>显示指定工作目录下之内容（列出目前工作目录所含之档案及子目录)。</p>
<ul>
<li>-a 显示所有档案及目录 (ls 内定将档案名或目录名称开头为 “.” 的视为隐藏档,不会列出) </li>
<li>-l 除档案名称外,亦将档案型态,权限,拥有者,档案大小等资讯详细列出 </li>
<li>-r 将档案以相反次序显示 (原定依英文字母次序) </li>
<li>-t 将档案依建立时间之先后次序列出 </li>
<li>-A 同 -a ,但不列出 “.” (目前目录) 及 “..” (父目录) </li>
<li>-F 在列出的档案名称后加一符号；例如可执行档则加 “*“, 目录则加 “&#x2F;“ </li>
<li>-R 若目录下有档案,则以下之档案亦皆依序列出</li>
</ul>
<p><strong>范例</strong>： </p>
<p>列出目前工作目录下所有名称是 s 开头的档案,愈新的排愈后面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -ltr s*</span><br></pre></td></tr></table></figure>

<p>将 &#x2F;bin 目录以下所有目录及档案详细资料列出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -lR /bin </span><br></pre></td></tr></table></figure>

<p>列出目前工作目录下所有档案及目录；目录于名称后加 “&#x2F;“, 可执行档于名称后加 “*“:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -AF </span><br></pre></td></tr></table></figure>

<h1 id="more"><a href="#more" class="headerlink" title="more"></a>more</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>类似 cat ,不过会以一页一页的显示方便使用者逐页阅读,而最基本的指令就是按空白键（space）就往下一页显示,按 b 键就会往回（back）一页显示,而且还有搜寻字串的功能（与 vi 相似）,使用中的说明文件,请按 h 。 </p>
<p>参数：</p>
<ul>
<li>-num 一次显示的行数 </li>
<li>-d 提示使用者,在画面下方显示 [Press space to continue, q to quit.] ,如果使用者按错键,则会显示 [Press h for instructions.] 而不是 哔 声 </li>
<li>-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能 </li>
<li>-f 计算行数时,以实际上的行数,而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上） </li>
<li>-p 不以卷动的方式显示每一页,而是先清除萤幕后再显示内容 </li>
<li>-c 跟 -p 相似,不同的是先显示内容再清除其他旧资料 </li>
<li>-s 当遇到有连续两行以上的空白行,就代换为一行的空白行 </li>
<li>-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同） </li>
<li>+&#x2F; 在每个档案显示前搜寻该字串（pattern）,然后从该字串之后开始显示 </li>
<li>+num 从第 num 行开始显示 </li>
<li>fileNames 欲显示内容的档案,可为复数个数</li>
</ul>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more -s testfile 逐页显示 testfile 之档案内容,如有连续两行以上空白行则以一行空白行显示。 </span><br><span class="line"></span><br><span class="line">more +20 testfile 从第 20 行开始显示 testfile 之档案内容。</span><br></pre></td></tr></table></figure>

<h1 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv [options] source dest </span><br><span class="line"></span><br><span class="line">mv [options] source... directory </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>将一个档案移至另一档案,或将数个档案移至另一目录。 </p>
<p>参数：</p>
<ul>
<li>-i 若目的地已有同名档案,则先询问是否覆盖旧档。</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将档案 aaa 更名为 bbb:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv aaa bbb </span><br></pre></td></tr></table></figure>

<p>将所有的 C 语言程式移至 Finished 子目录中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv -i *.c </span><br></pre></td></tr></table></figure>

<h1 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm [options] name... </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>删除档案及目录。 </p>
<ul>
<li>-i 删除前逐一询问确认。 </li>
<li>-f 即使原档案属性设为唯读,亦直接删除,无需逐一确认。 </li>
<li>-r 将目录及以下之档案亦逐一删除。</li>
</ul>
<p><strong>范例</strong>： </p>
<p>删除所有 C 语言程式档；删除前逐一询问确认:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -i *.c </span><br></pre></td></tr></table></figure>

<p>将 Finished 子目录及子目录中所有档案删除:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -r Finished </span><br></pre></td></tr></table></figure>

<h1 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir [-p] dirName </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>删除空的目录。 </p>
<p>参数： </p>
<ul>
<li>-p 是当子目录被删除后使它也成为空目录的话,则顺便一并删除。</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将工作目录下,名为 AAA 的子目录删除:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir AAA </span><br></pre></td></tr></table></figure>

<p>在工作目录下的 BBB 目录中,删除名为 Test 的子目录。若 Test 删除后,BBB 目录成为空目录,则 BBB 亦予删除。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir -p BBB/Test </span><br></pre></td></tr></table></figure>

<h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">split [OPTION] [INPUT [PREFIX]]</span><br></pre></td></tr></table></figure>

<p>将一个档案分割成数个。而从 INPUT 分割输出成固定大小的档案,其档名依序为 PREFIXaa, PREFIXab…；PREFIX 预设值为 `x。若没有 INPUT 档或为 `-,则从标准输入读进资料。 </p>
<ul>
<li>-b, –bytes&#x3D;SIZE SIZE 值为每一输出档案的大小,单位为 byte。</li>
<li>-C, –line-bytes&#x3D;SIZE 每一输出档中,单行的最大 byte 数。 </li>
<li>-l, –lines&#x3D;NUMBER NUMBER 值为每一输出档的列数大小。 </li>
<li>-NUMBER 与 -l NUMBER 相同。 </li>
<li>–verbose 于每个输出档被开启前,列印出侦错资讯到标准错误输出。 </li>
<li>–help 显示辅助资讯然后离开。 </li>
<li>–version 列出版本资讯然后离开。 </li>
<li>SIZE 可加入单位: b 代表 512, k 代表 1K, m 代表 1 Meg。</li>
</ul>
<p><strong>范例</strong>：</p>
<p>PostgresSQL 大型资料库备份与回存：</p>
<p>因 Postgres 允许表格大过你系统档案的最大容量,所以要将表格 dump 到单一的档案可能会有问题,使用 split 进行档案分割。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% pg_dump dbname | split -b 1m - filename.dump. </span><br></pre></td></tr></table></figure>

<p>重新载入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% createdb dbname </span><br><span class="line"></span><br><span class="line">% cat filename.dump.* | pgsql dbname </span><br></pre></td></tr></table></figure>

<h1 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch [-acfm]  [-r reference-file] [--file=reference-file] [-t MMDDhhmm[[CC]YY][.ss]] [-d time] [--date=time] [--time=&#123;atime,access,use,mtime,modify&#125;] [--no-create] [--help] [--version] file1 [file2 ...] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>touch 指令改变档案的时间记录。 ls -l 可以显示档案的时间记录。</p>
<p>参数： </p>
<ul>
<li>a 改变档案的读取时间记录。 </li>
<li>m 改变档案的修改时间记录。 </li>
<li>c 假如目的档案不存在,不会建立新的档案。与 –no-create 的效果一样。 </li>
<li>f 不使用,是为了与其他 unix 系统的相容性而保留。 </li>
<li>r 使用参考档的时间记录,与 –file 的效果一样。 </li>
<li>d 设定时间与日期,可以使用各种不同的格式。 </li>
<li>t 设定档案的时间记录,格式与 date 指令相同。 </li>
<li>–no-create 不会建立新档案。 </li>
<li>–help 列出指令格式。 </li>
<li>–version 列出版本讯息。</li>
</ul>
<p><strong>范例</strong>：</p>
<p>最简单的<strong>使用方式</strong>,将档案的时候记录改为现在的时间。若档案不存在,系统会建立一个新的档案。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch file </span><br><span class="line">touch file1 file2 </span><br></pre></td></tr></table></figure>

<p>将 file 的时间记录改为 5 月 6 日 18 点 3 分,公元两千年。时间的格式可以参考 date 指令,至少需输入 MMDDHHmm ,就是月日时与分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch -c -t 05061803 file </span><br><span class="line">touch -c -t 050618032000 file </span><br></pre></td></tr></table></figure>

<p>将 file 的时间记录改变成与 referencefile 一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch -r referencefile file </span><br></pre></td></tr></table></figure>

<p>将 file 的时间记录改成 5 月 6 日 18 点 3 分,公元两千年。时间可以使用 am, pm 或是 24 小时的格式,日期可以使用其他格式如 6 May 2000 。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch -d &quot;6:03pm&quot; file </span><br><span class="line">touch -d &quot;05/06/2000&quot; file </span><br><span class="line">touch -d &quot;6:03pm 05/06/2000&quot; file </span><br></pre></td></tr></table></figure>

<h1 id="at"><a href="#at" class="headerlink" title="at"></a>at</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at -V [-q queue] [-f file] [-mldbv] TIME </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>at 可以让使用者指定在 TIME 这个特定时刻执行某个程式或指令,TIME 的格式是 HH:MM 其中的 HH 为小时,MM 为分钟,甚至你也可以指定 am, pm, midnight, noon, teatime(就是下午 4 点锺) 等口语词。 </p>
<p>如果想要指定超过一天内的时间,则可以用 MMDDYY 或者 MM&#x2F;DD&#x2F;YY 的格式,其中 MM 是分钟,DD 是第几日,YY 是指年份。</p>
<p>另外,使用者甚至也可以使用像是 now + 时间间隔来弹性指定时间,其中的时间间隔可以是 minutes, hours, days, weeks</p>
<p>另外,使用者也可指定 today 或 tomorrow 来表示今天或明天。当指定了时间并按下 enter 之后,at 会进入交谈模式并要求输入指令或程式,当你输入完后按下 ctrl+D 即可完成所有动作,至于执行的结果将会寄回你的帐号中。</p>
<ul>
<li>-V: 印出版本编号 </li>
<li>-q: 使用指定的伫列 (Queue) 来储存,at 的资料是存放在所谓的 queue 中,使用者可以同时使用多个 queue,而 queue 的编号为 a, b, c… z 以及 A, B, … Z 共 52 个 </li>
<li>-m: 即使程式&#x2F;指令执行完成后没有输出结果, 也要寄封信给使用者 </li>
<li>-f file: 读入预先写好的命令档。使用者不一定要使用交谈模式来输入,可以先将所有的指定先写入档案后再一次读入 </li>
<li>-l: 列出所有的指定 (使用者也可以直接使用 atq 而不用 at -l) </li>
<li>-d: 删除指定 (使用者也可以直接使用 atrm 而不用 at -d) </li>
<li>-v: 列出所有已经完成但尚未删除的指定</li>
</ul>
<p><strong>范例</strong>：</p>
<p>三天后的下午 5 点锺执行 &#x2F;bin&#x2F;ls:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at 5pm + 3 days /bin/ls </span><br></pre></td></tr></table></figure>

<p>三个星期后的下午 5 点锺执行 &#x2F;bin&#x2F;ls:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at 5pm + 2 weeks /bin/ls </span><br></pre></td></tr></table></figure>

<p>明天的 17:20 执行 &#x2F;bin&#x2F;date:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at 17:20 tomorrow /bin/date </span><br></pre></td></tr></table></figure>

<p>1999 年的最后一天的最后一分钟印出 the end of world ! </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at 23:59 12/31/1999 echo the end of world ! </span><br></pre></td></tr></table></figure>

<h1 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cal [-mjy] [month [year]] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>显示日历。若只有一个参数,则代表年份 (1-9999),显示该年的年历。</p>
<p>年份必须全部写出：&#96;&#96;cal 89\ 将不会是显示 1989 年的年历。使用两个参数,则表示月份及年份。若没有参数则显示这个月的月历。 </p>
<p>1752 年 9 月第 3 日起改用西洋新历,因这时大部份的国家都采用新历,有 10 天被去除,所以该月份的月历有些不同。在此之前为西洋旧历。 </p>
<ul>
<li>-m: 以星期一为每周的第一天方式显示。 </li>
<li>-j: 以凯撒历显示,即以一月一日起的天数显示。 </li>
<li>-y: 显示今年年历。</li>
</ul>
<p><strong>范例</strong>： </p>
<p>cal: 显示本月的月历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@mylinux /root]# date</span><br><span class="line">Tue Aug 15 08:00:18 CST 2000 </span><br><span class="line"></span><br><span class="line">[root@mylinux /root]# cal</span><br><span class="line">August 2000 </span><br><span class="line">Su Mo Tu We Th Fr Sa </span><br><span class="line">1 2 3 4 5 </span><br><span class="line">6 7 8 9 10 11 12 </span><br><span class="line">13 14 15 16 17 18 19 </span><br><span class="line">20 21 22 23 24 25 26 </span><br><span class="line">27 28 29 30 31 </span><br></pre></td></tr></table></figure>

<h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab [ -u user ] filecrontab [ -u user ] &#123; -l | -r | -e &#125; </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>crontab 是用来让使用者在固定时间或固定间隔执行程式之用,换句话说,也就是类似使用者的时程表。</p>
<ul>
<li>-u user 是指设定指定 user 的时程表,这个前提是你必须要有其权限 (比如说是 root) 才能够指定他人的时程表。如果不使用 -u user 的话,就是表示设定自己的时程表。 </li>
<li>-e: 执行文字编辑器来设定时程表,内定的文字编辑器是 VI,如果你想用别的文字编辑器,则请先设定 VISUAL 环境变数来指定使用那个文字编辑器 (比如说 setenv VISUAL joe) </li>
<li>-r: 删除目前的时程表 </li>
<li>-l: 列出目前的时程表</li>
</ul>
<p>时程表的格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program </span><br></pre></td></tr></table></figure>

<p>其中 f1 是表示分钟,f2 表示小时,f3 表示一个月份中的第几日,f4 表示月份,f5 表示一个星期中的第几天。program 表示要执行的程式。 </p>
<ul>
<li>当 f1 为 * 时表示每分钟都要执行 program,f2 为 * 时表示每小时都要执行程式,其余类推 </li>
<li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行,f2 为 a-b 时表示从第 a 到第 b 小时都要执行,其余类推 </li>
<li>当 f1 为 *&#x2F;n 时表示每 n 分钟个时间间隔执行一次,f2 为 *&#x2F;n 表示每 n 小时个时间间隔执行一次,其余类推 </li>
<li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行,f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行,其余类推</li>
</ul>
<p>使用者也可以将所有的设定先存放在档案 file 中,用 crontab file 的方式来设定时程表。 </p>
<p><strong>范例</strong>： </p>
<p>每月每天每小时的第 0 分钟执行一次 &#x2F;bin&#x2F;ls:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 7 * * * /bin/ls </span><br></pre></td></tr></table></figure>

<p>在 12 月内, 每天的早上 6 点到 12 点中,每隔 20 分钟执行一次 &#x2F;usr&#x2F;bin&#x2F;backup:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 6-12/3 * 12 * /usr/bin/backup </span><br></pre></td></tr></table></figure>

<p>周一到周五每天下午 5:00 寄一封信给 <a href="mailto:&#x61;&#108;&#x65;&#120;&#x40;&#x64;&#x6f;&#x6d;&#97;&#x69;&#110;&#46;&#x6e;&#97;&#x6d;&#x65;">&#x61;&#108;&#x65;&#120;&#x40;&#x64;&#x6f;&#x6d;&#97;&#x69;&#110;&#46;&#x6e;&#97;&#x6d;&#x65;</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 17 * * 1-5 mail -s &quot;hi&quot; alex@domain.name &lt; /tmp/maildata </span><br></pre></td></tr></table></figure>

<p>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha” </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 0-23/2 * * * echo &quot;haha&quot; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>当程式在你所指定的时间执行后,系统会寄一封信给你,显示该程式执行的内容,若是你不希望收到这样的信,请在每一行空一格之后加上 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 即可。 </p>
</blockquote>
<h1 id="date"><a href="#date" class="headerlink" title="date"></a>date</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help] [--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>date 可以用来显示或设定系统的日期与时间,在显示方面,使用者可以设定欲显示的格式,格式设定为一个加号后接数个标记,其中可用的标记列表如下:</p>
<p>时间方面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%:印出 % </span><br><span class="line">%n:下一行 </span><br><span class="line">%t:跳格 </span><br><span class="line">%H:小时(00..23) </span><br><span class="line">%I:小时(01..12) </span><br><span class="line">%k:小时(0..23) </span><br><span class="line">%l:小时(1..12) </span><br><span class="line">%M:分钟(00..59) </span><br><span class="line">%p:显示本地 AM 或 PM </span><br><span class="line">%r:直接显示时间 (12 小时制,格式为 hh:mm:ss [AP]M) </span><br><span class="line">%s:从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数 </span><br><span class="line">%S:秒(00..61) </span><br><span class="line">%T:直接显示时间 (24 小时制) </span><br><span class="line">%X:相当于 %H:%M:%S </span><br><span class="line">%Z:显示时区 </span><br></pre></td></tr></table></figure>

<p>日期方面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%a:星期几 (Sun..Sat) </span><br><span class="line">%A:星期几 (Sunday..Saturday) </span><br><span class="line">%b:月份 (Jan..Dec) </span><br><span class="line">%B:月份 (January..December) </span><br><span class="line">%c:直接显示日期与时间 </span><br><span class="line">%d:日 (01..31) </span><br><span class="line">%D:直接显示日期 (mm/dd/yy) </span><br><span class="line">%h:同 %b </span><br><span class="line">%j:一年中的第几天 (001..366) </span><br><span class="line">%m:月份 (01..12) </span><br><span class="line">%U:一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形) </span><br><span class="line">%w:一周中的第几天 (0..6) </span><br><span class="line">%W:一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形) </span><br><span class="line">%x:直接显示日期 (mm/dd/yy) </span><br><span class="line">%y:年份的最后两位数字 (00.99) </span><br><span class="line">%Y:完整年份 (0000..9999) </span><br></pre></td></tr></table></figure>

<p>若是不以加号作为开头,则表示要设定时间,而时间格式为 MMDDhhmm[[CC]YY][.ss],其中 MM 为月份,DD 为日,hh 为小时,mm 为分钟,CC 为年份前两位数字,YY 为年份后两位数字,ss 为秒数 </p>
<ul>
<li>-d datestr: 显示 datestr 中所设定的时间 (非系统时间) </li>
<li>–help: 显示辅助讯息 </li>
<li>-s datestr: 将系统时间设为 datestr 中所设定的时间 </li>
<li>-u: 显示目前的格林威治时间 </li>
<li>–version: 显示版本编号</li>
</ul>
<p><strong>范例</strong>： </p>
<p>显示时间后跳行,再显示目前日期:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date +%T%n%D </span><br></pre></td></tr></table></figure>

<p>显示月份与日数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date +%B %d </span><br></pre></td></tr></table></figure>

<p>显示日期与设定时间 (12:34:56):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date --date 12:34:56 </span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p>当你不希望出现无意义的 0 时 (比如说 1999&#x2F;03&#x2F;07),则可以在标记中插入 - 符号,比如说 date +%-H:%-M:%-S 会把时分秒中无意义的 0 给去掉,像是原本的 08:09:04 会变为 8:9:4。另外,只有取得权限者 (比如说 root) 才能设定系统时间。 </p>
<p>当你以 root 身分更改了系统时间之后,请记得以 clock -w 来将系统时间写入 CMOS 中,这样下次重新开机时系统时间才会持续抱持最新的正确值。</p>
<h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep [--help] [--version] number[smhd] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>sleep 可以用来将目前动作延迟一段时间 </p>
<ul>
<li>–help: 显示辅助讯息 </li>
<li>–version: 显示版本编号 </li>
<li>number: 时间长度,后面可接 s,m,h 或 d </li>
<li><ul>
<li>其中 s 为秒,m 为 分钟,h 为小时,d 为日数</li>
</ul>
</li>
</ul>
<p><strong>范例</strong>： </p>
<p>显示目前时间后延迟 1 分钟,之后再次显示时间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date;</span><br><span class="line">sleep 1m;</span><br><span class="line">date </span><br></pre></td></tr></table></figure>

<h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time [options] COMMAND [arguments] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>time 指令的用途,在于量测特定指令执行时所需消耗的时间及系统资源等资讯。例如 CPU 时间,记忆体,输入输出等等。需要特别注意的是,部分资讯在 Linux 上显示不出来。这是因为在 Linux 上部分资源的分配函式与 time </p>
<p>指令所预设的方式并不相同,以致于 time 指令无法取得这些资料。 </p>
<ul>
<li>-o or –output&#x3D;FILE 设定结果输出档。这个选项会将 time 的输出写入 所指定的档案中。如果档案已经存在,系统将覆写其内容。 </li>
<li>-a or –append 配合 -o 使用,会将结果写到档案的末端,而不会覆盖掉原来的内容。 </li>
<li>-f FORMAT or –format&#x3D;FORMAT 以 FORMAT 字串设定显示方式。当这个选项没有被设定的时候,会用系统预设的格式。不过你可以用环境变数 time 来设定这个格式,如此一来就不必每次登入系统都要设定一次。</li>
</ul>
<p>一般设定上,你可以用 \t 表示跳栏,或者是用 \n 表示换行。</p>
<p>每一项资料要用 % 做为前导。如果要在字串中使用百分比符号,就用.（学过 C 语言的人大概会觉得很熟悉） </p>
<p>time 指令可以显示的资源有四大项,分别是： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Time resources </span><br><span class="line">Memory resources </span><br><span class="line">IO resources </span><br><span class="line">Command info </span><br></pre></td></tr></table></figure>

<p>详细的内容如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Time Resources </span><br><span class="line">E 执行指令所花费的时间,格式是：[hour]:minute:second。请注意这个数字并不代表实际的 CPU 时间。 </span><br><span class="line">e 执行指令所花费的时间,单位是秒。请注意这个数字并不代表实际的 CPU 时间。 </span><br><span class="line">S 指令执行时在核心模式（kernel mode）所花费的时间,单位是秒。 </span><br><span class="line">U 指令执行时在使用者模式（user mode）所花费的时间,单位是秒。 </span><br><span class="line">P 执行指令时 CPU 的占用比例。其实这个数字就是核心模式加上使用者模式的 CPU 时间除以总时间。 </span><br><span class="line"></span><br><span class="line">Memory Resources </span><br><span class="line">M 执行时所占用的实体记忆体的最大值。单位是 KB </span><br><span class="line">t 执行时所占用的实体记忆体的平均值,单位是 KB </span><br><span class="line">K 执行程序所占用的记忆体总量（stack+data+text）的平均大小,单位是 KB </span><br><span class="line">D 执行程序的自有资料区（unshared data area）的平均大小,单位是 KB </span><br><span class="line">p 执行程序的自有堆叠（unshared stack）的平均大小,单位是 KB </span><br><span class="line">X 执行程序间共享内容（shared text）的平均值,单位是 KB </span><br><span class="line">Z 系统记忆体页的大小,单位是 byte。对同一个系统来说这是个常数 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IO Resources </span><br><span class="line">F 此程序的主要记忆体页错误发生次数。所谓的主要记忆体页错误是指某一记忆体页已经置换到置换档（swap file)中,而且已经分配给其他程序。此时该页的内容必须从置换档里再读出来。 </span><br><span class="line">R 此程序的次要记忆体页错误发生次数。所谓的次要记忆体页错误是指某一记忆体页虽然已经置换到置换档中,但尚未分配给其他程序。此时该页的内容并未被破坏,不必从置换档里读出来 </span><br><span class="line">W 此程序被交换到置换档的次数 </span><br><span class="line">c 此程序被强迫中断（像是分配到的 CPU 时间耗尽）的次数 </span><br><span class="line">w 此程序自愿中断（像是在等待某一个 I/O 执行完毕,像是磁碟读取等等）的次数 </span><br><span class="line">I 此程序所输入的档案数 </span><br><span class="line">O 此程序所输出的档案数 </span><br><span class="line">r 此程序所收到的 Socket Message </span><br><span class="line">s 此程序所送出的 Socket Message </span><br><span class="line">k 此程序所收到的信号 ( Signal )数量 </span><br><span class="line"></span><br><span class="line">Command Info </span><br><span class="line">C 执行时的参数以及指令名称 </span><br><span class="line">x 指令的结束代码 ( Exit Status ) </span><br></pre></td></tr></table></figure>

<p>-p or –portability 这个选项会自动把显示格式设定成为： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">real %e </span><br><span class="line">user %U </span><br><span class="line">sys %S</span><br></pre></td></tr></table></figure>

<p>这么做的目的是为了与 POSIX 规格相容。 </p>
<p>-v or –verbose 这个选项会把所有程式中用到的资源通通列出来,不但如一般英文语句,还有说明。对不想花时间去熟习格式设定或是刚刚开始接触这个指令的人相当有用。 </p>
<p><strong>范例</strong>： </p>
<p>利用下面的指令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time -v ps -aux </span><br></pre></td></tr></table></figure>

<p>我们可以获得执行 ps -aux 的结果和所花费的系统资源。如下面所列的资料： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND </span><br><span class="line">root 1 0.0 0.4 1096 472 ? S Apr19 0:04 init </span><br><span class="line">root 2 0.0 0.0 0 0 ? SW Apr19 0:00 [kflushd] </span><br><span class="line">root 3 0.0 0.0 0 0 ? SW Apr19 0:00 [kpiod] </span><br><span class="line">...... </span><br><span class="line">root 24269 0.0 1.0 2692 996 pts/3 R 12:16 0:00 ps -aux </span><br><span class="line"></span><br><span class="line">Command being timed: &quot;ps -aux&quot; </span><br><span class="line">User time (seconds): 0.05 </span><br><span class="line">System time (seconds): 0.06 </span><br><span class="line">Percent of CPU this job got: 68% </span><br><span class="line">Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.16 </span><br><span class="line">Average shared text size (kbytes): 0 </span><br><span class="line">Average unshared data size (kbytes): 0 </span><br><span class="line">Average stack size (kbytes): 0 </span><br><span class="line">Average total size (kbytes): 0 </span><br><span class="line">Maximum resident set size (kbytes): 0 </span><br><span class="line">Average resident set size (kbytes): 0 </span><br><span class="line">Major (requiring I/O) page faults: 238 </span><br><span class="line">Minor (reclaiming a frame) page faults: 46 </span><br><span class="line">Voluntary context switches: 0 </span><br><span class="line">Involuntary context switches: 0 </span><br><span class="line">Swaps: 0 </span><br><span class="line">File system inputs: 0 </span><br><span class="line">File system outputs: 0 </span><br><span class="line">Socket messages sent: 0 </span><br><span class="line">Socket messages received: 0 </span><br><span class="line">Signals delivered: 0 </span><br><span class="line">Page size (bytes): 4096 </span><br><span class="line">Exit status: 0 </span><br></pre></td></tr></table></figure>

<h1 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uptime [-V] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>uptime 提供使用者下面的资讯,不需其他参数： </p>
<ul>
<li>现在的时间 </li>
<li>系统开机运转到现在经过的时间 </li>
<li>连线的使用者数量 </li>
<li>最近一分钟,五分钟和十五分钟的系统负载</li>
</ul>
<p>参数： </p>
<ul>
<li>-V 显示版本资讯。</li>
</ul>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uptime </span><br></pre></td></tr></table></figure>

<p>其结果为： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10:41am up 5 days, 10 min, 1 users, load average: 0.00, 0.00, 1.99 </span><br></pre></td></tr></table></figure>

<h1 id="chfn"><a href="#chfn" class="headerlink" title="chfn"></a>chfn</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; chfn </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>提供使用者更改个人资讯,用于 finger and mail username </p>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; chfn </span><br><span class="line">Changing finger information for user </span><br><span class="line">Password: [del] </span><br><span class="line">Name[]:Johnney Huang ## 提供 finger 时的资料 </span><br><span class="line">Office[]:NCCU </span><br><span class="line">Office Phone[]: [del] </span><br><span class="line">Home Phone[]: [del] </span><br></pre></td></tr></table></figure>

<h1 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; chsh </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>更改使用者 shell 设定 </p>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; chsh </span><br><span class="line">Changing fihanging shell for user1 </span><br><span class="line">Password: [del] </span><br><span class="line">New shell [/bin/tcsh]: ## [是目前使用的 shell] </span><br><span class="line">[del] </span><br><span class="line"></span><br><span class="line">shell&gt;&gt; chsh -l ## 展示 /etc/shells 档案内容 </span><br><span class="line">/bin/bash </span><br><span class="line">/bin/sh </span><br><span class="line">/bin/ash </span><br><span class="line">/bin/bsh </span><br><span class="line">/bin/tcsh </span><br><span class="line">/bin/csh </span><br></pre></td></tr></table></figure>

<h1 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">finger [options] user[@address] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>finger 可以让使用者查询一些其他使用者的资料。会列出来的资料有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Login Name </span><br><span class="line">User Name </span><br><span class="line">Home directory </span><br><span class="line">Shell </span><br><span class="line">Login status </span><br><span class="line">mail status </span><br><span class="line">.plan </span><br><span class="line">.project </span><br><span class="line">.forward </span><br></pre></td></tr></table></figure>

<p>其中 .plan ,.project 和 .forward 就是使用者在他的 Home Directory 里的 .plan , .project 和 .forward 等档案里的资料。如果没有就没有。finger 指令并不限定于在同一伺服器上查询,也可以寻找某一个远端伺服器上的使用者。只要给一个像是 E-mail address 一般的地址即可。 </p>
<ul>
<li>-l 多行显示。</li>
<li>-s 单行显示。这个选项只显示登入名称,真实姓名,终端机名称,闲置时间,登入时间,办公室号码及电话号码。如果所查询的使用者是远端伺服器的使用者,这个选项无效。</li>
</ul>
<p><strong>范例</strong>：</p>
<p>下列指令可以查询本机管理员的资料： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">finger root </span><br></pre></td></tr></table></figure>

<p>其结果如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Login: root Name: root </span><br><span class="line">Directory: /root Shell: /bin/bash </span><br><span class="line">Never logged in. </span><br><span class="line">No mail. </span><br><span class="line">No Plan. </span><br></pre></td></tr></table></figure>

<h1 id="last"><a href="#last" class="headerlink" title="last"></a>last</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; last [options] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>显示系统开机以来获是从每月初登入者的讯息 </p>
<ul>
<li>-R 省略 hostname 的栏位 </li>
<li>-num 展示前 num 个 </li>
<li>username 展示 username 的登入讯息 </li>
<li>tty 限制登入讯息包含终端机代号</li>
</ul>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; last -R -2 </span><br><span class="line">johnney pts/1 Mon Aug 14 20:42 still logged in </span><br><span class="line">johnney pts/0 Mon Aug 14 19:59 still logged in </span><br><span class="line"></span><br><span class="line">wtmp begins Tue Aug 1 09:01:10 2000 ## /var/log/wtmp</span><br><span class="line"></span><br><span class="line">shell&gt;&gt; last -2 minery </span><br><span class="line">minery pts/0 140.119.217.115 Mon Aug 14 18:37 - 18:40 (00:03) </span><br><span class="line">minery pts/0 140.119.217.115 Mon Aug 14 17:22 - 17:24 (00:02) </span><br><span class="line">wtmp begins Tue Aug 1 09:01:10 2000 </span><br></pre></td></tr></table></figure>

<h1 id="login"><a href="#login" class="headerlink" title="login"></a>login</h1><h1 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd [-k] [-l] [-u [-f]] [-d] [-S] [username] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>用来更改使用者的密码 </p>
<ul>
<li>-k </li>
<li>-l </li>
<li>-u </li>
<li>-f </li>
<li>-d 关闭使用者的密码认证功能, 使用者在登入时将可以不用输入密码, 只有具备 root 权限的使用者方可使用. </li>
<li>-S 显示指定使用者的密码认证种类, 只有具备 root 权限的使用者方可使用.</li>
</ul>
<p>[username] 指定帐号名称. </p>
<h1 id="who"><a href="#who" class="headerlink" title="who"></a>who</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">who - [husfV] [user] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>显示系统中有那些使用者正在上面,显示的资料包含了使用者 ID,使用的终端机,从那边连上来的,上线时间,呆滞时间,CPU 使用量,动作等等。 </p>
<ul>
<li>-h: 不要显示标题列 </li>
<li>-u: 不要显示使用者的动作&#x2F;工作 </li>
<li>-s: 使用简短的格式来显示 </li>
<li>-f: 不要显示使用者的上线位置 </li>
<li>-V: 显示程式版本</li>
</ul>
<h1 id="etc-aliases"><a href="#etc-aliases" class="headerlink" title="&#x2F;etc&#x2F;aliases"></a>&#x2F;etc&#x2F;aliases</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newaliases </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>sendmail 会使用一个在 &#x2F;etc&#x2F;aliases 中的档案做使用者名称转换的动作。</p>
<p>当 sendmail 收到一个要送给 xxx 的信时,它会依据 aliases 档的内容送给另一个使用者。这个功能可以创造一个只有在信件系统内才有效的使用者。</p>
<p>例如 mailing list 就会用到这个功能,在 mailinglist 中,我们可能会创造一个叫 <a href="mailto:&#x72;&#101;&#x64;&#x6c;&#105;&#x6e;&#x75;&#120;&#64;&#108;&#105;&#110;&#107;&#x2e;&#101;&#x63;&#101;&#46;&#117;&#99;&#x69;&#x2e;&#x65;&#x64;&#x75;">&#x72;&#101;&#x64;&#x6c;&#105;&#x6e;&#x75;&#120;&#64;&#108;&#105;&#110;&#107;&#x2e;&#101;&#x63;&#101;&#46;&#117;&#99;&#x69;&#x2e;&#x65;&#x64;&#x75;</a> 的 mailinglist,但实际上并没有一个叫 redlinux 的使用者。</p>
<p>实际 aliases 档的内容是将送给这个使用者的信都收给 mailing list 处理程式负责分送的工作。 </p>
<p>&#x2F;etc&#x2F;aliases 是一个文字模式的档案,sendmail 需要一个二进位格式的 &#x2F;etc&#x2F;aliases.db。newaliases 的功能传是将 &#x2F;etc&#x2F;aliases 转换成一个 sendmail 所能了解的资料库。 </p>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newaliases</span><br></pre></td></tr></table></figure>

<p>下面命令会做相同的事, </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sendmail -bi</span><br></pre></td></tr></table></figure>

<h1 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mail [-iInv] [-s subject] [-c cc-addr] [-b bcc-addr] user1 [user 2 ...] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>mail 不仅只是一个指令, mail 还是一个电子邮件程式,不过利用 mail 来读信的人应该很少吧！对于系统管理者来说 mail 就很有用,因为管理者可以用 mail 写成 script ,定期寄一些备忘录提醒系统的使用者。 </p>
<ul>
<li>i 忽略 tty 的中断讯号。 (interrupt) </li>
<li>I 强迫设成互动模式。 (Interactive) </li>
<li>v 列印出讯息,例如送信的地点,状态等等。 (verbose) </li>
<li>n 不读入 mail.rc 设定档。 </li>
<li>s 邮件标题。 </li>
<li>c cc 邮件地址。 </li>
<li>b bcc 邮件地址。</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将信件送给一个或以上的电子邮件地址,由于没有加入其他的选项,使用者必须输入标题与信件的内容等。而 user2 没有主机位置,就会送给邮件伺服器的 user2 使用者。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mail user1@email.address </span><br><span class="line">mail user1@email.address user2 </span><br></pre></td></tr></table></figure>

<p>将 mail.txt 的内容寄给 user2 同时 cc 给 user1 。如果将这一行指令设成 cronjob 就可以定时将备忘录寄给系统使用者。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mail -s 标题 -c user1 user2 &lt; mail.txt </span><br></pre></td></tr></table></figure>

<h1 id="mesg"><a href="#mesg" class="headerlink" title="mesg"></a>mesg</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mesg [y|n] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>决定是否允许其他人传讯息到自己的终端机介面 </p>
<ul>
<li>y: 允许讯息传到终端机介面上。 </li>
<li>n: 不允许讯息传到终端机介面上 。</li>
</ul>
<p>如果没有设定,则讯息传递与否则由终端机界面目前状态而定。 </p>
<p><strong>范例</strong>： </p>
<p>改变目前讯息设定,改成不允许讯息传到终端机介面上:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mesg n </span><br></pre></td></tr></table></figure>

<p>与 mesg 相关的指令有： talk,write,wall。 </p>
<h1 id="talk"><a href="#talk" class="headerlink" title="talk"></a>talk</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">talk person [ttyname] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>与其他使用者对谈 </p>
<ul>
<li>person: 预备对谈的使用者帐号,如果该使用者在其他机器上,则可输入 <a href="mailto:&#112;&#101;&#x72;&#x73;&#x6f;&#x6e;&#64;&#x6d;&#x61;&#99;&#x68;&#x69;&#x6e;&#101;&#46;&#110;&#97;&#x6d;&#101;">&#112;&#101;&#x72;&#x73;&#x6f;&#x6e;&#64;&#x6d;&#x61;&#99;&#x68;&#x69;&#x6e;&#101;&#46;&#110;&#97;&#x6d;&#101;</a> </li>
<li>ttyname: 如果使用者同时有两个以上的 tty 连线,可以自行选择合适的 tty 传讯息</li>
</ul>
<p><strong>范例</strong>： </p>
<p>与现在机器上的使用者 Rollaend 对谈,此时 Rollaend 只有一个连线:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">talk Rollaend </span><br></pre></td></tr></table></figure>

<p>接下来就是等 Rollaend 回应,若 Rollaend 接受,则 Rollaend 输入 <code>talk jzlee</code> 即可开始对谈,结束请按 ctrl+c </p>
<p>与 linuxfab.cx 上的使用者 Rollaend 对谈,使用 pts&#x2F;2 来对谈:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">talk Rollaend@linuxfab.cx pts/2</span><br></pre></td></tr></table></figure>

<p>接下来就是等 Rollaend 回应,若 Rollaend 接受,则 Rollaend 输入 <code>talk jzlee@jzlee.home</code> 即可开始对谈,结束请按 ctrl+c </p>
<p>注意: 若萤幕的字会出现不正常的字元,试着按 ctrl+l 更新萤幕画面。</p>
<h1 id="wall"><a href="#wall" class="headerlink" title="wall"></a>wall</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wall [ message ] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>wall 会将讯息传给每一个 mesg 设定为 yes 的上线使用者。当使用终端机介面做为标准传入时, 讯息结束时需加上 EOF (通常用 Ctrl+D)</p>
<p><strong>范例</strong>： </p>
<p>传讯息 “hi” 给每一个使用者:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wall hi </span><br></pre></td></tr></table></figure>

<h1 id="write"><a href="#write" class="headerlink" title="write"></a>write</h1><p><strong>使用方式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">write user [ttyname] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>传讯息给其他使用者 </p>
<ul>
<li>user: 预备传讯息的使用者帐号 </li>
<li>ttyname: 如果使用者同时有两个以上的 tty 连线,可以自行选择合适的 tty 传讯息</li>
</ul>
<p><strong>范例</strong>： </p>
<p>传讯息给 Rollaend,此时 Rollaend 只有一个连线:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">write Rollaend </span><br></pre></td></tr></table></figure>

<p>接下来就是将讯息打上去,结束请按 ctrl+c </p>
<p>传讯息给 Rollaend,Rollaend 的连线有 pts&#x2F;2,pts&#x2F;3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">write Rollaend pts/2</span><br></pre></td></tr></table></figure>

<p>接下来就是将讯息打上去,结束请按 ctrl+c </p>
<p>注意: 若对方设定 mesg n,则此时讯席将无法传给对方 </p>
<h1 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill [ -s signal | -p ] [ -a ] pid ... </span><br><span class="line">kill -l [ signal ] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>kill 送出一个特定的信号 (signal) 给行程 id 为 pid 的行程根据该信号而做特定的动作, 若没有指定, 预设是送出终止 (TERM) 的信号 </p>
<ul>
<li>-s (signal): 其中可用的讯号有 HUP (1), KILL (9), TERM (15), 分别代表着重跑, 砍掉, 结束; 详细的信号可以用 kill -l </li>
<li>-p: 印出 pid , 并不送出信号 </li>
<li>-l (signal): 列出所有可用的信号名称</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将 pid 为 323 的行程砍掉 (kill):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 323 </span><br></pre></td></tr></table></figure>

<p>将 pid 为 456 的行程重跑 (restart):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -HUP 456 </span><br></pre></td></tr></table></figure>

<h1 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nice [-n adjustment] [-adjustment] [--adjustment=adjustment] [--help] [--version] [command [arg...]] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>以更改过的优先序来执行程式, 如果未指定程式, 则会印出目前的排程优先序, 内定的 adjustment 为 10, 范围为 -20 (最高优先序) 到 19 (最低优先序) </p>
<ul>
<li>-n adjustment, -adjustment, –adjustment&#x3D;adjustment 皆为将该原有优先序的增加 adjustment </li>
<li>–help 显示求助讯息 </li>
<li>–version 显示版本资讯</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将 ls 的优先序加 1 并执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nice -n 1 ls </span><br></pre></td></tr></table></figure>

<p>nice ls 将 ls 的优先序加 1 并执行 </p>
<p>注意: 优先序 (priority) 为作业系统用来决定 CPU 分配的参数,Linux 使用『回合制 (round-robin)』的演算法来做 CPU 排程,优先序越高,所可能获得的 CPU 时间就越多。 </p>
<h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps [options] [--help] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>显示瞬间行程 (process) 的动态 </p>
<p>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义 </p>
<ul>
<li>-A 列出所有的行程 </li>
<li>-w 显示加宽可以显示较多的资讯 </li>
<li>-au 显示较详细的资讯 </li>
<li>-aux 显示所有包含其他使用者的行程</li>
</ul>
<p>au(x) 输出格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND </span><br><span class="line">USER: 行程拥有者 </span><br><span class="line">PID: pid </span><br><span class="line">%CPU: 占用的 CPU 使用率 </span><br><span class="line">%MEM: 占用的记忆体使用率 </span><br><span class="line">VSZ: 占用的虚拟记忆体大小 </span><br><span class="line">RSS: 占用的记忆体大小 </span><br><span class="line">TTY: 终端的次要装置号码 (minor device number of tty) </span><br><span class="line">STAT: 该行程的状态: </span><br><span class="line">D: 不可中断的静止 (通悸□□缜b进行 I/O 动作) </span><br><span class="line">R: 正在执行中 </span><br><span class="line">S: 静止状态 </span><br><span class="line">T: 暂停执行 </span><br><span class="line">Z: 不存在但暂时无法消除 </span><br><span class="line">W: 没有足够的记忆体分页可分配 </span><br><span class="line">&lt;: 高优先序的行程 </span><br><span class="line">N: 低优先序的行程 </span><br><span class="line">L: 有记忆体分页分配并锁在记忆体内 (即时系统或捱A I/O) </span><br><span class="line">START: 行程开始时间 </span><br><span class="line">TIME: 执行的时间 </span><br><span class="line">COMMAND:所执行的指令 </span><br></pre></td></tr></table></figure>

<p><strong>范例</strong>： </p>
<h1 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user] </span><br><span class="line">pstree -V </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>将所有行程以树状图显示, 树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root) ,如果有指定使用者 id , 则树状图会只显示该使用者所拥有的行程 </p>
<ul>
<li>-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号 </li>
<li>-c 如果有重覆的行程名, 则分开列出 (预设值是会在前面加上 *</li>
</ul>
<p><strong>范例</strong>： </p>
<h1 id="renice"><a href="#renice" class="headerlink" title="renice"></a>renice</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">renice priority [[-p] pid ...] [[-g] pgrp ...] [[-u] user ...] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>重新指定一个或多个行程 (Process) 的优先序 (一个或多个将根据所下的参数而定) </p>
<ul>
<li>-p pid 重新指定行程的 id 为 pid 的行程的优先序 </li>
<li>-g pgrp 重新指定行程群组 (process group) 的 id 为 pgrp 的行程 (一个或多个) 的优先序 </li>
<li>-u user 重新指定行程拥有者为 user 的行程的优先序</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将行程 id 为 987 及 32 的行程与行程拥有者为 daemon 及 root 的优先序号码加 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">renice +1 987 -u daemon root -p 32 </span><br></pre></td></tr></table></figure>

<p>注意: 每一个行程 (Process) 都有一个唯一的 (unique) id</p>
<h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top [-] [d delay] [q] [c] [S] [s] [i] [n] [b] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>即时显示 process 的动态 </p>
<ul>
<li>d: 改变显示的更新速度,或是在交谈式指令列 ( interactive command) 按 s </li>
<li>q: 没有任何延迟的显示速度,如果使用者是有 superuser 的权限,则 top 将会以最高的优先序执行 </li>
<li>c: 切换显示模式,共有两种模式,一是只显示执行档的名称,另一种是显示完整的路径与名称 S: 累积模式,会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来 </li>
<li>s: 安全模式,将交谈式指令取消, 避免潜在的危机 </li>
<li>i: 不显示任何闲置 (idle) 或无用 (zombie) 的行程 </li>
<li>n: 更新的次数,完成后将会退出 top </li>
<li>b: 批次档模式,搭配 “n” 参数一起使用,可以用来将 top 的结果输出到档案内</li>
</ul>
<p><strong>范例</strong>： </p>
<p>显示更新十次后退出 ; </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -n 10 </span><br></pre></td></tr></table></figure>

<p>使用者将不能利用交谈式指令来对行程下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -s </span><br></pre></td></tr></table></figure>

<p>将更新显示二次的结果输入到名称为 top.log 的档案里:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -n 2 -b &lt; top.log </span><br></pre></td></tr></table></figure>

<h1 id="skill"><a href="#skill" class="headerlink" title="skill"></a>skill</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skill [signal to send] [options] 选择程序的规则 </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>送个讯号给正在执行的程序,预设的讯息为 TERM (中断) , 较常使用的讯息为 HUP , INT , KILL , STOP , CONT ,和 0 </p>
<p>讯息有三种写法: 分别为 -9 , -SIGKILL , -KILL , 可以使用 -l 或 -L 已列出可使用的讯息。 </p>
<ul>
<li>-f 快速模式&#x2F;尚未完成 </li>
<li>-i 互动模式&#x2F; 每个动作将要被确认 </li>
<li>-v 详细输出&#x2F; 列出所选择程序的资讯 </li>
<li>-w 智能警告讯息&#x2F; 尚未完成 </li>
<li>-n 没有动作&#x2F; 显示程序代号</li>
</ul>
<p>选择程序的规则可以是, 终端机代号,使用者名称,程序代号,命令名称。 </p>
<ul>
<li>-t 终端机代号 ( tty 或 pty )</li>
<li>-u 使用者名称 </li>
<li>-p 程序代号 ( pid ) </li>
<li>-c 命令名称 可使用的讯号:</li>
</ul>
<p>以下列出已知的讯号名称,讯号代号,功能。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">名称 (代号) 功能/ 描述</span><br><span class="line">ALRM 14 离开 </span><br><span class="line">HUP 1 离开 </span><br><span class="line">INT 2 离开 </span><br><span class="line">KILL 9 离开/ 强迫关闭 </span><br><span class="line">PIPE 13 离开 </span><br><span class="line">POLL 离开 </span><br><span class="line">PROF 离开 </span><br><span class="line">TERM 15 离开 </span><br><span class="line">USR1 离开 </span><br><span class="line">USR2 离开 </span><br><span class="line">VTALRM 离开 </span><br><span class="line">STKFLT 离开/ 只适用于i386, m68k, arm 和 ppc 硬体 </span><br><span class="line">UNUSED 离开/ 只适用于i386, m68k, arm 和 ppc 硬体 </span><br><span class="line">TSTP 停止 /产生与内容相关的行为 </span><br><span class="line">TTIN 停止 /产生与内容相关的行为 </span><br><span class="line">TTOU 停止 /产生与内容相关的行为 </span><br><span class="line">STOP 停止 /强迫关闭 </span><br><span class="line">CONT 从新启动 /如果在停止状态则从新启动,否则忽略 </span><br><span class="line">PWR 忽略 /在某些系统中会离开 </span><br><span class="line">WINCH 忽略 </span><br><span class="line">CHLD 忽略 </span><br><span class="line">ABRT 6 核心 </span><br><span class="line">FPE 8 核心 </span><br><span class="line">ILL 4 核心 </span><br><span class="line">QUIT 3 核心 </span><br><span class="line">SEGV 11 核心 </span><br><span class="line">TRAP 5 核心 </span><br><span class="line">SYS 核心 /或许尚未实作 </span><br><span class="line">EMT 核心 /或许尚未实作 </span><br><span class="line">BUS 核心 /核心失败 </span><br><span class="line">XCPU 核心 /核心失败 </span><br><span class="line">XFSZ 核心 /核心失败 </span><br></pre></td></tr></table></figure>

<p><strong>范例</strong>： </p>
<p>停止所有在 PTY 装置上的程序 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skill -KILL -v pts/* </span><br></pre></td></tr></table></figure>

<p>停止三个使用者 user1 , user2 , user3 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skill -STOP user1 user2 user3 </span><br></pre></td></tr></table></figure>

<h1 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h1><p>字串长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; expr length &quot;this is a test&quot; </span><br><span class="line">14 </span><br></pre></td></tr></table></figure>

<p>数字商数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; expr 14 % 9 </span><br><span class="line">5 </span><br></pre></td></tr></table></figure>

<p>从位置处抓取字串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; expr substr &quot;this is a test&quot; 3 5 </span><br><span class="line">is is </span><br></pre></td></tr></table></figure>

<p>数字串 only the first character</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; expr index &quot;testforthegame&quot; e </span><br><span class="line">2 </span><br></pre></td></tr></table></figure>

<p>字串真实重现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; expr quote thisisatestformela </span><br><span class="line">thisisatestformela </span><br></pre></td></tr></table></figure>

<h1 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h1><p>1.比方说要把目录下所有的大写档名换为小写档名?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh </span><br><span class="line">dir=&quot;/tmp/testdir&quot;; </span><br><span class="line">files=`find $dir -type f`; </span><br><span class="line">for i in $files </span><br><span class="line">do </span><br><span class="line">dir_name=`dirname $i`; </span><br><span class="line">ori_filename=`basename $i` </span><br><span class="line">new_filename=`echo $ori_filename | tr [:upper:] [:lower:]` &gt; /dev/null; </span><br><span class="line">#echo $new_filename; </span><br><span class="line">mv $dir_name/$ori_filename $dir_name/$new_filename </span><br><span class="line">done </span><br></pre></td></tr></table></figure>

<p>2.自己试验中…lowercase to uppercase</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tr abcdef...[del] ABCDE...[del] </span><br><span class="line">tr a-z A-Z </span><br><span class="line">tr [:lower:] [:upper:] </span><br><span class="line"></span><br><span class="line">shell&gt;&gt; echo &quot;this is a test&quot; | tr a-z A-Z &gt; www </span><br><span class="line">shell&gt;&gt; cat www </span><br><span class="line">THIS IS A TEST </span><br></pre></td></tr></table></figure>

<p>3.去掉不想要的字串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; tr -d this ## 去掉有关 t.e.s.t </span><br><span class="line">this </span><br><span class="line"></span><br><span class="line">man </span><br><span class="line">man </span><br><span class="line">test </span><br><span class="line">e </span><br></pre></td></tr></table></figure>

<p>4.取代字串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt;&gt; tr -s &quot;this&quot; &quot;TEST&quot; </span><br><span class="line">this </span><br><span class="line">TEST </span><br><span class="line">th </span><br><span class="line">TE </span><br></pre></td></tr></table></figure>

<h1 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h1><p><strong>使用说明</strong>： </p>
<p>清除萤幕用。 </p>
<h1 id="reset-tset"><a href="#reset-tset" class="headerlink" title="reset, tset"></a>reset, tset</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tset [-IQqrs] [-] [-e ch] [-i ch] [-k ch] [-m mapping] [terminal] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>： </p>
<p>reset 其实和 tset 是一同个命令,它的用途是设定终端机的状态。一般而言,这个命令会自动的从环境变数,命令列或是其它的组态档决定目前终端机的型态。如果指定型态是 ? 的话,这个程式会要求使用者输入终端机的型别。 </p>
<p>由于这个程式会将终端机设回原始的状态,除了在 login 时使用外,当系统终端机因为程式不正常执行而进入一些奇怪的状态时,你也可以用它来重设终端机 o 例如不小心把二进位档用 cat 指令进到终端机,常会有终端机不再回应键盘输入,或是回应一些奇怪字元的问题。此时就可以用 reset 将终端机回复至原始状态。</p>
<ul>
<li>-p 将终端机类别显示在萤幕上,但不做设定的动作。这个命令可以用来取得目前终端机的类别。</li>
<li>-e ch 将 erase 字元设成 ch </li>
<li>-i ch 将中断字元设成 ch </li>
<li>-k ch 将删除一行的字元设成 ch </li>
<li>-I 不要做设定的动作,如果没有使用选项 -Q 的话,erase,中断及删除字元的目前值依然会送到萤幕上。 </li>
<li>-Q 不要显示 erase,中断及删除字元的值到萤幕上。 </li>
<li>-r 将终端机类别印在萤幕上。 </li>
<li>-s 将设定 TERM 用的命令用字串的型式送到终端机中,通常在 .login 或 .profile 中用</li>
</ul>
<p><strong>范例</strong>: </p>
<p>让使用者输入一个终端机型别并将终端机设到该型别的预设状态。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset ?</span><br></pre></td></tr></table></figure>

<p>将 erase 字元设定 control-h </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset -e ^B</span><br></pre></td></tr></table></figure>

<p>将设定用的字串显示在萤幕上 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset -s</span><br><span class="line">Erase is control-B (^B). </span><br><span class="line">Kill is control-U (^U). </span><br><span class="line">Interrupt is control-C (^C). </span><br><span class="line">TERM=xterm; </span><br></pre></td></tr></table></figure>

<h1 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compress [-dfvcV] [-b maxbits] [file ...] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>compress 是一个相当古老的 unix 档案压缩指令,压缩后的档案会加上一个 .Z 延伸档名以区别未压缩的档案,压缩后的档案可以以 uncompress 解压。</p>
<p>若要将数个档案压成一个压缩档,必须先将档案 tar 起来再压缩。由于 gzip 可以产生更理想的压缩比例,一般人多已改用 gzip 为档案压缩工具。</p>
<ul>
<li>c 输出结果至标准输出设备（一般指荧幕） </li>
<li>f 强迫写入档案,若目的档已经存在,则会被覆盖 (force) </li>
<li>v 将程式执行的讯息印在荧幕上 (verbose) </li>
<li>b 设定共同字串数的上限,以位元计算,可以设定的值为 9 至 16 bits 。由于值越大,能使用的共同字串就 越多,压缩比例就越大,所以一般使用预设值 16 bits (bits) </li>
<li>d 将压缩档解压缩 </li>
<li>V 列出版本讯息</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将 source.dat 压缩成 source.dat.Z ,若 source.dat.Z 已经存在,内容则会被压缩档覆盖。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compress -f source.dat </span><br></pre></td></tr></table></figure>

<p>将 source.dat 压缩成 source.dat.Z ,并列印出压缩比例。 -v 与 -f 可以一起使用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compress -vf source.dat </span><br></pre></td></tr></table></figure>

<p>将压缩后的资料输出后再导入 target.dat.Z 可以改变压缩档名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compress -c source.dat &gt; target.dat.Z </span><br></pre></td></tr></table></figure>

<p>-b 的值越大,压缩比例就越大,范围是 9-16 ,预设值是 16 。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compress -b 12 source.dat </span><br></pre></td></tr></table></figure>

<p>将 source.dat.Z 解压成 source.dat ,若档案已经存在,使用者按 y 以确定覆盖档案,若使用 -df 程式则会自动覆盖档案。由于系统会自动加入 .Z 为延伸档名,所以 source.dat 会自动当作 source.dat.Z 处理。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compress -d source.dat </span><br><span class="line">compress -d source.dat.Z </span><br></pre></td></tr></table></figure>

<h1 id="lpd"><a href="#lpd" class="headerlink" title="lpd"></a>lpd</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpd [-l] [#port] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>lpd 是一个常驻的印表机管理程式,它会根据 &#x2F;etc&#x2F;printcap 的内容来管理本地或远端的印表机。&#x2F;etc&#x2F;printcap 中定义的每一个印表机必须在 &#x2F;var&#x2F;lpd 中有一个相对应的目录,目录中以 cf 开头的档案表示一个等待送到适当装置的印表工作。这个档案通常是由 lpr 所产生。 </p>
<p>lpr 和 lpd 组成了一个可以离线工作的系统,当你使用 lpr 时,印表机不需要能立即可用,甚至不用存在。lpd 会自动监视印表机的状况,当印表机上线后,便立即将档案送交处理。这个得所有的应用程式不必等待印表机完成前一工作。 </p>
<ul>
<li>-l: 将一些除错讯息显示在标准输出上。</li>
</ul>
<p>port: 一般而言,lpd 会使用 getservbyname 取得适当的 TCP&#x2F;IP port,你可以使用这个参数强迫 lpd 使用指定的 port。 </p>
<p><strong>范例</strong>： </p>
<p>这个程式通常是由 &#x2F;etc&#x2F;rc.d 中的程式在系统启始阶段执行。 </p>
<h1 id="lpq"><a href="#lpq" class="headerlink" title="lpq"></a>lpq</h1><p><strong>使用方式</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpq [l] [P] [user] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>lpq 会显示由 lpd 所管理的列表机贮列中未完成的项目。 </p>
<p><strong>范例</strong> </p>
<ol>
<li>显示所有在 lp 列表机贮列中的工作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpq -PlpRank Owner Job Files Total Size1st root 238 (standard input) 1428646 bytes</span><br></pre></td></tr></table></figure>

<h1 id="lpr"><a href="#lpr" class="headerlink" title="lpr"></a>lpr</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpr [ -P printer ] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>将档案或是由标准输入送进来的资料送到印表机贮列之中,印表机管理程式 lpd 会在稍后将这个档案送给适当的程式或装置处理。lpr 可以用来将料资送给本地或是远端的主机来处理。</p>
<ul>
<li>-p Printer: 将资料送至指定的印表机 Printer,预设值为 lp。</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将 <a href="http://www.c/">www.c</a> 和 kkk.c 送到印表机 lp。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpr -Plp www.c kkk.c </span><br></pre></td></tr></table></figure>

<h1 id="lprm"><a href="#lprm" class="headerlink" title="lprm"></a>lprm</h1><p><strong>使用方式</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/lprm [P] [file...] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>尚未完成的印表机工作会被放在印表机贮列之中,这个命令可用来将常未送到印表机的工作取消。由于每一个印表机都有一个独立的贮列,你可以用 -P 这个命令设定想要作用的印列机。如果没有设定的话,会使用系统预设的印表机。 </p>
<p>这个命令会检查使用者是否有足够的权限删除指定的档案,一般而言,只有档案的拥有者或是系统管理员才有这个权限。 </p>
<p><strong>范例</strong> </p>
<p>将印表机 hpprinter 中的第 1123 号工作移除 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lprm -Phpprinter 1123 </span><br></pre></td></tr></table></figure>

<p>将第 1011 号工作由预设印表机中移除 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lprm 1011 </span><br></pre></td></tr></table></figure>

<h1 id="fdformat"><a href="#fdformat" class="headerlink" title="fdformat"></a>fdformat</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdformat [-n] device </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>对指定的软碟机装置进行低阶格式化。使用这个指令对软碟格式化的时候,最好指定像是下面的装置： </p>
<ul>
<li>&#x2F;dev&#x2F;fd0d360 磁碟机 A: ,磁片为 360KB 磁碟 </li>
<li>&#x2F;dev&#x2F;fd0h1440 磁碟机 A: ,磁片为 1.4MB 磁碟 </li>
<li>&#x2F;dev&#x2F;fd1h1200 磁碟机 B: ,磁片为 1.2MB 磁碟</li>
</ul>
<p>如果使用像是 &#x2F;dev&#x2F;fd0 之类的装置,如果里面的磁碟不是标准容量,格式化可能会失败。在这种情况之下,使用者可以用 setfdprm 指令先行指定必要参数。 </p>
<ul>
<li>-n 关闭确认功能。这个选项会关闭格式化之后的确认步骤。</li>
</ul>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdformat -n /dev/fd0h1440 </span><br></pre></td></tr></table></figure>

<p>将磁碟机 A 的磁片格式化成 1.4MB 的磁片。并且省略确认的步骤。</p>
<h1 id="mformat"><a href="#mformat" class="headerlink" title="mformat"></a>mformat</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mformat [-t cylinders] [-h heads] [-s sectors] [-l volume_label] [-F] [-I fsVer-sion] [-S sizecode] [-2 sectors_on_track_0] [-M software_sector_size] [-a] [-X] [-C] [-H hidden_sectors] [-r root_sectors] [-B boot_sector] [-0 rate_on_track_0] [-A rate_on_other_tracks] [-1] [-k] drive: </span><br></pre></td></tr></table></figure>

<p>在已经做过低阶格式化的磁片上建立 DOS 档案系统。如果在编译 mtools 的时候把 USE_2M 的参数打开,部分与 2M 格式相关的参数就会发生作用。否则这些参数（像是 S,2,1,M）不会发生作用。</p>
<ul>
<li>-t 磁柱（synlider）数 </li>
<li>-h 磁头（head）数 </li>
<li>-s 每一磁轨的磁区数 </li>
<li>-l 标签 </li>
<li>-F 将磁碟格式化为 FAT32 格式,不过这个参数还在实验中。 </li>
<li>-I 设定 FAT32 中的版本号。这当然也还在实验中。 </li>
<li>-S 磁区大小代码,计算方式为 sector &#x3D; 2^(大小代码 +7) </li>
<li>-c 磁丛（cluster）的磁区数。如果所给定的数字会导致磁丛数超过 FAT 表的限制,mformat 会自动放大磁区数。 </li>
<li>-s </li>
<li>-M 软体磁区大小。这个数字就是系统回报的磁区大小。通常是和实际的大小相同。 </li>
<li>-a 如果加上这个参数,mformat 会产生一组 Atari 系统的序号给这块软碟。 </li>
<li>-X 将软碟格式化成 XDF 格式。使用前必须先用 xdfcopy 指令对软碟作低阶格式化的动作。 </li>
<li>-C 产生一个可以安装 MS-DOS 档案系统的磁碟影像档（disk image）。当然对一个实体磁碟机下这个参数是没有意义的。 </li>
<li>-H 隐藏磁区的数目。这通常适用在格式化硬碟的分割区时,因为通常一个分割区的前面还有分割表。这个参数未经测试,能不用就不用。 </li>
<li>-n 磁碟序号 </li>
<li>-r 根目录的大小,单位是磁区数。这个参数只对 FAT12 和 FAT16 有效。 </li>
<li>-B 使用所指定的档案或是设备的开机磁区做为这片磁片或分割区的开机磁区。当然当中的硬体参数会随之更动。 </li>
<li>-k 尽量保持原有的开机磁区。 </li>
<li>-0 第 0 轨的资料传输率 </li>
<li>-A 第 0 轨以外的资料传输率 </li>
<li>-2 使用 2m 格式 </li>
<li>-1 不使用 2m 格式</li>
</ul>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mformat a: </span><br></pre></td></tr></table></figure>

<p>这样会用预设值把 a: （就是 &#x2F;dev&#x2F;fd0）里的磁碟片格式化。 </p>
<h1 id="mkdosfs"><a href="#mkdosfs" class="headerlink" title="mkdosfs"></a>mkdosfs</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdosfs [ -c | -l filename ] </span><br><span class="line">[ -f number_of_FATs ] </span><br><span class="line">[ -F FAT_size ] </span><br><span class="line">[ -i volume_id ] </span><br><span class="line">[ -m message_file ] </span><br><span class="line">[ -n volume_name ] </span><br><span class="line">[ -r root_dir_entry ] </span><br><span class="line">[ -s sector_per_cluster ] </span><br><span class="line">[ -v ] </span><br><span class="line">device </span><br><span class="line">[ block_count ] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>建立 DOS 档案系统。 device 指你想要建立 DOS 档案系统的装置代号。像是 &#x2F;dev&#x2F;hda1 等等。 block_count 则是你希望配置的区块数。如果 block_count 没有指定则系统会自动替你计算符合该装置大小的区块数。 </p>
<ul>
<li>-c 建立档案系统之前先检查是否有坏轨。 </li>
<li>-l 从得定的档案中读取坏轨记录。 </li>
<li>-f 指定档案配置表（FAT , File Allocation Table）的数量。预设值为 2 。目前 Linux 的 FAT 档案系统不支援超过 2 个 FAT 表。通常这个不需要改。 </li>
<li>-F 指定 FAT 表的大小,通常是 12 或是 16 个位元组。12 位元组通常用于磁碟片,16 位元组用于一般硬碟的分割区,也就是所谓的 FAT16 格式。这个值通常系统会自己选定适当的值。在磁碟片上用 FAT16 通常不会发生作用,反之在硬碟上用 FAT12 亦然。 </li>
<li>-i 指定 Volume ID。一般是一个 4 个位元组的数字,像是 2e203a47 。如果不给系统会自己产生。 </li>
<li>-m 当使用者试图用这片磁片或是分割区开机,而上面没有作业系统时,系统会给使用者一段警告讯息。这个参数就是用来变更这个讯息的。你可以先用档案编辑好,然后用这个参数指定,或是用 -m - 这样系统会要求你直接输入这段文字。要特别注意的是,档案里的字串长度不要超过 418 个字,包括展开的跳栏符号（TAB）和换行符号（换行符号在 DOS 底下算两个字元！） </li>
<li>-n 指定 Volume Name,就是磁碟标签。如同在 DOS 底下的 format 指令一样,给不给都可以。没有预设值。 </li>
<li>-r 指定根目录底下的最大档案数。这里所谓的档案数包括目录。预设值是在软碟上是 112 或是 224 ,在硬碟上是 512。没事不要改这个数字。 </li>
<li>-s 每一个磁丛（cluster）的磁区数。必须是 2 的次方数。不过除非你知道你在作什么,这个值不要乱给。 </li>
<li>-v 提供额外的讯息</li>
</ul>
<p><strong>范例</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdosfs -n Tester /dev/fd0 </span><br></pre></td></tr></table></figure>

<p>将 A 槽里的磁碟片格式化为 DOS 格式,并将标签设为 Tester</p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>FRP配置访问内网NAS</title>
    <url>/2024/05/22/%E8%BD%AF%E4%BB%B6-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-FRP%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91NAS/</url>
    <content><![CDATA[<h1 id="文档-frp-gofrp-org"><a href="#文档-frp-gofrp-org" class="headerlink" title="文档 | frp (gofrp.org)"></a><a href="https://gofrp.org/zh-cn/docs/">文档 | frp (gofrp.org)</a></h1><h1 id="配置时间服务器"><a href="#配置时间服务器" class="headerlink" title="配置时间服务器"></a>配置时间服务器</h1><ul>
<li>打开控制面板 - 选择区域选项</li>
<li>在时间页面选择时间设置</li>
<li>选择与 NTP 服务器同步</li>
<li>输入服务器地址 <a href="ntp1.aliyun.com">ntp1.aliyun.com</a>,然后点击立即更新</li>
</ul>
<h1 id="FRP-配置外网访问-NAS"><a href="#FRP-配置外网访问-NAS" class="headerlink" title="FRP 配置外网访问 NAS"></a>FRP 配置外网访问 NAS</h1><h2 id="1-VPS-服务器端设置"><a href="#1-VPS-服务器端设置" class="headerlink" title="1.VPS 服务器端设置"></a>1.VPS 服务器端设置</h2><p>下载 frp 文件，根据实际要部署的环境的架构利用 <code>wget</code> 下载相应版本</p>
<p><a href="https://github.com/fatedier/frp/releases">下载地址</a></p>
<p>下载完成后 <code>tar -xvf</code> 解压，进入目录，修改 fps.toml 配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#bindAddr = &quot;0.0.0.0&quot;</span><br><span class="line">#绑定的端口</span><br><span class="line">bindPort = 9085</span><br><span class="line">#验证的接口</span><br><span class="line">auth.token = &quot;123456&quot;</span><br><span class="line"></span><br><span class="line">#使能控制面板</span><br><span class="line">#控制面板必须配置port</span><br><span class="line">webServer.addr = &quot;0.0.0.0&quot;</span><br><span class="line">webServer.port = 9086</span><br><span class="line">webServer.user = &quot;lemonade&quot;</span><br><span class="line">webServer.password = &quot;lemonade&quot;</span><br><span class="line"></span><br><span class="line">#输入的日志文件</span><br><span class="line">log.to = &quot;./frps.log&quot;</span><br><span class="line"># trace, debug, info, warn, error</span><br><span class="line">log.level = &quot;info&quot;</span><br><span class="line">log.maxDays = 3</span><br></pre></td></tr></table></figure>

<p>编辑 rc.local 添加自启动脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">cd /home/ubuntu/frpServer/frp_0.52.3_linux_amd64</span><br><span class="line">#按照配置文件启动服务器端</span><br><span class="line">./frps -c ./frps.toml</span><br></pre></td></tr></table></figure>

<h2 id="2-客户端配置"><a href="#2-客户端配置" class="headerlink" title="2.客户端配置"></a>2.客户端配置</h2><ul>
<li>打开控制面板</li>
<li>选择终端机和 SNMP，启动 SSH 功能，设置端口号</li>
<li>打开 mobaxterm 连接 NAS 的 IP 加上设置的 SSH 端口号</li>
<li>进入终端后输入用户名和密码登录，之后输入 <code>sudo -i</code> 进入 root 用户</li>
<li>下载 frp 的下载包，编辑 frpc 的配置文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">serverAddr = &quot;xx.xx.xx.xx&quot;</span><br><span class="line">serverPort = 9085</span><br><span class="line">auth.token=&quot;123456&quot;</span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = &quot;frp-nas&quot;</span><br><span class="line">type = &quot;tcp&quot;</span><br><span class="line">localIP = &quot;0.0.0.0&quot;</span><br><span class="line">localPort = 5000#NAS的端口</span><br><span class="line">remotePort = 9087#暴露到公网的端口，即映射到5000端口</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑启动脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frpc -c ./frpc.toml</span><br></pre></td></tr></table></figure>

<ul>
<li>在 NAS 中添加脚本到任务计划</li>
</ul>
<ul>
<li>进入控制面板，选择任务计划，选择新增 - 触发的任务 - 用户定义的脚本</li>
<li>编辑任务名称，选择账号为 root，事件为开机，勾选已启动</li>
<li>编辑任务设置，编辑运行命令中的内容为 <code>bash /root/start.sh</code></li>
<li>确定保存后在该任务上右击，选择运行</li>
</ul>
<h2 id="3-测试配置"><a href="#3-测试配置" class="headerlink" title="3.测试配置"></a>3.测试配置</h2><p>访问 VPS 地址 + 客户端中 frpc 中的 remotePort 打开页面</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>内网穿透</category>
      </categories>
  </entry>
  <entry>
    <title>远程访问方案</title>
    <url>/2024/05/22/%E8%BD%AF%E4%BB%B6-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="获取公网-IP-DDNS-解析"><a href="#获取公网-IP-DDNS-解析" class="headerlink" title="获取公网 IP+DDNS 解析"></a>获取公网 IP+DDNS 解析</h1><p><strong>什么是 DDNS</strong><br>DDNS 的意思是动态域名解析。是解决公网 IP 不固定的问题，用固定的域名代替动态变化的公网 IP，固定的公网 IP 当然不需要再用 DDNS。</p>
<p>无公网 IP 网络环境用内网穿透方案，即类似如 nat123 内网映射方式，将内网 IP 映射成域名（自动生成二级域名或用自己域名）地址，然后通过域名来访问</p>
<p>DDNS (Dynamic Domain Name System) 是一种可以动态更新域名解析的服务，它可以让您的域名指向一个动态 IP 地址，而不是一个固定的 IP 地址。它可以让您的域名跟随您的设备，而不需要您每次更改 IP 地址时都去更新域名解析。</p>
<p>适用情况：</p>
<p>路由器是公网 IP，但是公网 IP 不固定</p>
<p>检测方法：</p>
<p>用百度搜索 IP，百度会显示当前的 IP 地址，把这个 IP 地址和路由器的 IP 地址作比较，如果一致，说明是公网 IP，如果不一致，说明是运营商用一个 IP 然后经过多层 NAT 之后分配的内网 IP。</p>
<h1 id="隧道穿透-—frp"><a href="#隧道穿透-—frp" class="headerlink" title="隧道穿透 —frp"></a>隧道穿透 —frp</h1><p>  需求公网服务器，将内网端口映射到公网服务器，通过公网服务器 + 端口的形式访问内网端口</p>
<p>  需要了解配置 frps 和 frpc 的配置文件如何配置，针对特定端口进行开放</p>
<p>  <a href="https://github.com/fatedier/frp">frp仓库</a></p>
<p>  <a href="https://github.com/FrpcCluster/frpc-Android">安卓版frpc</a></p>
<p><strong>frps 服务端配置文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#bindAddr = &quot;0.0.0.0&quot;</span><br><span class="line">bindPort = 9085      //内网设备绑定的端口</span><br><span class="line"># auth token</span><br><span class="line">auth.token = &quot;******&quot;    //接入验证码，需要和设备端保持一致</span><br><span class="line"></span><br><span class="line"># Configure the web server to enable the dashboard for frps.</span><br><span class="line"># 使能dashboard(非必要)</span><br><span class="line"># dashboard is available only if webServer.port is set.</span><br><span class="line">webServer.addr = &quot;0.0.0.0&quot;</span><br><span class="line">webServer.port = 9086</span><br><span class="line">webServer.user = &quot;lemonade&quot;</span><br><span class="line">webServer.password = &quot;lemonade&quot;</span><br><span class="line"></span><br><span class="line"># console or real logFile path like ./frps.log  </span><br><span class="line"># 使能log(非必要)</span><br><span class="line">log.to = &quot;./frps.log&quot;      //日志存储位置</span><br><span class="line"># trace, debug, info, warn, error</span><br><span class="line">log.level = &quot;info&quot;        //存储等级</span><br><span class="line">log.maxDays = 3            //时间</span><br></pre></td></tr></table></figure>

<p><strong>frpc 配置文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">serverAddr = &quot;124.222.246.***&quot;      //具有公网IP的服务器地址</span><br><span class="line">serverPort = 9085                   //接入端口</span><br><span class="line">auth.token=&quot;******&quot;                 //接入token</span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = &quot;frp-nas&quot;                  //将本设备的5000端口映射到服务器的9087端口</span><br><span class="line">type = &quot;tcp&quot;                      //类型</span><br><span class="line">localIP = &quot;0.0.0.0&quot;</span><br><span class="line">localPort = 5000                  //本地端口</span><br><span class="line">remotePort = 9087                 //公网端口</span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = &quot;frp-nas-ssh&quot;</span><br><span class="line">type = &quot;tcp&quot;</span><br><span class="line">localIP = &quot;0.0.0.0&quot;</span><br><span class="line">localPort = 9090</span><br><span class="line">remotePort = 9088</span><br></pre></td></tr></table></figure>

<ul>
<li>注意： 需要注意服务器开通指定端口的防火墙</li>
</ul>
<h1 id="构建虚拟局域网-—ZeroTier、Tailscale-以及蒲公英"><a href="#构建虚拟局域网-—ZeroTier、Tailscale-以及蒲公英" class="headerlink" title="构建虚拟局域网 —ZeroTier、Tailscale 以及蒲公英"></a>构建虚拟局域网 —ZeroTier、Tailscale 以及蒲公英</h1><p>  在 <a href="https://www.zerotier.com/">zerotier</a> 创建虚拟局域网，客户端安装后复制虚拟局域网 ID 加入即可实现访问，但是连接速度不稳定</p>
<p>  进阶方式可以自己搭建 moon 服务器和 planet 服务器，但是也需要公网服务器</p>
<p>  <a href="https://github.com/xubiaolin/docker-zerotier-planet">私有部署zerotier-planet服务</a></p>
<p>  <a href="https://github.com/Jonnyan404/zerotier-planet">一分钟自建zerotier-planet</a>  </p>
<h1 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h1><p><a href="https://www.mrdoc.fun/doc/254/">内网穿透 - Jonnyan的原创笔记 - 亖亖亖 (mrdoc.fun)</a></p>
]]></content>
      <categories>
        <category>软件</category>
        <category>内网穿透</category>
      </categories>
  </entry>
  <entry>
    <title>Sqlie使用</title>
    <url>/2024/05/22/%E8%BD%AF%E4%BB%B6-%E6%95%B0%E6%8D%AE%E5%BA%93-Sqlie%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><p>安装数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo  apt-get install sqlite3</span><br></pre></td></tr></table></figure>

<h1 id="数据库指令操作"><a href="#数据库指令操作" class="headerlink" title="数据库指令操作"></a>数据库指令操作</h1><p>打开一个数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite3 my.db</span><br></pre></td></tr></table></figure>

<p>常用查询:</p>
<pre><code>`.table`   				查看数据库中的表

`.schema  tablename`  	查看相应表的结构

`.database` 			查看当前打开的数据库

`.quit` 				退出当前数据库

`.help` 				列出帮助信息
</code></pre>
<p><strong>创建表:</strong><br>    create table movies (id int, name text,  time int, auth text);<br><strong>删除表:</strong><br>    drop   table  tablename;	<br><strong>添加信息:</strong><br>    insert into  movies values (…..);<br>    insert into  movies values (…..);<br><strong>查询信息:</strong><br>    select * from movies ;<br><strong>删除信息:</strong><br>    delete  from movies  where id&#x3D;1;l<br><strong>更新信息:</strong><br>    update  tablename set name&#x3D;’’ where id&#x3D;2;<br><strong>添加字段:</strong><br>    alter table  tablename add column  sex char ;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建名字为tong.db的数据库</span><br><span class="line">sqlite3 tong.db</span><br><span class="line">//创建一个叫user的table,里面有name, age</span><br><span class="line">create table user(name, age integer);</span><br><span class="line">//name的默认类型是字符串，用“taotao”</span><br><span class="line">//age的类型相当于int</span><br><span class="line">//删除一个table</span><br><span class="line">drop table user;</span><br><span class="line">//向user中存储数据</span><br><span class="line">insert into user values（“taotao”, 18）;</span><br><span class="line">//增加一个column叫num,类型是 integer</span><br><span class="line">alter table user add column num integer;</span><br><span class="line">//更新数据</span><br><span class="line">update user set name=&quot;taotao&quot;,age=18 where num=110;</span><br><span class="line">//打印所有信息</span><br><span class="line">select * from user;</span><br><span class="line">//打印某一个信息</span><br><span class="line">select * from user where name=&quot;taotao&quot;;</span><br><span class="line">//删除一个叫taotao的人</span><br><span class="line">delete from user where name=&quot;taotao&quot;;</span><br><span class="line">//查看有哪几个表</span><br><span class="line">.tables</span><br><span class="line">//查看某一个表的属性</span><br><span class="line">.schema user</span><br><span class="line">//退出</span><br><span class="line">.q</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>TV Box源</title>
    <url>/2024/05/22/%E8%BD%AF%E4%BB%B6-%E9%9F%B3%E8%A7%86%E9%A2%91-TV-Box%E6%BA%90/</url>
    <content><![CDATA[<p>FongMi   <a href="https://ghproxy.com/raw.githubusercontent.com/FongMi/CatVodSpider/main/json/config.json">https://ghproxy.com/raw.githubusercontent.com/FongMi/CatVodSpider/main/json/config.json</a></p>
<p>巧技 (需关注公众号) <a href="http://pandown.pro/tvbox/tvbox.json">http://pandown.pro/tvbox/tvbox.json</a></p>
<p>俊于   <a href="http://home.jundie.top:81/top98.json">http://home.jundie.top:81/top98.json</a></p>
<p>霜辉月明 (py)     <a href="https://ghproxy.com/raw.githubusercontent.com/lm317379829/PyramidStore/pyramid/py.json">https://ghproxy.com/raw.githubusercontent.com/lm317379829/PyramidStore/pyramid/py.json</a></p>
<p>小雅 (js)   <a href="http://drpy.site/js1">http://drpy.site/js1</a></p>
<p>菜妮丝 xBPQ <a href="https://tvbox.cainisi.cf/">https://tvbox.cainisi.cf</a></p>
<p>神器   https:&#x2F;&#x2F;神器每日推送.tk&#x2F;pz.json</p>
<p>饭太硬 http:&#x2F;&#x2F;饭太硬.ga&#x2F;x&#x2F;o.json</p>
<p>云星日记     <a href="https://maoyingshi.cc/tvbox/%E4%BA%91%E6%98%9F%E6%97%A5%E8%AE%B0/1.m3u8">https://maoyingshi.cc/tvbox/云星日记/1.m3u8</a></p>
<p>肥猫   http:&#x2F;&#x2F;肥猫.love</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>影视APP</title>
    <url>/2024/05/22/%E8%BD%AF%E4%BB%B6-%E9%9F%B3%E8%A7%86%E9%A2%91-%E5%BD%B1%E8%A7%86APP/</url>
    <content><![CDATA[<p>影视 APP 采用的都是用「套壳＋视频源」的模式，将壳体和视频源分开，接口也有逐渐发展为他人专门提供的趋势</p>
<h1 id="TVBOX"><a href="#TVBOX" class="headerlink" title="TVBOX"></a>TVBOX</h1><p>Github 开源了一个名为 <a href="https://github.com/CatVodTVOfficial/TVBoxOSC">TVBox</a> 的项目：</p>
<p>o0HalfLife0o 最新测试版 APK <a href="https://github.com/o0HalfLife0o/TVBoxOSC/releases/">https://github.com/o0HalfLife0o/TVBoxOSC/releases/</a></p>
<p>APP 设置 » 配置地址，我们需要在这里给 APP 添加视频源之后才能使用</p>
<h2 id="YuanHsing"><a href="#YuanHsing" class="headerlink" title="YuanHsing"></a>YuanHsing</h2><p>YuanHsing 维护的 <a href="https://github.com/YuanHsing/freed/tree/master/TVBox/">TVBOX接口项目</a></p>
<p>如果以上地址失效，你可以到原项目上找到 json 文件获取文件的 raw 地址进行添加，不过由于现在墙的存在，我们不能直接订阅 Github 原生文件地址，需要将链接稍作修改，改成经过 CDN 加速后的地址，才可以使用：</p>
<p>jsDelivr 加速地址：</p>
<p><a href="https://gcore.jsdelivr.net/gh/YuanHsing/freed@master/TVBox/meow.json">https://gcore.jsdelivr.net/gh/YuanHsing/freed@master/TVBox/meow.json</a></p>
<p>Statically 加速地址：</p>
<p><a href="https://cdn.staticaly.com/gh/YuanHsing/freed/master/TVBox/meow.json">https://cdn.staticaly.com/gh/YuanHsing/freed/master/TVBox/meow.json</a></p>
<p>jsDelivr、Statically 这俩个加速服务还是挺稳的，不过具体文件名可能以后会有变化，如果文件名变化了，自行修改上面两个链接末尾的 meow.json 就行了</p>
<p>导入之后，返回一下首页，等待 jar 文件加载成功，再到设置 » 首页数据源</p>
<h2 id="在代码托管平台上找视频源"><a href="#在代码托管平台上找视频源" class="headerlink" title="在代码托管平台上找视频源"></a>在代码托管平台上找视频源</h2><p>在 Github 上其实有很多程序员在维护自用的 TVBOX 接口，而 Github 上的代码多数都是公开的，搜索方法也很简单，在 github.com 上搜索关键词：TVBOX，然后再右上角 Sort 筛选这里，选择 Recently upload 最近更新</p>
<p>然一般我们只需要找到项目里面的 json 文件，然后点进去看一下 json 文件的具体代码，看看代码里面有没有关键词 TVBOX，有的话，就基本上就可以断定这是一个可用的 TVBOX 接口了，如果你有安装相关的 Github 加速油猴脚本，那直接从上面直接复制 json 文件的加速地址，添加到 TVBOX 就行了，如果没安装相关脚本的话，可以参照本文 1.1 节，将文件链接格式修改为 jsDelivr、Statically 等的加速链接即可使用，同理在 Gitee 上也能找到一些 TVBOX 相关的接口分享项目，虽然相关项目比较少，但优点是 Gitee.com 在国内可以直接访问，接口文件也是直接添加即可（注意是添加原始数据链接）</p>
<h2 id="TVBox-软件接口大全"><a href="#TVBox-软件接口大全" class="headerlink" title="TVBox 软件接口大全"></a>TVBox 软件接口大全</h2><p>来源 <a href="https://maoyingshi.cc/%E6%8E%A5%E5%8F%A3%E5%B1%95%E7%A4%BA/">某公众号在线TVBox软件接口大全</a></p>
<p>来源于导航站 <a href="https://www.yydsys.top/box/api/">风向标导航</a></p>
<h1 id="海阔视界"><a href="#海阔视界" class="headerlink" title="海阔视界"></a>海阔视界</h1><h2 id="官方-Github"><a href="#官方-Github" class="headerlink" title="官方 Github"></a>官方 Github</h2><p>海阔视界的 <a href="https://github.com/qiusunshine/hiker-rules/tree/master/rules">官方规则 Github 分享地址</a></p>
<p>你能在这里找到很多由官方维护与更新的规则文件，这里注意一下最后的更新时间，这里我们找一个最近不久才更新的规则，还是一样的：如果你有安装相关的 Github 加速油猴脚本，那直接从上面直接复制 json 文件的加速地址，如果没安装相关脚本的话，可以参照本文 1.1 节，先将文件链接格式修改为 jsDelivr、Statically 等的加速链接，比如这个规则的加速地址之一是：</p>
<p><a href="https://cdn.staticaly.com/gh/qiusunshine/hiker-rules/master/rules/2022-8-2.txt">https://cdn.staticaly.com/gh/qiusunshine/hiker-rules/master/rules/2022-8-2.txt</a></p>
<p>但注意我们还不能直接就这样导入到海阔海阔视界，你需要在规则文件的链接前再加上一个前缀：海阔视界￥home_rule_url￥</p>
<p>即我们将链接拼接成：</p>
<p><code>海阔视界￥home_rule_url￥https://cdn.staticaly.com/gh/qiusunshine/hiker-rules/master/rules/2022-8-2.txt</code></p>
<p>这样就可以将其导入到海阔视界了（如果导入后没反应，可以尝试多导入几次）</p>
<p>导入成功后，再回到 APP 主页，你就会发现上面多出了各种合集，而在这里就能轻松进行聚合影视搜索了</p>
<p>虽然他其实就是网页聚合搜索，但搭配上海阔影视不错的广告拦截效果，观看体验还是很不错的</p>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><p>直接关注 APP 的官方公众号：新方圆小棉袄、海阔视界小棉袄这俩个公众号都时不时会分享海阔视界的规则，并且可以从公众号上一键复制</p>
<h1 id="ZY-Player"><a href="#ZY-Player" class="headerlink" title="ZY-Player"></a>ZY-Player</h1><p>内置源已经全部失效，APP 下载链接：</p>
<p><a href="https://github.com/cuiocean/ZY-Player-APP">https://github.com/cuiocean/ZY-Player-APP</a></p>
<h2 id="YuanHsing-1"><a href="#YuanHsing-1" class="headerlink" title="YuanHsing"></a>YuanHsing</h2><p><a href="https://github.com/YuanHsing/freed/tree/master/ZY-Player">https://github.com/YuanHsing/freed/tree/master/ZY-Player</a></p>
<p>虽然你可以到视频源文件写了 PC 两个字，但实际上是通用的，安卓端也可以使用还是一样的，由于现在墙的存在，我们不能直接订阅 Github 原生文件地址，需要将链接稍作修改，改成经过 CDN 加速后的地址，才可以使用：</p>
<p>jsDelivr 加速地址：</p>
<p><a href="https://gcore.jsdelivr.net/gh/YuanHsing/freed@master/ZY-Player/ZY-Player-PC.json">https://gcore.jsdelivr.net/gh/YuanHsing/freed@master/ZY-Player/ZY-Player-PC.json</a></p>
<p>Statically 加速地址：</p>
<p><a href="https://cdn.staticaly.com/gh/YuanHsing/freed/master/ZY-Player/ZY-Player-PC.json">https://cdn.staticaly.com/gh/YuanHsing/freed/master/ZY-Player/ZY-Player-PC.json</a></p>
<h2 id="在代码托管平台上找视频源-1"><a href="#在代码托管平台上找视频源-1" class="headerlink" title="在代码托管平台上找视频源"></a>在代码托管平台上找视频源</h2><p>在代码托管平台上找 ZY-Player 的公开视频源，但 ZY-Player 就比较推荐到 Gitee 上找视频源了，相关的仓库会多一点，方法还是一样的很简单，在 Gitee.com 上搜索 ZY-Player，并按最近更新排序，随便点进一个项目，发现在根目录并没有找到 json 文件，没关系，看到有一个名为 resources（资源）的文件夹，点进去，果然里面有一个最近不久才更新的 json 文件，这个就是视频源，然后我们在源代码这里，点击原始数据，获取文件直链，将这个直链添加进 ZY-Player，然后就能在首页切换网站查看</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>CAN Open Linux 调试</title>
    <url>/2024/05/24/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN-Open-Linux-%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>作为 CAN Open 总线上的数据抓取设备，要求程序具有以下功能</p>
<ul>
<li>能够作为总线上的从机设备，要求具有以下功能：<ul>
<li>HeartBeat</li>
<li>本设备 SDO 配置项</li>
<li>PDO 数据配置</li>
<li>如何通过主机 ASK 某一设备的数据</li>
</ul>
</li>
<li>能够作为总线上的主机设备，要求具有以下功能：<ul>
<li>从机设备的状态管理</li>
<li>PDO 数据采集</li>
</ul>
</li>
</ul>
<p>例如，预配置的过程数据对象 (PDO) 由生产者传输。每个 PDO 可能由多个节点使用。每个 CANopen 设备的其他有用的 CANopen 功能还包括：心跳生产者和消费者、紧急生产者、同步生产者或消费者、时间生产者或消费者、SDO 服务器（服务数据对象 - 从对象字典中提供变量）、NMT 从属（网络管理 - 启动或停止通信部分）、LSS 从属（节点 ID 和比特率的配置）。</p>
<p>CANopen 网络通常有一个具有命令功能的设备用于网络配置，例如：NMT 主站、LSS 主站、SDO 客户端、紧急消费者。CANopenNode 中的命令功能根据标准 CiA309-3 使用 Ascii 命令行接口实现。</p>
<h1 id="使能-CAN-Open-网络"><a href="#使能-CAN-Open-网络" class="headerlink" title="使能 CAN Open 网络"></a>使能 CAN Open 网络</h1><p>利用 modprobe 创建 Linux 下 CAN 设备</p>
<p><em><code>modprobe</code> 是 Linux 系统中的一个命令行工具，用于管理内核模块。内核模块是可以动态加载或卸载的可扩展组件，允许 Linux 内核在运行时添加或删除功能而不需要重启系统。常见的内核模块包括设备驱动程序、文件系统支持以及网络协议等。</em></p>
<p>创建一个虚拟 CAN 设备，并启用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo modprobe vcan</span><br><span class="line">sudo ip <span class="built_in">link</span> add dev can0 <span class="built_in">type</span> vcan</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> up can0</span><br></pre></td></tr></table></figure>

<p>安装 CAN 监测调试工具，can-utils</p>
<p>项目地址 <a href="https://github.com/linux-can/can-utils">https://github.com/linux-can/can-utils</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install can-utils</span><br><span class="line">candump -td can0 <span class="comment">#显示can消息</span></span><br></pre></td></tr></table></figure>

<p>*rk3568 的 can 使用时 ip link set can0 up 启用失败报错：<br>can0: incorrect missing data bit-timing<br>驱动问题，设备树中的节点配置，需要将 kernel&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi 中的 can0 节点中的 compatible &#x3D; “rockchip,canfd-1.0”修改为 compatible &#x3D; “rockchip,can-1.0”，重新编译后下载</p>
<p>启动 3568 的 CAN</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig can0 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 500000</span><br><span class="line">ifconfig can0 up</span><br><span class="line"></span><br><span class="line">ifconfig can1 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 up <span class="built_in">type</span> can bitrate 500000</span><br><span class="line">ifconfig can1 up</span><br><span class="line"></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 1000000 sample-point 0.75 dbitrate 4000000 dsample-point 0.8 fd on</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 up <span class="built_in">type</span> can bitrate 1000000 sample-point 0.75 dbitrate 4000000 dsample-point 0.8 fd on</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询当前网络设备:</span></span><br><span class="line">ifconfig -a</span><br><span class="line"><span class="comment">#关闭CAN:</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 down</span><br><span class="line"><span class="comment">#设置比特率500KHz:</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> can bitrate 500000</span><br><span class="line"><span class="comment">#打印can0信息:</span></span><br><span class="line">ip -details -statistics <span class="built_in">link</span> show can0</span><br><span class="line"><span class="comment">#启动CAN:</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up</span><br><span class="line"><span class="comment">#发送（标准帧,数据帧,ID:123,date:DEADBEEF）:</span></span><br><span class="line">cansend can0 123<span class="comment">#DEADBEEF</span></span><br><span class="line"><span class="comment">#发送（标准帧,远程帧,ID:123）:</span></span><br><span class="line">cansend can0 123<span class="comment">#R</span></span><br><span class="line"><span class="comment">#发送（扩展帧,数据帧,ID:00000123,date:DEADBEEF）:</span></span><br><span class="line">cansend can0 00000123<span class="comment">#12345678</span></span><br><span class="line"><span class="comment">#发送（扩展帧,远程帧,ID:00000123）:</span></span><br><span class="line">cansend can0 00000123<span class="comment">#R</span></span><br><span class="line"><span class="comment">#开启打印，等待接收:</span></span><br><span class="line">candump can0</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"><span class="comment">#设置can fd</span></span><br><span class="line"><span class="comment">#设置仲裁段1M波特率，数据段3M波特率:</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> can bitrate 1000000 dbitrate 3000000 fd on</span><br><span class="line"><span class="comment">#发送（标准帧,数据帧,ID:123,date:DEADBEEF）:</span></span><br><span class="line">cansend can0 123<span class="comment">##1DEADBEEF</span></span><br><span class="line"><span class="comment">#发送（扩展帧,数据帧,ID:00000123,date:DEADBEEF）:</span></span><br><span class="line">cansend can0 00000123<span class="comment">##1DEADBEEF</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="CAN-通信测试工具"><a href="#CAN-通信测试工具" class="headerlink" title="CAN 通信测试工具"></a>CAN 通信测试工具</h1><p>canutils 是常用的 CAN 通信测试工具包，内含 5 个独立的程序：canconfig、candump、canecho、cansend、cansequence。</p>
<p>这几个程序的功能简述如下：</p>
<p><code>canconfig</code> 用于配置 CAN 总线接口的参数，主要是波特率和模式。</p>
<p><code>candump</code> 从 CAN 总线接口接收数据并以十六进制形式打印到标准输出，也可以输出到指定文件。</p>
<p><code>canecho</code> 把从 CAN 总线接口接收到的所有数据重新发送到 CAN 总线接口。</p>
<p><code>cansend</code> 往指定的 CAN 总线接口发送指定的数据。</p>
<p><code>cansequence</code> 往指定的 CAN 总线接口自动重复递增数字，也可以指定接收模式并校验检查接收的递增数字。</p>
<p><code>ip</code> CAN 波特率、功能等配置。</p>
<p>注意：busybox 里也有集成了 ip 工具，但 busybox 里的是阉割版本。不支持 CAN 的操作。故使用前请先确定 ip 命令的版本（iproute2）。上面工具包，网络上都有详细的编译说明。如果是自己编译 buildroot，直接开启宏就可以支持上述工具包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BR2_PACKAGE_CAN_UTILS=y</span><br><span class="line">BR2_PACKAGE_IPROUTE2=y</span><br></pre></td></tr></table></figure>

<h1 id="CAN-比特率和采样点计算"><a href="#CAN-比特率和采样点计算" class="headerlink" title="CAN 比特率和采样点计算"></a>CAN 比特率和采样点计算</h1><p>目前 CAN 架构根据输入频率和比特率自动计算。采样点的规则按照 CIA 标准协议：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Use CiA recommended sample points */</span></span><br><span class="line"><span class="keyword">if</span> (bt-&gt;sample_point) &#123;</span><br><span class="line">	sample_point_nominal = bt-&gt;sample_point;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (bt-&gt;bitrate &gt; <span class="number">800000</span>)</span><br><span class="line">		sample_point_nominal = <span class="number">750</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;bitrate &gt; <span class="number">500000</span>)</span><br><span class="line">		sample_point_nominal = <span class="number">800</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sample_point_nominal = <span class="number">875</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比特率计算公式（详细原理可以百度，这里只介绍芯片配置相关）：</p>
<p><code>BitRate = clk_can / (2 *(brq + 1) / ((tseg2 + 1) + (tseg1 + 1) + 1)</code></p>
<p><code>Sample = (1 + (tseg1 + 1)) / (1 + (tseg1 + 1) + (tseg2 + 1))</code></p>
<p>brq、tseg1、tseg2 见 CAN 的 TRM 中 BITTIMING 寄存器。</p>
<h1 id="用例分析"><a href="#用例分析" class="headerlink" title="用例分析"></a>用例分析</h1><h2 id="状态恢复和存储"><a href="#状态恢复和存储" class="headerlink" title="状态恢复和存储"></a>状态恢复和存储</h2><p>紧急信息、错误寄存器和 NMT 运行前状态在未初始化的非易失性存储器中都有数据源。对象 0x1010 和 0x1011 用于存储和恢复数据，通常来自 CANopen 对象字典。</p>
<p><em><code>CO_EM_NON_VOLATILE_MEMORY</code> 是一般的严重错误，默认情况下会设置 CANopen 错误寄存器。如果错误寄存器的值不为零，则可能禁止节点进入 NMT 操作状态，并且无法与其交换 PDO。</em></p>
<p>恢复所有非易失性存储器：</p>
<ul>
<li><p>CAN ID：0x600 + 节点 ID（表示从主机到从节点的 SDO 请求）。0x600 + 4 &#x3D; 0x604。</p>
</li>
<li><p>命令字节：表示写入命令和数据长度。0x23 表示写入 4 字节数据（visible string）。</p>
</li>
<li><p>索引：对象字典索引。0x1011（字节顺序为低字节在前）。</p>
</li>
<li><p>子索引：对象字典子索引。0x01</p>
</li>
<li><p>数据：load：ASCII 码 l、o、a、d 分别为 0x6C、0x6F、0x61、0x64。</p>
</li>
<li><p>构建数据恢复 CAN 帧 </p>
<ul>
<li>CAN ID：0x604。</li>
<li>数据：命令字节（0x23），索引（0x11 0x10），子索引（0x01），数据（0x6C 0x6F 0x61 0x64）。</li>
<li><code>can0 604 [8] 23 11 10 01 6C 6F 61 64</code></li>
</ul>
</li>
<li><p><code>save</code>：ASCII 码 <code>s</code>、<code>a</code>、<code>v</code>、<code>e</code> 分别为 <code>0x73</code>、<code>0x61</code>、<code>0x76</code>、<code>0x65</code>。</p>
</li>
<li><p>构建数据存储 CAN 帧</p>
<ul>
<li><strong>CAN ID</strong>：0x604。</li>
<li><strong>数据</strong>：命令字节（0x23），索引（0x10 0x10），子索引（0x01），数据（0x73 0x61 0x76 0x65）。</li>
<li><code>can0  604   [8]  23 10 10 01 73 61 76 65</code></li>
</ul>
</li>
</ul>
<h2 id="设置-NMT-状态"><a href="#设置-NMT-状态" class="headerlink" title="设置 NMT 状态"></a>设置 NMT 状态</h2><p>报文可以发送给特定节点或所有节点。它们可以重置设备、通信或将远程设备的内部状态设置为运行、预运行（禁用 PDO）或停止（仅启用心跳生产者和 NMT 消费者）。</p>
<p>当出现了设置错误寄存器的紧急状况时，start 不起作用。</p>
<p>设置 Node ID 为 4 的设备状态为 reset。</p>
<p><code>000 82 04</code></p>
<table>
<thead>
<tr>
<th align="center">Byte 0 取值（命令）</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td>start_remote_node</td>
</tr>
<tr>
<td align="center">02</td>
<td>stop_remote_node</td>
</tr>
<tr>
<td align="center">80</td>
<td>enter_pre-operational</td>
</tr>
<tr>
<td align="center">81</td>
<td>reset_node</td>
</tr>
<tr>
<td align="center">82</td>
<td>reset_communication</td>
</tr>
</tbody></table>
<h2 id="设置心跳包"><a href="#设置心跳包" class="headerlink" title="设置心跳包"></a>设置心跳包</h2><h3 id="读取心跳时间设置"><a href="#读取心跳时间设置" class="headerlink" title="读取心跳时间设置"></a>读取心跳时间设置</h3><p><code>CAN0 604 [8] 40 17 10 00 00 00 00 00</code></p>
<h3 id="写入心跳时间设置"><a href="#写入心跳时间设置" class="headerlink" title="写入心跳时间设置"></a>写入心跳时间设置</h3><ul>
<li><strong>CAN ID</strong>：0x600 + 节点 ID（4）&#x3D; 0x604。</li>
<li><strong>命令字节</strong>：<code>0x2B</code> 表示写入 2 字节（u16）。</li>
<li><strong>索引</strong>：0x1017（字节顺序为 <code>17 10</code>）。</li>
<li><strong>子索引</strong>：0x00。</li>
<li><strong>数据</strong>：1000ms&#x3D;<code>0x03E8</code>，字节顺序为 <code>E8 03</code>。10000ms&#x3D;<code>0x2710</code></li>
<li><code>can0 604 [8] 2B 17 10 00 E8 03 00 00</code></li>
</ul>
<h2 id="PDO-配置"><a href="#PDO-配置" class="headerlink" title="PDO 配置"></a>PDO 配置</h2><p>按以下步骤通过写入 OD 变量配置 PDO：</p>
<ul>
<li>将 PDO 通信参数 COB-ID 中的第 31 位设置为 1，禁用 PDO。</li>
<li>只有禁用 PDO 时才能配置 Node-Id。</li>
<li>将 PDO 映射参数，子索引 0 设置为 0，禁用映射。</li>
<li>配置映射</li>
<li>通过设置 PDO 映射参数，子索引 0 至映射对象数启用映射</li>
<li>通过将 PDO 通信参数 COB-ID 中的第 31 位设置为 0 来启用 PDO</li>
</ul>
<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="同步传输信号配置"><a href="#同步传输信号配置" class="headerlink" title="同步传输信号配置"></a>同步传输信号配置</h2><p>全局同步周期 SYNC 设置值保存在对象 1006h 中。</p>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>CANopen 主站的对象 1016h 的值(接收器心跳时间)变为自动优化后的值。 对象 1017h 的值(发生器心跳时间)被此处设置的值重写。适用于所有从站对象的对象 1017h(发生器心跳时间)的值被此处设置的值重写，对象 1016h 的值(接收器心跳时间)变为自动优化后的值。</p>
<h1 id="CAN-Open-总线建设"><a href="#CAN-Open-总线建设" class="headerlink" title="CAN Open 总线建设"></a>CAN Open 总线建设</h1><p>假定在一个 can open 网络中，node1 为主节点，node2 和 node3 为从节点，需要配置 node2，让 node2 接收 node3 的 TPDO 消息。</p>
<h2 id="设备配置"><a href="#设备配置" class="headerlink" title="设备配置"></a>设备配置</h2><table>
<thead>
<tr>
<th align="center">设备名</th>
<th>节点地址</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Node 1</td>
<td>0x01</td>
<td>主节点（NMT Master）</td>
</tr>
<tr>
<td align="center">Node 2</td>
<td>0x02</td>
<td>从节点（NMT Slave）</td>
</tr>
<tr>
<td align="center">Node 3</td>
<td>0x03</td>
<td>从节点（NMT Slave）</td>
</tr>
</tbody></table>
<p>其中 Node3 作为 TPDO 消息发出（生产者），期望 Node2 接收 Node3 消息。</p>
<h2 id="PDO-参数配置"><a href="#PDO-参数配置" class="headerlink" title="PDO 参数配置"></a>PDO 参数配置</h2><h3 id="配置所需信息"><a href="#配置所需信息" class="headerlink" title="配置所需信息"></a>配置所需信息</h3><p>配置 Node 3 的 TPDO：</p>
<ul>
<li>确定 Node 3 的 TPDO 消息的 COB-ID 和映射对象。</li>
<li>在 Node 3 的对象字典中设置 TPDO 通信参数和映射参数。</li>
</ul>
<p>配置 Node 2 的 RPDO：</p>
<ul>
<li>设置 Node 2 的 RPDO 通信参数，使其接收 Node 3 的 TPDO 消息。</li>
<li>配置 Node 2 的 RPDO 映射参数，以处理从 Node 3 接收到的数据。</li>
</ul>
<h3 id="通讯参数和映射参数（OD）"><a href="#通讯参数和映射参数（OD）" class="headerlink" title="通讯参数和映射参数（OD）"></a>通讯参数和映射参数（OD）</h3><p>Node 3 的配置：</p>
<ul>
<li>TPDO 通信参数（0x1802）：<ul>
<li>子索引 0x01: COB-ID &#x3D; 0x183</li>
<li>子索引 0x02: 传输类型（例如 0xFF，事件触发）</li>
</ul>
</li>
<li>TPDO 映射参数（0x1A02）：<ul>
<li>子索引 0x00: 映射对象数量 &#x3D; 2</li>
<li>子索引 0x01: 0x60000208（对象 0x6000，子索引 0x02，8 位）</li>
<li>子索引 0x02: 0x64010110（对象 0x6401，子索引 0x01，16 位）</li>
</ul>
</li>
</ul>
<p>Node 2 的配置：</p>
<ul>
<li>RPDO 通信参数（0x1400）：<ul>
<li>子索引 0x01: COB-ID &#x3D; 0x183（与 Node 3 的 TPDO COB-ID 一致）</li>
<li>子索引 0x02: 传输类型（例如 0xFF，事件触发）</li>
</ul>
</li>
<li>RPDO 映射参数（0x1600）：<ul>
<li>子索引 0x00: 映射对象数量 &#x3D; 2</li>
<li>子索引 0x01: 0x60000208（与 Node 3 的 TPDO 映射一致）</li>
<li>子索引 0x02: 0x64010110（与 Node 3 的 TPDO 映射一致）</li>
</ul>
</li>
</ul>
<h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>设置 Node 3 的 TPDO 通信参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAN ID: 0x601 (SDO 请求)</span><br><span class="line">Data: [2B 00 18 02 83 01 00 00]  # 设置 COB-ID 为 0x183（启用）</span><br><span class="line">CAN ID: 0x601 (SDO 请求)</span><br><span class="line">Data: [2B 00 18 02 FF 00 00 00]  # 设置传输类型为 0xFF（事件触发）</span><br></pre></td></tr></table></figure>

<p>设置 Node 3 的 TPDO 映射参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAN ID: 0x601 (SDO 请求)</span><br><span class="line">Data: [2F 00 1A 02 00 00 00 00]  # 禁用 TPDO 映射</span><br><span class="line">CAN ID: 0x601 (SDO 请求)</span><br><span class="line">Data: [23 00 1A 02 01 08 02 60]  # 映射对象 0x6000，子索引 0x02，8 位</span><br><span class="line">CAN ID: 0x601 (SDO 请求)</span><br><span class="line">Data: [23 00 1A 02 02 10 01 64]  # 映射对象 0x6401，子索引 0x01，16 位</span><br><span class="line">CAN ID: 0x601 (SDO 请求)</span><br><span class="line">Data: [2F 00 1A 02 02 00 00 00]  # 启用 TPDO 映射</span><br></pre></td></tr></table></figure>

<p>设置 Node 2 的 RPDO 通信参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAN ID: 0x602 (SDO 请求)</span><br><span class="line">Data: [2B 00 14 00 83 01 00 00]  # 设置 COB-ID 为 0x183</span><br><span class="line">CAN ID: 0x602 (SDO 请求)</span><br><span class="line">Data: [2B 00 14 02 FF 00 00 00]  # 设置传输类型为 0xFF（事件触发）</span><br></pre></td></tr></table></figure>

<p>设置 Node 2 的 RPDO 映射参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAN ID: 0x602 (SDO 请求)</span><br><span class="line">Data: [2F 00 16 00 00 00 00 00]  # 禁用 RPDO 映射</span><br><span class="line">CAN ID: 0x602 (SDO 请求)</span><br><span class="line">Data: [23 00 16 01 08 02 60]  # 映射对象 0x6000，子索引 0x02，8 位</span><br><span class="line">CAN ID: 0x602 (SDO 请求)</span><br><span class="line">Data: [23 00 16 02 10 01 64]  # 映射对象 0x6401，子索引 0x01，16 位</span><br><span class="line">CAN ID: 0x602 (SDO 请求)</span><br><span class="line">Data: [2F 00 16 00 02 00 00 00]  # 启用 RPDO 映射</span><br></pre></td></tr></table></figure>

<p>通过上述步骤配置 Node 2 的 RPDO 通信参数和映射参数，使其能够接收和处理来自 Node 3 的 TPDO 消息。这种配置确保了 Node 2 能够正确接收和解析 Node 3 发送的 TPDO 数据，完成数据的有效传输和处理。</p>
<h1 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h1><p>控制 NMT 状态</p>
<p><code>CAN0 000 [2] 01 04</code>&#x2F;<code>CAN0 000 [2] 02 04</code> 控制节点 4</p>
<p><code>CAN0 000 [2] 01 00</code>&#x2F;<code>CAN0 000 [2] 02 00</code> 控制所有节点</p>
<p>发送 SYNC 信号</p>
<p><code>CAN0 080 [0]</code></p>
<p>发送 ERROR 信号</p>
<p><code>CAN0 084 [8] 数据区根据实际错误定义</code></p>
<p>恢复参数，在 1011 的 01 写入 load</p>
<p><code>CAN0 604 [8] 23 11 10 01 6C 6F 61 64</code></p>
<p>读取 1005 信息（SYNC 的 COB-ID）</p>
<p><code>CAN0 604 [8] 40 05 10 00 00 00 00 00</code></p>
<p>配置 1005 信息，设 SYNC 的 COB-ID 为 0x80（默认值）。</p>
<p>&#96;CAN0 604 [8] 23 05 10 00 80 00 00 00</p>
<p>读取 1006 信息(SYNC 通信周期)</p>
<p>&#96;CAN0 604 [8] 40 06 10 00 00 00 00 00</p>
<p>写入 1006 信息，将 SYNC 的通信周期设置为 100ms，那么需要写入到 <code>0x1006</code> 的值为 100000（100ms &#x3D; 100000us）。</p>
<p><code>CAN0 604 [8] 23 06 10 00 A0 86 01 00</code></p>
<p>读取心跳时间设置</p>
<p><code>CAN0 604 [8] 40 17 10 00 00 00 00 00</code></p>
<p>通过配置 0x1017 的 heartbeat 时间，自动上报设备状态。</p>
<p><code>CAN0 604 [8] 2B 17 10 00 E8 03 00 00</code></p>
<h2 id="设置一个-TPDO"><a href="#设置一个-TPDO" class="headerlink" title="设置一个 TPDO"></a>设置一个 TPDO</h2><p>配置 1800 的上报方式为异步，读取的话改 2F 为 40</p>
<p><code>CAN0 604 [8] 2F 00 18 02 FF 00 00 00</code></p>
<p>配置 1800 的上报事件为 100ms（子索引 05）（数据类型 uint16）</p>
<p><code>CAN0 604 [8] 2B 00 18 05 64 00 00 00</code>（单位为 ms）</p>
<p>设置子索引禁用</p>
<p><code>CAN0 604 [8] 2F 00 1A 00 00 00 00 00</code> </p>
<p>0x40300010，设置映射索引 0x4030，子索引 00，大小 0x10（16 位）</p>
<p><code>CAN0 604 [8] 23 00 1A 01 10 00 30 40</code></p>
<p>0x20100020，设置映射索引 0x2010，子索引 00，大小 0x20（32 位）</p>
<p><code>CAN0 604 [8] 23 00 1A 02 20 00 10 20</code></p>
<p>设置映射数量，用多少设多少，这里用了 2 个</p>
<p><code>CAN0 604 [8] 2F 00 1A 00 02 00 00 00</code> </p>
<h2 id="设置-RPDO"><a href="#设置-RPDO" class="headerlink" title="设置 RPDO"></a>设置 RPDO</h2><p>配置 1400 接收来自 181 的数据</p>
<p><code>CAN0 601 [8] 23 00 14 01 81 01 00 00</code></p>
<p>配置 1400 的上报方式为异步，读取的话改 2F 为 40</p>
<p><code>CAN0 601 [8] 2F 00 14 02 FF 00 00 00</code></p>
<p>配置 1400 的上报事件为 100ms（子索引 05）（数据类型 uint16）</p>
<p><code>CAN0 601 [8] 2B 00 14 05 64 00 00 00</code>（单位为 ms）</p>
<p>设置子索引禁用</p>
<p><code>CAN0 601 [8] 2F 00 1A 00 00 00 00 00</code> </p>
<p>0x40300010，设置映射索引 0x4030，子索引 00，大小 0x10（16 位）</p>
<p><code>CAN0 601 [8] 23 00 1A 01 10 00 30 40</code></p>
<p>0x20100020，设置映射索引 0x2010，子索引 00，大小 0x20（32 位）</p>
<p><code>CAN0 601 [8] 23 00 1A 02 20 00 10 20</code></p>
<p>设置映射数量，用多少设多少，这里用了 2 个</p>
<p><code>CAN0 601 [8] 2F 00 1A 00 02 00 00 00</code> </p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CAN Open Linux代码分析</title>
    <url>/2024/05/28/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN-Open-Linux%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="主文件-CO-main-basic-c"><a href="#主文件-CO-main-basic-c" class="headerlink" title="主文件 CO_main_basic.c"></a>主文件 <code>CO_main_basic.c</code></h1><p>进入 Main 函数中运行，最开始都是一些关于存储&#x2F;多线程&#x2F;功能启用部分的配置代码，后面我们会根据宏定义来讲解。实际的第一行初始化代码从以下开始。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> heapMemoryUsed = <span class="number">0</span>;</span><br><span class="line">CO_config_t *config_ptr = <span class="literal">NULL</span>;</span><br><span class="line">CO = CO_new(config_ptr, &amp;heapMemoryUsed);</span><br></pre></td></tr></table></figure>

<p>该函数的作用是创建一个 CAN open 对象，在单个 OD 的情况下，config 应为 NULL，参数从默认的 “OD.h “文件中获取。如果定义了 CO_USE_GLOBALS，那么函数将为所有 CANopenNode 对象使用全局静态变量。否则，它将从堆中分配所有对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_epoll_t epMain;</span><br><span class="line">err = CO_epoll_create(&amp;epMain, MAIN_THREAD_INTERVAL_US);</span><br></pre></td></tr></table></figure>

<p>该函数创建 Linux epoll 监控 timerfd 和 eventfd。创建并配置多个 Linux 通知，以触发任务的执行。CO_epoll_create 中实现了 epoll 拦截并监控多个文件描述符，其中 timerfd 以恒定的定时器间隔触发，eventfd 则根据外部信号触发。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_CANptrSocketCan_t CANptr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">CANptr.can_ifindex = if_nametoindex(<span class="string">&quot;can0&quot;</span>);</span><br><span class="line">CANptr.epoll_fd = epMain.epoll_fd;</span><br></pre></td></tr></table></figure>

<p>设置用于 CO_CANinit 的指针参数，主要传入 CAN 设备名和监控的 epoll 描述符。</p>
<p>之后进入 CAN open 通讯初始化阶段，注意该阶段是可以通过 0x82 命令，即 CANopen communication reset 重置的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_CANsetConfigurationMode((<span class="type">void</span> *)&amp;CANptr);</span><br><span class="line">CO_CANmodule_disable(CO-&gt;CANmodule);</span><br></pre></td></tr></table></figure>

<p>进入 CAN 配置，主要还是在通过 0x82 命令重启后，禁用 CANmodule 模块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = CO_CANinit(CO, (<span class="type">void</span> *)&amp;CANptr, <span class="number">0</span> <span class="comment">/* bit rate not used */</span>);</span><br></pre></td></tr></table></figure>

<p>初始化 CAN 驱动，如果是通过 0x82 命令重启的通讯，也必须重新初始化。其中的波特率参数在 Linux 部分中还不被支持。之后是 LSS 部分的初始化，该部分内容属于 CiA 305，先略过，之后有时间在分析实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NMT_CONTROL \</span></span><br><span class="line"><span class="meta">            CO_NMT_STARTUP_TO_OPERATIONAL \</span></span><br><span class="line"><span class="meta">          | CO_NMT_ERR_ON_ERR_REG \</span></span><br><span class="line"><span class="meta">          | CO_ERR_REG_GENERIC_ERR \</span></span><br><span class="line"><span class="meta">          | CO_ERR_REG_COMMUNICATION</span></span><br><span class="line">          </span><br><span class="line">err = CO_CANopenInit(CO,            <span class="comment">/* CANopen object */</span></span><br><span class="line">				 <span class="literal">NULL</span>,              <span class="comment">/* alternate NMT */</span></span><br><span class="line">				 <span class="literal">NULL</span>,              <span class="comment">/* alternate em */</span></span><br><span class="line">				 OD,                <span class="comment">/* Object dictionary */</span></span><br><span class="line">				 <span class="literal">NULL</span>,              <span class="comment">/* Optional OD_statusBits */</span></span><br><span class="line">				 NMT_CONTROL,       <span class="comment">/* CO_NMT_control_t */</span></span><br><span class="line">				 <span class="number">500</span>,               <span class="comment">/* firstHBTime_ms */</span></span><br><span class="line">				 <span class="number">1000</span>,            <span class="comment">/* SDOserverTimeoutTime_ms */</span></span><br><span class="line">				 <span class="number">500</span>,             <span class="comment">/* SDOclientTimeoutTime_ms */</span></span><br><span class="line">				 <span class="literal">false</span>,           <span class="comment">/* SDOclientBlockTransfer */</span></span><br><span class="line">				 CO_activeNodeId, <span class="comment">//Node ID</span></span><br><span class="line">				 &amp;errInfo);</span><br></pre></td></tr></table></figure>

<p>初始化除 PDO 对象外的 CAN open 通讯协议（同样也必须在 0x82 命令后调用）。</p>
<ul>
<li>CO CANopen 对象。</li>
</ul>
<ul>
<li>em 紧急对象，用于不同的 CANopen 对象内部，通常用于错误报告。如果为空，则使用 <code>co-&gt;em</code>。如果为空，且 <code>co-&gt;CNT_EM</code> 为 0，则函数错误返回。</li>
<li>NMT 如果 <code>co-&gt;CNT_NMT</code> 为 0，则必须指定该对象；如果 <code>co-&gt;CNT_NMT</code> 为 1，则该对象将被忽略，可以为 NULL。<strong>NMT 对象用于 NMT 对象用于在 CO_process()内部检索 NMT 内部状态</strong>。</li>
<li>od CANopen 对象字典。之前有提到的 ODxyz.h 中定义。</li>
<li>OD_statusBits 传递给 CO_EM_init() 的参数。可以为空。</li>
<li>NMTcontrol 传递给 CO_NMT_init() 的参数。</li>
<li>firstHBTime_ms 传递给 CO_NMT_init() 的参数。</li>
<li>SDOserverTimeoutTime_ms 传递给 CO_SDOserver_init() 的参数。</li>
<li>SDOclientTimeoutTime_ms SDO 客户端的默认超时时间毫秒，一般为 500。</li>
<li>SDOclientBlockTransfer 如果为 “true”，则默认在 SDO 客户端设置块传输。</li>
<li>nodeId CANopen 节点 ID（1 … 127）或 0xFF（未配置）。在 CANopen 初始化中，它与 CO_LSSinit() 中的 pendingBitRate 相同。如果为未配置，则某些 CANopen 对象将不会被初始化或处理。</li>
<li>errInfo 也可以在函数返回 CO_ERROR_NO 的非关键错误中设置。</li>
<li>成功时返回 CO_ERROR_NO。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_epoll_initCANopenMain(&amp;epMain, CO);</span><br></pre></td></tr></table></figure>

<p>该函数用于配置 CAN 接收后的自定义回调。自定义回调函数可由应用程序选择性注册，并在操作系统中配置线程。回调函数会在高优先级线程预处理完某些内容后调用，并且必须由低优先级线程进一步处理。例如，当接收到 CAN 报文并进行预处理后，回调应唤醒主线程处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_EM_initCallbackRx(CO-&gt;em, EmergencyRxCallback);</span><br><span class="line">CO_NMT_initCallbackChanged(CO-&gt;NMT, NmtChangedCallback);</span><br><span class="line">CO_HBconsumer_initCallbackNmtChanged(CO-&gt;HBcons, <span class="number">0</span>, <span class="literal">NULL</span>, HeartbeatNmtChangedCallback);</span><br></pre></td></tr></table></figure>

<ul>
<li>CO_EM_initCallbackRx，初始化 Emergency 接收回调函数。该函数在收到错误条件后执行。</li>
<li>CO_NMT_initCallbackChanged，初始化 NMT 状态变化回调函数。该函数在 NMT 状态发生变化后被调用。该函数可能会唤醒处理 NMT 事件的外部任务。第一次调用会立即向消费者提供 当前的 NMT 状态。</li>
<li>CO_HBconsumer_initCallbackNmtChanged，初始化心跳消费者 NMT 更改回调函数，当 NMT 状态发生变化时调用的回调函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_TIME_set(CO-&gt;TIME, time_ms, time_days, TIME_STAMP_INTERVAL_MS);</span><br></pre></td></tr></table></figure>

<p>设置当前时间，并设置生产者的间隔时间为 <code>TIME_STAMP_INTERVAL_MS</code>，以毫秒为单位，此处设置为 10000ms。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = CO_CANopenInitPDO(CO,             <span class="comment">/* CANopen object */</span></span><br><span class="line">						CO-&gt;em,         <span class="comment">/* emergency object */</span></span><br><span class="line">						OD,             <span class="comment">/* Object dictionary */</span></span><br><span class="line">						CO_activeNodeId,</span><br><span class="line">						&amp;errInfo);</span><br></pre></td></tr></table></figure>

<p>必须在通信重置 0x82 部分的末尾调用该函数，否则某些 OD 变量将无法正确映射到 PDO 中。函数参数就是 CAN Open 对象，EM 对象，OD 对象，NodeID 以及错误信息这些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_CANsetNormalMode(CO-&gt;CANmodule);</span><br></pre></td></tr></table></figure>

<p>已完成所有对象初始化，设置状态，准备进入主循环函数。在主循环函数中，通过 epoll 监控多个文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_epoll_wait(&amp;epMain);</span><br><span class="line">CO_epoll_processRT(&amp;epMain, CO, <span class="literal">false</span>);</span><br><span class="line">CO_epoll_processMain(&amp;epMain, CO, GATEWAY_ENABLE, &amp;reset);</span><br><span class="line">CO_epoll_processLast(&amp;epMain);</span><br></pre></td></tr></table></figure>

<ul>
<li>CO_epoll_wait 函数会阻塞，直到 epoll 上注册了以下事件：timerfd、eventfd 或应用程序指定的事件。函数还会计算自上次调用以来的 timeDifference_us 并准备 timerNext_us。</li>
<li>CO_epoll_processLast，epoll 事件的关闭函数，此函数必须在 CO_epoll_wait() 之后调用。在它们之间是应用程序指定的处理函数，可以检查自己的事件并进行处理。应用程序还可以降低 timerNext_us 变量的值。如果将 timerNext_us 变量调低，则将重新配置间隔定时器，并提前触发 CO_epoll_wait()。</li>
<li>CO_epoll_processRT 和 CO_epoll_processMain 指定了处理函数，接下来先说明 CO_epoll_processRT 处理函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CO_CANrxFromEpoll 如果 epoll 事件与任何 CAN 接口匹配，则返回 True。</span></span><br><span class="line">CO_CANrxFromEpoll(co-&gt;CANmodule, &amp;ep-&gt;ev, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">syncWas = CO_process_SYNC(co, ep-&gt;timeDifference_us,pTimerNext_us);</span><br><span class="line">CO_process_RPDO(co, syncWas, ep-&gt;timeDifference_us,pTimerNext_us);</span><br><span class="line">CO_process_TPDO(co, syncWas, ep-&gt;timeDifference_us,pTimerNext_us);</span><br></pre></td></tr></table></figure>

<p>在 CO_epoll_processRT 中处理以上的 SYNC&#x2F;TPDO&#x2F;RPDO 协议。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_CANmodule_process(co-&gt;CANmodule);</span><br><span class="line"></span><br><span class="line">CO_EM_process(co-&gt;em, NMTisPreOrOperational, timeDifference_us, timerNext_us);</span><br><span class="line"></span><br><span class="line">CO_NMT_process(co-&gt;NMT,&amp;NMTstate,timeDifference_us,timerNext_us);</span><br><span class="line"></span><br><span class="line">CO_SDOserver_process(&amp;co-&gt;SDOserver[i], NMTisPreOrOperational, timeDifference_us,timerNext_us);</span><br><span class="line"></span><br><span class="line">CO_HBconsumer_process(co-&gt;HBcons, NMTisPreOrOperational, timeDifference_us, timerNext_us);</span><br><span class="line"></span><br><span class="line">CO_TIME_process(co-&gt;TIME, NMTisPreOrOperational, timeDifference_us);</span><br></pre></td></tr></table></figure>

<p>在 CO_epoll_processMain 中处理了以上的 EM&#x2F;NMT&#x2F;SDOServer&#x2F;HB&#x2F;TIME 协议。</p>
<h2 id="CO-SINGLE-THREAD"><a href="#CO-SINGLE-THREAD" class="headerlink" title="CO_SINGLE_THREAD"></a>CO_SINGLE_THREAD</h2><p>该参数在 Makefile 中通过-D 参数指定，作用是配置程序在单线程中运行。单线程运行时不同的事件（例如 CAN 接收或计时器到期）会触发循环通过堆栈（所有代码都是非阻塞的）。它需要较少的系统资源。</p>
<p>在多线程操作中，除了主线线程外，还建立了一个实时线程。RT 线程每毫秒运行一次，并使用外围设备读&#x2F;写、控制程序或类似程序处理 PDO 和可选应用程序代码。使用此配置必须考虑竞争条件，例如，从主线线程运行的应用程序代码在访问 OD 变量时必须使用 CO_(UN)LOCK_OD 宏。</p>
<h2 id="CO-CONFIG-STORAGE"><a href="#CO-CONFIG-STORAGE" class="headerlink" title="CO_CONFIG_STORAGE"></a>CO_CONFIG_STORAGE</h2><p>该参数由 <code>CO_CONFIG_STORAGE_ENABLE</code> 在 CO_config.h 中使能，主要作用是依据 CiA 301 标准对控制数据进行存储和恢复。数据源通常是对象字典中的一组变量，但并不局限于 OD。在生成对象字典（OD.h 和 OD.c 文件）时，会根据 “存储组 “参数将 OD 变量分组为结构。</p>
<h3 id="OD-对象-0x1010-存储参数"><a href="#OD-对象-0x1010-存储参数" class="headerlink" title="OD 对象 0x1010 - 存储参数"></a>OD 对象 0x1010 - 存储参数</h3><p>OD 对象 0x1010 - 存储参数：</p>
<ul>
<li>子索引 0：支持的最高子索引</li>
<li>子索引 1：保存所有参数，UNSIGNED32</li>
<li>子索引 2：保存通信参数，UNSIGNED32</li>
<li>子索引 3：保存应用参数，UNSIGNED32</li>
<li>子索引 4 - 127：特定于制造商，UNSIGNED32</li>
</ul>
<p>子索引 1 及以上：</p>
<ul>
<li>读取提供有关其存储功能的信息：<ul>
<li>位 0：如果设置，CANopen 设备根据命令保存参数</li>
<li>位 1：如果设置，CANopen 设备自主保存参数</li>
</ul>
</li>
<li>写入值 0x65766173（’s’、’a’、’v’、’e’，从 LSB 到 MSB）可存储相应数据。<br>相应数据。</li>
</ul>
<h3 id="OD-对象-0x1011-恢复默认参数"><a href="#OD-对象-0x1011-恢复默认参数" class="headerlink" title="OD 对象 0x1011 - 恢复默认参数"></a>OD 对象 0x1011 - 恢复默认参数</h3><ul>
<li>子索引 0：支持的最高子索引</li>
<li>子索引 1：恢复所有默认参数，UNSIGNED32</li>
<li>子索引 2：恢复通信默认参数，UNSIGNED32</li>
<li>子索引 3：恢复应用程序默认参数，UNSIGNED32</li>
<li>子索引 4 - 127：特定于制造商，UNSIGNED32</li>
</ul>
<ul>
<li></li>
</ul>
<p>子索引 1 及以上：</p>
<ul>
<li>读取提供有关其恢复能力的信息：<ul>
<li>位 0：如果设置，CANopen 设备恢复参数</li>
</ul>
</li>
<li>写入值 0x64616F6C（’l’、’o’、’a’、’d’从 LSB 到 MSB）可恢复相应数据。<br>相应数据。</li>
</ul>
<h2 id="CO-CONFIG-GTW"><a href="#CO-CONFIG-GTW" class="headerlink" title="CO_CONFIG_GTW"></a>CO_CONFIG_GTW</h2><p>网关对象由标准 CiA 309 - CANopen 从其他网络访问涵盖。它可以将 NMT 主站、SDO 客户端和 LSS 主站用作网关设备。</p>
<p>本次使用中不支持该形式，直接在 CO_config.h 中注释掉该模块即可。</p>
<h1 id="数据字典-OD-操纵"><a href="#数据字典-OD-操纵" class="headerlink" title="数据字典 OD 操纵"></a>数据字典 OD 操纵</h1><p>CANopen 数据字典 OD 基本上是一个 XML 文件，其中包含 CANopen 设备的所有信息。文件的大部分是所有对象字典变量的列表，其中包含所有必要的属性和文档。该文件可使用 OD 编辑器应用程序进行编辑，并可用作数据源，从中生成 CANopenNode 的对象字典。该文件还可用于 CANopen 配置工具，在运行的 CANopen 网络上与 CANopen 设备进行交互。</p>
<p>CANopen 还为 CANopen 设备描述指定了另一种类型的文件。它们是 INI 格式的 EDS 文件。可以在这两种格式之间进行转换。设备描述文件的扩展名为 “XDD”。该文件的名称应包含 CANopen 设备的供应商 ID，以 8 位十六进制数字的形式出现在名称的任意位置，并用下划线分隔。例如 “name1_12345678_name2.XDD”。CANopenNode 包含多个配置文件定义文件，每个 CANopen 对象一个。这些文件的扩展名为 “XPD”。它们采用与 XDD 文件相同的 XML 格式。XML 编辑工具可以使用 XPD 文件将准备好的数据插入正在编辑的设备描述文件 (XDD)。还有扩展名为 “XDC “的设备配置文件。这些文件描述了已配置的 CANopen 设备，并包含其他元素，如默认值、分母和设备调试元素。类似于 INI 格式的 “dcf “文件。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>OD object</strong>是指对象字典中位于特定 16 位索引的对象。CANopen 中有不同类型的 OD 对象：变量、数组和记录（结构）。每个 OD 对象都包含指向实际数据、数据长度和属性的指针。在 OD_objectTypes_t 中被定义。</p>
<p><strong>OD variable</strong> 是指定类型的基本变量。例如：int8_t、uint32_t、float64_t……或数据长度已知或未知的二进制数据序列。每个 OD 变量都以指定的 16 位索引和 8 位子索引存在于对象字典中。</p>
<p><strong>OD entry</strong>指的是结构元素，其中包含 OD 对象的一些基本属性、OD 对象的类型指示以及指向 OD 对象所有必要数据的指针。OD 条目数组以及 OD 条目总数信息代表 CANopenNode 内部定义的对象字典。参见 OD_entry_t 和 OD_t。</p>
<p>应用程序和堆栈可通过通用的 OD_t 对象和 OD_find() 函数访问 OD 对象。无需直接访问定义对象字典的自定义结构。特定 OD 变量的属性可通过 OD_getSub()函数获取。通过 <strong>read</strong> 和 <strong>write</strong> 函数访问实际变量。 OD_getSub() 可以获取这两个函数的指针。参见 OD_stream_t。另请参见快捷方式：  CO_ODgetSetters 用于访问不同类型的数据。</p>
<p><em>可以从不同的线程访问 OD 变量。CANopenNode 基本上在两个线程中运行：快速实时线程（PDO 处理等）和非关键时间主线程（SDO 等）。两个线程都可以访问 OD 变量，因此必须小心谨慎。CANopenNode 使用锁定机制，SDO 服务器在读取或写入 OD 变量时会阻止实时线程的执行。在 CO_storage 中也需要对 OD 变量进行同样的保护。更多信息请参见 CO_driver.h 中的 CO_critical_sections。</em></p>
<h2 id="OD-文件-ODxyz-c-h"><a href="#OD-文件-ODxyz-c-h" class="headerlink" title="OD 文件-ODxyz.c&#x2F;.h"></a>OD 文件-ODxyz.c&#x2F;.h</h2><p>一个 CANopen 设备的实际对象字典由一对 OD_xyz.h 和 ODxyz.c 文件定义。</p>
<p>后缀 “xyz “是对象字典的唯一名称。如果使用单个默认对象字典，则省略后缀。这样就可以配置多个对象字典。</p>
<p>用于定义 OD 的数据安排在多个结构中。不同的 OD 配置有不同的结构。用这些结构创建的数据对象可以是常量，也可以是变量。</p>
<p>实际的 OD 变量位于多个结构（即存储组）中。选定的组可以选择存储到非易失性存储器中。</p>
<p>手动编辑 ODxyz.h&#x2F;.c 文件非常容易出错。</p>
<p>OD 编辑工具可生成成对的 ODxyz.h&#x2F;.c 文件。该工具可以编辑 xml 格式的标准 CANopen 设备描述文件。Xml 文件可能还包括一些 CANopenNode 特有的非标准元素。然后，Xml 文件将用于自动生成 ODxyz.h&#x2F;.c 文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* OD data declaration of all groups ******************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> x1000_deviceType;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> maxSubIndex;</span><br><span class="line">        <span class="type">uint32_t</span> vendorID;</span><br><span class="line">        <span class="type">uint32_t</span> productCode;</span><br><span class="line">        <span class="type">uint32_t</span> revisionNumber;</span><br><span class="line">        <span class="type">uint32_t</span> serialNumber;</span><br><span class="line">    &#125; x1018_identity;</span><br><span class="line">&#125; ODxyz_PERSIST_COMM_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> x1001_errorRegister;</span><br><span class="line">    <span class="type">uint8_t</span> x1003_preDefinedErrorField_sub0;</span><br><span class="line">    <span class="type">uint32_t</span> x1003_preDefinedErrorField[<span class="number">8</span>];</span><br><span class="line">&#125; ODxyz_RAM_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> ODxyz_PERSIST_COMM_t ODxyz_PERSIST_COMM;</span><br><span class="line"><span class="keyword">extern</span> ODxyz_RAM_t ODxyz_RAM;</span><br><span class="line"><span class="keyword">extern</span> OD_t *ODxyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object dictionary entries - shortcuts **************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1000 &amp;ODxyz-&gt;list[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1001 &amp;ODxyz-&gt;list[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1003 &amp;ODxyz-&gt;list[2]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1018 &amp;ODxyz-&gt;list[3]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1000_deviceType &amp;ODxyz-&gt;list[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1001_errorRegister &amp;ODxyz-&gt;list[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1003_preDefinedErrorField &amp;ODxyz-&gt;list[2]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1018_identity &amp;ODxyz-&gt;list[3]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OD_DEFINITION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;301/CO_ODinterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ODxyz.h&quot;</span></span></span><br><span class="line"><span class="comment">/* OD data initialization of all groups ***************************************/</span></span><br><span class="line">ODxyz_PERSIST_COMM_t ODxyz_PERSIST_COMM = &#123;</span><br><span class="line">    .x1000_deviceType = <span class="number">0</span>,</span><br><span class="line">    .x1018_identity = &#123;</span><br><span class="line">        .maxSubIndex = <span class="number">4</span>,</span><br><span class="line">        .vendorID = <span class="number">0</span>,</span><br><span class="line">        .productCode = <span class="number">0</span>,</span><br><span class="line">        .revisionNumber = <span class="number">0</span>,</span><br><span class="line">        .serialNumber = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ODxyz_RAM_t ODxyz_RAM = &#123;</span><br><span class="line">    .x1001_errorRegister = <span class="number">0</span>,</span><br><span class="line">    .x1003_preDefinedErrorField_sub0 = <span class="number">0</span>,</span><br><span class="line">    .x1003_preDefinedErrorField = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All OD objects (constant) **************************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    OD_obj_var_t o_1000_deviceType;</span><br><span class="line">    OD_obj_var_t o_1001_errorRegister;</span><br><span class="line">    OD_obj_array_t o_1003_preDefinedErrorField;</span><br><span class="line">    OD_obj_record_t o_1018_identity[<span class="number">5</span>];</span><br><span class="line">&#125; ODxyzObjs_t;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> CO_PROGMEM ODxyzObjs_t ODxyzObjs = &#123;</span><br><span class="line">    .o_1000_deviceType = &#123;</span><br><span class="line">        .dataOrig = &amp;ODxyz_PERSIST_COMM.x1000_deviceType,</span><br><span class="line">        .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">        .dataLength = <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .o_1001_errorRegister = &#123;</span><br><span class="line">        .dataOrig = &amp;ODxyz_RAM.x1001_errorRegister,</span><br><span class="line">        .attribute = ODA_SDO_R,</span><br><span class="line">        .dataLength = <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .o_1003_preDefinedErrorField = &#123;</span><br><span class="line">        .dataOrig0 = &amp;ODxyz_RAM.x1003_preDefinedErrorField_sub0,</span><br><span class="line">        .dataOrig = &amp;ODxyz_RAM.x1003_preDefinedErrorField[<span class="number">0</span>],</span><br><span class="line">        .attribute0 = ODA_SDO_RW,</span><br><span class="line">        .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">        .dataElementLength = <span class="number">4</span>,</span><br><span class="line">        .dataElementSizeof = <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    .o_1018_identity = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.maxSubIndex,</span><br><span class="line">            .subIndex = <span class="number">0</span>,</span><br><span class="line">            .attribute = ODA_SDO_R,</span><br><span class="line">            .dataLength = <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.vendorID,</span><br><span class="line">            .subIndex = <span class="number">1</span>,</span><br><span class="line">            .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">            .dataLength = <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.productCode,</span><br><span class="line">            .subIndex = <span class="number">2</span>,</span><br><span class="line">            .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">            .dataLength = <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.revisionNumber,</span><br><span class="line">            .subIndex = <span class="number">3</span>,</span><br><span class="line">            .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">            .dataLength = <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.serialNumber,</span><br><span class="line">            .subIndex = <span class="number">4</span>,</span><br><span class="line">            .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">            .dataLength = <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object dictionary **********************************************************/</span></span><br><span class="line"><span class="type">static</span> OD_entry_t ODxyzList[] = &#123;</span><br><span class="line">    &#123;<span class="number">0x1000</span>, <span class="number">0x01</span>, ODT_VAR, &amp;ODxyzObjs.o_1000_deviceType, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1001</span>, <span class="number">0x01</span>, ODT_VAR, &amp;ODxyzObjs.o_1001_errorRegister, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1003</span>, <span class="number">0x09</span>, ODT_VAR, &amp;ODxyzObjs.o_1003_preDefinedErrorField, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1018</span>, <span class="number">0x05</span>, ODT_REC, &amp;ODxyzObjs.o_1018_identity, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x0000</span>, <span class="number">0x00</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OD_t _ODxyz = &#123;</span><br><span class="line">    (<span class="keyword">sizeof</span>(ODxyzList) / <span class="keyword">sizeof</span>(ODxyzList[<span class="number">0</span>])) - <span class="number">1</span>,</span><br><span class="line">    &amp;ODxyzList[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OD_t *ODxyz = &amp;_ODxyz;</span><br></pre></td></tr></table></figure>

<h2 id="OD-find-查找指定对象"><a href="#OD-find-查找指定对象" class="headerlink" title="OD_find 查找指定对象"></a>OD_find 查找指定对象</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> OD_t *ODxyz;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunc</span><span class="params">(OD_t *od)</span> &#123;</span><br><span class="line">    ODR_t odRet;<span class="comment">//保存对象字典操作的返回值。</span></span><br><span class="line">    OD_entry_t *entry;<span class="comment">//指向对象字典条目的指针。</span></span><br><span class="line">    OD_IO_t io1008;<span class="comment">//用于对象字典I/O操作的结构体。</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    OD_size_t bytesRd;<span class="comment">//存储读取的字节数。</span></span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并初始化0x1008条目和其子索引0x00的IO结构体</span></span><br><span class="line">    entry = OD_find(od, <span class="number">0x1008</span>);<span class="comment">//查找对象字典中的条目。</span></span><br><span class="line">    odRet = OD_getSub(entry, <span class="number">0x00</span>, &amp;io1008, <span class="literal">false</span>);<span class="comment">//获取对象字典条目的子索引。</span></span><br><span class="line">    <span class="comment">// 读取制造商设备名称</span></span><br><span class="line">    <span class="keyword">if</span> (odRet == ODR_OK) &#123;</span><br><span class="line">        <span class="comment">/* Locking is necessary from mainline thread, but must not be used from</span></span><br><span class="line"><span class="comment">         * timer interval (real-time) thread. Locking is not necessary in the</span></span><br><span class="line"><span class="comment">         * CANoopen initialization section. Locking is also not necessary, if</span></span><br><span class="line"><span class="comment">         * OD variable is not mappable to PDO and not accessed from RT thread.*/</span></span><br><span class="line">        CO_LOCK_OD(CANmodule);</span><br><span class="line">        odRet = io1008.read(&amp;io1008.stream, &amp;buf[<span class="number">0</span>], <span class="keyword">sizeof</span>(buf), &amp;bytesRd);<span class="comment">//读取子索引的数据。</span></span><br><span class="line">        CO_UNLOCK_OD(CANmodule);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odRet != ODR_OK) error++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Use helper and set &quot;Producer heartbeat time&quot; at index 0x1017, sub 0x00 */</span></span><br><span class="line">    <span class="comment">// 设置生产者心跳时间</span></span><br><span class="line">    CO_LOCK_OD(CANmodule); <span class="comment">/* may not be necessary, see comment above */</span></span><br><span class="line">    odRet = OD_set_u16(OD_find(od, <span class="number">0x1017</span>), <span class="number">0x00</span>, <span class="number">500</span>, <span class="literal">false</span>);<span class="comment">//设置对象字典条目的子索引值。</span></span><br><span class="line">    CO_UNLOCK_OD(CANmodule);</span><br><span class="line">    <span class="keyword">if</span> (odRet != ODR_OK) error++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="直接根据结构体查找-OD-对象"><a href="#直接根据结构体查找-OD-对象" class="headerlink" title="直接根据结构体查找 OD 对象"></a>直接根据结构体查找 OD 对象</h2><p>如何直接访问和操作 CANopen 对象字典（Object Dictionary）中的条目，而不是通过查找函数 <code>OD_find</code> 来间接访问。直接访问对象字典条目和变量比通过函数查找要快，因为它避免了函数调用和查找过程。</p>
<p>对象字典的头文件 <code>ODxyz.h</code>，其中定义了对象字典的所有条目和相关结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ODxyz.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFuncGlob</span><span class="params">(<span class="type">void</span>)</span> &#123;     </span><br><span class="line">	<span class="comment">// Direct address instead of OD_find()     </span></span><br><span class="line">	OD_entry_t *entry_errReg = ODxyz_1001_errorRegister;      </span><br><span class="line">	<span class="comment">// Direct access to OD variable     </span></span><br><span class="line">	<span class="type">uint32_t</span> devType = ODxyz_0.x1000_deviceType;     </span><br><span class="line">	ODxyz_0.x1018_identity.serialNumber = <span class="number">0x12345678</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>OD_entry_t *entry_errReg = ODxyz_1001_errorRegister;</code> 直接获取对象字典中 <code>0x1001</code> 索引（错误寄存器）的条目指针 <code>entry_errReg</code>。这里使用的是直接声明的指针 <code>ODxyz_1001_errorRegister</code>，而不是通过 <code>OD_find</code> 函数查找。</p>
<p><code>uint32_t devType = ODxyz_0.x1000_deviceType;</code> 直接读取对象字典中 <code>0x1000</code> 索引（设备类型）的变量 <code>ODxyz_0.x1000_deviceType</code>，并将其存储到本地变量 <code>devType</code> 中。<code>ODxyz_0.x1018_identity.serialNumber = 0x12345678;</code> 直接修改对象字典中 <code>0x1018</code> 索引（设备标识）的 <code>serialNumber</code> 字段，将其设置为 <code>0x12345678</code>。</p>
<p><em>如果 OD 对象已启用 OD 扩展，则不得直接访问其 OD 变量。只有通过读、写或辅助函数访问才有效。</em></p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CAN Open 笔记</title>
    <url>/2024/05/20/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN-Open-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>项目地址 </p>
<p>CANopenNode <a href="https://github.com/CANopenNode/CANopenNode">https://github.com/CANopenNode/CANopenNode</a></p>
<p>CANopenLinux <a href="https://github.com/CANopenNode/CANopenLinux">https://github.com/CANopenNode/CANopenLinux</a></p>
<p>CANopenDemo <a href="https://github.com/CANopenNode/CANopenDemo">https://github.com/CANopenNode/CANopenDemo</a></p>
<p>CANopenEditor <a href="https://github.com/CANopenNode/CANopenEditor">https://github.com/CANopenNode/CANopenEditor</a></p>
<p>帮助文档</p>
<p>CANopenLinux <a href="https://canopennode.github.io/CANopenLinux">https://canopennode.github.io/CANopenLinux</a></p>
<p>CANopenDemo <a href="https://canopennode.github.io/index.html">https://canopennode.github.io/index.html</a></p>
<h1 id="CANopen"><a href="#CANopen" class="headerlink" title="CANopen"></a>CANopen</h1><p>CANopen 是一种基于 CAN（Controller Area Network）通信协议的高层协议和设备协议，定义了网络管理、设备配置、通信对象和应用对象等方面的标准，以确保不同设备之间的互操作性和通信的一致性。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>CiA 通过一系列文件维护保持 CANopen 设备和通讯协议规定。基本配置由 CiA 301 规范定义。它被命名为“CANopen 应用层和通信配置”，并规定了 CANopen 应用层。这些规范包括：</p>
<ul>
<li>CANopen 对象字典中的数据类型、编码规则和对象  </li>
<li>CANopen 通信服务和协议  </li>
<li>CANopen 网络管理服务和协议  </li>
<li>CANopen 通讯配置 – 物理层  </li>
<li>预定义的通信对象标识符连接数集、与紧急事件相关的对象、时间标识和同步通信对象</li>
</ul>
<p>此基本 CiA 301 配置规定由其他 CiA 文件进行了补充和扩展，为一些具体领域的设备和功能规定了设备、应用程序和接口配置。具体有以下几个部分，按照自身应用程序的实际情况引入。</p>
<ul>
<li>CiA 302 – CANopen 附加应用层功能  </li>
<li>CiA 303-1 – 布线和接头管脚分配  </li>
<li>CiA 303-3 – 指示器规范  </li>
<li>CiA 306 – CANopen 电子数据表规范  </li>
<li>CiA 309 – 从其他网络接入 CANopen  </li>
<li>CiA 315 – CANopen 通用框架  </li>
<li>CiA 401 – 通用 I&#x2F;O 模块的 CANopen 设备配置  </li>
<li>CiA 402 – 驱动和运动控制的 CANopen 设备配置</li>
</ul>
<h2 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h2><p>CANopen 的 OSI 模型，Data link 和 Physical 是由 CAN 进行实现的，Presentation 和 Session 是由 CANopen 进行实现的。</p>
<ul>
<li>物理层（Physical Layer）定义了物理介质、电气特性、传输速率和编码规范等。</li>
<li>数据链路层（Data Link Layer）划分数据帧、错误检测与纠正、流量控制。</li>
<li>网络层（Network Layer）提供路径选择、逻辑寻址、路由选择等功能。</li>
<li>传输层（Transport Layer）提供端到端的传输控制和错误恢复。</li>
<li>会话层（Session Layer）建立、维护、同步和恢复会话。</li>
<li>表示层（Presentation Layer）数据的加密、压缩、格式转换等。</li>
<li>应用层（Application Layer）用户数据交互和应用支持。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520145302.png" alt="image.png"></p>
<h2 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h2><p>每个 CANopen 设备都遵循一个通用的设备模型，因此不同的设备能依据同样的 CANopen 标准。CANopen 设备模型的三个组成部分是：      </p>
<ul>
<li>通讯接口</li>
<li>对象字典</li>
<li>应用程序<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523161558.png" alt="image.png"><br>一个 CANopen 设备必须支持一定数量的网络管理服务 NMT，需要至少一个 SDO。每个生产或消费过程数据的设备需要至少一个 PDO。所有其它的通讯对象是可选的。</li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><strong>通讯模式</strong></p>
<ul>
<li>设备&#x2F;节点通信有 3 种模型：主设备&#x2F;从设备、客户端&#x2F;服务器和生产者&#x2F;消费者</li>
</ul>
<p><strong>通讯协议</strong></p>
<ul>
<li>协议用于通信，例如配置节点（SDO）或传输实时数据（PDO）</li>
<li>定义了设备之间通信的机制和方式，包括对象字典、服务数据对象（SDO）、过程数据对象（PDO）、网络管理（NMT）等。</li>
</ul>
<p><strong>设备状态</strong></p>
<ul>
<li>设备支持不同的状态。“主”节点可以更改“从”节点的状态，例如将其重置。</li>
</ul>
<p><strong>对象字典（Object Dictionary，OD）</strong></p>
<ul>
<li>每个 CANopen 设备都有一个对象字典，OD 带有指定设备配置的条目，类似于一个查找表，列出了设备中的所有参数和数据。对象字典包括通信对象和应用对象，使用 16 位索引和 8 位子索引进行标识。可以通过 SDO 访问。</li>
</ul>
<p><strong>EDS（Electronic Data Sheet）</strong></p>
<ul>
<li>EDS 是用于 OD 的标准文件格式，允许更新设备的服务</li>
</ul>
<h1 id="通讯模式"><a href="#通讯模式" class="headerlink" title="通讯模式"></a>通讯模式</h1><p>CANopen 通过不同的通讯模式在节点之间传输报文:</p>
<p><strong>生产&#x2F;消费模式:</strong> 它是一个广播连接，以推送模式工作（信号生产节点向消费节点发送无任何特定要求的信息）和引入模式（消费节点向信号生产节点要求特定信息）。</p>
<p><strong>用户机&#x2F;服务器模式:</strong> 通过 SDO 协议，用户节点向服务器节点要求数据（对象字典索引），然后服务器节点通过发送在指定索引处的对象内容来响应。</p>
<p><strong>主机&#x2F;从机模式:</strong> 主机节点可在任何时候向从机节点发送或要求数据。例如：NMT 协议通信。</p>
<h1 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h1><p>数据帧由帧头 + 数据区组成，帧头由功能 ID+NodeID+RTR(远程传输请求)构成。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523134834.png" alt="image.png"></p>
<p>11 位的 CAN ID 称为通信对象标识符（COB-ID），分为两个部分：</p>
<ul>
<li>前 4 位等于功能代码 <code>Function Code</code>（代表一个 CANopen 通信对象）</li>
<li>后 7 位包含节点 ID<code>Node ID</code></li>
</ul>
<p>CANopen 网络中使用的 COB-ID 标识符的预定义分配</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520150656.png" alt="image.png"></p>
<p>数据区部分的定义就要通过 CANopen 中的重要概念，对象字典 OD 来实现。</p>
<h1 id="对象字典-OD"><a href="#对象字典-OD" class="headerlink" title="对象字典 OD"></a>对象字典 OD</h1><p>对象字典（OD）是 CANopen 协议的核心概念。它是一组预定义的 CANopen 对象，使用索引和子索引访问对象。对象字典提供了应用程序和设备之间的沟通方式，提供了配置该设备的途径，和与设备通信的方法。</p>
<p>所有 CANopen 节点必须具有对象字典（OD），对象字典是指含有描述的 CANopen 节点的 <code>行为</code> 的所有 <code>参数</code> 的 <code>标准化结构</code>。</p>
<p><strong>设备（例如从设备）的 OD 条目可以由其他设备（例如主机）使用 SDO 通过 CAN 进行访问</strong>。例如，通过 SDO 可以使应用程序主机更改从属发送心跳的频率。</p>
<p>作为对象索引存储在对象字典中的信息包括：</p>
<ul>
<li>通信和应用程序配置参数</li>
<li>标准化设备配置参数</li>
<li>制造商特定设备配置文件参数</li>
<li>设备配置静态数据类型</li>
<li>设备配置复杂数据类型</li>
<li>复杂和静态数据类型</li>
<li>制造商特定数据类型</li>
<li>其他</li>
</ul>
<p>可以按照 CANopen 标准的指导，以预定义的方式添加自己特定的制造商配置和数据类型。制造商还可以通过扩展由标准设备配置和数据类型规范要求的标准设备功能，来增强其设备的功能。</p>
<h3 id="主索引"><a href="#主索引" class="headerlink" title="主索引"></a>主索引</h3><p>索引值低于 0x0FFF 的是一些数据类型定义。一个节点的对象字典的有关范围在 0x1000 到 0x9FFF 之间，该范围内定义了一系列称为子协议的文档，用于定义节点的通讯行为。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523161012.png" alt="image.png"></p>
<p><strong>通讯子协议区域详细划分</strong><br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524131554.png" alt="image.png"></p>
<p><strong>通用通讯对象</strong><br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524131828.png" alt="image.png"></p>
<h2 id="OD-示例配置"><a href="#OD-示例配置" class="headerlink" title="OD 示例配置"></a>OD 示例配置</h2><p>下图是一个 TPDO 的定义示例，该 TPDO 在主索引 0x1800 的子索引中定义该 TPDO 相关的通信参数，主要是 TPDO 的发送类型和触发事件等设置，同时在和 0x1800 地址对应的 0x1A00 中定义了映射参数，在该参数的子索引中，定义了具体的映射地址和对象。并给出了该 TPDO 消息在发送时数据区内容。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524135154.png" alt="image.png"></p>
<h2 id="电子数据表（EDS）"><a href="#电子数据表（EDS）" class="headerlink" title="电子数据表（EDS）"></a>电子数据表（EDS）</h2><p>一个节点的对象字典是在电子数据文档（EDS：Electronic Data Sheet）中描述。</p>
<p>实际上，将使用适当的软件工具来配置&#x2F;管理复杂的 CANopen 网络。</p>
<p>一个电子数据表（EDS）是一个标准化的电子文件，描述为 CANopen 设备定义的通信功能和对象。此供应方生成的文件有 3 个区域：</p>
<ul>
<li>关于 EDS 文件的信息</li>
<li>一般设备信息</li>
<li>具有默认变量的对象字典</li>
</ul>
<p>EDS 文件可用作 CANopen 设备的配置和网络设置工具。</p>
<h1 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h1><h2 id="通信对象"><a href="#通信对象" class="headerlink" title="通信对象"></a>通信对象</h2><p>CANopen 通信单元由必要的通信接口和协议软件组成，通过总线在节点之间进行通信对象的发送和接收。各种 CANopen 通信对象用于实现各种类型的通信，CANopen 协议定义了几种不同类型的通信对象，每种对象都用于特定的通信目的：</p>
<ol>
<li><strong>过程数据对象（PDO）</strong>：用于实时数据传输，具有高优先级和低延迟。PDO 传输的数据量小，但传输速度快，适用于传感器数据和控制命令等实时性要求高的场景。</li>
<li><strong>服务数据对象（SDO）</strong>：用于非实时数据传输，如配置参数和大数据块的传输。SDO 传输的灵活性更大，但优先级较低，适用于设备配置和诊断等场景。</li>
<li><strong>网络管理对象（NMT）</strong>：用于控制设备状态和网络操作模式，如启动、停止和复位设备。</li>
<li><strong>同步对象（SYNC）</strong>：用于网络同步，确保所有节点在同一时间点进行操作。</li>
<li><strong>时间戳对象（TIME）</strong>：提供时间参考，用于时间相关的操作。</li>
<li><strong>紧急情况对象 (EMCY)</strong> ：</li>
</ol>
<p>指定状态下可用的通讯对象及状态转换说明：</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523165217.png" alt="image.png"></p>
<p>中括号内的字母表示处于不同状态那些通讯对象可以使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. NMT</span><br><span class="line">b. Node Guard </span><br><span class="line">c. SDO </span><br><span class="line">d. Emergency</span><br><span class="line">e. PDO </span><br><span class="line">f. Boot-up</span><br></pre></td></tr></table></figure>

<h2 id="网络管理（NMT）"><a href="#网络管理（NMT）" class="headerlink" title="网络管理（NMT）"></a>网络管理（NMT）</h2><p>所有的 CANopen 节点都有自己专属的 NMT 状态，而主站可以通过 NMT 去控制从站的状态。CANopen 的网络管理采取主机&#x2F;从机通信模式。整个网络被设置为一个“状态机”，其中一个设备被指定为 NMT 主机，其余设备被指定为 NMT 从机。NMT 主机控制和监控 NMT 从机的状态。通过 NMT 主机触发，NMT 从机进行状态转换，实现 CANopen 网络的各个阶段。</p>
<p>NMT 服务用于通过 NMT 命令来控制 CANopen 设备的状态。只有 NMT-Master 节点能够传送 NMT Module Control 报文。所有从设备必须支持 NMT 模块控制服务。NMT Module Control 消息不需要应答。为了更改状态，NMT 主设备发送 COBID+2 字节的消息。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520151626.png" alt="image.png"></p>
<ol>
<li>COB-ID 为 0（function code&#x3D;0 和 node ID&#x3D;0），优先级为最高。</li>
<li>第一个 CAN 数据字节 Requested State 包含请求的状态</li>
<li>第二个 CAN 数据字节包含目标节点的节点 ID。节点 ID 0 表示广播命令。所有从节点都处理此消息。</li>
</ol>
<p>通过具体的 NMT 协议，如启动协议、模块控制协议、心跳协议（Heartbeat Protocol）和节点监测，<strong>主机向从机发出状态更改命令，进行这些状态转换</strong>。NMT 主机向特定节点或所有节点发送 NMT 命令代码以改变状态。</p>
<p>在<strong>预运行状态</strong>下，应用程序配置工具可以使用<strong>SDO 通信</strong>，配置 NMT 从机和设置参数。由于设备尚未开始运行，因此在此状态下<strong>不能使用 PDO 通信</strong>。</p>
<p>一旦状态从<strong>预运行</strong>变为<strong>运行</strong>状态，节点中的<strong>所有通信对象</strong>都将变为活跃状态，并且运行节点之间均可进行 PDO 和 SDO 通信。在此阶段，<strong>也可以通过 SDO 访问对象字典</strong>。当节点状态更改为停止时，PDO 和 SDO 通信都将停止。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524132402.png" alt="image.png"></p>
<p><strong>实际状态取值</strong></p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">Byte 0 取值（命令）</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">（2）</td>
<td align="center">01</td>
<td>operation</td>
</tr>
<tr>
<td align="center">（3）</td>
<td align="center">02</td>
<td>stop</td>
</tr>
<tr>
<td align="center">（4）</td>
<td align="center">80</td>
<td>pre-operation</td>
</tr>
<tr>
<td align="center">（5）</td>
<td align="center">81</td>
<td>reset app</td>
</tr>
<tr>
<td align="center">（6）</td>
<td align="center">82</td>
<td>reset communication</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># node 0x6 进入 `operational` 模式</span></span><br><span class="line">000 01 06</span><br><span class="line"><span class="comment"># 所有节点进入 `pre-operational` 模式</span></span><br><span class="line">000 80 00</span><br></pre></td></tr></table></figure>

<h2 id="服务数据对象（SDO）"><a href="#服务数据对象（SDO）" class="headerlink" title="服务数据对象（SDO）"></a>服务数据对象（SDO）</h2><p>SDO 提供了直接访问 CANopen 设备对象字典的入口，入口条件包括数据类型及大小。</p>
<p>访问者被称作客户端(client)，对象字典被访问且提供所请求服务的 CANopen 设备别称作服务器(server)。任何类型的 SDO 传输都由客户端发起，数据字典 OD 持有者是服务端，客户端和服务端都可以主动中止传输。通常情况下 CAN 总线网络中只有一个客户端。</p>
<p>客户的 CAN 报文和服务器的应答 CAN 报文总是包含 8 字节数据（尽管不是所有的数据字节都一定有意义）。一个客户的请求一定有来自服务器的应答。如果超时没有确认，则客户端节点将会重新发送原报文。</p>
<p>SDO 服务用于访问&#x2F;更改 CANopen 设备的对象字典中的值。允许 CANopen 节点通过 CAN 网络读取另一个节点的对象字典&#x2F;编辑值。下载（Download）是指对对象字典进行写操作，上传（Upload）指对对象字典进行读操作。</p>
<p>客户端节点可以通过以下 CAN 帧广播来启动 SDO 下载到节点 5，这将触发节点 5（并被其他节点忽略）。SDO 客户端的“接收”（即请求）CAN 帧如下所示：</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520153535.png" alt="image.png"></p>
<p>SDO 消息变量数据区 Byte 说明：</p>
<ul>
<li>Byte0 命令字节，主要定义了以下内容：<ul>
<li>CCS（客户端命令说明符，Client Command Specifier）描述<strong>传输类型</strong>（下载 download&#x2F;上载 upload）</li>
<li>n 是数据字节 4-7 中<strong>不包含数据的 bytes</strong> （如果设置了 e＆s 则有效）</li>
<li>如果设置，e 表示 <code>快速传输</code>(所有数据在单个 CAN 帧中)&#x2F;<code>分段传输</code></li>
<li>如果设置，s 表示<strong>数据大小</strong>显示在 n 中</li>
</ul>
</li>
<li>Byte1+Byte2 主索引字节（16 位）确认 OD 主索引</li>
<li>Byte3 子索引字节（8 位）确认 OD 子索引</li>
<li>Byte4-7 包含实际的数据内容</li>
</ul>
<p><em>一旦节点（客户端）发送了 CAN 帧，从节点 5（服务端）便会通过 RSDO 进行响应，并带有 COB-ID585。该响应包含索引&#x2F;子索引和 4 个空数据字节。<br>自然地，如果客户端节点请求上传（即从节点 5 OD 读取数据），则节点 5 将以字节 4-7 中包含的相关数据进行响应。</em></p>
<p>SDO 灵活，但会带来大量输出，使其不适用于实时操作数据。同时数据只能包含在后续 4 个字节中，对于较大的数据方案，无法一次传输完毕。因此 SDO 中实现了 2 种传送机制，两种传送机制实际包含 4 个请求&#x2F;应答协议，共有 5 个协议如下：</p>
<ul>
<li>快速传送（Expedited transfer） ： 最多传输 4 字节数据<ul>
<li>启动域下载 （Initiate Domain Download）</li>
<li>启动域上传 （Initiate Domain Upload）</li>
</ul>
</li>
<li>分段传送（Segmented transfer） ： 传输数据长度大于 4 字节<ul>
<li>域分段下载（Download Domain Segment）</li>
<li>域分段上传 （Upload Domain Segment）</li>
</ul>
</li>
<li>域传送中止（Abort Domain Transfer）。</li>
</ul>
<h3 id="快速-SDO"><a href="#快速-SDO" class="headerlink" title="快速 SDO"></a>快速 SDO</h3><p>Command specifier(CS)命令符:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="left"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">0x40</td>
<td align="left">读取命令</td>
<td></td>
</tr>
<tr>
<td align="center">0x2F</td>
<td align="center">写一个字节</td>
<td align="center">0x4F</td>
<td align="left">返回值响应一个字节</td>
<td></td>
</tr>
<tr>
<td align="center">0x2B</td>
<td align="center">写两个字节</td>
<td align="center">0x4B</td>
<td align="left">返回值响应两个字节</td>
<td></td>
</tr>
<tr>
<td align="center">0x27</td>
<td align="center">写三个字节</td>
<td align="center">0x47</td>
<td align="left">返回值响应三个字节</td>
<td></td>
</tr>
<tr>
<td align="center">0x23</td>
<td align="center">写四个字节</td>
<td align="center">0x43</td>
<td align="left">返回值响应四个字节</td>
<td></td>
</tr>
<tr>
<td align="center">0x60</td>
<td align="center">写成功应答</td>
<td align="center"></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">0x80</td>
<td align="center">异常响应</td>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h4 id="启动域下载（Initiate-Domain-Download）"><a href="#启动域下载（Initiate-Domain-Download）" class="headerlink" title="启动域下载（Initiate Domain Download）"></a>启动域下载（Initiate Domain Download）</h4><table>
<thead>
<tr>
<th>Bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>-</td>
<td>n</td>
<td>n</td>
<td>e</td>
<td>s</td>
</tr>
<tr>
<td>服务器</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>n</strong> ： 如果 <code>e=1</code> 且 <code>s=1</code>，则有效，否则为 0；表示数据部分中无意义数据的字节数（字节 8－n 到 7 数据无意义）。</li>
<li><strong>e</strong> ： 0 &#x3D; 正常传送，1 &#x3D; 加速传送（数据在一个帧中）。</li>
<li><strong>s</strong> ： 是否指明数据长度，0 &#x3D; 数据长度未指明，1 &#x3D; 数据长度指明。</li>
<li><strong>e &#x3D; 0， s &#x3D; 0</strong>： 由 CiA 保留。</li>
<li><strong>e &#x3D; 0， s &#x3D; 1</strong> ： 数据字节为字节计数器，byte 4 是数据低位部分（LSB），byte 7 是数据高位部分（MSB）。</li>
<li><strong>e &#x3D; 1</strong> ： 数据字节为将要下载（download）的数据。</li>
</ul>
<h4 id="启动域上传（Initiate-Domain-Upload）"><a href="#启动域上传（Initiate-Domain-Upload）" class="headerlink" title="启动域上传（Initiate Domain Upload）"></a>启动域上传（Initiate Domain Upload）</h4><table>
<thead>
<tr>
<th>Bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>服务器</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-</td>
<td>n</td>
<td>n</td>
<td>e</td>
<td>s</td>
</tr>
</tbody></table>
<p><strong>n</strong>，<strong>e</strong>，<strong>s</strong>： 与启动域下载相同。</p>
<h3 id="分段-SDO"><a href="#分段-SDO" class="headerlink" title="分段 SDO"></a>分段 SDO</h3><h4 id="域分段下载（Download-Domain-Segment）"><a href="#域分段下载（Download-Domain-Segment）" class="headerlink" title="域分段下载（Download Domain Segment）"></a>域分段下载（Download Domain Segment）</h4><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524142515.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>t</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>c</td>
</tr>
<tr>
<td>服务器</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>t</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<ul>
<li><strong>n</strong> ：无意义的数据字节数。如果没有指明段长度，则为 0。</li>
<li><strong>c</strong> ： 0 &#x3D; 有后续分段需要 download，1 &#x3D; 最后一个段。</li>
<li><strong>t</strong> ： 触发位，后续每个分段交替清零和置位（第一次传送为 0，等效于 request&#x2F;response）。</li>
</ul>
<h4 id="域分段上传（Upload-Domain-Segment）"><a href="#域分段上传（Upload-Domain-Segment）" class="headerlink" title="域分段上传（Upload Domain Segment）"></a>域分段上传（Upload Domain Segment）</h4><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524142553.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>t</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>服务器</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>t</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>c</td>
</tr>
</tbody></table>
<p><strong>n</strong>，<strong>c</strong>，<strong>t</strong> ： 与域分段下载相同。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>通讯示例 -upload</strong><br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152443.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152452.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152500.png" alt="image.png"></p>
<p>数据 0xFE ，对象字典节点 5 ,  索引 index 0x1400, 子索引 subindex 2 </p>
<p>客户端请求   ： <code>605 40 00 14 02 00 00 00 00</code> </p>
<p>若成功，应答： <code>585 4F 00 14 02 FE 00 00 00</code></p>
<p>数据 0x60120208 ，对象字典节点 5 ,  索引 index 0x1802, 子索引 subindex 1</p>
<p>客户端请求   ：<code>605 40 02 18 01 00 00 00 00</code></p>
<p>若成功，应答：<code>585 60 02 18 01 08 02 12 60</code></p>
<p><strong>通讯示例 -download</strong><br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152715.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152725.png" alt="image.png"><br>数据 0xFE ，对象字典节点 5 ,  索引 index 0x1400, 子索引 subindex 2 </p>
<p>客户端请求   ： <code>605 2F 00 14 02 FE 00 00 00</code></p>
<p>若成功，应答： <code>585 60 00 14 02 00 00 00 00</code></p>
<p>数据 0x60120208 ，对象字典节点 5 ,  索引 index 0x1802, 子索引 subindex 1</p>
<p>客户端请求   ：<code>605 23 02 18 01 08 02 12 60</code></p>
<p>若成功，应答：<code>585 60 02 18 01 00 00 00 00</code></p>
<h2 id="过程数据对象（PDO）"><a href="#过程数据对象（PDO）" class="headerlink" title="过程数据对象（PDO）"></a>过程数据对象（PDO）</h2><p>PDO 属于过程数据，即单向传输，无需接收节点回应 CAN 报文来确认，从通讯术语上来说是属于“生产消费”模型。、生产者“生产数据”，并使用 Transmit PDO（TPDO）将其传输到“消费者”（主用户）。相反，它可以通过 Receive PDO（RPDO）从使用者接收数据。</p>
<p>PDO 服务用于在设备之间传输实时数据，例如来自温度传感器的温度数据。PDO 承载大量信息，被视为最重要的 CANopen 协议。PDO 消息可以包含 8 个完整字节的数据，并且它可以在单个帧中包含多个对象参数值。因此在 PDO 服务中用 1 帧完成 SDO 至少需要 4 帧的操作。</p>
<p>带有特定 11 位 CAN 标识符的 TPDO 由一个设备发送，并作为 RPDO 由零个或多个设备接收。每个 PDO 在对象字典中用 2 个对象描述：</p>
<ul>
<li>PDO 通讯参数：包含哪个 COB-ID 将被 PDO 使用，传输类型，禁止时间和定时器周期。在索引 0x1400+ 和 0x1800+ 的对象字典中。</li>
<li>PDO 映射参数：包含一个对象字典中对象的列表，这些对象映射到 PDO 里，包括它们的数据长度（in bits）。生产者和消费者必须知道这个映射，以解释 PDO 内容。在索引 0x1600+ 和 0x1A00+ 的对象字典中。</li>
</ul>
<p>生产者节点可以被配置为每 100ms 响应消费者所广播的 SYNC 触发。然后，节点 5 可以例如在下面广播，以 COB-ID 185 的 TPDO：</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520153344.png" alt="image.png"></p>
<p>注意数据区部分 3 个参数值的打包方式，这些值是由数据字典中对应的映射结构决定了一个 PDO 的数据类型和映射关系。</p>
<h3 id="通信参数"><a href="#通信参数" class="headerlink" title="通信参数"></a>通信参数</h3><p>定义了该设备所使用的 COB-ID、传输类型、定时周期等。RPDO 通讯参数位于对象字典索引的 0x1400 to 0x15FF，TPDO 通讯参数位于对象字典索引的 0x1800 to 0x19FF。每条索引代表一个 PDO 的通信参数集，其中的子索引分别指向具体的各种参数。PDO 消息的内容是预定义的（或者在网络启动时配置的）。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524134811.png" alt="image.png"></p>
<ul>
<li>Number of entries 参数条目数量：即本索引中有几条参数；</li>
<li>COB-ID：即这个 PDO 发出或者接收的对应 CAN 帧 ID；</li>
<li>发送类型：即这个 PDO 发送或者接收的传输形式，通常使用循环同步和异步制造商特定事件较多；</li>
<li>Inhibit time 生产禁止约束时间(1&#x2F;10ms)：约束 PDO 发送的最小间隔，避免导致总线负载剧烈增加，比如数字量输入过快，导致状态改变发送的 TPDO 频繁发送，总线负载加大，所以需要一个约束时间来进行“滤波”，这个时间单位为 0.1ms；</li>
<li>Event timer 事件定时器触发的时间(单位 ms)：定时发送的 PDO，它的定时时间，如果这个时间为 0，则这个 PDO 为事件改变发送。</li>
<li>SYNC start value 同步起始值：同步传输的 PDO，收到诺干个同步包后，才进行发送，这个同步起始值就是同步包数量。比如设置为 2，即收到 2 个同步包后才进行发送。</li>
</ul>
<h4 id="发送类型"><a href="#发送类型" class="headerlink" title="发送类型"></a>发送类型</h4><p>PDO 可以有多种发送类型：</p>
<ul>
<li>同步（通过接收 SYNC 对象实现同步）<ul>
<li>非周期：远程帧预触发传送或设备子协议中规定的对象特定事件预触发传送。</li>
<li>周期：传送在每 1 到 240 个 SYNC 消息后触发。</li>
</ul>
</li>
<li>异步<ul>
<li>远程帧触发传送。通过发送与 PDO 的 COB-ID 相同的远程帧来触发 PDO 发送</li>
<li>由设备子协议中规定的对象特定事件触发传送。（基本采用这种，例如定时传输，数据变化传输等）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524133832.png" alt="image.png"></p>
<p>由传输类型定义的不同 PDO 传输模式，传输类型为 PDO 通讯参数对象的一部分，由 8 位无符号整数定义。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523162157.png" alt="image.png"></p>
<h4 id="间隔时间"><a href="#间隔时间" class="headerlink" title="间隔时间"></a>间隔时间</h4><p>一个 PDO 可以指定一个禁止时间，即定义两个连续 PDO 传输的最小间隔时间，避免由于高优先级信息的数据量太大，始终占据总线，而使其它优先级较低的数据无力竞争总线的问题。禁止时间由 16 位无符号整数定义，单位 100us。</p>
<h4 id="定时周期"><a href="#定时周期" class="headerlink" title="定时周期"></a>定时周期</h4><p>一个 PDO 可以指定一个事件定时周期，当超过定时时间后，一个 PDO 传输可以被触发（不需要触发位）。事件定时周期由 16 位无符号整数定义，单位 1ms。</p>
<h3 id="映射参数"><a href="#映射参数" class="headerlink" title="映射参数"></a>映射参数</h3><p>RPDO 通讯参数 1400h to 15FFh，映射参数 1600h to 17FFh，数据存放为 2000h 之后厂商自定义区域；</p>
<p>TPDO 通讯参数 1800h to 19FFh，映射参数 1A00h to 1BFFh，数据存放为 2000h 之后厂商自定义区域。</p>
<p>包含了一个对象字典中的对象列表，这些对象映射到相应的 PDO，其中包括数据的长度（单位，位），对于生产者和消费者都必须要知道这个映射参数，才能够正确的解释 PDO 内容。就是将通信参数、应用数据和具体 CAN 报文中数据联系起来。</p>
<p>子索引 0：PDO 中映射应用程序对象的数量：</p>
<ul>
<li>值 0：映射被禁用。</li>
<li>值 1：子索引 0x01 有效。</li>
<li>值 2-8: 子索引 0x01 至 (0x02 至 0x08) 有效。</li>
</ul>
<p>子索引 1-8： 应用对象 1-8：</p>
<ul>
<li>位 16-31：索引</li>
<li>位 8-15：子索引</li>
<li>位 0-7：数据长度（位）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/29/20240529152926.png" alt="image.png"></p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><h4 id="示例设备配置"><a href="#示例设备配置" class="headerlink" title="示例设备配置"></a>示例设备配置</h4><ul>
<li><strong>节点 ID</strong>: 0x01</li>
<li><strong>第二个 Transmit PDO (TPDO2)</strong>:<ul>
<li>TPDO2 的 COB-ID: 0x280 + Node_ID &#x3D; 0x281</li>
</ul>
</li>
</ul>
<p> 对象字典（Object Dictionary）定义：</p>
<ol>
<li>0x1801: TPDO2 通信参数 <ul>
<li>子索引 0x00: 0x02 (表示有 2 个子索引) </li>
<li>子索引 0x01: 0x00000281 (TPDO2 的 COB-ID, 使能) </li>
<li>子索引 0x02: 0x00 (传输类型，假设为 0x00 表示同步传输)</li>
</ul>
</li>
<li>0x1A01: TPDO2 映射参数 <ul>
<li>子索引 0x00: 0x02 (映射对象数量，表示有两个对象映射到这个 TPDO) </li>
<li>子索引 0x01: 0x60000208 (映射对象 0x6000，子索引 0x02，8 位) </li>
<li>子索引 0x02: 0x64010110 (映射对象 0x6401，子索引 0x01，16 位)</li>
</ul>
</li>
</ol>
<p>假设当前设备中的数据如下：</p>
<ul>
<li><strong>对象 0x6000，子索引 0x02</strong>: 0xAB </li>
<li><strong>对象 0x6401，子索引 0x01</strong>: 0x1234</li>
</ul>
<p>TPDO2 实际发送的 CANopen 数据帧报文由以下 3 个字节组成：</p>
<ul>
<li>Byte 0: 0xAB</li>
<li>Byte 1: 0x34 (低 8 位)</li>
<li>Byte 2: 0x12 (高 8 位)</li>
</ul>
<p>实际的 CANopen 数据帧：<code>CAN ID: 0x281 Data: [0xAB, 0x34, 0x12]</code></p>
<h4 id="设置一个-TPDO"><a href="#设置一个-TPDO" class="headerlink" title="设置一个 TPDO"></a>设置一个 TPDO</h4><ul>
<li>Index 1800 + n，subindex <code>01</code> ，<strong>COB_ID</strong>（通讯对象的标识符）：包含 CAN-ID 和附加控制位的标识符</li>
<li>Index 1800 + n，subindex <code>02</code>， 写<strong>传输类型 t</strong>，<br>  t &#x3D; 1 – 0xF0：同步，时间触发模式 ，每 t 一周期<br>  t &#x3D; FD  　　：收到 PDO 请求后<br>  t &#x3D; FE　　  ：事件驱动（制造商指定）<br>  t &#x3D; FF  　　：事件传输，节点自发传输 PDO</li>
<li>Index 1800 + n， subindex <code>03</code>，<strong>抑制时间</strong>。<br>  如果传输类型设置为 FE 和 FF，它是最小的 PDO 传输间隔，单位 100us，值为 0 禁用抑制时间。PDO 报文需要延时 t × 100us 的时间才发出，以此避免在多 PDO 报文同时发出时，引起的时间冲突 。</li>
<li>Index 1800 + n， subindex <code>05</code>，<strong>时间定时器</strong>。<br>  如果传输类型设置为 FE 和 FF，它是 PDO 传输间隔，单位 ms，值为 0 禁用。t &#x3D;0xCB，200ms。</li>
<li>Index 1A00 + n，<strong>定义映射</strong><ul>
<li>subindex <code>0</code> ：定义映射数量（1 byte）。<br>  值 0，映射禁用；值 01，子索引 01 有效；值 02，子索引 01–02 有效……</li>
<li>subindex <code>1</code> ：映射第一个参数。<br>  格式，index (2 bytes) – subindex (1 byte) – size (1 byte)</li>
<li>subindex <code>2</code> ：映射第二个参数。<br>  格式，index (2 bytes) – subindex (1 byte) – size (1 byte)</li>
</ul>
</li>
</ul>
<p><code>605 2F 00 18 02 FF 00 00 00</code> 设置索引 Index 1800，事件传输</p>
<p><code>605 2F 00 18 05 CB 00 00 00</code> 设置索引 Index 1800，时间间隔 200ms</p>
<p><code>605 2F 00 1A 00 00 00 00 00</code> 设置子索引禁用</p>
<p><code>605 23 00 1A 01 10 00 30 40</code>0x40300010，设置映射索引 0x4030，子索引 00，大小 0x10（16 位）</p>
<p><code>605 23 00 1A 02 20 00 10 20</code>0x20100020，设置映射索引 0x2010，子索引 00，大小 0x20（32 位）</p>
<p><code>605 2F 00 1A 00 02 00 00 00</code> 设置映射数量，用多少设多少，这里用了 2 个</p>
<h4 id="设置一个-RPDO"><a href="#设置一个-RPDO" class="headerlink" title="设置一个 RPDO"></a>设置一个 RPDO</h4><ul>
<li>Index 1400 + n, subindex <code>01</code> ，<strong>COB_ID</strong>（通讯对象的标识符）</li>
<li>Index 1400 + n, subindex <code>02</code>，写<strong>传输类型</strong> t，　　　　　　　　　　　　　　<br>  t &#x3D; 1 – 0xF0：同步，时间触发模式 ，每 t 一周期<br>  t &#x3D; FD  　　：收到 PDO 请求后<br>  t &#x3D; FE　　  ：事件驱动（制造商指定）<br>  t &#x3D; FF  　　：事件传输，节点自发传输 PDO</li>
<li>Index 1600 + n，<strong>定义映射</strong><ul>
<li>subindex 0 ：定义映射数量（1 byte）。<br>  值 0，映射禁用；值 01，子索引 01 有效；值 02，子索引 01–02 有效……</li>
<li>subindex 1 ：映射第一个参数。<br>  格式，index (2 bytes) – subindex (1 byte) – size (1 byte)</li>
<li>subindex 2 ：映射第二个参数。<br>  格式，index (2 bytes) – subindex (1 byte) – size (1 byte)</li>
</ul>
</li>
</ul>
<p><code>605 2F 00 14 02 FF 00 00 00</code> 设置索引 Index 1400，事件传输</p>
<p><code>605 2F 00 16 00 00 00 00 00</code> 设置子索引禁用</p>
<p><code>605 23 00 16 01 10 00 30 40</code> 设置映射索引 0x4030，子索引 00，大小 0x10（16 位）</p>
<p><code>605 2F 00 16 00 01 00 00 00</code> 设置映射数量，用多少设多少，这里用了 01</p>
<p><em>定义映射时，先设置子索引禁用；再设置相应映射；然后设置映射数量</em><br><em>对于 TPDO 来说，其通信参数中的 COB-ID 是<strong>自身</strong>的 COB-ID，当发送 TPDO 时用来表明这个 TPDO 是谁发出的。</em><br><em>对于 RPDO 来说，其通信参数的 COB-ID 是<strong>发送方</strong>的 COB-ID，用来表示自己只接受某个 CAN 节点发过来的 TPDO。</em></p>
<h2 id="同步（SYNC）"><a href="#同步（SYNC）" class="headerlink" title="同步（SYNC）"></a>同步（SYNC）</h2><p>SYNC 消息通常由应用程序主机触发。每个节点都以该同步报文作为 PDO 触发参数，因此该同步报文的 COB-ID 具有比较高的优先级以及最短的传输时间。一般选用 0x80 作为同步报文的 CAN-ID，将 SYNC 消息（COB-ID 080）发送到 CANopen 网络。</p>
<ul>
<li>在网络范围内同步（尤其在驱动应用中）：在整个网络范围内当前输入值准同时保存，随后传送（如果需要），根据前一个 SYNC 后接收到的报文更新输出值。</li>
<li>主从模式：SYNC 主节点定时发送 SYNC 对象，SYNC 从节点收到后同步执行任务。</li>
<li>在 SYNC 报文传送后，在给定的时间窗口内传送一个同步 PDO。</li>
<li>用 CAL 中基本变量类型的 CMS 对象实现。</li>
<li>CANopen 建议用一个最高优先级的 COB-ID 以保证同步信号正常传送。SYNC 报文可以不传送数据以使报文尽可能短。</li>
</ul>
<p>一般同步报文由 NMT 主机发出，CAN 报文的数据为 0 字节。但如果一个网络内有 2 个同步机制，就需要设置不同的同步节拍，比如某些节点按 1 个同步帧发送 1 次 PDO，其他的节点收到 2 个同步帧才发送 1 次 PDO，所以这里 PDO 参数中的同步起始值就起了作用。</p>
<p>在同步协议中，有 3 个约束条件：</p>
<ul>
<li>同步命令：0x1005 中规定了同步帧的命令为 0x80；</li>
<li>通讯循环周期：索引 0x1006 规定了同步帧的循环周期；</li>
<li>同步窗口时间：索引 0x1007 约束了同步帧发送后，从节点发送 PDO 的时效，即在这个时间内发送的 PDO 才有效，超过时间的 PDO 将被丢弃。</li>
</ul>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>配置 1005 信息，设 SYNC 的 COB-ID 为 0x80（默认值）</p>
<p><code>23 05 10 00 80 00 00 00</code></p>
<p>读取 1006 信息</p>
<p><code>40 06 10 00 00 00 00 00</code></p>
<p>写入 1006 信息，将 SYNC 的通信周期设置为 100ms，那么需要写入到 <code>0x1006</code> 的值为 100000（100ms &#x3D; 100000us）</p>
<p><code>23 06 10 00 A0 86 01 00</code></p>
<h2 id="时间戳（TIME-stamp）"><a href="#时间戳（TIME-stamp）" class="headerlink" title="时间戳（TIME-stamp）"></a>时间戳（TIME-stamp）</h2><p>时间标记对象（Time Stamp），NMT 主机发送自身的时钟，为网络各个节点提供公共的时间参考，即网络对时，这在故障诊断中非常需要。</p>
<p>时间戳协议采用广播方式，无需节点应答，CAN-ID 为 0x100，数据长度为 6，数据为当前时刻与 1984 年 1 月 1 日 0 时的时间差。节点将此时间存储在对象字典 1012h 的索引中。</p>
<p>主机发出带有 CAN ID 100 的 TIME 消息，TIME 服务包含一个 6 字节的日期和时间信息。其中最初的 4 个数据字节包含午夜之后的毫秒数，随后的 2 个字节包含自 1984 年 1 月 1 日以来的天数。</p>
<h2 id="紧急情况（EMCY）"><a href="#紧急情况（EMCY）" class="headerlink" title="紧急情况（EMCY）"></a>紧急情况（EMCY）</h2><p>紧急报文协议（Emergency protocol）用于设备发生致命错误（例如传感器故障）的情况，从而使其可以向网络的其余部分指示此错误。</p>
<p>受影响的节点以高优先级向网络发送发送设备内部错误代码，提示 NMT 主站。紧急报文属于诊断性报文，一般不会影响 CANopen 通讯，其 CAN-ID 存储在 0x1014 的索引中，一般会定义为 0x080 + node-ID，数据包含 8 个字节，例如，节点 5 具有 COB-ID 085 + 数据字节，数据字节包含有关错误的信息，可以查找厂商定义的错误代码。</p>
<p>紧急信息的内容如下</p>
<ul>
<li>Bytes 0…1： CO_EM_errorCode_t，在本例中为 0x5000（设备硬件）</li>
<li>Bytes 2：CO_errorRegister_t，本例中为 0x01（通用错误）</li>
<li>Bytes 3：CO_EM_errorStatusBits_t 中的错误条件索引，本例中为 0x2F（CO_EM_NON_VOLATILE_MEMORY - 访问非易失性设备内存时出错）</li>
<li>Bytes 4…7：附加信息参数，本例中为 0x00000014 或 0x00000074</li>
</ul>
<p>紧急信息由 CO_errorReport() 函数内部触发。您可以在 CO_EM_NON_VOLATILE_MEMORY 的源代码中查找紧急信息的来源。</p>
<p>CO_EM_NON_VOLATILE_MEMORY 是一般的严重错误，默认情况下会设置 CANopen 错误寄存器。如果<strong>错误寄存器的值不等于零，则禁止节点进入 NMT 运行状态，并且不能与其交换 PDO</strong>。</p>
<h2 id="节点监测"><a href="#节点监测" class="headerlink" title="节点监测"></a>节点监测</h2><p>NMT 主机定期使用远程帧询问从机的当前状态，并将其与网络数据库中记录的早期状态相比较。任何不匹配和缺少 PDO 传输的状态都会以适当的错误代码表示，然后应用程序将采取适当的操作，如设备重置或错误标识。这称为节点监测，是通过使用节点监测协议得以实现。</p>
<p>NMT 从机使用一种称为生命监测的技术，通过在预定义的时间间隔里，内部检查节点监测帧的接收，来检测 NMT 主机的缺失。</p>
<p>现代设备设计使用 Heartbeat 协议进行节点监视，其中 NMT 从设备（Heartbeat Producer 心跳发出者）将周期性地向 NMT 主设备（Heartbeat Consumer 心跳使用者）发送 Heartbeat 报文。</p>
<p>这些报文之间的间隔是可配置的，并在主、从两个设备的对象字典中 Heartbeat producer time（心跳产生时间）对象上都进行设置。如果心跳报文在此时间限制内未到达，则发出者将被视为关机，使用者将采取补救措施，如设备重置或错误显示。</p>
<p>当一个 Heartbeat 节点启动后它的 Boot-up 报文是其第一个 Heartbeat 报文。Heartbeat 消费者通常是 NMT-Master 节点，它为每个 Heartbeat 节点设定一个超时值，当超时发生时采取相应动作。</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p>读取心跳时间设置</p>
<p><code>40 17 10 00 00 00 00 00</code></p>
<p>通过配置 0x1017 的 heartbeat 时间，自动上报设备状态。</p>
<p><code>2B 17 10 00 E8 03 00 00</code></p>
<p><del>Master 节点发送远程帧（无数据）NMT-Master -&gt; NMT-Slave</del></p>
<p><code>COB-ID</code> &#x3D; <code>0x700</code> + <code>Node_ID</code></p>
<p><del>NMT-Slave 节点发送如下报文应答 NMT-Master &lt;- NMT-Slave</del></p>
<p><code>COB-ID</code> &#x3D; <code>0x700</code> + <code>Node_ID</code></p>
<p><code>Byte0</code> &#x3D; <code>Bit 7-0 : 状态</code></p>
<h2 id="LSS"><a href="#LSS" class="headerlink" title="LSS"></a>LSS</h2><p>LSS（Layer Setting Services）是一个用于配置和管理 CANopen 设备的一种服务。它提供了一些特定的功能，主要用于设备的初始化和配置，例如设置节点 ID 和波特率。LSS 对于在生产、调试和运行过程中配置 CANopen 设备非常有用。</p>
<h3 id="LSS-的主要功能"><a href="#LSS-的主要功能" class="headerlink" title="LSS 的主要功能"></a>LSS 的主要功能</h3><ol>
<li><p><strong>设置节点 ID</strong>：</p>
<ul>
<li>在 CANopen 网络中，每个节点都有一个唯一的节点 ID，范围为 1 到 127。LSS 允许动态设置或修改节点 ID，而不需要物理访问设备。这在设备初始安装和替换时特别有用。</li>
</ul>
</li>
<li><p><strong>设置波特率</strong>：</p>
<ul>
<li>CANopen 网络中的所有节点必须使用相同的波特率进行通信。LSS 允许动态修改设备的波特率，以便在不同的网络条件下进行适应和优化。</li>
</ul>
</li>
<li><p><strong>设备识别</strong>：</p>
<ul>
<li>LSS 可以用于识别网络中的设备。通过 LSS 服务，可以查询设备的唯一标识符（例如制造商代码、产品代码、序列号等），从而实现设备的识别和管理。</li>
</ul>
</li>
</ol>
<h3 id="LSS-服务的主要操作"><a href="#LSS-服务的主要操作" class="headerlink" title="LSS 服务的主要操作"></a>LSS 服务的主要操作</h3><ol>
<li><p><strong>Switch Mode Global</strong>：</p>
<ul>
<li>切换所有节点到配置模式或操作模式。</li>
</ul>
</li>
<li><p><strong>Switch Mode Selective</strong>：</p>
<ul>
<li>选择性地切换特定节点到配置模式或操作模式。</li>
</ul>
</li>
<li><p><strong>Configure Node-ID</strong>：</p>
<ul>
<li>设置节点 ID。</li>
</ul>
</li>
<li><p><strong>Configure Bit Timing Parameters</strong>：</p>
<ul>
<li>设置 CAN 总线的波特率参数。</li>
</ul>
</li>
<li><p><strong>Identify Remote Slave</strong>：</p>
<ul>
<li>识别网络中的设备，读取其唯一标识符。</li>
</ul>
</li>
</ol>
<h3 id="LSS-协议的示例"><a href="#LSS-协议的示例" class="headerlink" title="LSS 协议的示例"></a>LSS 协议的示例</h3><p>假设我们需要将一个设备的节点 ID 设置为 0x02，并将波特率设置为 250 kbps。以下是使用 LSS 的步骤：</p>
<ol>
<li><p><strong>切换到配置模式</strong>： 发送 LSS Switch Mode Selective 命令，将目标设备切换到配置模式。</p>
</li>
<li><p><strong>设置节点 ID</strong>： 使用 LSS Configure Node-ID 命令，设置设备的节点 ID。</p>
</li>
<li><p><strong>设置波特率</strong>： 使用 LSS Configure Bit Timing Parameters 命令，设置设备的波特率。</p>
</li>
<li><p><strong>切换到操作模式</strong>： 发送 LSS Switch Mode Global 命令，将所有设备切换到操作模式。</p>
</li>
</ol>
<h3 id="LSS-消息格式"><a href="#LSS-消息格式" class="headerlink" title="LSS 消息格式"></a>LSS 消息格式</h3><p>LSS 消息使用特定的 CAN 标识符和数据格式。以下是 LSS Switch Mode Selective 命令的示例：</p>
<ul>
<li><strong>CAN ID</strong>：0x7E5（LSS 主站到从站）</li>
<li><strong>数据</strong>：0x04 0x00 0x00 0x00 0x00 0x00 0x00 0x00（切换到配置模式）</li>
</ul>
<p><strong>设置节点 ID 的命令</strong>：</p>
<ul>
<li><strong>CAN ID</strong>：0x7E5</li>
<li><strong>数据</strong>：0x11 0x02 0x00 0x00 0x00 0x00 0x00 0x00（设置节点 ID 为 0x02）</li>
</ul>
<p><strong>设置波特率的命令</strong>：</p>
<ul>
<li><strong>CAN ID</strong>：0x7E5</li>
<li><strong>数据</strong>：0x13 0x03 0x00 0x00 0x00 0x00 0x00 0x00（设置波特率为 250 kbps，假设 0x03 表示 250 kbps）</li>
</ul>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CAN和CANFD</title>
    <url>/2024/05/20/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN%E5%92%8CCANFD/</url>
    <content><![CDATA[<h1 id="CAN-和-CANFD"><a href="#CAN-和-CANFD" class="headerlink" title="CAN 和 CANFD"></a>CAN 和 CANFD</h1><p>CAN 与 CAN-FD 主要区别：</p>
<ul>
<li>传输速率不同<br>  CAN：最大传输速率 1Mbps。<br>  CAN-FD：速率可变，仲裁比特率最高 1Mbps（与 CAN 相同），数据比特率最高 8Mbps。</li>
<li>数据长度不同<br>  CAN：一帧数据最长 8 字节<br>  CAN-FD：一帧数据最长 64 字节。</li>
<li>帧格式不同和 ID 长度不同。</li>
</ul>
<p>CANFD 不存在远程帧，CAN 报文中的 RTR（用于区别标准帧与远程帧）被替换为 RRS（远程请求替代位，默认值为 0）</p>
<p>CANFD 报文的标准帧和扩展帧—IDE 为 1 表示为扩展帧、为 0 表示标准帧</p>
<p>FDF 用于传统 CAN 报文和 CANFD 报文，FDF 位为 0 时为传统报文，FDF 为 1 时为 CANFD 报文</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520123827.png" alt="image.png"></p>
<p>BRS 位速率切换为，BRS 位为 0 时 CANFD 速率保持恒定速率、BRS 位为 1 时 CANFD 的数据段会被切换到高速率。</p>
<p>ESI 错误状态指示位：CAN 报文中发送节点的错误状态只有该节点自己知道，CANFD 报文中可以通过 ESI 标志位来告诉其他节点该节点的错误状态，当 ESI 为 1 时表示发送节点处于被动错误状态、当 ESI 为 0 时表示发送节点处于主动错误状态</p>
<p>CRC：随着数据场的扩大，为了保证信息发送的质量，CAN FD 的 CRC 计算不仅要包括数据段的位，还包括来自 SOF 的 Stuff Count 和填充位。通过比较 CRC 的计算结果，可以判断接收节点是否能够正常接收。</p>
<p>在 CAN 中，CRC 的位数是 15 位，而在 CAN FD 中，CRC 场扩展到了 21 位。</p>
<p>当传输报文为 15 字节时：CRC 15 位</p>
<p>当传输数据为 16 字节或更少时：CRC 17 位</p>
<p>当传输数据超过 16 字节时：CRC 21 位</p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CAN学习笔记</title>
    <url>/2024/05/17/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CAN 总线是一种串行通信协议，使用的是两条差分信号线，只能表达一个信号。</p>
<p>简洁的物理层决定了 CAN 必然要配上一套复杂的协议。</p>
<p>根据不同的距离、不同的网络，可配置不同的速度，最高速度为 1MBit&#x2F;s。</p>
<p>CAN 2.0A 为标准格式，CAN 2.0B 为扩展格式。</p>
<p>优点：</p>
<ul>
<li>可以多主方式工作，网络上的任意节点均可以在任意时刻主动地向网络上的其他节点发送信息，而不分主从，通信方式灵活。</li>
<li>网络上的节点 (信息) 可分成不同的优先级，可以满足不同的实时要求。</li>
<li>采用非破坏性位仲裁总线结构机制，当两个节点同时向网络上传送信息时，优先级低的节点主动停止数据发送，而优先级高的节点可不受影响地继续传输数据。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>当 CAN 总线上的节点发送数据时，以报文形式广播给网络中的所有节点，总线上的所有节点都不使用节点地址等系统配置信息，只根据每组报文开头的 11 位标识符 (CAN 2.0A 规范) 解释数据的含义来决定是否接收。这种数据收发方式称为面向内容的编址方案。</p>
<p>当某个节点要向其他节点发送数据时，这个节点的处理器将要发送的数据和自己的标识符传送给该节点的 CAN 总线接口控制器，并处于准备状态；当收到总线分配时，转为发送报文状态。数据根据协议组织成一定的报文格式后发出，此时网络上的其他节点处于接收状态。处于接收状态的每个节点对接收到的报文进行检 测，判断这些报文是否是发给自己的以确定是否接收。</p>
<h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p>CAN 被细分为三个层次：</p>
<p>（1）CAN 对象层（the object layer）；</p>
<p>（2）CAN 传输层（the transfer layer）；</p>
<p>（3）CAN 物理层（the phyical layer）；</p>
<p>对象层和传输层包括所有由 ISO&#x2F;OSI 模型定义的数据链路层的服务和功能。</p>
<p>对象层的作用范围包括：</p>
<p>（1）查找被发送的报文。</p>
<p>（2）确定由实际要使用的传输层接收哪一个报文。</p>
<p>（3）为应用层相关硬件提供接口。</p>
<p>传输层的作用主要：</p>
<p>（1）传送规则，也就是控制帧结构、执行仲裁、错误检测、出错标定、故障界定。</p>
<p>（2）总线上什么时候开始发送新报文及什么时候开始接收报文，均在传输层里确定。</p>
<p>（3）位定时的一些普通功能也可以看作是传输层的一部分。</p>
<p>（4）传输层的修改是受到限制的。</p>
<p>物理层的作用：</p>
<p>在不同节点之间根据所有的电气属性进行位信息的实际传输。当然，同一网络内，物理层对于所有的节点必须是相同的。</p>
<p>编程在对象层进行，这一层直接与应用层交互，并且提供了管理和处理 CAN 消息的接口。通过对象层，应用程序可以发送和接收 CAN 的打包消息。打包的过程就是在原始数据的基础上再加上帧起始段、仲裁段、控制段、CRC 校验、应答和帧结束，把这些内容按特定的格式打包好，就可以用一个通道表达各种信号了，当数据包被发送时，只要接收方按约定格式去解读，就能还原出原始数据。</p>
<p>传输层的功能主要由 CAN 控制器硬件和驱动程序实现。通常，程序员不直接操作传输层，而是通过对象层的 API 间接利用传输层的功能。</p>
<p>传输层负责处理 CAN 协议的低级细节，如位级传输、错误处理和仲裁。</p>
<ul>
<li>位填充（BitStuffing）</li>
</ul>
<p>位填充是为了防止突发错误而设定的功能。位填充的规则如下：</p>
<p>（1）5 位连续相同电平之后，必须填充一位反向位，即不允许有 6 个连续相同位；</p>
<p>（2）SOF 之前为总线空闲状态，不需要同步，因此不需要位填充；</p>
<p>（3）CRC 之后为固定格式，不允许填充；</p>
<p>（4）<strong>由 CAN 控制器自动实现</strong>；</p>
<p>物理层通常由 CAN 收发器硬件和相关电气接口组成。</p>
<h2 id="CAN-属性"><a href="#CAN-属性" class="headerlink" title="CAN 属性"></a>CAN 属性</h2><p>CAN 具有以下的属性：</p>
<p>（1）报文（Messages）：CAN 协议对数据、操作命令 (如读&#x2F;写) 以及同步信号进行打包，打包后的这些内容称为报文，简单来说就是具有固定格式的数据包。</p>
<p>（2）信息路由（Information Routing）：即，报文寻找结点的方式。</p>
<p>（3）位速率（Bit rate）：数据位的传输速度。</p>
<p>（4）优先权（Priorities）：即报文发送的优先权。</p>
<p>（5）远程数据请求（Remote Data Request）：通过发送远程帧，需要数据的节点可以请求另一节点发送相应的数据帧。</p>
<p>（6）多主机（Multimaster）：总线空闲时，任何结点都可以开始传送报文。</p>
<p>（7）仲裁（Arbitration）：当 2 个及以上的单元同时开始传送报文，那么就会有总线访问冲突。仲裁是确定哪个单元的具有发送优先权。</p>
<p>（8）安全性（Safety）：CAN 的每一个节点均采取了强有力的措施以进行错误检测、错误标定及错误自检。</p>
<p>（9）错误检测（Error Detection）：包括监视、循环冗余检查、位填充、报文格式检查。</p>
<p>（10）错误检测的执行（Performance of Error Detection）</p>
<p>（11）错误标定和恢复时间（Error Sinalling and Recovery Time）：任何检测到错误的结点会标志出已损坏的报文。此报文会失效并将自动地开始重新传送。如果不再出现新的错误，从检测到错误到下一报文的传送开始为止，恢复时间最多为 29 个位的时间。</p>
<p>（12）故障界定（Fault Confinement）：CAN 结点能够把永久故障和短暂扰动区分开来。永久故障的结点会被关闭。</p>
<p>（13）连接（Connections）：CAN 串行通讯链路是可以连接许多结点的总线。理论上，可连接无数多的结点。但由于实际上受延迟时间或者总线线路上电气负载的影响，连接结点的数量是有限的。</p>
<p>（14）单通道（Single Channel）：总线是由单一进行双向位信号传送的通道组成。</p>
<p>（15）总线值（Bus value）：总线可以具有两种互补的逻辑值之一：“显性”（可表示为逻辑 0）或“隐性”（可表示为逻辑 1）。</p>
<p>（16）应答（Acknowledgment）：所有的接收器检查报文的连贯性。对于连贯的报文，接收器应答；对于不连贯的报文，接收器作出标志。</p>
<p>（17） 睡眠模式／唤醒（Sleep Mode &#x2F; Wake-up）：为了减少系统电源的功率消耗，可以将 CAN 器件设为睡眠模式以便停止内部活动及断开与总线驱动器的连接。CAN 器件可由总线激活，或系统内部状态而被唤醒。</p>
<h2 id="仲裁方式"><a href="#仲裁方式" class="headerlink" title="仲裁方式"></a>仲裁方式</h2><p>在总线空闲态，最先开始发送消息的单元获得发送权。多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。<strong>连续输出显性电平最多的单元可继续发送</strong>。即逐位地对比 各个结点发出的报文 ID。</p>
<p>由于线与的关系，显示位“0”可以覆盖隐性位“1”，因此 ID 最小的节点赢得仲裁，总线上表现为该结点的报文，其他结点失去仲裁，退出发送，转为接收状态。</p>
<ul>
<li>标准格式 ID 与具有相同 ID 的远程帧或者扩展格式的数据帧在总线上竞争时，标准格式的 RTR 位为显性位的具有优先权，可继续发送。</li>
</ul>
<h2 id="位时序"><a href="#位时序" class="headerlink" title="位时序"></a>位时序</h2><p>由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为 4 段。</p>
<ul>
<li>同步段（SS）</li>
<li>传播时间段（PTS）</li>
<li>相位缓冲段 1（PBS1）</li>
<li>相位缓冲段 2（PBS2）</li>
</ul>
<p>这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。</p>
<p>1 位分为 4 个段，每个段又由若干个 Tq 构成，这称为位时序。</p>
<p>1 位由多少个 Tq 构成、每个段又由多少个 Tq 构成等，可以任意设定位时序。通过设定位时序，多个单元可</p>
<p>同时采样，也可任意设定采样点。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523155731.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523155741.png" alt="image.png"></p>
<p>Linux 下设置位时序的方式</p>
<p><code>ip link set can0 type cantq 125 prop-seg 6phase-seg1 7 phase-seg2 2 sjw 1</code></p>
<ul>
<li>同步段（Sync Segment）: 固定为 1 TQ，用于同步位定时器。</li>
</ul>
<p>传播时间段（Propagation Segment, prop-seg）: 用于补偿信号在总线上传播的时间延迟。</p>
<p>相位缓冲段 1（Phase Buffer Segment 1, phase-seg1）: 用于提高抗干扰能力，允许时间调整。</p>
<p>相位缓冲段 2（Phase Buffer Segment 2, phase-seg2）: 也用于提高抗干扰能力，允许时间调整。</p>
<p>*ip link set can0 type can: 设置名为 can0 的网络接口的类型为 CAN。<br>tq 125: 设置时间量化（Time Quantum，TQ）为 125 ns。TQ 是 CAN 控制器内部的基本时间单位，用于划分整个位时间。<br>prop-seg 6: 设置传播时间段（Propagation Segment）为 6 TQ。传播时间段用于补偿信号在 CAN 总线上传播的延迟。<br>phase-seg1 7: 设置相位缓冲段 1（Phase Buffer Segment 1）为 7 TQ。这个时间段用于调整边沿相位，通常包括采样点之前的时间。<br>phase-seg2 2: 设置相位缓冲段 2（Phase Buffer Segment 2）为 2 TQ。这个时间段用于调整边沿相位，通常包括采样点之后的时间。<br>sjw 1: 设置同步跳跃宽度（Synchronization Jump Width，SJW）为 1 TQ。SJW 用于重新同步时可以跳跃的最大时间量。</p>
<ul>
<li>具体计算<br>tq 125: 时间量化为 125 ns。<br>prop-seg 6: 传播时间段为 6 个时间量化，6 * 125 ns &#x3D; 750 ns。<br>phase-seg1 7: 相位缓冲段 1 为 7 个时间量化，7 * 125 ns &#x3D; 875 ns。<br>phase-seg2 2: 相位缓冲段 2 为 2 个时间量化，2 * 125 ns &#x3D; 250 ns。<br>sjw 1: 同步跳跃宽度为 1 个时间量化，1 * 125 ns &#x3D; 125 ns。<br>计算位时间<br>总位时间是所有段的时间总和：<br>Sync Segment: 1 TQ<br>Propagation Segment: 6 TQ<br>Phase Buffer Segment 1: 7 TQ<br>Phase Buffer Segment 2: 2 TQ<br>总时间量化数 &#x3D; 1 + 6 + 7 + 2 &#x3D; 16 TQ<br>总位时间 &#x3D; 16 * 125 ns &#x3D; 2000 ns &#x3D; 2 μs<br>位速率（Bit Rate） &#x3D; 1 &#x2F; 总位时间 &#x3D; 1 &#x2F; 2 μs &#x3D; 500 kbps</li>
</ul>
<h1 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h1><h2 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h2><p>为了更有效地控制通讯，CAN 一共规定了 5 种类型的帧</p>
<ul>
<li>数据帧：发送单元向接收单元传送数据的帧。</li>
<li>远程帧：接收单元向发送单元请求数据的帧。</li>
<li>错误帧：检测出错误时向其它单元通知错误的帧。</li>
<li>过载帧：接收单元通知其尚未就绪的帧。</li>
<li>间隔帧：将数据帧及遥控帧与前面的帧分离开来的帧。</li>
</ul>
<ul>
<li>数据帧和遥控帧有<strong>标准帧和扩展帧</strong>两种帧，标准帧有 11 个位的标识符 ID，扩展帧有 29 个位的 ID</li>
</ul>
<h2 id="标准-CAN-帧定义"><a href="#标准-CAN-帧定义" class="headerlink" title="标准 CAN 帧定义"></a>标准 CAN 帧定义</h2><p>数据帧由帧起始、仲裁段、控制段、数据段、CRC、ACK、帧结束共 7 个段构成</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520113845.png" alt="image.png"></p>
<p><code>隐形=1</code></p>
<p><code>显性=0</code></p>
<p>帧起始 (Start Of Frame,SOF)，1bit</p>
<p>表示帧开始的段，设置为 0。</p>
<p>仲裁段（Identifier，ID），11bits&#x2F;29bits</p>
<p>表示数据帧优先级的段<br>标准帧与扩展帧的构成有所不同，均禁止高 7 位为隐性 (ID&#x3D;1111111XXXX…)</p>
<p>仲裁段的内容主要为本数据帧的 ID，标准帧的 ID 有 11 个位，扩展帧的 ID 有 29 个位，在 CAN 协议中，ID 决定着数据帧发送的优先级，也决定着其它节点是否会接收这个数据帧。CAN 总线不对挂载在它之上的节点分配优先级和地址，对总线的占有权是由信息的 ID 决定的，即对于重要的信息，优先级高的 ID，能够优先发送出去</p>
<ul>
<li>RTR 位 (Remote Transmission Request Bit)<br>远程传输请求位，用于区分数据帧和遥控帧的，为 0 表示数据帧，1 表示遥控帧。</li>
</ul>
<p>控制段</p>
<p>控制段由 6 个位构成，表示数据段的字节数  </p>
<ul>
<li>IDE 位 (Identifier Extension Bit)<br>标识符扩展位，用于区分标准帧与扩展帧，为 0 表示标准帧，1 表示扩展帧</li>
<li>SRR 位 (Substitute Remote Request Bit)<br>只存在于扩展帧，它用于替代标准帧中的 RTR 位，扩展帧中的 SRR 位固定为 1，RTR 在数据帧中为 0，所以两个 ID 相同的标准帧与扩展帧，标准帧的优先级较高 </li>
<li>DLC 数据长度码（Data Length Code）<br>数据的字节数必须为 0～8 字节</li>
</ul>
<p>数据段（Data Field）</p>
<p>数据段可包含 0～8 个字节的数据</p>
<p>CRC 段</p>
<ul>
<li>CRC 段是检查帧传输错误的段，由 15 个位的 CRC 值和 1 个位的 CRC 界定符 (隐性分隔位) 构成</li>
<li>CRC 是根据多项式生成的 CRC 值，CRC 的计算范围包括帧起始、仲裁段、控制段、数据段  </li>
<li>接收方以同样的方式计算 CRC 值并进行比较，不一致时利用错误帧请求重新发送</li>
</ul>
<p>ACK 段</p>
<p>ACK 段包括 ACK 槽位、ACK 界定符位 2 个位</p>
<p>发送单元的 ACK 段：发送单元在 ACK 段发送 2 个位的隐性位<br>接收单元的 ACK 段：接收到正确消息的单元在 ACK 槽发送显性位，通知发送单元正常接收结束，这称作“发送 ACK”或者“返回 ACK”</p>
<p>帧结束 (End Of Frame，EOF)</p>
<p>帧结束是表示该帧结束的段，由发送节点发送 7 个位的隐性位构成</p>
<p>*CAN 数据帧的结束符长度并不是完全不定的，而是根据数据位速率（Data Bit Rate，DBR）而定。CAN 总线协议规定，对于数据位速率低于等于 125kbps 的网络，CAN 数据帧的结束符长度为 7 个位；对于数据位速率大于 125kbps 的网络，CAN 数据帧的结束符长度为 3 个位。这是因为在高速网络中，由于数据传输速率更快，所以 CAN 控制器可以更快地检测到结束位，因此可以减少结束符的长度，从而提高网络的传输效率。而在低速网络中，由于数据传输速率较慢，所以 CAN 控制器需要更长的时间来检测结束位，因此需要一个更长的结束符来确保数据帧传输的正确性和完整性。因此，CAN 数据帧的结束符长度是根据数据位速率而定的，并不是完全不定的。</p>
<h2 id="Linux-下的-Socket-CAN-帧定义"><a href="#Linux-下的-Socket-CAN-帧定义" class="headerlink" title="Linux 下的 Socket CAN 帧定义"></a>Linux 下的 Socket CAN 帧定义</h2><ul>
<li>帧头，<code>canid_t</code> 定义了一个无符号的 32 位整形数，按位确定功能<br> *0-28 位为标识符，如果是扩展帧，则高 11 位为标准 ID<br> 29 位标识是数据帧还是错误消息<br> 30 位说明是否是远程帧<br> 31 位说明是标准帧还是扩展帧。</li>
<li>帧长，8 位无符号表示数据区长度</li>
<li>数据区，定义 <code>CAN_MAX_DLEN</code> 个 8 位无符号数，按照数组的形式申请<br>*<code>__attribute__((aligned(8)))</code> 告诉编译器，将变量 <code>data</code> 放在一个地址是 8 的倍数的内存位置上。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CAN payload length and DLC definitions according to ISO 11898-1 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_MAX_DLC 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_MAX_DLEN 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> &#123;</span><br><span class="line"> <span class="type">canid_t</span> can_id; <span class="comment">/* 32 bit CAN_ID + EFF/RTR/ERR flags */</span></span><br><span class="line"> __u8 can_dlc; <span class="comment">/* frame payload length in byte */</span></span><br><span class="line"> __u8 data[CAN_MAX_DLEN] __attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Controller Area Network Identifier structure</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* bit 0-28 : CAN identifier (11/29 bit)</span></span><br><span class="line"><span class="comment">* bit 29 : error message frame flag (0 = data frame, 1 = error message)</span></span><br><span class="line"><span class="comment">* bit 30 : remote transmission request flag (1 = rtr frame)</span></span><br><span class="line"><span class="comment">* bit 31 : frame format flag (0 = standard 11 bit, 1 = extended 29 bit)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> __u32 <span class="type">canid_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> __u8;</span><br></pre></td></tr></table></figure>

<p>Linux 处理 can_frame 时用到的掩码和标识符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* special address description flags for the CAN_ID */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_EFF_FLAG 0x80000000U <span class="comment">/* EFF/SFF is set in the MSB */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_RTR_FLAG 0x40000000U <span class="comment">/* remote transmission request */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_ERR_FLAG 0x20000000U <span class="comment">/* error message frame */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* valid bits in CAN ID for frame formats */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_SFF_MASK 0x000007FFU <span class="comment">/* standard frame format (SFF) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_EFF_MASK 0x1FFFFFFFU <span class="comment">/* extended frame format (EFF) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_ERR_MASK 0x1FFFFFFFU <span class="comment">/* omit EFF, RTR, ERR flags */</span></span></span><br></pre></td></tr></table></figure>

<p>实际对 can_frame 的处理是在 mcp251x_hw_tx&#x2F;mcp251x_hw_rx_frame 中进行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mcp251x_hw_tx</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> can_frame *frame,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> tx_buf_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mcp251x_priv</span> *priv = <span class="built_in">spi_get_drvdata</span>(spi);</span><br><span class="line">u32 sid, eid, exide, rtr;</span><br><span class="line">u8 buf[SPI_TRANSFER_BUF_LEN];</span><br><span class="line"><span class="comment">//取can_id的31位，判断是标准帧还是扩展帧</span></span><br><span class="line">exide = (frame-&gt;can_id &amp; CAN_EFF_FLAG) ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (exide)<span class="comment">//如果是扩展帧，can_id的0-28位为ID，其中高11位为标准ID</span></span><br><span class="line">sid = (frame-&gt;can_id &amp; CAN_EFF_MASK) &gt;&gt; <span class="number">18</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sid = frame-&gt;can_id &amp; CAN_SFF_MASK; <span class="comment">/* Standard ID */</span></span><br><span class="line">eid = frame-&gt;can_id &amp; CAN_EFF_MASK; <span class="comment">/* Extended ID */</span></span><br><span class="line">rtr = (frame-&gt;can_id &amp; CAN_RTR_FLAG) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">/* 是否是远程帧*/</span></span><br><span class="line">buf[TXBCTRL_OFF] = <span class="built_in">INSTRUCTION_LOAD_TXB</span>(tx_buf_idx); <span class="comment">//发送缓冲器控制寄存器地址</span></span><br><span class="line">buf[TXBSIDH_OFF] = sid &gt;&gt; SIDH_SHIFT; <span class="comment">//发送缓冲器标准ID高8位</span></span><br><span class="line"><span class="comment">//5-7位存放发送缓冲器低3位,3位存放帧格式，0-1位存放扩展标识符低18位的高两位（16-17）</span></span><br><span class="line">buf[TXBSIDL_OFF] = ((sid &amp; SIDL_SID_MASK) &lt;&lt; SIDL_SID_SHIFT) | (exide &lt;&lt;</span><br><span class="line">SIDL_EXIDE_SHIFT) | ((eid &gt;&gt; SIDL_EID_SHIFT) &amp; SIDL_EID_MASK);</span><br><span class="line">buf[TXBEID8_OFF] = <span class="built_in">GET_BYTE</span>(eid, <span class="number">1</span>); <span class="comment">//存放扩展标识符低18位的8-15位</span></span><br><span class="line">buf[TXBEID0_OFF] = <span class="built_in">GET_BYTE</span>(eid, <span class="number">0</span>); <span class="comment">//扩展标识符低18位的低8位（0-7）</span></span><br><span class="line">buf[TXBDLC_OFF] = (rtr &lt;&lt; DLC_RTR_SHIFT) | frame-&gt;can_dlc; <span class="comment">//6位存放远程帧标识符，0-3存放数据长度码</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf + TXBDAT_OFF, frame-&gt;data, frame-&gt;can_dlc);<span class="comment">//拷贝要发送的数据</span></span><br><span class="line"><span class="built_in">mcp251x_hw_tx_frame</span>(spi, buf, frame-&gt;can_dlc, tx_buf_idx);</span><br><span class="line"><span class="comment">/* use INSTRUCTION_RTS, to avoid &quot;repeated frame problem&quot; */</span></span><br><span class="line">priv-&gt;spi_tx_buf[<span class="number">0</span>] = <span class="built_in">INSTRUCTION_RTS</span>(<span class="number">1</span> &lt;&lt; tx_buf_idx);</span><br><span class="line"><span class="built_in">mcp251x_spi_trans</span>(priv-&gt;spi, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mcp251x_hw_rx_frame</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, u8 *buf,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> buf_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mcp251x_priv</span> *priv = <span class="built_in">spi_get_drvdata</span>(spi);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mcp251x_is_2510</span>(spi)) &#123;</span><br><span class="line"><span class="type">int</span> i, len;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; RXBDAT_OFF; i++)</span><br><span class="line">	buf[i] = <span class="built_in">mcp251x_read_reg</span>(spi, <span class="built_in">RXBCTRL</span>(buf_idx) + i);</span><br><span class="line">	len = <span class="built_in">get_can_dlc</span>(buf[RXBDLC_OFF] &amp; RXBDLC_LEN_MASK);</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; (RXBDAT_OFF + len); i++)</span><br><span class="line">	buf[i] = <span class="built_in">mcp251x_read_reg</span>(spi, <span class="built_in">RXBCTRL</span>(buf_idx) + i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	priv-&gt;spi_tx_buf[RXBCTRL_OFF] = <span class="built_in">INSTRUCTION_READ_RXB</span>(buf_idx);</span><br><span class="line">	<span class="built_in">mcp251x_spi_trans</span>(spi, SPI_TRANSFER_BUF_LEN);</span><br><span class="line">	<span class="built_in">memcpy</span>(buf, priv-&gt;spi_rx_buf, SPI_TRANSFER_BUF_LEN);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Linux-CAN-功能分析"><a href="#Linux-CAN-功能分析" class="headerlink" title="Linux CAN 功能分析"></a>Linux CAN 功能分析</h1><p>一个标准的 CAN 功能包括：</p>
<ul>
<li>CAN 接口号指定 CAN 接口号 <code>can0</code></li>
<li>指定 CAN 通讯波特率，单位 Kbps，默认为 500 Kbps</li>
<li>指定 CAN 发送帧 ID</li>
<li>指定 CAN 发送帧数据</li>
</ul>
<ul>
<li>需要包含数据的大小端模式转换</li>
</ul>
<ul>
<li>指定 CAN 帧发送间隔，单位 ms， 默认为 250ms, 最小值为 1ms  </li>
<li>指定 CAN 帧发送次数</li>
<li>指定 CAN 发送帧为标准帧&#x2F;扩展帧  </li>
<li>发送数据时错误判断，本地环回功能<br>基于 LINUX SOCKET 机制实现的 CAN 接口，其基本的流程如下所示：</li>
<li>设置套接字 <code>socket</code></li>
<li>指定 CAN 设备 <code>ioctl</code></li>
<li>绑定套接字与设备 <code>bind</code></li>
<li>设置过滤规则 <code>setsockopt</code></li>
<li>发送&#x2F;接受报文 <code>read/write</code></li>
<li>关闭套接字 <code>close</code><br>以下介绍各部分如何实现。</li>
</ul>
<h1 id="Linux-应用层-SocketCAN-实例"><a href="#Linux-应用层-SocketCAN-实例" class="headerlink" title="Linux 应用层 SocketCAN 实例"></a>Linux 应用层 SocketCAN 实例</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>SocketCAN 中大部分的数据结构和函数在头文件 linux&#x2F;can.h 中进行了定义。 CAN 总线套接字的创建采用标准的网络套接字操作来完成。网络套接字在头文件 sys&#x2F;socket.h 中定义。 套接字的初始化方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_can</span> addr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ifreq</span> ifr;</span><br><span class="line">s = <span class="built_in">socket</span>(PF_CAN, SOCK_RAW, CAN_RAW);<span class="comment">//创建SocketCAN 套接字</span></span><br><span class="line"><span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span>);</span><br><span class="line"><span class="built_in">ioctl</span>(s, SIOCGIFINDEX, &amp;ifr);<span class="comment">//指定 can0 设备</span></span><br><span class="line">addr.can_family = AF_CAN;</span><br><span class="line">addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line"><span class="built_in">bind</span>(s, (structsockaddr *)&amp;addr,<span class="built_in">sizeof</span>(addr)); <span class="comment">//将套接字与 can0 绑定</span></span><br></pre></td></tr></table></figure>

<h2 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h2><p>在数据收发的内容方面， CAN 总线与标准套接字通信稍有不同，每一次通信都采用 can_ frame 结构体将数据封装成帧。 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">structcan_frame &#123;</span><br><span class="line"><span class="type">canid_t</span> can_id;<span class="comment">//CAN 标识符</span></span><br><span class="line">__u8 can_dlc;<span class="comment">//数据场的长度</span></span><br><span class="line">__u8 data[<span class="number">8</span>];<span class="comment">//数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>can_id 为帧的标识符， 如果发出的是标准帧， 就使用 can_id 的低 11 位； 如果为扩展帧， 就使用 0～ 28 位。 can_id 的第 29、 30、 31 位是帧的标志位，用来定义帧的类型，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_EFF_FLAG 0x80000000U <span class="comment">//扩展帧的标识</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_RTR_FLAG 0x40000000U <span class="comment">//远程帧的标识</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_ERR_FLAG 0x20000000U <span class="comment">//错误帧的标识，用于错误检查</span></span></span><br></pre></td></tr></table></figure>

<p>数据发送使用 write 函数来实现。 如果发送的数据帧 (标识符为 0x123) 包含单个字节 (0xAB) 的数据，可采用如下方法进行发送：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> frame;</span><br><span class="line"><span class="comment">//如果为扩展帧，那么frame.can_id = CAN_EFF_FLAG | 0x123;</span></span><br><span class="line">frame.can_id = <span class="number">0x123</span>;</span><br><span class="line"></span><br><span class="line">frame.can_dlc = <span class="number">1</span>; <span class="comment">//数据长度为 1</span></span><br><span class="line">frame.data[<span class="number">0</span>] = <span class="number">0xAB</span>; <span class="comment">//数据内容为 0xAB</span></span><br><span class="line"><span class="type">int</span> nbytes = <span class="built_in">write</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame));<span class="comment">//发送数据</span></span><br><span class="line"><span class="keyword">if</span>(nbytes != <span class="built_in">sizeof</span>(frame)) <span class="comment">//如果 nbytes 不等于帧长度，就说明发送失败</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error\n!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果要发送远程帧 (标识符为 0x123)，可采用如下方法进行发送：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> frame;</span><br><span class="line">frame.can_id = CAN_RTR_FLAG | <span class="number">0x123</span>;</span><br><span class="line"><span class="built_in">write</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame));</span><br></pre></td></tr></table></figure>

<h2 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h2><p>数据接收使用 read 函数来完成，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> frame;</span><br><span class="line"><span class="type">int</span> nbytes = <span class="built_in">read</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame));</span><br></pre></td></tr></table></figure>

<p>套接字数据收发时常用的 send、 sendto、 sendmsg 以及对应的 recv 函数也都可以用于 CAN 总线数据的收发。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当帧接收后，可以通过判断 can_id 中的 CAN_ERR_FLAG 位来判断接收的帧是否为错误帧。 如果为错误帧，可以通过 can_id 的其他符号位来判断错误的具体原因。</p>
<p>错误帧的符号位在头文件 linux&#x2F;can&#x2F;error.h 中定义。</p>
<h2 id="过滤规则设置"><a href="#过滤规则设置" class="headerlink" title="过滤规则设置"></a>过滤规则设置</h2><p>在数据接收时，系统可以根据预先设置的过滤规则，实现对报文的过滤。过滤规则使用 can_filter 结构体来实现，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_filter</span> &#123;</span><br><span class="line"><span class="type">canid_t</span> can_id;</span><br><span class="line"><span class="type">canid_t</span> can_mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>过滤的规则为：接收到的数据帧的 <code>can_id &amp; mask == can_id &amp; mask</code></p>
<p>通过这条规则可以在系统中过滤掉所有不符合规则的报文，使得应用程序不需要对无关的报文进行处理。在 can_filter 结构的 can_id 中，符号位 CAN_INV_FILTER 在置位时可以实现 can_id 在执行过滤前的位反转。</p>
<p>用户可以为每个打开的套接字设置多条独立的过滤规则，使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">structcan_filter rfilter[<span class="number">2</span>];</span><br><span class="line">rfilter[<span class="number">0</span>].can_id = <span class="number">0x123</span>;</span><br><span class="line">rfilter[<span class="number">0</span>].can_mask = CAN_SFF_MASK;</span><br><span class="line"><span class="comment">//#define CAN_SFF_MASK 0x000007FFU</span></span><br><span class="line">rfilter[<span class="number">1</span>].can_id = <span class="number">0x200</span>;</span><br><span class="line">rfilter[<span class="number">1</span>].can_mask = <span class="number">0x700</span>;</span><br><span class="line"><span class="comment">//设置规则</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_FILTER,&amp;rfilter, <span class="built_in">sizeof</span>(rfilter));</span><br></pre></td></tr></table></figure>

<p>在极端情况下，如果应用程序不需要接收报文，可以禁用过滤规则。这样的话，原始套接字就会忽略所有接收到的报文。在这种仅仅发送数据的应用中，可以在内核中省略接收队列，以此减少 CPU 资源的消耗。禁用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_FILTER, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//禁用过滤规则</span></span><br></pre></td></tr></table></figure>

<p>通过错误掩码可以实现对错误帧的过滤， 例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">can_err_mask_t</span> err_mask = (CAN_ERR_TX_TIMEOUT | CAN_ERR_BUSOFF );</span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW,CAN_RAW_ERR_FILTER, err_mask,<span class="built_in">sizeof</span>(err_mask));</span><br></pre></td></tr></table></figure>

<h2 id="回环功能设置"><a href="#回环功能设置" class="headerlink" title="回环功能设置"></a>回环功能设置</h2><p>在默认情况下， 本地回环功能是开启的，可以使用下面的方法关闭回环&#x2F;开启功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> loopback = <span class="number">0</span>; <span class="comment">// 0 表示关闭, 1 表示开启( 默认)</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_LOOPBACK,&amp;loopback, <span class="built_in">sizeof</span>(loopback));</span><br></pre></td></tr></table></figure>

<p>在本地回环功能开启的情况下，所有的发送帧都会被回环到与 CAN 总线接口对应的套接字上。 默认情况下，发送 CAN 报文的套接字不想接收自己发送的报文，因此发送套接字上的回环功能是关闭的。</p>
<p>可以在需要的时候改变这一默认行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ro = <span class="number">1</span>; <span class="comment">// 0 表示关闭( 默认), 1 表示开启</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &amp;ro, <span class="built_in">sizeof</span>(ro));</span><br></pre></td></tr></table></figure>

<h1 id="如何在-ARM-上实现-CAN-通讯"><a href="#如何在-ARM-上实现-CAN-通讯" class="headerlink" title="如何在 ARM 上实现 CAN 通讯"></a>如何在 ARM 上实现 CAN 通讯</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>ARM 需要有 CAN 控制器和 CAN 收发器</p>
<p><em>CAN 控制器</em>（CAN Controller）是负责实现 CAN 协议的逻辑部分的组件</p>
<p><em>CAN 收发器</em>（CAN Transceiver）是负责 CAN 总线电平信号和 CAN 控制器之间的电信号转换的组件</p>
<p><strong>CAN 控制器</strong>示例：</p>
<ul>
<li>内置于微控制器中的 CAN 模块（例如 STM32 系列微控制器的内置 CAN 控制器）。</li>
<li>独立的 CAN 控制器芯片（例如 MCP2515）。<br><strong>CAN 收发器</strong>示例：</li>
<li>常见的独立 CAN 收发器芯片（例如 MCP2551、TJA1050 等）。</li>
</ul>
<p>先选择 CAN 控制器芯片，一般的 PC 和 ARM 都没有 CAN 控制器，一般是 MCP2515 和 SJA1000，主要区别是 MCP2515 是 SPI 接口，SJA1000 是 I&#x2F;O 接口。所以 MCP2515 占用资源少，5-6 个管脚就可以控制，SJA1000 占用的管脚就多。</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>需要支持 CAN 控制器驱动，控制 CAN 控制器发送 CAN 帧</p>
<p>对于一般的 CAN 控制器，进行初始化时，最关键的是以下两步：</p>
<ol>
<li>配置 CAN 的位时序；</li>
<li>配置 CAN 的消息报文；</li>
</ol>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>Linux 中有对 CAN（Controller Area Network）总线的支持，主要通过 SocketCAN 子系统实现。内核编译时选择响应的支持芯片。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make linux-menuconfig</span><br><span class="line">Networking support ---&gt;</span><br><span class="line">CAN bus subsystem support ---&gt;</span><br><span class="line">--- CAN bus subsystem support</span><br><span class="line">Raw CAN Protocol (raw access with CAN-ID filtering)</span><br><span class="line">Broadcast Manager CAN Protocol (with content filtering)</span><br><span class="line">CAN Device Drivers ---&gt;</span><br><span class="line">Virtual Local CAN Interface (vcan)</span><br><span class="line">Platform CAN drivers with Netlink support</span><br><span class="line">[*] CAN bit-timing calculation</span><br><span class="line">Microchip 251x series SPI CAN Controller</span><br></pre></td></tr></table></figure>

<p>SocketCAN 支持多种 CAN 控制器硬件，通过不同的内核驱动程序实现对具体硬件的支持。例如，以下是一些常见的 CAN 控制器驱动程序：</p>
<ul>
<li><code>sja1000</code>：Philips&#x2F;NXP SJA1000 CAN 控制器</li>
<li><code>mcp251x</code>：Microchip MCP251x SPI CAN 控制器系列（如 MCP2515）</li>
<li><code>flexcan</code>：Freescale&#x2F;NXP FlexCAN 模块<br>这些驱动程序通常位于内核源代码树的 <code>drivers/net/can</code> 目录下。</li>
</ul>
<h3 id="CAN-数据发送跟踪"><a href="#CAN-数据发送跟踪" class="headerlink" title="CAN 数据发送跟踪"></a>CAN 数据发送跟踪</h3><p>当我们在用户层通过 socket 进行 CAN 数据的发送时，需要进行以下操作：</p>
<ol>
<li>创建一个套接字 <code>socket</code>，采用 <code>AF_CAN</code> 协议。</li>
<li>将创建的套接字返回描述符 <code>sockfd</code>，绑定到本地的地址。</li>
<li>通过 <code>sendto</code> 系统调用函数进行发送，<code>sendto</code> 的系统调用会发送一帧数据报到指定的地址，在 CAN 协议调用之前把该地址移到内核空间和检查用户空间数据域是否可读。</li>
<li>在 <code>net/socket.c</code> 源文件中，在 <code>sendto</code> 的系统调用 <code>（sys_sendto）</code> 里，会调用到 <code>sock_sendmsg()</code> 函数，接下来调用 <code>__sock_sendmsg()</code> 函数。</li>
<li>再往下一步就是 <code>__sock_sendmsg_nosec</code> 函数。在 <code>__sock_sendmsg_nosec()</code> 函数中会返回一个 <code>sendmsg</code> 函数指针。</li>
<li>在 <code>/net/can/raw.c</code> 源文件中，将 <code>raw_sendmsg</code> 函数地址赋给 <code>sendmsg</code> 函数指针，即在函数 <code>__sock_sendmsg_nosec()</code> 中 <code>return sock-&gt;ops-&gt;sendmsg(iocb,sock, msg, size)</code>，返回的函数指针将指向 <code>raw_sendmsg()</code> 函数。</li>
<li>在 <code>net/can/af_can.c</code> 源文件中，<code>can_send</code> 函数负责 CAN 协议层的数据传输，即传输一帧 CAN 报文（可选本地回环）。参数 <code>skb</code> 指针指向套接字缓冲区和在数据段的 CAN 帧。loop 参数是在本地 CAN 套接字上为监听者提供回环。</li>
</ol>
<p>以下开始进行到 CAN 的底层驱动代码了，由于 CAN 驱动是编译进内核中，所以在系统启动时会注册 CAN 驱动。</p>
<ul>
<li>注册 CAN 驱动过程中会初始化 <code>d_can_netdev_ops</code> 结构体变量。</li>
<li>在这个过程中，<code>d_can_netdev_ops</code> 结构体变量定义了 3 个函数指针，其中 <code>(*ndo_start_xmit)</code> 函数指针指向 <code>d_can_start_xmit</code> 函数的入口地址。</li>
<li>在 <code>d_can_start_xmit()</code> 函数中，会调用 <code>d_can_write_msg_object()</code> 函数准备消息报文进行传输。</li>
</ul>
<h3 id="CAN-数据接收跟踪"><a href="#CAN-数据接收跟踪" class="headerlink" title="CAN 数据接收跟踪"></a>CAN 数据接收跟踪</h3><p>对于网络设备，数据接收大体上采用中断 +NAPI 机制进行数据的接收。同样，我们现在的 CAN 模块也是采用同样的方式进行数据的接收。由于我们只针对 CAN 总线接收数据这条主线进行分析。因些，会忽略一些针对 CAN 协议的设置及初始化等相关代码。</p>
<p>*NAPI（New API）是一种改进的网络数据接收机制，它通过减少中断处理的次数来提高性能。NAPI 的基本思想是延迟数据包的处理，使得多个数据包可以一次性地在中断处理程序中进行处理，从而减少了中断的数量，提高了系统的处理效率。</p>
<p>中断 +NAPI 机制的工作原理大致如下：</p>
<p>当网络数据包到达时，网络接口卡会生成一个中断通知操作系统。</p>
<p>中断服务程序会执行一些必要的处理，然后调用 NAPI 机制。</p>
<p>NAPI 机制会检查网络接口缓冲区中是否有足够的数据需要处理。</p>
<p>如果有足够的数据，NAPI 会立即开始处理这些数据，而不会再次触发中断。如果数据量不足，NAPI 会退出，并要求在将来的某个时候再次调用。</p>
<p>处理完数据后，系统可以选择性地决定是否重新启用中断服务程序。</p>
<p>通过将数据包的处理延迟到一组数据包到达时再进行，中断 +NAPI 机制能够大大减少中断的数量，提高系统的处理效率，特别是在高负载情况下。</p>
<ol>
<li>在初始化 CAN 设备时，我们需要给 CAN 设备分配 NAPI 功能。我们通过 <code>netif_napi_add()</code> 函数将 CAN 设备添加到 NAPI 机制列表中。</li>
<li>将 CAN 设备添加到 NAPI 机制列表中后，在中断处理函数 <code>d_can_isr</code> 中，我们通过 <code>napi_schedule()</code> 函数调度已经在 NAPI 机制列表中的 <code>d_can_poll()</code> 函数。该函数会通过轮询的方式接收数据。而根据 NAPI 机制，当中断产生后，会调度轮询机制同时关闭所有的中断。</li>
<li>当中断产生时，会调用函数 <code>d_can_poll()</code>，该函数即采用轮询的方式进行数据的接收。由于 CAN 总线状态中断具有最高优先权，在接收数据之前，需要对 CAN 总线的状态进行判断。而对于 CAN 总线错误状态有三种：主动&#x2F;被动&#x2F;关闭。</li>
<li>当总线状态数据状态正常时，从 CAN 模块的接收寄存器中接收数据。</li>
</ol>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>要在 linux 下面配置和测试 CAN，需要安装以下三个组件。</p>
<ul>
<li>iproute2 （配置 CAN 接口时需要）</li>
<li>libsocketcan（使用 CAN 必须）</li>
<li>can-utils <a href="https://github.com/linux-can/can-utils">https://github.com/linux-can/can-utils</a>  (CAN 的测试小工具，linux 下测试 CAN 比较好用应用程序)</li>
</ul>
<p>可以直接通过命令行形式控制 CAN</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置CAN接口（假设设备名为`can0`）：</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 500000</span><br><span class="line"><span class="comment"># 启动CAN接口</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> up can0</span><br><span class="line"><span class="comment"># 查看CAN接口状态</span></span><br><span class="line">ip -details <span class="built_in">link</span> show can0</span><br><span class="line"><span class="comment"># CAN 2.0 linkup</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 100000</span><br><span class="line"><span class="comment"># CAN 2.0 FD linkup</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 500000 dbitrate 2000000 fd on</span><br><span class="line"><span class="comment"># 命令来配置 CAN 总线的位速率：</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> cantq 125 prop-seg 6phase-seg1 7 phase-seg2 2 sjw 1</span><br><span class="line"><span class="comment"># 可以使用 ip 命令直接设定位速率500kbps：</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> can bitrate 500000</span><br><span class="line"><span class="comment"># 当设置完成后，可以通过下面的命令查询 can0 设备的参数设置：</span></span><br><span class="line">ip -details <span class="built_in">link</span> show can0</span><br><span class="line"><span class="comment"># 当设置完成后，可以使用下面的命令使能 can0 设备：</span></span><br><span class="line">ifconfig can0 up</span><br><span class="line"><span class="comment"># 使用下面的命令取消 can0 设备使能：</span></span><br><span class="line">ifconfig can0 down</span><br><span class="line"><span class="comment"># 在设备工作中，可以使用下面的命令来查询工作状态：</span></span><br><span class="line">ip -details -statistics <span class="built_in">link</span> show can0</span><br></pre></td></tr></table></figure>

<h1 id="Qt-中使用-SocketCAN"><a href="#Qt-中使用-SocketCAN" class="headerlink" title="Qt 中使用 SocketCAN"></a>Qt 中使用 SocketCAN</h1><p>需要编译安装 socketCAN 插件， <a href="https://doc.qt.io/qt-5/qtserialbus-socketcan-overview.html">https://doc.qt.io/qt-5/qtserialbus-socketcan-overview.html</a> ，关键字【Using SocketCAN Plugin】</p>
<p>pro 文件中添加 <code>QT += serialbus</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString errorString;</span><br><span class="line"><span class="type">const</span> QList&lt;QCanBusDeviceInfo&gt; devices = QCanBus::<span class="built_in">instance</span>()-&gt;<span class="built_in">availableDevices</span>(</span><br><span class="line">	<span class="built_in">QStringLiteral</span>(<span class="string">&quot;socketcan&quot;</span>), &amp;errorString);</span><br><span class="line"><span class="keyword">if</span> (!errorString.<span class="built_in">isEmpty</span>())</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; errorString;</span><br></pre></td></tr></table></figure>

<h1 id="在-Qt-中利用线程权限进行高速的-CAN-通信"><a href="#在-Qt-中利用线程权限进行高速的-CAN-通信" class="headerlink" title="在 Qt 中利用线程权限进行高速的 CAN 通信"></a>在 Qt 中利用线程权限进行高速的 CAN 通信</h1><p>用 PC 里能达到的 CAN 通信（使用 USBCAN-II）速度是 1ms</p>
<ul>
<li>使用 3 个线程类：1 个用来接收，1 个用来发送，1 个用来解析</li>
<li>接收线程使用最高线程权限：<strong>QThread::HighestPriority</strong>，其余线程用 <strong>QThread::HighPriority</strong></li>
<li>如何循环发送报文：在发送线程里再多加一个定时器，timeout 时间为需要循环发送的时间（可达到 1ms）；</li>
<li>用户在主界面设置需要发送的报文为 OBJ 结构体数组，然后通过构造函数的方式传到发送线程，最后发送就行了。</li>
<li>解析过程：接收函数循环接收报文，每接收到 n 帧就发送到解析线程，然后根据 ID 解析，将解析数据发送主界面显示（不要 append）</li>
</ul>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>USB挂载监测</title>
    <url>/2024/05/17/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-USB-USB%E6%8C%82%E8%BD%BD%E7%9B%91%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><pre><code>程序监测到插入U盘后，自动执行执行U盘内和本地指定文件夹双向同步功能
</code></pre>
<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol>
<li>Linux 下如何用 QT 检测到 U 盘已经插入，并实现 mount 与 umount</li>
</ol>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>使用 qt 自带的 QDBus 可以实现，下面为连接代码，当系统有设备插入时，可以调用 <code>slotDeviceAdded(QString udi)</code> 函数。</p>
<p>在 pro 文件中应该加入</p>
<p><code>QT +=dbus</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtDBus/QDBusConnection&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDbusInterface&gt;</span></span></span><br><span class="line"><span class="comment">//以下为检测设备的插入</span></span><br><span class="line">      QDBusConnection::<span class="built_in">systemBus</span>().<span class="built_in">connect</span>(    <span class="string">&quot;org.freedesktop.Hal&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/org/freedesktop/Hal/Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;org.freedesktop.Hal.Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;DeviceAdded&quot;</span>,</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        <span class="built_in">SLOT</span>(<span class="built_in">slotDeviceAdded</span>(QString )));</span><br><span class="line"><span class="comment">//以下为检查设备的拨出</span></span><br><span class="line">    QDBusConnection::<span class="built_in">systemBus</span>().<span class="built_in">connect</span>(    <span class="string">&quot;org.freedesktop.Hal&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/org/freedesktop/Hal/Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;org.freedesktop.Hal.Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;DeviceRemoved&quot;</span>,</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        <span class="built_in">SLOT</span>(<span class="built_in">slotDeviceRemoved</span>(QString )));</span><br></pre></td></tr></table></figure>

<p>在 slotDeviceAdded(QString udi) 函数中，要使用到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QDBusInterface <span class="title">device</span><span class="params">(<span class="string">&quot;org.freedesktop.Hal&quot;</span>, udi, <span class="string">&quot;org.freedesktop.Hal.Device&quot;</span> , QDBusConnection::systemBus())</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过 HAL 可以查询到设备为 volume 的设备，然后通过判断是否为&#x2F;dev&#x2F;sd 的设备，就可以判断出是否为 U 盘，然后调用 mount 就可以了。</p>
<p>这时记录下 U 盘的 UDI，在检测到设备拨出时，再查询一下 U 盘的 UDI 是否还在，就知道 U 盘是否被拨出了。</p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>USB权限设置</title>
    <url>/2024/05/20/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-USB-USB%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>因 Linux 系统下将涉及到 usb 底层驱动的调用，运行时，一定要加 sudo 获取权限运行，否则 USB 设备没有权限操作。 </p>
<p>现通过创建 UDEV 规则，配置 USB 权限后，可以调用指定设备不加权限运行。</p>
<p>输入 lsusb，查看当前的 USB 设备的 ID，确定需要配置的 USB。</p>
<p>创建一个新的 udev 规则。名称取为：99-myusb.rules</p>
<p><code>sudo vi /etc/udev/rules.d/99-myusb.rules</code></p>
<p>在 99-myusb.rules 文件中，输入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##</span><br><span class="line">ACTION==&quot;add&quot;,SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;04d8&quot;, ATTRS&#123;idProduct&#125;==&quot;0053&quot;, GROUP=&quot;users&quot;, MODE=&quot;0777&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>这条 <code>udev</code> 规则的作用是，当供应商 ID 为 <code>04d8</code> 且产品 ID 为 <code>0053</code> 的 USB 设备插入系统时，将该设备的用户组设置为 <code>users</code>，并赋予所有用户读、写、执行的全部权限。</li>
</ul>
<p>插拔一下 USBCAN 设备或重启一下电脑后，即可不加 sudo 权限运行程序了</p>
<p>对某个特定 USB 设备设置权限。每当这个设备插入系统时，规则会自动应用。</p>
<ol>
<li><code>ACTION==&quot;add&quot;</code>：这表示规则在设备添加（插入）时生效。<code>udev</code> 可以根据不同的动作（如添加、移除等）触发规则，<code>add</code> 动作指设备插入时。</li>
<li><code>SUBSYSTEMS==&quot;usb&quot;</code>：表示规则适用于 USB 子系统的设备。<code>udev</code> 管理系统中的设备，子系统用于分类，USB 是其中一种。</li>
<li><code>ATTRS&#123;idVendor&#125;==&quot;04d8&quot;</code>：表示设备的供应商 ID（Vendor ID）为 <code>04d8</code>。每个 USB 设备都有唯一的供应商 ID，用于标识设备的制造商。</li>
<li><code>ATTRS&#123;idProduct&#125;==&quot;0053&quot;</code>：表示设备的产品 ID（Product ID）为 <code>0053</code>。每个供应商的不同产品有不同的产品 ID，用于区分供应商的各个设备。</li>
<li><code>GROUP=&quot;users&quot;</code>：表示设备的用户组被设置为 <code>users</code>。这决定了哪些用户组的成员有权访问该设备。</li>
<li><code>MODE=&quot;0777&quot;</code>：表示设备的权限模式被设置为 <code>0777</code>，即所有用户对该设备都有读、写、执行权限。</li>
</ol>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下的CH34x串口识别</title>
    <url>/2024/05/21/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-%E4%B8%B2%E5%8F%A3-Linux%E4%B8%8B%E7%9A%84CH34x%E4%B8%B2%E5%8F%A3%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p><strong>判断是否识别</strong><br>使用 <code>lsusb</code> 命令可以看到有 <code>Bus 001 Device 005: ID 1a86:7523 QinHeng Electronics CH340 serial converter</code> 是能识别出 ch34x 设备</p>
<p><strong>检查串口是否被驱动加载</strong><br>输入指令 <code>ls /dev/ttyUSB*</code> 将会列出 USB 的加载情况。如果提示 No such file or directory 则是没有被驱动加载。</p>
<p><strong>占用情况</strong><br>因报文件不存在错误，采用 <code>dmesg|grep tty</code> 命令检查发现，被 <code>brltty</code> 进程占用。</p>
<p><code>brltty</code> 是一个后台进程（守护进程），为盲人提供对 Linux&#x2F;Unix 控制台的访问（当处于文本模式时），使用可刷新盲文显示。</p>
<p>移除该 <code>apt remove brltty</code>。</p>
<p><strong>权限</strong><br><code>chmod a+rw /dev/ttyUSB0</code> 即可</p>
<p><strong>重装驱动</strong><br>下载最新的驱动 CH341SER_LINUX<br><a href="https://github.com/WCHSoftGroup/ch341ser_linux">https://github.com/WCHSoftGroup/ch341ser_linux</a> </p>
<ol>
<li>解压后进入 “driver” 目录下</li>
<li>输入 <code>make</code> 命令编译驱动，正常编译完成后，将会看到生成了 <code>ch341.ko</code> 模块</li>
<li>输入 <code>sudo make load</code> 或者 <code>sudo insmod ch341.ko</code> 动态加载驱动（重启需要再次加载），或者输入 <code>sudo make install</code> 安装驱动（重启不丢失）</li>
<li>输入 <code>sudo make unload</code> 或者 <code>sudo rmmod ch341.ko</code> 或者 <code>sudo make uninstall</code> 卸载驱动</li>
</ol>
<ul>
<li><p>如果编译失败，可能是 ch34x.c 和实际内核版本不匹配，<code>uname -r</code> 可查看操作系统的发行版号，之后在 <a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source</a> 中查找对应内核版本的源代码文件，一般位于 <code>/drivers/usb/serial/ch341.c</code>，替换后重新编译</p>
</li>
<li><p>如果 insmod 失败，查看 <code>/lib/modules/$(uname -r)/kernel/drivers/usb/serial</code> 目录下是否已经有了 ko 模块，将目录中生成 ko 文件复制到此处，使用 <code>lsmod</code> 查看模块</p>
</li>
</ul>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>串口</category>
      </categories>
  </entry>
  <entry>
    <title>Socket套接字</title>
    <url>/2024/05/20/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C-Socket%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<p>Socket 最初是作为网络上不同主机之间进程的通信接口，后来应用越来越广，在同一主机上的不同进程之间通信也可以用 Socket。</p>
<p>简单来说，当网络上不同主机之间的两个进程（A、B）采用 Socket 进行通信时，那么它们之间需要建立一个通信端点，即创建 Socket，创建 Socket 时就分配端口号和网络地址。当进程 A 向进程 B 发送数据时，那么进程 A 必须要知道进程 B 的网络地址及端口号。</p>
<p>Socket 采用 C&#x2F;S 模型进行设计的，即 Client&#x2F;Server，面向客户端—服务器模型。</p>
<p>每一个 Socket 都用一个半相关描述：</p>
<p>{协议，本地地址，本地端口}</p>
<p>一个完整的 Socket 则用一个相关描述:</p>
<p>{协议，本地地址，本地端口，远程地址，远程端口}</p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="字节流套接字（SOCK-STREAM）"><a href="#字节流套接字（SOCK-STREAM）" class="headerlink" title="字节流套接字（SOCK_STREAM）"></a>字节流套接字（SOCK_STREAM）</h2><p>字节流的套接字可以提供可靠的数据传输、面向连接的通讯流。数据按何种顺序发送，就按何种顺序接收。例如，当我们按顺序发送 A-B-C，那么在数据到达接收端时，它的顺序也是 A-B-C。字节流套接字采用的是 TCP（Transmission Control Protocol）协议。保证了数据传输的可靠性。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520132726.png" alt="image.png"></p>
<h2 id="数据报套接字（SOCK-DGRAM）"><a href="#数据报套接字（SOCK-DGRAM）" class="headerlink" title="数据报套接字（SOCK_DGRAM）"></a>数据报套接字（SOCK_DGRAM）</h2><p>数据报套接字定义了一种无连接的服务。所谓无连接服务，简单来说，即在发送数据时，无需在收发两端建立类似 TCP 那样的握手连接，在发送时，将数据打包，然后加上远程 IP 地址，即可把该数据包发送出去。</p>
<p>数据通过相互独立的报文进行传输。并且是无序的、不可靠的传输。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520132823.png" alt="image.png"></p>
<h2 id="原始套接字（SOCK-ROW）"><a href="#原始套接字（SOCK-ROW）" class="headerlink" title="原始套接字（SOCK_ROW）"></a>原始套接字（SOCK_ROW）</h2><p>先启动服务器，通过调用 socket() 函数建立一个套接字，然后调用 bind() 函数将该套接字和本地网络地址联系在一起，再调用 listen() 函数使套接字做好侦听的准备，并规定它的请求队列的长度，之后就调用 accept() 函数来接收连接。</p>
<p>客户端在建立套接字之后就可调用 connect() 和服务器建立连接。</p>
<p>连接一旦建立，客户端和服务器之间就可以通过调用 recv()&#x2F;recvfrom() 函数和 send()&#x2F;sendto 函数来进行发收数据。</p>
<p>最后，待数据传送结束后，双方调用 close() 函数关闭套接字。</p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>DRM+GBM+EGL显示</title>
    <url>/2024/05/17/%E5%B9%B3%E5%8F%B0Platform-Linux-Linux-Graphics-DRM-GBM-EGL%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>DRM (Direct Rendering Manager)、GBM (Generic Buffer Manager) 和 EGL (Embedded-System Graphics Library) 组合在一起，是在 Linux 平台上进行图形渲染和硬件加速的常见方式。这些组件一起提供了一个完整的图形渲染栈，允许应用程序直接与图形硬件进行交互。</p>
<ul>
<li><p><strong>DRM（Direct Rendering Manager）</strong>：DRM 是 Linux 内核中的一个子系统，用于管理图形硬件的驱动程序。它提供了一种通用的接口，允许用户空间程序直接与硬件交互，通过设备文件 <code>/dev/dri/cardX</code> 访问。DRM 提供了诸如模式设置、显示控制、渲染加速等功能。</p>
</li>
<li><p><strong>GBM（Generic Buffer Manager）</strong>：GBM 是一个用于管理图形缓冲区的库，通常与 DRM 配合使用。它提供了一种标准的接口，用于分配、管理和操作图形内存。GBM 还提供了与 EGL 和 OpenGL ES 兼容的接口，使应用程序能够使用硬件加速进行渲染。</p>
</li>
<li><p><strong>EGL（Embedded-System Graphics Library）</strong>：EGL 是一个用于管理图形资源的库，提供了一个通用的接口，用于创建和管理 OpenGL 和 OpenGL ES 上下文、表面和其他相关对象。EGL 通常与 GBM 和 DRM 一起使用，通过 GBM 提供的接口来创建图形表面，并将其与 OpenGL 或 OpenGL ES 上下文关联起来，实现硬件加速的图形渲染。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>Linux Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Mesa</title>
    <url>/2024/05/17/%E5%B9%B3%E5%8F%B0Platform-Linux-Linux-Graphics-Mesa/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134513.png" alt="20240506123633.png"></p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>Linux Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>OpenGL显示</title>
    <url>/2024/05/17/%E5%B9%B3%E5%8F%B0Platform-Linux-Linux-Graphics-OpenGL%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="GLU"><a href="#GLU" class="headerlink" title="GLU"></a>GLU</h1><p>GLU（OpenGL Utility Library）是 OpenGL 的一个辅助库，提供了一些更高级的几何计算和对象构造函数，如曲面和体的生成、平移、旋转等，这些函数在处理复杂的几何操作时非常有用。</p>
<h1 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h1><p>GLFW 是一个流行的开源库，主要用于创建和管理图形应用程序中的窗口、OpenGL 或 Vulkan 上下文，以及处理用户输入、定时器等功能。适用于各种图形应用程序的开发，提供了窗口管理、上下文管理、输入处理等功能，使开发者能够专注于图形渲染和应用逻辑的实现。</p>
<p>主要功能：</p>
<ol>
<li><strong>窗口管理：</strong> GLFW 允许开发者创建窗口并对其进行管理，包括调整大小、最小化、最大化、关闭等操作。</li>
<li><strong>上下文管理：</strong> 它提供了创建 OpenGL 或 Vulkan 上下文的功能，使得图形渲染程序可以在窗口中绘制图形。</li>
<li><strong>输入处理：</strong> GLFW 支持处理用户输入，包括键盘输入、鼠标移动和点击、游戏手柄等。</li>
<li><strong>事件处理：</strong> 它允许开发者监听和响应各种事件，如窗口大小改变、键盘按键、鼠标移动等。</li>
<li><strong>监视器管理：</strong> GLFW 支持多个显示器的管理，可以获取显示器的分辨率、刷新率等信息。</li>
</ol>
<p>使用步骤：</p>
<ol>
<li><strong>初始化：</strong> 在程序启动时，调用 GLFW 的初始化函数来初始化库。</li>
<li><strong>创建窗口：</strong> 使用 GLFW 的窗口创建函数来创建一个窗口并指定其属性，如大小、标题等。</li>
<li><strong>创建上下文：</strong> 使用 GLFW 的上下文创建函数来创建一个 OpenGL 或 Vulkan 上下文。</li>
<li><strong>主循环：</strong> 在主循环中轮询事件，并根据事件类型做出相应的处理。</li>
<li><strong>渲染：</strong> 在渲染阶段，使用 OpenGL 或 Vulkan 等图形 API 绘制场景。</li>
<li><strong>清理：</strong> 在程序结束时，调用 GLFW 的清理函数来释放资源并关闭库。</li>
</ol>
<p>利用 glfw 监视器 Demo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="comment">// 初始化 GLFW </span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>()) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125; </span><br><span class="line">	<span class="comment">// 获取监视器（显示器）列表 </span></span><br><span class="line">	<span class="type">int</span> count; GLFWmonitor** monitors = <span class="built_in">glfwGetMonitors</span>(&amp;count); </span><br><span class="line">	<span class="comment">// 指定要使用的显示设备索引 </span></span><br><span class="line">	<span class="type">int</span> monitor_index = <span class="number">0</span>; </span><br><span class="line">	<span class="comment">// 设置为你想要的显示设备索引 </span></span><br><span class="line">	<span class="comment">// 获取指定索引的显示设备 </span></span><br><span class="line">	GLFWmonitor* monitor = (monitor_index &lt; count) ? monitors[monitor_index] : <span class="literal">NULL</span>; </span><br><span class="line">	<span class="comment">// 获取显示设备的视频模式 </span></span><br><span class="line">	<span class="type">const</span> GLFWvidmode* mode = <span class="built_in">glfwGetVideoMode</span>(monitor); </span><br><span class="line">	<span class="comment">// 创建窗口并指定显示设备 </span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(mode-&gt;width, mode-&gt;height, <span class="string">&quot;OpenGL Window&quot;</span>, monitor, <span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">if</span> (!window) &#123; <span class="built_in">glfwTerminate</span>(); <span class="keyword">return</span> <span class="number">-1</span>; &#125; </span><br><span class="line">	<span class="comment">// 进入主循环 </span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123; </span><br><span class="line">		<span class="comment">// 渲染代码 </span></span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT); </span><br><span class="line">		<span class="comment">// ... </span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window); </span><br><span class="line">		<span class="built_in">glfwPollEvents</span>(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 清理资源 </span></span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window); </span><br><span class="line">	<span class="built_in">glfwTerminate</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GLUT（OpenGL-Utility-Toolkit）"><a href="#GLUT（OpenGL-Utility-Toolkit）" class="headerlink" title="GLUT（OpenGL Utility Toolkit）"></a>GLUT（OpenGL Utility Toolkit）</h1><p> GLUT 是一个跨平台的工具包，用于创建和管理 OpenGL 窗口、处理用户输入等。它提供了一组简单的 API，使得编写基本的 OpenGL 程序变得更加容易。</p>
<pre><code>- GLUT 支持多种操作系统，包括 Windows、Linux 和 macOS。

- 使用 GLUT，你可以很快地编写出一个可以在不同平台上运行的简单 OpenGL 程序，而不必担心平台特定的细节。

- 但是，GLUT 对于创建复杂的图形用户界面（GUI）可能不够灵活，因为它的功能相对有限。
</code></pre>
<ul>
<li><p><strong>GLUT</strong> 是一个跨平台的工具包，用于简化 OpenGL 应用程序的开发。它提供了一组函数，用于创建窗口、处理输入事件、进行基本的图形绘制等，使开发者可以更轻松地编写 OpenGL 应用程序，而无需处理底层的窗口系统的细节。</p>
</li>
<li><p>GLUT 提供了一个相对简单的接口，适用于快速原型设计和简单的图形应用程序。它通常用于学习 OpenGL、编写小型游戏、演示程序等。</p>
</li>
</ul>
<h1 id="GLX（OpenGL-Extension-to-the-X-Window-System）"><a href="#GLX（OpenGL-Extension-to-the-X-Window-System）" class="headerlink" title="GLX（OpenGL Extension to the X Window System）"></a>GLX（OpenGL Extension to the X Window System）</h1><ul>
<li><p><strong>GLX</strong> 是 OpenGL 在 X Window System 上的扩展，它允许 OpenGL 应用程序与 X 服务器通信，并在 X 窗口系统中创建 OpenGL 上下文。GLX 提供了一组函数，用于在 X 窗口系统中创建 OpenGL 渲染上下文、管理 OpenGL 窗口和图形渲染等。</p>
</li>
<li><p>GLX 允许 OpenGL 应用程序直接与 X 服务器通信，而不需要借助其他库或工具。它提供了对 OpenGL 的完整支持，可以实现高性能的图形渲染和交互。</p>
</li>
</ul>
<p>GLX 则是 OpenGL 在 X 窗口系统上的扩展，提供了与 X 服务器通信和在 X 窗口系统中创建 OpenGL 渲染上下文的功能。</p>
<h1 id="EGL（Embedded-Graphics-Library）"><a href="#EGL（Embedded-Graphics-Library）" class="headerlink" title="EGL（Embedded Graphics Library）"></a>EGL（Embedded Graphics Library）</h1><p>EGL 是一个用于管理图形渲染上下文的接口，通常用于嵌入式系统和移动设备上。</p>
<pre><code>- EGL 是 OpenGL ES 和 OpenVG 的标准的本地显示系统接口，它提供了与底层窗口系统交互的能力。

- 在 Linux 上，EGL 通常与 GBM（Generic Buffer Manager）或其他图形系统配合使用，如 Wayland。

- 使用 EGL，你可以在嵌入式系统上更好地控制 OpenGL 上下文的创建和管理，以及与窗口系统的交互。
</code></pre>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>Linux Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu18.04更换国内源</title>
    <url>/2024/05/17/%E5%B9%B3%E5%8F%B0Platform-Linux-Ubuntu-Ubuntu18-04%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<h1 id="Ubuntu18-04-更换国内源"><a href="#Ubuntu18-04-更换国内源" class="headerlink" title="Ubuntu18.04 更换国内源"></a>Ubuntu18.04 更换国内源</h1><p>Ubuntu 本身的源使用的是国内的源，下载速度比较慢，不像 CentOS 一样 yum 安装的时候对镜像站点进项选择， </p>
<p>所以选择了更换成国内的源。 </p>
<p><code>bionic</code> 代表 ubuntu18</p>
<h3 id="备份-etc-apt-sources-list-文件"><a href="#备份-etc-apt-sources-list-文件" class="headerlink" title="备份&#x2F;etc&#x2F;apt&#x2F;sources.list 文件"></a>备份&#x2F;etc&#x2F;apt&#x2F;sources.list 文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sourses.list.backup</span><br></pre></td></tr></table></figure>

<h3 id="新建-etc-apt-sources-list-文件并添加以下内容"><a href="#新建-etc-apt-sources-list-文件并添加以下内容" class="headerlink" title="新建&#x2F;etc&#x2F;apt&#x2F;sources.list 文件并添加以下内容"></a>新建&#x2F;etc&#x2F;apt&#x2F;sources.list 文件并添加以下内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#163源</span></span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h3 id="更改完成之后执行以下命令"><a href="#更改完成之后执行以下命令" class="headerlink" title="更改完成之后执行以下命令"></a>更改完成之后执行以下命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt update</span></span><br><span class="line"><span class="comment"># apt upgrade</span></span><br></pre></td></tr></table></figure>

<h3 id="其他的一些-apt-命令"><a href="#其他的一些-apt-命令" class="headerlink" title="其他的一些 apt 命令"></a>其他的一些 apt 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  更新源</span><br><span class="line">sudo apt-get install package 安装包</span><br><span class="line">sudo apt-get remove package 删除包</span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line">sudo apt-get install package --reinstall  重新安装包</span><br><span class="line">sudo apt-get -f install  修复安装</span><br><span class="line">sudo apt-get remove package --purge 删除包，包括配置文件等</span><br><span class="line">sudo apt-get build-dep package 安装相关的编译环境</span><br><span class="line">sudo apt-get upgrade 更新已安装的包</span><br><span class="line">sudo apt-get dist-upgrade 升级系统</span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line">sudo apt-get <span class="built_in">source</span> package  下载该包的源代码</span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</span><br><span class="line">sudo apt-get check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure>

<h3 id="其他几个国内的源："><a href="#其他几个国内的源：" class="headerlink" title="其他几个国内的源："></a>其他几个国内的源：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#中科大源</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#阿里云源</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#清华源</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu22.04 jammy更换源</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-Ubuntu-Ubuntu22-04-jammy%E6%9B%B4%E6%8D%A2%E6%BA%90/</url>
    <content><![CDATA[<h1 id="源文件所在位置"><a href="#源文件所在位置" class="headerlink" title="源文件所在位置"></a>源文件所在位置</h1><p>备份源文件 <code>/etc/apt/sources.list</code></p>
<h1 id="Ubuntu22-04-jammy-源"><a href="#Ubuntu22-04-jammy-源" class="headerlink" title="Ubuntu22.04 jammy 源"></a>Ubuntu22.04 jammy 源</h1><h2 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h2><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse
</code></pre>
<h2 id="阿里云源"><a href="#阿里云源" class="headerlink" title="阿里云源"></a>阿里云源</h2><pre><code>deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
</code></pre>
<h2 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h2><pre><code>deb https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse
</code></pre>
<h2 id="网易-163-源"><a href="#网易-163-源" class="headerlink" title="网易 163 源"></a>网易 163 源</h2><pre><code>deb http://mirrors.163.com/ubuntu/ jammy main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ jammy-security main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ jammy-updates main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ jammy-proposed main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ jammy-backports main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ jammy main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ jammy-security main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ jammy-updates main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ jammy-proposed main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ jammy-backports main restricted universe multiverse
</code></pre>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>linux-crypto</title>
    <url>/2024/05/17/%E5%B9%B3%E5%8F%B0Platform-Linux-%E5%8A%A0%E5%AF%86-linux-crypto/</url>
    <content><![CDATA[<p>加密技术通常分为两大类“对称式”和“非对称式”</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/21/20240521132053.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title>ELF文件分析</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-%E7%A8%8B%E5%BA%8F-ELF%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133509.png" alt="pic.1714466684000yjk2fw.png"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133534.png" alt="pic.1714466896000tz0d56.png"></p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>程序内存</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-%E7%A8%8B%E5%BA%8F-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="linux-的-ELF-可执行文件内存分布"><a href="#linux-的-ELF-可执行文件内存分布" class="headerlink" title="linux 的 ELF 可执行文件内存分布"></a>linux 的 ELF 可执行文件内存分布</h1><p><strong>可执行文件 4G 内存分布，在 32bit 的 OS 中</strong></p>
<p>用户空间 app+C 库	3G</p>
<p>内核空间 驱动		1G</p>
<p>硬件</p>
<p><strong>elf 分布</strong><br>.heap		堆: 用户自定义空间，用完释放<br>.stack 		栈: 局部变量，函数参数<br>.bss		未初始化的全局，静态变量<br>.data		数据段: 初始化的全局，静态变量<br>.text		代码段: 存放二进制可执行代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">/*C语言中数据的内存分配*/</span><br><span class="line">int a=0;</span><br><span class="line">char *p1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int b;						/*b在栈 */</span><br><span class="line">	char s[] =&quot;abc&quot;;			/*s在栈，&quot;abc&quot;在常量区*/</span><br><span class="line">	char *p2;					/*p2在栈*/</span><br><span class="line">	char *p3=“123456&quot;;			/*&quot;123456&quot;在常量区，p3 在栈*/</span><br><span class="line">	static int c=0;				/*可读可写数据段*/</span><br><span class="line">	p1 = (char *)malloc(10);	/*分配得来的 10个字节的区域在堆区*/</span><br><span class="line">	p2 = (char *)malloc(20);	/*分配得来的 20个字节的区域在堆区*/</span><br><span class="line">	</span><br><span class="line">	/* 从常量区的“Hello world”字符串复制到刚分配到的堆区 */</span><br><span class="line">	strcpy(p1，“Hello World&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Char:1B</p>
<p>Int:4B</p>
<p>Short:2B</p>
<p>Long:4B</p>
<p>long long :8B</p>
<p>Float:4B</p>
<p>double:8B </p>
<p>long double:16B</p>
<h1 id="位的使用和对齐操作"><a href="#位的使用和对齐操作" class="headerlink" title="位的使用和对齐操作"></a>位的使用和对齐操作</h1><p>字节对齐：在 32 位操作系统中，大多数计算机体系结构要求数据按照特定的字节边界对齐。常见的对齐边界是 4 字节（32 位）或 8 字节（64 位）。这是为了优化内存访问和数据传输的效率。如果数据没有按照正确的字节对齐方式存储，可能会导致额外的开销和性能下降。</p>
<p>结构体成员对齐：在结构体中，结构体成员的对齐方式可能会影响整个结构体的对齐方式。编译器通常会自动对结构体成员进行对齐，以满足所使用的编译器和平台的要求。默认情况下，大多数编译器会使用最大对齐方式，即按照结构体中最大成员的字节大小进行对齐。</p>
<p>指令对齐：在代码中，指令的对齐方式也是重要的。大多数处理器要求指令按照特定的字节边界对齐。指令对齐可以提高指令的执行速度和整体性能。</p>
<p>对于字节对齐，编译器通常会自动处理，但也可以通过编译器的指令或属性进行手动控制。在 C 语言中，可以使用特定的编译指令来控制结构体成员的对齐方式，例如使用#pragma pack 指令。</p>
<p>以下是一个示例，展示了如何使用#pragma pack 指令来设置<strong>结构体成员的对齐方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#pragma pack(push, 1) // 以1字节对齐方式压栈</span><br><span class="line"></span><br><span class="line">struct Example &#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#pragma pack(pop) // 弹出对齐方式</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    struct Example ex;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Size of struct Example: %zu\n&quot;, sizeof(ex)); // 输出结构体的大小</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，通过使用#pragma pack(push, 1) 指令将对齐方式设置为 1 字节，然后定义了一个名为 Example 的结构体，包含了 char、int 和 short 类型的成员变量。最后使用#pragma pack(pop) 指令将对齐方式还原为默认值。</p>
<p>在运行示例程序后，可以观察到结构体 Example 的大小可能会受到对齐方式的影响。如果不进行任何对齐操作，默认情况下编译器可能会根据平台和编译器的要求进行对齐，大小会大于 1 字节。</p>
<p>总结来说，在 32 位的操作系统中，位的使用和对齐操作是为了优化内存访问和数据传输的效率。字节对齐、结构体成员对齐和指令对齐是常见的对齐方式，可以通过编译器的指令或属性进行手动控制，以满足特定的需求和平台要求。</p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>Linux网络配置</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-%E7%BD%91%E7%BB%9C-Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="配置网卡信息"><a href="#配置网卡信息" class="headerlink" title="配置网卡信息"></a>配置网卡信息</h1><p>IP、网关、掩码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/network/interfaces</span><br></pre></td></tr></table></figure>

<p>DNS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;》重启网卡 sudo service networking restart</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/sysconfig/network-scripts/ifcfg-eno16777736</span><br><span class="line">TYPE=Ethernet(设备类型） BOOTPROTO=static（地址分配模式） NAME=eno16777736 ONBOOT=yes（是否启用）</span><br><span class="line">IPADDR=192.168.10.10 NETMASK=255.255.255.0 GATEWAY=192.168.10.1 DNS1=192.168.10.1</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;》重启网卡 systemctl restart network</p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>linux下网络配置命令</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-%E7%BD%91%E7%BB%9C-linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li>TCP&#x2F;IP 网络相关概念</li>
<li>配置以太网络接口</li>
<li>配置 ppp 网络接口</li>
<li>Linux 环境下的网络配置</li>
<li>检测网络配置</li>
</ul>
<p>TCP&#x2F;IP 网络相关概念</p>
<ul>
<li>TCP&#x2F;IP 协议</li>
<li>IP 地址、子网掩码和域名</li>
<li>路由选择和网关地址</li>
<li>端到端连接</li>
<li>Linux 的网络应用</li>
</ul>
<h1 id="Linux-的网络接口设备"><a href="#Linux-的网络接口设备" class="headerlink" title="Linux 的网络接口设备"></a>Linux 的网络接口设备</h1><ul>
<li>在网络中使用的每一个外围设备的网络接口，在 Linux 的核心（kernel）中都有相应的名字。</li>
<li>网络接口设备和相关的设备接口名：<br>lo 本地回送接口。用于网络软件测试以及本地机进程间通信，无论什么程序一旦使用回送地址发送数据，协议软件立即将其返回，不进行任何网络传输。在 Linux 系统中，回送设备是默认设置好的。<br>ethn 第 n 个以太网卡接口 (n 为 0 表示第一块，以此类推)，eth 是大多数网卡的接口设备名。<br>pppn 第 n 个 ppp 接口。PPP 接口按照与它们有关的 PPP 配置顺序连接在串口上。</li>
</ul>
<h1 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h1><ul>
<li>hostnameLinux<br>– 查看或配置计算机的主机名</li>
<li>ifconfig<br>– 查看或配置网络接口</li>
<li>ifup<br>– 启用指定的网络接口</li>
<li>ifdown<br>– 禁用指定的网络接口</li>
<li>route<br>– 查看或配置内核路由表的配置情况</li>
</ul>
<h1 id="配置以太网络－使用命令"><a href="#配置以太网络－使用命令" class="headerlink" title="配置以太网络－使用命令"></a>配置以太网络－使用命令</h1><ul>
<li>配置 IP 地址<br>– # ifconfig [interface] [ip-address] [netmask …]</li>
</ul>
<p>[broadcast … ] [up] [down]</p>
<ul>
<li>配置默认网关<br>– # route add default gw IP 地址</li>
</ul>
<p>– #route add 0.0.0.0 netmask 0.0.0.0 eth0</p>
<ul>
<li>配置 DNS 客户<br>– # vi &#x2F;etc&#x2F;resolv.conf</li>
</ul>
<h1 id="TCP-IP-配置文件"><a href="#TCP-IP-配置文件" class="headerlink" title="TCP&#x2F;IP 配置文件"></a>TCP&#x2F;IP 配置文件</h1><p>&#x2F;etc&#x2F;sysconfig&#x2F;network 主机最基本网络信息，用于系统启动</p>
<p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts 系统启动初始化网络信息</p>
<p>&#x2F;etc&#x2F;xinetd.conf 定义由超级进程 xinetd 启动的网络服务</p>
<p>&#x2F;etc&#x2F;hosts 主机和 ip 映射</p>
<p>&#x2F;etc&#x2F;host.conf DNS 客户端搜索顺序</p>
<p>&#x2F;etc&#x2F;resoly.conf 指定 DNS 地址</p>
<p>&#x2F;etc&#x2F;serveices </p>
<p>编辑&#x2F;etc&#x2F;sysconfig&#x2F;entwork-script&#x2F;ifcfg-eth0 文件</p>
<p>Linux 支持一块网卡绑定多 IP，编辑子接口配置文件 ifcfg-eth0:1</p>
<p>Netconfig 调用菜单</p>
<h1 id="配置-ADSL-网络接口"><a href="#配置-ADSL-网络接口" class="headerlink" title="配置 ADSL 网络接口"></a>配置 ADSL 网络接口</h1><ul>
<li>安装 pppoe<br>rpm –qa |grep pppoe</li>
<li>配置 pppoe<br>adsl-setup<br>&#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;ifcfg-ppp0<br>adsl-status</li>
<li>启用和挂断 ADSL 网络连接<br>adsl-start (或 ifup ppp0)<br>adsl-stop (或 ifdown ppp0)</li>
</ul>
<h1 id="网络测试一般方法"><a href="#网络测试一般方法" class="headerlink" title="网络测试一般方法"></a>网络测试一般方法</h1><ul>
<li>排除非自身因素</li>
<li>查看本机 IP 地址</li>
<li>检测与网关的连接</li>
<li>监测与互联网的连接</li>
<li>测试域名解析</li>
<li>测试与特定站点的连接</li>
</ul>
<h1 id="检测网络状态"><a href="#检测网络状态" class="headerlink" title="检测网络状态"></a>检测网络状态</h1><ul>
<li>Ifconfig<br>– 检测网络接口</li>
<li>ping<br>– 检测网络连通性</li>
<li>netstat<br>– 查看网络状态</li>
<li>traceroute<br>– 检测到目的主机所经过的路由器</li>
<li>tcpdump<br>– 显示本机网络流量的状态</li>
</ul>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>网络超时检测的三种方法</title>
    <url>/2024/05/22/%E5%B9%B3%E5%8F%B0Platform-Linux-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E8%B6%85%E6%97%B6%E6%A3%80%E6%B5%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>网络超时检测的三种方法</p>
<p>网络通信中，很多操作会使得进程阻塞，这时我们要设定时间，到时间后强制返回，避免进程在没有数据的情况下无限阻塞</p>
<p>这里我们总结一下网络超时检测的三种方法：</p>
<p>一、通过 setsockopt 设置套接字属性 SO_RCVTIMEO</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct timeval t = &#123;5, 0&#125;</span><br><span class="line">         if (setsockopt(listenfd, SOL_SOCKET, SO_RCVTIMEO, &amp;t, sizeof(t)) == -1) &#123;</span><br><span class="line">                   perror(&quot;setsockopt&quot;);</span><br><span class="line">                   return -1;</span><br><span class="line">         &#125;</span><br><span class="line">         memset(&amp;peeraddr, 0, sizeof(peeraddr));</span><br><span class="line">         len = sizeof(peeraddr);</span><br><span class="line">         if ((connfd = accept(listenfd, (struct sockaddr *)&amp;peeraddr, &amp;len)) == -1) &#123;</span><br><span class="line">         printf(&quot;errno=%d: %s\n&quot;, errno, strerror(errno));</span><br><span class="line">                   if (errno == EAGAIN) &#123;</span><br><span class="line">                            printf(&quot;timeout\n&quot;);</span><br><span class="line">                            return -1;</span><br><span class="line">                   &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p>二、设定 select 函数的一个参数实现超时处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct timeval t= &#123;3, 0&#125;;</span><br><span class="line">         while (1) &#123;</span><br><span class="line">                   。。。。。。</span><br><span class="line">                   t.tv_sec = 3;</span><br><span class="line">                   t.tv_usec = 0;</span><br><span class="line">                   if ((ret = select(maxfd+1, &amp;rdfs, NULL, NULL, &amp;t)) == -1) &#123;</span><br><span class="line">                            perror(&quot;select&quot;);</span><br><span class="line">                            return -1;</span><br><span class="line">                   &#125;</span><br><span class="line">                   。。。。。。</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>三、设定一个定时器捕捉 SIGALRM 信号做超时控制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sigaction act;</span><br><span class="line">         sigaction(SIGALRM, NULL, &amp;act); //获取SIGALRM信号的属性</span><br><span class="line">         act.sa_handler = handler; // 设置SIGALRM信号的处理函数</span><br><span class="line">         sigaction(SIGALRM, &amp;act, NULL); // 设置SIGALRM信号的属性</span><br><span class="line">         alarm(3); // 定时器设置3秒钟</span><br><span class="line">         while (1) &#123;</span><br><span class="line">                   if ((connfd = accept(listenfd, (struct sockaddr *)&amp;peeraddr, &amp;len)) == -1) &#123;</span><br><span class="line">                            if (errno == EINTR) &#123;</span><br><span class="line">                                     printf(&quot;timeout\n&quot;);</span><br><span class="line">                                     return -1;</span><br><span class="line">                            &#125;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>

<p>定时器 3 秒钟内没有数据到来，内核产生 SIGALRM 信号中断当前操作。我们知道设置信号捕捉函数可以用 signal 函数或是 sigaction 函数。但这里只能使用 sigaction 函数，因为 signal 设置的信号处理函数执行完后会重新执行被中断的操作</p>
]]></content>
      <categories>
        <category>平台Platform</category>
        <category>Linux</category>
        <category>网络</category>
      </categories>
  </entry>
</search>

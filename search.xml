<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>华为手机ADB</title>
    <url>/2024/09/24/3-%E8%BD%AF%E4%BB%B6-%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BAADB/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 卸载系统应用包</span><br><span class="line"></span><br><span class="line">adb shell pm uninstall --user <span class="number">0</span> com.huawei.hifolder # 卸载竞品推荐,纯广告,卸载!!!</span><br><span class="line"></span><br><span class="line">adb shell pm uninstall --user <span class="number">0</span> com.huawei.educenter    # <span class="string">&quot;教育中心&quot;</span>App</span><br><span class="line"></span><br><span class="line">adb shell pm uninstall --user <span class="number">0</span> com.huawei.hiskytone    # <span class="string">&quot;天际通&quot;</span>App</span><br><span class="line"></span><br><span class="line">adb shell pm uninstall --user <span class="number">0</span> com.huawei.skytone  # <span class="string">&quot;天际通&quot;</span>服务</span><br><span class="line"></span><br><span class="line">adb shell pm uninstall --user <span class="number">0</span> com.huawei.gamebox  # <span class="string">&quot;游戏中心&quot;</span>App,不玩游戏可删!</span><br><span class="line"></span><br><span class="line">adb shell pm uninstall --user <span class="number">0</span> com.huawei.game.kitserver   # <span class="string">&quot;GameKit&quot;</span>服务,不玩游戏可删!</span><br><span class="line"></span><br><span class="line">adb shell pm uninstall --user <span class="number">0</span> com.huawei.gameassistant    # <span class="string">&quot;应用助手&quot;</span>服务,其实就是<span class="string">&quot;游戏助手,不玩游戏可删!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.tips # &quot;</span>智能提醒<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.tips # &quot;</span>玩机技巧<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.health   # &quot;</span>运动健康<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.ohos.health  # [HarmongOS]&quot;</span>运动健康<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.stylus.mpenzone  # &quot;</span>手写笔应用专区<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.stylus.floatmenu # &quot;</span>手写笔悬浮窗<span class="string">&quot;服务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.wallet   # &quot;</span>华为钱包<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.wallet.sdk.walletsdk # &quot;</span>WalletSDK<span class="string">&quot;服务,钱包 SDK 而已</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.unionpay.tsmservice # &quot;</span>银联可信服务安全组件<span class="string">&quot;,给华为钱包调用的安全组件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.hicloud.android.clone   # &quot;</span>手机克隆<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.mirror   # &quot;</span>镜子<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.remotecontroller # &quot;</span>智能遥控<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.ar.measure   # &quot;</span>AR 测量<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.android.soundrecorder   # &quot;</span>录音机<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.calculator   # &quot;</span>计算器<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.totemweather # &quot;</span>天气<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.email    # &quot;</span>电子邮件<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.mycenter # &quot;</span>会员中心<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.lives    # &quot;</span>生活服务<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.smarthome    # &quot;</span>智慧生活<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.ohos.smarthome   # [HarmongOS]&quot;</span>智慧生活<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hilink.framework    # &quot;</span>智慧生活基础服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.notepad  # &quot;</span>备忘录<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.vmall.client    # &quot;</span>华为商城<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hwireader    # &quot;</span>阅读<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.welinknow    # &quot;</span>Link Now<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.compass  # &quot;</span>指南针<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.intelligent  # &quot;</span>智慧助手·今天<span class="string">&quot;服务,负一屏的垃圾广告</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.magazine # &quot;</span>杂志锁屏<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hwdetectrepair   # &quot;</span>智能检测<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.phoneservice # &quot;</span>我的华为<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hwblockchain # &quot;</span>华为区块链<span class="string">&quot;????,这... ...删了吧!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.search   # &quot;</span>智慧搜索<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.searchservice   # &quot;</span>融合搜索服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.ohos.search  # [HarmongOS]&quot;</span>全局搜索数据服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.meetime  # &quot;</span>畅连<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hwvoipservice    # &quot;</span>畅连服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.findmyphone  # &quot;</span>查找设备<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.videoeditor  # &quot;</span>视频编辑<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.himovie  # &quot;</span>华为视频<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.himovie.partner1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.himovie.partner2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.tencent.qqlivehuawei    # &quot;</span>华为视频<span class="string">&quot;App - 腾讯视频模块</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.sohu.sohuvideo.emplayer # &quot;</span>华为视频<span class="string">&quot;App - 搜狐视频模块</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.android.mediacenter # &quot;</span>华为音乐<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.scenepack    # &quot;</span>旅行助手<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hicard   # &quot;</span>HiCard<span class="string">&quot;卡片服务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hicar    # &quot;</span>HiCar<span class="string">&quot;汽车服务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.karaoke  # &quot;</span>K 歌特效<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.featurelayer.sharedfeature.xrkit # &quot;</span>XRKit<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.arengine.service # &quot;</span>AREngineServer<span class="string">&quot;华为 AR 引擎服务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.audioaccessorymanager    # &quot;</span>音频产品管家<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.waudio   # &quot;</span>WAudios<span class="string">&quot;,不知是啥!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.multimedia.audioengine   # &quot;</span>HwAudioKit<span class="string">&quot;,不知是啥!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.android.simappdialog  #   &quot;</span>SIM App Dialog<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.android.stk   # &quot;</span>SIM 卡应用<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.thememanager # &quot;</span>主题<span class="string">&quot;App,更换完主题就删除,用的时候在&quot;</span>华为应用商店<span class="string">&quot;安装就行了;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.browser  # 华为&quot;</span>浏览器<span class="string">&quot;App,推荐 Edge 浏览器,别用&quot;</span>夸克<span class="string">&quot;了,太&quot;</span>和谐<span class="string">&quot;了!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hidisk   # &quot;</span>华为云空间<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hicloud  # &quot;</span>华为云空间服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.privatespace # &quot;</span>隐私空间<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.securitymgr # &quot;</span>隐私空间<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.calendar # 华为&quot;</span>日历<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.android.providers.calendar  # &quot;</span>日历存储<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.android.deskclock   # 华为&quot;</span>时钟<span class="string">&quot;App</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.baidu.input_huawei  # &quot;</span>百度输入法<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.ohos.suggestion  # &quot;</span>小艺建议<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.pengine  # &quot;</span>华为智能建议<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.spaceservice  # 华为&quot;</span>地理围栏服务<span class="string">&quot;,其实就是精准推送广告</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.fastapp  # 华为&quot;</span>快应用中心<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.localBackup  # 华为&quot;</span>备份<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.easygo  # 华为&quot;</span>EasyGo SDK<span class="string">&quot;,给折叠屏用的;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.trustspace   # 华为&quot;</span>支付保护中心<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.featurelayer.sharedfeature.map   # &quot;</span>华为地图服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.featurelayer.featureframework    # &quot;</span>Feature Framework<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hiai # &quot;</span>华为智慧引擎<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hiaction # 华为&quot;</span>HUAWEI HiAI Base<span class="string">&quot; 基础服务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.recsys # &quot;</span>华为智慧引擎<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.vassistant   # 华为&quot;</span>智慧语音<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.contactscamcard  # &quot;</span>扫名片<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hitouch  # 华为&quot;</span>智慧识屏<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.vrservice  # &quot;</span>华为 VR 服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.motionservice    # 华为&quot;</span>手势服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.devicemanager    # 华为&quot;</span>智慧协同<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.airsharing   # 华为&quot;</span>无线投屏<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.suggestion   # 华为&quot;</span>情景智能<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.scanner  # 华为&quot;</span>智慧视觉<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.pcassistant  # &quot;</span>华为分享<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.instantshare  # &quot;</span>华为分享<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.wfdft    # &quot;</span>WLAN 直连<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.android.FloatTasks    # 华为&quot;</span>悬浮导航<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.printservice   # &quot;</span>华为打印<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.nearby   # 华为&quot;</span>HwNearby<span class="string">&quot;附近服务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.bjbyhd.screenreader_huawei  # 华为&quot;</span>屏幕朗读<span class="string">&quot;服务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.securityserver   # &quot;</span>华为安全公共服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.filemanager  # 华为&quot;</span>文件管理<span class="string">&quot;,推荐 &quot;</span>MT管理器<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.desktop.explorer # 华为&quot;</span>我的文件<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.android.providers.downloads # &quot;</span>下载管理<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.android.providers.downloads.ui   # &quot;</span>下载管理<span class="string">&quot; UI</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.assetsync    # 华为&quot;</span>关键资产同步<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.assetsyncservice # 华为&quot;</span>关键资产同步<span class="string">&quot;服务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.contacts.sync    # 华为&quot;</span>联系人同步<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.airlink  # 华为&quot;</span>Air Link<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.rcsserviceapplication    # &quot;</span>华为 RCS 服务<span class="string">&quot;,同华为手机的免费短信</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.bluetooth    # 华为&quot;</span>通过蓝牙导入<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.trustagent   # 华为&quot;</span>智能解锁<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hwbluetoothpencilmanager # 华为&quot;</span>蓝牙触控笔管理<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.iflytek.speechsuite # 讯飞语音引擎</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.ohos.famanager # [HarmongOS]华为&quot;</span>服务中心<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.android.sharedstoragebackup  # &quot;</span>共享存储备份<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hwpanpayservice  # 华为&quot;</span>息屏支付<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.hwdiagnosis  # 华为&quot;</span>检测/诊断<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.controlcenter    # 华为&quot;</span>超级终端<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.multimedia.hivideoplayengine # 华为&quot;</span>视频开发引擎<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.regservice   # 华为&quot;</span>注册服务<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.trustedthingsauth    # 华为&quot;</span>可信认证跳过<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.synergy  # 华为&quot;</span>协同<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell pm uninstall --user 0 com.huawei.coauthservice    # 华为&quot;</span>联合认证<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">echo &quot;</span>===========================系统精简结束===========================<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第八步：进行一下动画和帧数的优化</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell settings put global window_animation_scale 0.96</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell settings put global transition_animation_scale 0.96</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell settings put global animator_duration_scale 0.43</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">adb shell wm density 480 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">关闭系统更新 adb shell pm disable-user com.huawei.android.hwouc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">卸载前先调整部分设置。比如智慧多窗默认是开启的，要先关闭，否则会残留手势。</span></span><br><span class="line"><span class="string">智慧助手 adb shell pm uninstall --user 0 com.huawei.intelligent</span></span><br><span class="line"><span class="string">智慧搜索 adb shell pm uninstall --user 0 com.huawei.search</span></span><br><span class="line"><span class="string">情景智能 adb shell pm uninstall --user 0 com.huawei.suggestion</span></span><br><span class="line"><span class="string">智慧识屏 adb shell pm uninstall --user 0 com.huawei.hitouch</span></span><br><span class="line"><span class="string">智慧视觉 adb shell pm uninstall --user 0 com.huawei.scanner</span></span><br><span class="line"><span class="string">智慧语音 adb shell pm uninstall --user 0 com.huawei.vassistant</span></span><br><span class="line"><span class="string">智慧多窗 adb shell pm uninstall --user 0 com.huawei.hwdockbar</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">华为钱包 adb shell pm uninstall --user 0 com.huawei.wallet</span></span><br><span class="line"><span class="string">华为钱包kit工具 adb shell pm uninstall --user 0 com.huawei.wallet.sdk.walletsdk</span></span><br><span class="line"><span class="string">华为钱包安全支付 adb shell pm uninstall --user 0 com.huawei.hwpanpayservice</span></span><br><span class="line"><span class="string">支付保护中心 adb shell pm uninstall --user 0 com.huawei.trustspace</span></span><br><span class="line"><span class="string">畅联通话 adb shell pm uninstall --user 0 com.huawei.hwvoipservice</span></span><br><span class="line"><span class="string">天际通 adb shell pm uninstall --user 0 com.huawei.hiskytone</span></span><br><span class="line"><span class="string">天际通数据服务 adb shell pm uninstall --user 0 com.huawei.skytone</span></span><br><span class="line"><span class="string">智慧生活 adb shell pm uninstall --user 0 com.huawei.smarthome</span></span><br><span class="line"><span class="string">智慧生活基础服务 adb shell pm uninstall --user 0 com.huawei.hilink.framework</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">百度输入法华为版 adb shell pm uninstall --user 0 com.baidu.input_huawei</span></span><br><span class="line"><span class="string">腾讯视频华为版 adb shell pm uninstall --user 0 com.tencent.qqlivehuawei</span></span><br><span class="line"><span class="string">应用助手 adb shell pm uninstall --user 0 com.huawei.gameassistant</span></span><br><span class="line"><span class="string">快应用中心 adb shell pm uninstall --user 0 com.huawei.fastapp</span></span><br><span class="line"><span class="string">浏览器 adb shell pm uninstall --user 0 com.huawei.browser</span></span><br><span class="line"><span class="string">华为汽车 adb shell pm uninstall --user 0 com.huawei.hicar</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">杂志锁屏 adb shell pm uninstall --user 0 com.huawei.magazine</span></span><br><span class="line"><span class="string">华为主题 adb shell pm uninstall --user 0 com.huawei.android.thememanager</span></span><br><span class="line"><span class="string">服务中心 adb shell pm uninstall --user 0 com.huawei.ohos.famanager</span></span><br><span class="line"><span class="string">小艺建议 adb shell pm uninstall --user 0 com.huawei.ohos.suggestion</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>3.软件</category>
      </categories>
  </entry>
  <entry>
    <title>裸机驱动的开发步骤</title>
    <url>/2024/08/27/0-%E5%B9%B3%E5%8F%B0-ARM-%E8%A3%B8%E6%9C%BA%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>最简例子 LED 灯控制</p>
<h1 id="看电路图"><a href="#看电路图" class="headerlink" title="看电路图"></a>看电路图</h1><ul>
<li>找到我要控制的设备</li>
<li>找到设备在 CPU 侧的控制管脚(如 GPX27)</li>
</ul>
<h1 id="看芯片手册"><a href="#看芯片手册" class="headerlink" title="看芯片手册"></a>看芯片手册</h1><ul>
<li>先看相关的中文文档，熟悉设备再看手册)</li>
<li>搜索电路图里对应控制管脚的名称(如 GPX2)</li>
<li>看目录找到对应的控制模块(如:6General Purpose Input&#x2F;Output(GPIO)Control)</li>
<li>看该模块的 overview 了解该模块的大概功能</li>
<li>看控制寄存器(REGISTER DESCRIPTION)重点，难点</li>
<li>如果寄存器比较多，看技术支持提供的 demo，找到需要修改的寄存器(通常情况下只有几个)。部分厂商会提供配置软件，通过界面去配置功能，我们只需使用配置好的寄存器值就可以</li>
</ul>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><ul>
<li>定义要控制的寄存器的宏(与手册里的寄存器地址对应起来)</li>
<li>设备初始化(如设置 GPI0 为输出状态)</li>
<li>把功能分成最基本的小块:逐个实现,如点亮灯-&gt;在灭灯-&gt;加延时-&gt;闪烁-&gt;跑马灯</li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>Docker Pull超时</title>
    <url>/2024/07/24/0-%E5%B9%B3%E5%8F%B0-Docker-Docker-Pull%E8%B6%85%E6%97%B6/</url>
    <content><![CDATA[<p>修改镜像仓库地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p>选一个加速地址即可</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="string">&quot;https://mirror.ccs.tencentyun.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;https://do.nark.eu.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;https://dc.j8.work&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;https://dockerproxy.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;https://docker.nju.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>修改完成后重新加载</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>测试是否配置成功</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker下将已部署的wordpress备份及迁移</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-Docker-Docker%E4%B8%8B%E5%B0%86%E5%B7%B2%E9%83%A8%E7%BD%B2%E7%9A%84wordpress%E5%A4%87%E4%BB%BD%E5%8F%8A%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><p><del># Docker 镜像备份 在已经部署好 wordpress 的机器上，使用 <code>docker save</code> 命令将 <code>Docker</code> 镜像保存到本地文件中。</del></p>
<p>使用以下命令将名为 <code>wordpress</code> 和 <code>mysql</code> 的 <code>Docker</code> 镜像分别保存到名为 <code>wordpress_image.tar</code> 和 <code>mysql_image.tar</code> 的本地文件中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save wordpress &gt; wordpress_image.tar <span class="comment">#保存wordpress</span></span><br><span class="line">docker save mysql &gt; mysql_image.tar <span class="comment">#保存mysql</span></span><br></pre></td></tr></table></figure>

<p><del># Docker 镜像读取 将 <code>wordpress_image.tar</code> 和 <code>mysql_image.tar</code> 文件复制到目标机器上。在目标机器上，使用 <code>docker load</code> 命令将本地文件中的 <code>Docker</code> 镜像加载到 <code>Docker</code> 中。</del></p>
<p>使用以下命令将名为 <code>wordpress_image.tar</code> 和 <code>mysql_image.tar</code> 的本地文件中的 <code>Docker</code> 镜像加载到 <code>Docker</code> 中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load &lt; wordpress_image.tar</span><br><span class="line">docker load &lt; mysql_image.tar</span><br></pre></td></tr></table></figure>

<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件系统备份"><a href="#文件系统备份" class="headerlink" title="文件系统备份"></a>文件系统备份</h2><p>要将 <code>Docker</code> 中的整个 <code>WordPress</code> 应用程序打包并部署到另一个地方，可以使用 <code>Docker</code> 的导入和导出功能，具体步骤如下： 在运行 <code>WordPress</code> 应用程序的 <code>Docker</code> 容器上执行以下命令，将容器中的 <code>WordPress</code> 应用程序导出为 <code>tar</code> 文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> &lt;container_id&gt; &gt; wordpress.tar</span><br></pre></td></tr></table></figure>

<p>这将在当前目录下创建一个名为 <code>wordpress.tar</code> 的文件，其中包含 <code>Docker</code> 容器中的整个 <code>WordPress</code> 应用程序。</p>
<h2 id="文件系统读取"><a href="#文件系统读取" class="headerlink" title="文件系统读取"></a>文件系统读取</h2><p>将 <code>wordpress.tar</code> 文件传输到要部署 <code>WordPress</code> 应用程序的目标服务器上。在目标服务器上执行以下命令，将 <code>wordpress.tar</code> 文件导入到 <code>Docker</code> 中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> wordpress.tar | docker import - &lt;image_name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;image_name&gt;</code> 是你为导入的 <code>Docker</code> 镜像指定的名称，<code>&lt;tag&gt;</code> 是你为该镜像指定的标签。运行导入的 <code>Docker</code> 镜像，启动 <code>WordPress</code> 应用程序的容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p &lt;host_port&gt;:&lt;container_port&gt; -d &lt;image_name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;host_port&gt;</code> 是你要将容器的端口映射到主机上的端口号，<code>&lt;container_port&gt;</code> 是容器内运行 <code>WordPress</code> 应用程序的端口号。这样，你就可以将 <code>Docker</code> 中的整个 <code>WordPress</code> 应用程序打包并部署到另一个地方。</p>
<h1 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h1><ol>
<li>按照之前的 docker-compose 的方法启动 dokcer 使用 <code>docker ps -a --no-trunc</code> 需要修改并添加 command</li>
<li><code>wordpress</code> 是 <code>docker-entrypoint.sh apache2-foreground</code></li>
<li><code>mysql</code> 是 <code>docker-entrypoint.sh mysqld</code></li>
<li>使用 <code>docker run</code> 命令在目标机器上启动该 <code>Docker</code> 镜像。例如，使用以下命令在目标机器上启动名为 <code>wordpress</code> 的 <code>Docker</code> 镜像：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动mysql</span></span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-v mysql_data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=liuluhua \</span><br><span class="line">-e MYSQL_DATABASE=wordpress \</span><br><span class="line">-e MYSQL_USER=liuluhua \</span><br><span class="line">-e MYSQL_PASSWORD=liuluhua \</span><br><span class="line">mysql:latest docker-entrypoint.sh mysqld</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动wordpress</span></span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">--name wordpress \</span><br><span class="line">--<span class="built_in">link</span> mysql \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-e WORDPRESS_DB_HOST=mysql:3306 \</span><br><span class="line">-e WORDPRESS_DB_USER=liuluhua \</span><br><span class="line">-e WORDPRESS_DB_PASSWORD=liuluhua \</span><br><span class="line">-e WORDPRESS_DB_NAME=wordpress \</span><br><span class="line">-v ./wp-content:/var/www/html/wp-content \</span><br><span class="line">-v ./uploads.ini:/usr/local/etc/php/conf.d/uploads.ini \</span><br><span class="line">wordpress:latest docker-entrypoint.sh apache2-foreground</span><br></pre></td></tr></table></figure>

<p>启动参数： </p>
<p>**<code>-d</code>**：表示以“后台模式”运行容器，即使容器的主进程退出也不会停止容器。 </p>
<p>**<code>--name</code>**：表示为容器指定一个名称，这样可以方便地对容器进行管理。 </p>
<p>**<code>-v</code>**：表示将主机的目录或文件与容器内的目录或文件进行挂载，即数据卷。例，<code>-v mysql_data:/var/lib/mysql</code> 表示将主机的 mysql_data 目录挂载到容器内的 <code>/var/lib/mysql</code> 目录，这样容器内的 <code>MySQL</code> 数据就可以持久化存储在主机上。 </p>
<p>**<code>-e</code>**：表示设置容器内的环境变量。例如，<code>-e MYSQL_ROOT_PASSWORD=liuluhua</code> 表示设置容器内的 <code>MYSQL_ROOT_PASSWORD</code> 环境变量为 <code>liuluhua</code>。 </p>
<p>**<code>--link</code>**：表示将一个容器链接到另一个容器，使得容器之间可以进行通信。例如，<code>--link mysql</code> 表示将容器链接到名为 mysql 的容器。 </p>
<p>**<code>-p</code>**：表示将容器的端口映射到主机的端口。例如，<code>-p 80:80</code> 表示将容器的 <code>80</code> 端口映射到主机的 <code>80</code> 端口，使得可以通过主机的 <code>IP</code> 地址访问容器内的服务。 </p>
<p>**<code>wordpress:latest</code> 和 <code>mysql:latest</code>**：表示使用 wordpress 和 mysql 镜像的最新版本来创建容器。 </p>
<p>**<code>./wp-content:/var/www/html/wp-content</code> 和 <code>./uploads.ini:/usr/local/etc/php/conf.d/uploads.ini</code>**：表示将主机上的 <code>wp-content</code> 目录和 <code>uploads.ini</code> 文件挂载到容器内的 <code>/var/www/html/wp-content</code> 目录和 <code>/usr/local/etc/php/conf.d/uploads.ini</code> 文件，使得容器内的 <code>WordPress</code> 网站可以访问这些文件。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker下配置wordpress</title>
    <url>/2024/08/22/0-%E5%B9%B3%E5%8F%B0-Docker-Docker%E4%B8%8B%E9%85%8D%E7%BD%AEwordpress/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote>
<p>docker.io 和 docker 的区别<br>    docker.io 是 ubuntu 维护的，生产环境应该使用 docker.io</p>
</blockquote>
<h2 id="安装-Docker-及-Docker-compose"><a href="#安装-Docker-及-Docker-compose" class="headerlink" title="安装 Docker 及 Docker-compose"></a>安装 Docker 及 Docker-compose</h2><p>Docker Compose 是一个工具，您可以使用它轻松定义和启动 Docker 中的多容器应用程序。 使用 Compose，您可以在单个 YAML 文件中定义所有服务，并且使用单个命令，可以启动或拆除所有服务。 在本教程中，我们将使用 Docker Compose 在隔离的容器化环境中并排运行两个容器（WordPress 和 MySQL）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">apt install docker.io</span><br><span class="line">apt install docker-compose</span><br></pre></td></tr></table></figure>

<ul>
<li>确认版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>

<ul>
<li>启动 docker</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo service docker  start</span><br></pre></td></tr></table></figure>

<h1 id="DockerCompose-方式"><a href="#DockerCompose-方式" class="headerlink" title="DockerCompose 方式"></a>DockerCompose 方式</h1><h2 id="安装-WordPress-及-Mysql"><a href="#安装-WordPress-及-Mysql" class="headerlink" title="安装 WordPress 及 Mysql"></a>安装 WordPress 及 Mysql</h2><h3 id="准备存储目录"><a href="#准备存储目录" class="headerlink" title="准备存储目录"></a>准备存储目录</h3><p>Docker 容器中的数据不是持久的。这意味着如果您停止容器并再次运行它，您将丢失所有数据，里面将不再有任何数据。这可以通过添加 Docker 数据卷来避免。 </p>
<h3 id="创建-docker-compose-yml"><a href="#创建-docker-compose-yml" class="headerlink" title="创建 docker-compose.yml"></a>创建 docker-compose.yml</h3><p>在 Docker Compose 中，运行容器所需的所有资源都必须在名为 .yaml 的 YAML 文件中定义 docker-compose.yaml。然后 Docker Compose 将读取此类文件并与 Docker 守护程序通信以创建、配置或销毁定义的资源。 在我们的例子中，该 docker-compose.yaml 文件将包含我们的 dockerized WordPress 设置的服务定义。此外，Docker Compose 允许我们将这些服务与共享网络和卷链接在一起。 因此，让我们从使用 Vim 编辑器在&#x2F;srv&#x2F;wordpress 目录中创建一个新文件 docker-compose.yaml 开始 。示例内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">	<span class="attr">mysql:</span></span><br><span class="line">		<span class="attr">image:</span> </span><br><span class="line">			<span class="string">mysql:latest</span>   <span class="comment">#安装mysql镜像</span></span><br><span class="line">		<span class="attr">volumes:</span>    <span class="comment">#映射位置</span></span><br><span class="line">			<span class="string">mysql_data:/var/lib/mysql</span> </span><br><span class="line">		<span class="attr">restart:</span> </span><br><span class="line">			<span class="string">always</span></span><br><span class="line">		<span class="attr">environment:</span>  <span class="comment">#环境变量</span></span><br><span class="line">			<span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">liuluhua</span> </span><br><span class="line">			<span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">			<span class="attr">MYSQL_USER:</span> <span class="string">liuluhua</span></span><br><span class="line">			<span class="attr">MYSQL_PASSWORD:</span> <span class="string">liuluhua</span></span><br><span class="line">	<span class="attr">wordpress:</span></span><br><span class="line">		<span class="attr">depends_on:</span>    <span class="comment">#需要mysql</span></span><br><span class="line">		   <span class="string">mysql</span></span><br><span class="line">		<span class="attr">image:</span> </span><br><span class="line">			<span class="string">wordpress:latest</span>    <span class="comment">#安装wordpress镜像</span></span><br><span class="line">		<span class="attr">ports:</span></span><br><span class="line">		    <span class="string">&quot;80:80&quot;</span>      <span class="comment">#端口映射</span></span><br><span class="line">		<span class="attr">restart:</span> </span><br><span class="line">			<span class="string">always</span></span><br><span class="line">		<span class="attr">environment:</span>       <span class="comment">#环境变量</span></span><br><span class="line">			<span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql:3306</span></span><br><span class="line">			<span class="attr">WORDPRESS_DB_USER:</span> <span class="string">liuluhua</span></span><br><span class="line">			<span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">liuluhua</span></span><br><span class="line">			<span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">	<span class="string">./wp-content:/var/www/html/wp-content</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">	<span class="attr">mysql_data:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里定义了两个自动互相链接的服务 mysql 和 wordpress</li>
<li>使用最新的 mysql 和 wordpress 的 docker 镜像</li>
<li>设置了 MYSQL 和 WordPress 的环境</li>
<li>WordPress 映像基于 Apache，它通过 derfault 在端口 上运行 80。将默认 Apache 端口映射到 8080 本地计算机的端口。</li>
<li>mysql_data：流入这个数据库的数据将被持久化到一个命名卷 mysql_data，这样即使你删除了容器，数据仍然存在于你的机器上，并且可以再次安装在新的容器中。</li>
<li>volumes 参数 wordpress 是告诉 Docker 的 wp-content 在本地文件系统中显示目录。现在，我们为 WordPress 站点的某些部分（例如 wp-content 目录）提供了持久存储。在 wp-content 包含所有用户提供的内容。基本上，您可以上传到网站的任何内容都会在此处结束。</li>
<li>只要您同时拥有数据库和 wp-content 文件夹，您就可以随时恢复您的站点，即使其他所有内容都丢失了。</li>
</ul>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose.wordpress.yml up -d #后台运行</span><br><span class="line">docker-compose -f docker-compose.wordpress.yml down  #停止并删除服务</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"># Docker 命令行</span><br><span class="line"></span><br><span class="line">## 命令行方式安装</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">docker pull wordpress</span><br><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>

<h2 id="命令行方式启动"><a href="#命令行方式启动" class="headerlink" title="命令行方式启动"></a>命令行方式启动</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql -v mysql-data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=liuluhua \</span><br><span class="line">-e MYSQL_DATABASE=wordpress mysql \</span><br><span class="line"></span><br><span class="line">docker run -d -e WORDPRESS_DB_HOST=mysql:<span class="number">3306</span> --link mysql \</span><br><span class="line">-p <span class="number">8000</span>:<span class="number">80</span> wordpress</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br></pre></td></tr></table></figure>

<h1 id="访问-wordpress"><a href="#访问-wordpress" class="headerlink" title="访问 wordpress"></a>访问 wordpress</h1><p>打开 <a href="http://127.0.0.1/">http://127.0.0.1:80</a></p>
<h1 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h1><h2 id="WP-Githuber-MD"><a href="#WP-Githuber-MD" class="headerlink" title="WP Githuber MD"></a>WP Githuber MD</h2><p>支持 markdown</p>
<h2 id="配置上传文件大小"><a href="#配置上传文件大小" class="headerlink" title="配置上传文件大小"></a>配置上传文件大小</h2><p>在 yaml 文件中 volumes 中新增一行： </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">./uploads.ini:/usr/local/etc/php/conf.d/uploads.ini</span></span><br></pre></td></tr></table></figure>

<p>默认为文件夹，删除修改为文件就行，修改文件内容为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file_uploads = On</span><br><span class="line">memory_limit = <span class="number">5</span>G</span><br><span class="line">upload_max_filesize = <span class="number">5</span>G</span><br><span class="line">post_max_size = <span class="number">5</span>G</span><br><span class="line">max_execution_time = <span class="number">0</span> #上传时间限制，修改为<span class="number">0</span>则无限制</span><br></pre></td></tr></table></figure>

<p>之后安装 <a href="https://wordpress.org/plugins/wp-maximum-upload-file-size/">WP Maximum Upload File Size</a> 插件进行修改即可，最大支持到 2GB</p>
<p><strong>如果要修改超过 2GB：</strong></p>
<ol>
<li>卸载 <code>WP Maximum Upload File Size</code> 插件，编辑 <code>uploads.ini</code></li>
<li>编辑 <code>html/wp-config.php</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@ini\_set( <span class="string">&#x27;upload\_max\_filesize&#x27;</span> , <span class="string">&#x27;4G&#x27;</span> );</span><br><span class="line">@ini\_set( <span class="string">&#x27;post\_max\_size&#x27;</span>, <span class="string">&#x27;4G&#x27;</span>);</span><br><span class="line">@ini\_set( <span class="string">&#x27;memory\_limit&#x27;</span>, <span class="string">&#x27;8G&#x27;</span> );</span><br><span class="line">@ini\_set( <span class="string">&#x27;max\_execution\_time&#x27;</span>, <span class="string">&#x27;0&#x27;</span> );</span><br><span class="line">@ini\_set( <span class="string">&#x27;max\_input\_time&#x27;</span>, <span class="string">&#x27;0&#x27;</span> );</span><br></pre></td></tr></table></figure>

<ol>
<li>编辑 <code>html/wp-content/.htaccess</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">php_value upload_max_filesize <span class="number">4</span>G</span><br><span class="line">php_value post_max_size <span class="number">4</span>G</span><br><span class="line">php_value memory_limit <span class="number">8</span>G</span><br><span class="line">php_value max_execution_time <span class="number">0</span></span><br><span class="line">php_value max_input_time <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker介绍</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-Docker-Docker%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Docker 是一种流行的容器化平台，它可以帮助开发人员和运维人员更轻松地构建、交付和运行应用程序。</p>
<h1 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h1><p>Docker 的架构包括以下组件：</p>
<ul>
<li><strong>Docker 守护进程</strong>：运行在主机上的后台进程，负责管理 Docker 对象，如镜像、容器、网络和数据卷。</li>
<li><strong>Docker 客户端</strong>：通过 Docker API 与 Docker 守护进程通信。</li>
<li><strong>Docker 镜像</strong>：包含应用程序和其依赖项的只读文件系统。</li>
<li><strong>Docker 容器</strong>：Docker 镜像的可运行实例。</li>
<li><strong>Docker 仓库</strong>：用于存储 Docker 镜像的地方。</li>
</ul>
<p>主要需要注意的是镜像<strong>IMAGE</strong>和容器<strong>CONTAINER</strong></p>
<ul>
<li>可以将镜像视为虚拟机的一个快照，镜像是容器的基础，定义了容器的基本配置和内容</li>
<li>容器，即为镜像的实例化内容，当启动一个容器时，Docker 会从镜像创建一个只读的文件系统层，并在其上添加一个可写层，容器中的所有更改和数据都存储在这个可写层上。</li>
</ul>
<h1 id="Docker-基本命令"><a href="#Docker-基本命令" class="headerlink" title="Docker 基本命令"></a>Docker 基本命令</h1><p>Docker 提供了一系列命令行工具，用于管理 Docker 容器和镜像，以及执行与容器相关的操作</p>
<p>以下是一些常用的 Docker 命令：</p>
<ul>
<li><code>docker images</code>：列出本地所有的镜像。</li>
<li><code>docker rmi &lt;image&gt;</code>：删除一个镜像。</li>
<li><code>docker pull &lt;image&gt;</code>：从仓库中拉取一个镜像。</li>
<li><code>docker build -t &lt;image_name&gt; &lt;path_to_dockerfile&gt;</code>：根据 Dockerfile 构建新的自定义镜像。</li>
<li><code>docker push &lt;image&gt;</code>：将一个镜像推送到仓库中。</li>
<li><code>docker run &lt;image&gt;</code>：根据指定的镜像创建并启动一个新的容器。</li>
<li><code>docker ps</code>：列出当前正在运行的容器。加 <code>-a</code> 列出所有，包括运行中的和已经停止的</li>
<li><code>docker start &lt;container_id/container_name&gt;</code>：启动已停止的容器。</li>
<li><code>docker stop &lt;container_id/container_name&gt;</code>：停止运行中的容器。</li>
<li><code>docker restart &lt;container_id/container_name&gt;</code>：重启容器。</li>
<li><code>docker rm &lt;container_id/container_name&gt;</code>：删除指定容器。</li>
<li><code>docker logs &lt;container_id/container_name&gt;</code>：查看容器的日志输出。</li>
<li><code>docker exec -it &lt;container_id/container_name&gt; &lt;command&gt;</code>：在正在运行的容器中执行特定命令。</li>
<li><code>docker exec -it container /bin/bash</code> 进入 container 容器中的命令行</li>
<li><code>docker inspect &lt;container_id/container_name&gt;</code>：查看容器的详细信息，包括 IP 地址、端口映射等。</li>
<li><code>docker network ls</code>：列出所有 Docker 网络。</li>
<li><code>docker volume ls</code>：列出所有 Docker 卷。</li>
</ul>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Dockerfile 是一种文本文件，用于定义如何<strong>构建 Docker 镜像</strong>。包含了一系列的指令和参数，用于指导 Docker 引擎在基础镜像上添加应用程序代码、运行时环境、依赖项和配置文件等，最终生成一个新的 Docker 镜像。</p>
<p>以下是一个简单的 Dockerfile 示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    FROM ubuntu:latest</span><br><span class="line">    RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">    CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>该 Dockerfile 使用最新版本的 Ubuntu 镜像作为基础镜像，并在其中安装了 nginx。</p>
<p>一些 dockerfile 中的指令：</p>
<ul>
<li><code>FROM</code>： 指定基础镜像。每个 Docker 镜像都是基于一个基础镜像构建的，这个指令用于设置构建的起点。</li>
<li><code>MAINTAINER</code>： 设置镜像的作者信息，通常是作者的名字和电子邮件。</li>
<li><code>RUN</code>： 在镜像<strong>构建过程中</strong>执行的命令。可以用于安装软件包、更新系统、设置环境等操作。</li>
<li><code>CMD</code>： 设置容器<strong>启动</strong>时要执行的命令。如果在运行镜像时没有指定要执行的命令，则将执行这里设置的默认命令。</li>
<li><code>ENTRYPOINT</code>： 设置容器启动时要执行的固定命令。与 CMD 类似，但可以将参数传递给 ENTRYPOINT 指定的命令。</li>
<li><code>COPY</code>： 将本地文件复制到镜像中。</li>
<li><code>ADD</code>： 类似于 COPY，但它还支持复制网络资源和自动解压缩压缩文件。</li>
<li><code>WORKDIR</code>： 设置容器的工作目录，后续的指令将在这个目录下执行。</li>
<li><code>EXPOSE</code>： 指定容器运行时监听的端口号，但并不会自动将端口映射到宿主机。</li>
<li><code>ENV</code>： 设置环境变量，可以在容器内部访问。</li>
<li><code>ARG</code>： 声明构建时的参数，构建时可以通过 –build-arg 参数传递。</li>
<li><code>VOLUME</code>： 创建一个可以从宿主机或其他容器挂载的挂载点。</li>
<li><code>USER</code>： 设置运行镜像的用户。<code>ONBUILD</code>： 定义一个触发器，在子镜像构建时执行特定的操作。</li>
</ul>
<h1 id="Docker-Compose（重点）"><a href="#Docker-Compose（重点）" class="headerlink" title="Docker Compose（重点）"></a>Docker Compose（重点）</h1><p>Docker Compose 是一个工具，用于定义和运行多个 Docker 容器的应用程序。</p>
<ul>
<li>docker-compose 需要编写 yml 脚本，定义配置以及多个容器之间的依赖关系和网络连接<br>  * 注意：yml 文件对缩进有严格要求</li>
<li>通过命令控制 docker-compose<br>以下是一个简单的 docker-compose.yml 文件示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;3.9&quot;</span></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: mysql:<span class="number">5.7</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./db_data:/var/lib/mysql</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: somewordpress</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">      MYSQL_USER: wordpress</span><br><span class="line">      MYSQL_PASSWORD: wordpress</span><br><span class="line">  wordpress:</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    image: wordpress:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - ./wordpress_data:/var/www/html</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      - <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: db</span><br><span class="line">      WORDPRESS_DB_USER: wordpress</span><br><span class="line">      WORDPRESS_DB_PASSWORD: wordpress</span><br><span class="line">      WORDPRESS_DB_NAME: wordpress</span><br><span class="line">volumes:</span><br><span class="line">  db_data: &#123;&#125;</span><br><span class="line">  wordpress_data: &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里用到了 mysql:5.7 和 wordpress:latest 两个 Docker 镜像，WordPress 镜像依赖 <code>depends_on</code> 于 MySQL 镜像。</li>
<li>restart: always 参数表明容器服务宕机后会自动重启。</li>
<li>MYSQL_ROOT_PASSWORD 为数据库的 root 密码，MYSQL_PASSWORD 为数据库的普通用户密码，请自行修改，对应的 WORDPRESS_DB_PASSWORD 也要同时修改。MYSQL_USER 为数据库普通用户的用户名，如果有需要也可以修改，对应的 WORDPRESS_DB_USER 也要同时修改。</li>
<li>80:80 的意思是把宿主机的 80 端口映射到容器内部的 80 端口。如需通过其他端口访问，只需修改前面的 80。比如，我要通过 8080 端口访问 WordPress，填写 8080:80 即可。</li>
<li>volumes 会将主机中指定的目录 <code>./wordpress_data</code> 和容器中的指定目录 <code>/var/www/html</code> 共享，类似于虚拟机中的共享文件夹。并且在容器销毁后目录中的文件依旧存在。</li>
</ul>
<p>在 Docker Compose 版本 3 及以上的配置中，不再使用 links 字段来定义容器之间的连接。取而代之的是使用 Docker 网络来实现容器之间的通信。现在，Docker Compose 默认创建一个项目级别的默认网络，其中每个服务（service）都可以使用它。</p>
<p>只需保证 db 和 wordpress 属于同一个项目（即在同一个 docker-compose.yml 文件中定义），它们将自动连接到默认网络，并可以通过服务名称（db 和 wordpress）相互访问。</p>
<h2 id="docker-compose-脚本"><a href="#docker-compose-脚本" class="headerlink" title="docker-compose 脚本"></a>docker-compose 脚本</h2><p><a href="https://docs.docker.com/compose/compose-file/">Docker Compose官方文档</a></p>
<h2 id="docker-compose-命令"><a href="#docker-compose-命令" class="headerlink" title="docker-compose 命令"></a>docker-compose 命令</h2><ul>
<li><code>docker-compose up -d</code>：根据当前目录的 yml 文件配置启动容器，<code>-d</code> 参数代表在后台运行</li>
<li><code>docker-compose ps</code>：查看运行状态</li>
<li><code>docker-compose stop</code>：停止运行</li>
<li><code>docker-compose restart</code>：重启</li>
<li><code>docker-compose restart service-name</code>：重启单个服务</li>
<li><code>docker-compose exec service-name sh</code>：进入容器命令行</li>
<li><code>docker-compose logs [service-name]</code>：查看容器运行 log，-f 指定文件名</li>
</ul>
<h1 id="Docker-安装及使用"><a href="#Docker-安装及使用" class="headerlink" title="Docker 安装及使用"></a>Docker 安装及使用</h1><h2 id="利用-docker-配置-wordpress-个人博客"><a href="#利用-docker-配置-wordpress-个人博客" class="headerlink" title="利用 docker 配置 wordpress 个人博客"></a>利用 docker 配置 wordpress 个人博客</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在安装 docker 时，发现 docker 有多个版本：</p>
<ul>
<li><strong>docker.io</strong>：debian&#x2F;ubuntu 官方基于 docker 社区源码封装的版本，将 docker 的依赖直接转接到主系统上</li>
<li>docker-ce：docker.com 放出来的社区版，使用 golang 将依赖封装在一个包中</li>
<li>docker-ee：docker.com 维护的商业版<br>一般使用<strong>docker.io</strong></li>
<li>安装 docker.io：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 docker-compose：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install docker-compose</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>创建一个文件夹用于存储 volume 以及 yml 文件：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mkdir wordpress &amp;&amp; cd wordpress</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑 yml 文件（yml 文件内容参照 <a href="http://124.222.246.202:8080/2023/07/19/docker%E4%BB%8B%E7%BB%8D/">Docker介绍</a>）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vi myBlog.yml</span><br></pre></td></tr></table></figure>

<ul>
<li>启动容器（初次启动时会下载镜像，速度较慢）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure>

<ul>
<li>如果有错误，查看启动日志：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo docker-compose logs</span><br></pre></td></tr></table></figure>

<ul>
<li>如果需要进入容器内命令行：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo docker-compose exec -it &lt;容器名称&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>停止并删除容器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo docker-compose down</span><br></pre></td></tr></table></figure>

<h1 id="Docker-镜像和容器的构建、导出"><a href="#Docker-镜像和容器的构建、导出" class="headerlink" title="Docker 镜像和容器的构建、导出"></a>Docker 镜像和容器的构建、导出</h1><p><code>docker build</code>、<code>docker export</code>、<code>docker save</code> 和 <code>docker commit</code> 是 Docker 的一些常用命令，它们在 Docker 镜像和容器的构建、导出和保存等方面有不同的作用。</p>
<h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p>作用：使用 Dockerfile 定义构建规则，构建一个新的 Docker 镜像。</p>
<p>描述：docker build 命令是用于根据 Dockerfile 创建一个新的 Docker 镜像。</p>
<p>Dockerfile 中包含了构建镜像所需的指令，例如安装软件、配置环境等。</p>
<p>docker build 命令会根据 Dockerfile 的指令逐步构建镜像的不同层，最终生成一个可执行的镜像。</p>
<h2 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export"></a>docker export</h2><p>作用：导出 Docker 容器的文件系统作为一个 tar 归档文件。</p>
<p><code>docker export</code> 命令将 <code>Docker</code> 容器导出为一个 <code>tar</code> 文件，其中包含容器中的文件系统和元数据，但<strong>不包括镜像的元数据和层</strong>。这意味着，使用 <code>docker export</code> 命令导出的文件<strong>无法用作 <code>Docker</code> 镜像的源文件</strong>，只能用于将<strong>容器迁移</strong>到另一个 <code>Docker</code> 主机或将容器中的文件系统导出到本地。</p>
<p>例如，如果你想要将一个正在运行的 <code>WordPress</code> 容器迁移到另一个 <code>Docker</code> 主机，可以使用 <code>docker export</code> 命令将容器导出为一个 <code>tar</code> 文件，然后将该文件传输到目标主机并使用 <code>docker import</code> 命令导入为一个新的 <code>Docker</code> 镜像。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">export</span> &lt;container_id&gt; &gt; wordpress.tar</span><br></pre></td></tr></table></figure>

<h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p>作用：将 Docker 镜像保存为 tar 归档文件。</p>
<p><code>docker save</code> 命令将 <code>Docker</code> 镜像导出为一个 <code>tar</code> 文件，其中包含镜像的<strong>元数据和层</strong>，可以用作 <code>Docker</code> <strong>镜像的源文件</strong>。这意味着，使用 <code>docker save</code> 命令导出的文件可以用于在不同的 <code>Docker</code> 主机之间共享镜像，或者将镜像备份到本地。</p>
<p>例如，如果你想要将一个名为 <code>wordpress:latest</code> 的 <code>Docker</code> 镜像备份到本地，可以使用 <code>docker save</code> 命令将镜像导出为一个 tar 文件。</p>
<p>    docker save -o wordpress.tar wordpress:latest</p>
<p>总之，<code>docker export</code> 命令导出的文件<strong>只包含容器中的文件系统和元数据</strong>，而 <code>docker save</code> 命令导出的文件<strong>包含完整的镜像元数据和层</strong>，可以用于在不同的 <code>Docker</code> 主机之间共享镜像或备份到本地。</p>
<h2 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h2><p>作用：将容器的变更保存为新的 Docker 镜像。</p>
<p>描述：docker commit 命令允许你将一个正在运行的容器的变更保存为一个新的 Docker 镜像。它会创建一个新的镜像层，将容器中的变更添加到这个层中，最终生成一个新的镜像。</p>
<p>例如：遇到了一个 docker 环境，需要带回来自己调试，打包正在运行的容器，快速拖环境跑路</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker ps   //获取正在运行的容器,找到ID</span><br><span class="line">docker commit -a <span class="string">&quot;test&quot;</span> -m <span class="string">&quot;wordpress&quot;</span> &lt;容器名称或ID&gt;  //将容器打包成镜像</span><br><span class="line">docker save -o ./wordpress.tar &lt;容器名称或ID&gt;  //拖到本地</span><br><span class="line">docker load -i hackgod-demo.tar             //导入镜像</span><br></pre></td></tr></table></figure>

<h1 id="Docker-将容器打包成镜像以及导入导出"><a href="#Docker-将容器打包成镜像以及导入导出" class="headerlink" title="Docker 将容器打包成镜像以及导入导出"></a>Docker 将容器打包成镜像以及导入导出</h1><p>可以使用 <code>docker commit</code> 命令来完成，<code>docker commit</code> 可以从容器创建一个新的镜像。</p>
<h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>-a : 提交的镜像作者；<br>-c : 使用 Dockerfile 指令来创建镜像；<br>-m : 提交时的说明文字；<br>-p : 在 commit 时，将容器暂停</p>
<h2 id="容器打包成镜像："><a href="#容器打包成镜像：" class="headerlink" title="容器打包成镜像："></a>容器打包成镜像：</h2><p>将容器 a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker stop <span class="number">2</span>a2a11e2c043</span><br><span class="line">docker commit -a <span class="string">&quot;alway.com&quot;</span> -m <span class="string">&quot;socks5&quot;</span> <span class="number">2</span>a2a11e2c043  alway.com/wangwei/socks5:v1</span><br></pre></td></tr></table></figure>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><h3 id="在镜像包所在的文件夹下操作"><a href="#在镜像包所在的文件夹下操作" class="headerlink" title="在镜像包所在的文件夹下操作"></a>在镜像包所在的文件夹下操作</h3><p><code>docker load --input  uu.tar(也可以使用docker load -i uu.tar或者 docker load &lt; uu.tar)</code></p>
<p>或</p>
<p><code>docker load &lt; uu.tar</code></p>
<p>导出（镜像打包）</p>
<p><code>docker save &gt; /root/docker_images/uu.tar ubuntu:latest</code></p>
<p>或</p>
<p><code>docker save /root/docker_images/ubuntu:latest &gt; uu.tar</code></p>
<p>或</p>
<p><code>docker save -o /root/docker_images/[镜像名].tar [镜像名]:latest</code></p>
<p>启动镜像</p>
<p><code>docker run -it -d --name container-name -pp1:p1-pp2:p2new-image-name</code></p>
<p><code>docker run -it -d --name qinglong -p 5700:5700 alway.com/wangwei/qinglong:v1</code></p>
<h1 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h1><p><code>docker build</code> 和 <code>docker commit</code> 都用于构建 Docker 镜像，但它们的方式不同。</p>
<p>*docker build 是通过 Dockerfile 定义构建规则，逐步构建镜像，而 docker commit 是将容器的变更直接保存为新的镜像。</p>
<p>docker export 和 docker save 都用于导出 Docker 镜像或容器的文件系统，但它们导出的内容不同。</p>
<p>*docker export 导出容器的文件系统作为归档文件，但不包含镜像的元数据和历史记录，不能用于还原容器。而 docker save 导出完整的 Docker 镜像，包含了元数据和文件系统，可以用于还原镜像。</p>
<p>docker build 和 docker save 都用于创建 Docker 镜像</p>
<p>docker export 用于导出容器的文件系统，而 docker commit 用于将容器的变更保存为新的镜像。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker随手记</title>
    <url>/2024/08/14/0-%E5%B9%B3%E5%8F%B0-Docker-Docker%E9%9A%8F%E6%89%8B%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>docker.io 和 docker-ce 区别 docker.io 采用 apt 的方式管理依赖  docker-ce 用 go 的方式管理依赖，会自己管理所有的依赖。</li>
</ul>
<h1 id="导出镜像："><a href="#导出镜像：" class="headerlink" title="导出镜像："></a>导出镜像：</h1><p>使用 docker save 命令来导出镜像。</p>
<p>命令格式：docker save -o &lt;输出文件名&gt;.tar &lt;镜像名称&gt;:&lt;镜像标签&gt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker save -o my_image.tar my_docker_image:latest</span><br></pre></td></tr></table></figure>

<h1 id="导入镜像："><a href="#导入镜像：" class="headerlink" title="导入镜像："></a>导入镜像：</h1><p>使用 docker load 命令来导入镜像。</p>
<p>命令格式：docker load -i &lt;输入文件名&gt;.tar</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker load -i my_image.tar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Portainer</title>
    <url>/2024/07/22/0-%E5%B9%B3%E5%8F%B0-Docker-Portainer/</url>
    <content><![CDATA[<p>Portainer can be used to manage Docker containers through a web interface. </p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407221441980.png" alt="image.png"></p>
<p>CE 社区版本部署</p>
<p>首先，创建 Portainer Server 用于存储其数据库的卷：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker volume create portainer_data</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">portainer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">portainer/portainer-ce:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">portainer</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9094</span><span class="string">:9000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">portainer_data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">portainer_data:</span></span><br></pre></td></tr></table></figure>

<p>现在安装已完成，访问以下网址登录 Portainer Server 实例： <a href="https://localhost:9094/">https://localhost:9094</a></p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Vmware共享文件夹</title>
    <url>/2024/05/21/0-%E5%B9%B3%E5%8F%B0-VMware-Vmware%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<h1 id="查看共享的文件夹"><a href="#查看共享的文件夹" class="headerlink" title="查看共享的文件夹"></a>查看共享的文件夹</h1><p>使用 vmware-hgfsclient 命令</p>
<p>输入 <code>vmware-hgfsclient</code> 显示共享文件夹名称</p>
<h1 id="挂载共享文件夹"><a href="#挂载共享文件夹" class="headerlink" title="挂载共享文件夹"></a>挂载共享文件夹</h1><p>使用 vmhgfs-fuse 命令</p>
<p><code>vmhgfs-fuse .host:/ShareDir /home/forlinx/ShareDir -o subtype=vmhgfs-fuse,allow_other</code></p>
<p>将主机下的 ShareDir 挂载到虚拟机的&#x2F;home&#x2F;forlinx&#x2F;ShareDir 文件夹下</p>
<p>在虚拟机中设置共享文件夹完成后，发现共享文件夹没有出现，执行</p>
<p><code>vmhgfs-fuse .host:/ /home/forlinx/ShareDir</code> </p>
<p>如果没有其他显示报错，就可以认为挂载成功了。</p>
<ul>
<li>注意：&#x2F;mnt 文件夹下的 hgfs 是自己创建的，如果没有，可以用 <code>mkdir /mnt/hgfs</code> 命令创建。</li>
</ul>
<p>直接用 ls 命令查看 <code>ls /home/forlinx/ShareDir</code> 显示挂载的共享文件夹内的文件内容已经同步，表示成功挂载。</p>
<h1 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h1><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>创建一个 <code>startShare.sh</code></p>
<p>写入</p>
<p><code>vmhgfs-fuse .host:/ /home/forlinx/ShareDir</code></p>
<p>加权限</p>
<p><code>chmod a+x startShare.sh</code></p>
<p>添加该脚本到自启中</p>
<h2 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h2><p>另：如果不想每次重启后都挂载一遍的话，建议直接把挂载放入启动文件 首先，备份 <code>/etc/fstab</code> 文件 <code>cp fstab  fstab_bak</code> 其次，编辑 <code>fstab</code> <code>vim fstab</code> 在最后添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># mount hgfs</span></span><br><span class="line">.host:/kali_share       /mnt/hgfs        fuse.vmhgfs-fuse       allow_other     <span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>然后就能够不用每次重启挂载一遍。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>VMware</category>
      </categories>
  </entry>
  <entry>
    <title>编译内存不足</title>
    <url>/2024/08/30/0-%E5%B9%B3%E5%8F%B0-VMware-%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<p>当在 Linux 环境下编译 C++程序时遇到 <code>&#39;fatal error: Killed signal terminated program cc1plus&#39;</code> 的问题，可能是因为内存不足。解决方法是创建 swap 分区，通过增加虚拟内存来缓解。步骤包括创建 swap 文件，设置权限，激活 swap，最后确认 swap 已正确配置。若不再需要，可使用 swapoff 和 rm 命令移除。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在 Linux 系统中进行 C++编译时，出现如下报错，导致编译中止：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C++: fatal error: Killed signal terminated program cc1plus</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>

<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>查阅相关信息后，认为是虚拟机内存不足造成的。通过创建 swap 分区解决了这个问题，编译成功。下面总结一下 swap 分区的创建和激活等操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 创建分区路径</span><br><span class="line">sudo mkdir -p /var/cache/swap/</span><br><span class="line"># 设置分区的大小</span><br><span class="line"><span class="meta"># bs=64M是块大小，count=64是块数量，所以swap空间大小是bs*count=4096MB=4GB</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=/dev/zero of=/var/cache/swap/swap0 bs=<span class="number">64</span>M count=<span class="number">64</span></span><br><span class="line"># 设置该目录权限</span><br><span class="line">sudo chmod <span class="number">0600</span> /var/cache/swap/swap0</span><br><span class="line"># 创建SWAP文件</span><br><span class="line">sudo mkswap /var/cache/swap/swap0</span><br><span class="line"># 激活SWAP文件</span><br><span class="line">sudo swapon /var/cache/swap/swap0</span><br><span class="line"># 查看SWAP信息是否正确</span><br><span class="line">sudo swapon -s</span><br></pre></td></tr></table></figure>

<p>swap0 文件的路径在&#x2F;var&#x2F;cache&#x2F;swap&#x2F;下，编译完后, 如果不想要交换分区了, 可以删除。</p>
<p>删除交换分区的命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo swapoff /var/cache/swap/swap0</span><br><span class="line">sudo rm /var/cache/swap/swap0</span><br></pre></td></tr></table></figure>

<p>释放空间命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo swapoff -a</span><br><span class="line">#详细的用法：swapoff --help</span><br><span class="line">#查看当前内存使用情况：free -m</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>VMware</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟机磁盘收缩</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-VMware-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%94%B6%E7%BC%A9/</url>
    <content><![CDATA[<h1 id="1-删除快照"><a href="#1-删除快照" class="headerlink" title="1. 删除快照"></a>1. 删除快照</h1><p>打开 VMware，选择工具栏的虚拟机，选择快照，选择快照管理器，删除不用的快照</p>
<h1 id="2-删除缓存文件"><a href="#2-删除缓存文件" class="headerlink" title="2. 删除缓存文件"></a>2. 删除缓存文件</h1><p>打开虚拟机，删除虚拟机中的缓存文件目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf /home/forlinx/.cache/vmware/drag_and_drop</span><br></pre></td></tr></table></figure>

<blockquote>
<p>df -h 指令可查找到磁盘真实占据的磁盘空间</p>
</blockquote>
<h1 id="3-压缩磁盘空间"><a href="#3-压缩磁盘空间" class="headerlink" title="3. 压缩磁盘空间"></a>3. 压缩磁盘空间</h1><p>当虚拟机安装盘所剩余的空间大于.vmdk 文件的大小时，强烈推荐使用以下方式 在你的终端输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /usr/bin/vmware-toolbox-cmd disk list</span><br></pre></td></tr></table></figure>

<p>一般会有 <code>&quot;/&quot;</code> 目录 再输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /usr/bin/vmware-toolbox-cmd disk shrink /</span><br></pre></td></tr></table></figure>

<p>即压缩根目录 <code>&quot;/&quot;</code></p>
<h1 id="4-使用-DiskGenius-压缩"><a href="#4-使用-DiskGenius-压缩" class="headerlink" title="4. 使用 DiskGenius 压缩"></a>4. 使用 DiskGenius 压缩</h1><p>存放在物理硬盘上的虚拟磁盘文件的大小并没有减小。虚拟机磁盘文件只会慢慢地变大，虚拟机软件不会在用户删除数据后对虚拟磁盘进行“压缩”。可以使用 DiskGenius 软件进行压缩。比如我们使用的是 VMware 虚拟机，它的虚拟磁盘文件是 vmdk 格式。</p>
<p>1、在 DiskGenius 软件中，首先把要压缩的虚拟磁盘打开（菜单：“硬盘 –&gt; 打开虚拟硬盘文件”）。打开后就可以在左边的窗口中看到加载上的虚拟磁盘了。</p>
<p>2、然后我们再新建一个容量不小于源虚拟硬盘的 vmdk 虚拟磁盘（菜单：“硬盘 –&gt; 新建虚拟硬盘文件 –&gt; 新建 VMware 虚拟硬盘文件”）。</p>
<p>3、开始进行压缩。选择（菜单：“工具 –&gt; 克隆硬盘”），弹出对话框后，在“选择源硬盘”时选择要压缩的 vmdk 虚拟磁盘，在“选择目标硬盘”时选择刚刚我们新建的 vmdk 虚拟磁盘，然后点“开始”。</p>
<p>4、现在已经复制完毕了，我们找到两个虚拟磁盘文件的所在路径，对比一下大小。可以看到，虚拟硬盘被压缩了。</p>
<p>这时，还需要做一些后续的清理工作。首先在 DiskGenius 软件中关闭刚才打开的两个虚拟硬盘，或者直接关闭 DiskGenius 软件。然后将源虚拟硬盘文件改名（备用，以防万一），再将新的虚拟硬盘文件改名为源虚拟硬盘的文件名（注意要完全相同）。最后打开虚拟机，启动一下虚拟系统，没有问题后就可以删除压缩前的源虚拟硬盘文件了。</p>
<h1 id="5-导出-OVF-重新建立新-vmdk"><a href="#5-导出-OVF-重新建立新-vmdk" class="headerlink" title="5. 导出 OVF 重新建立新 vmdk"></a>5. 导出 OVF 重新建立新 vmdk</h1><p>有时候删除虚拟机快照出现错误，但快照图标已消失，导致无法再次删除，造成文件残留，就这样越堆越多，无法清理。</p>
<blockquote>
<p>优点是可以释放大量空间，缺点是只能保留 VMware 虚拟机当前的状态和文件，丢失其他快照（可以按需先转到某个快照再导出 OVF，这样就可以保留快照时的状态了。同样，会丢失其他状态）。<br>步骤如下：</p>
</blockquote>
<ul>
<li>点击要清理的虚拟机，然后左上角点击文件，导出为 OVF（只存了虚拟机当前的状态，大概有十几个 G），存到其他空闲的磁盘下。</li>
<li>将上述步骤导出的 ovf 再部署出来，看看虚拟机是否正常。</li>
<li>如果正常可用，就可以把虚拟机原来占用的磁盘清空了，快速释放大量空间。</li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>VMware</category>
      </categories>
  </entry>
  <entry>
    <title>USB设备连接到WSL</title>
    <url>/2024/05/21/0-%E5%B9%B3%E5%8F%B0-WSL-USB%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E5%88%B0WSL/</url>
    <content><![CDATA[<p>在 WSL2 中连接 3D 打印机的 USB 端口，须将该设备从 windows 中挂载至 Linux 中，需要在 windows 环境中安装 usbipd</p>
<p>usbipd GitHub 地址 <a href="https://github.com/dorssel/usbipd-win">https://github.com/dorssel/usbipd-win</a></p>
<p>安装 usbipd</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#在win命令行中执行</span><br><span class="line">winget install usbipd</span><br></pre></td></tr></table></figure>

<p>安装环境</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">##在你的wsl中执行</span><br><span class="line">sudo apt install linux-tools-<span class="keyword">virtual</span> hwdata</span><br><span class="line">sudo update-alternatives --install /usr/local/bin/usbip usbip `ls /usr/lib/linux-tools<span class="comment">/*/usbip | tail -n1` 20</span></span><br></pre></td></tr></table></figure>

<p>*usbipd: error: WSL ‘usbip’ client not correctly installed.<br>重新执行此步骤</p>
<p>列出并挂载 win 中的设备到 linux 环境下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 在win终端中执行</span><br><span class="line">usbipd wsl list</span><br><span class="line">usbipd wsl attach --busid=<span class="number">4</span><span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>WSL</category>
      </categories>
  </entry>
  <entry>
    <title>中文字符无法正常显示</title>
    <url>/2024/09/02/0-%E5%B9%B3%E5%8F%B0-WSL-%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>WSL 中没有相应中文字体库，显示为小方框。</p>
<p>我们直接使用 Windows 自带的字体链接到 WSL 下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo ln -s /mnt/c/Windows/Fonts /usr/share/fonts/font</span><br></pre></td></tr></table></figure>

<p>扫描字体目录，并生成字体信息的缓存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fc-cache -fv</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>WSL</category>
      </categories>
  </entry>
  <entry>
    <title>Linux子系统的GUI</title>
    <url>/2024/08/27/0-%E5%B9%B3%E5%8F%B0-Windows-Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84GUI/</url>
    <content><![CDATA[<p>项目地址 <a href="https://github.com/microsoft/wslg">https://github.com/microsoft/wslg</a></p>
<p>WSLg 是 Windows Subsystem for Linux GUI 的缩写，该项目旨在支持在 Windows 上以完全集成的桌面体验运行 Linux GUI 应用程序（包括 X11 和 Wayland）。</p>
<p>WSLg 为那些既需要在 PC 上运行 Windows，又需要使用在 Linux 环境中表现最佳或专门为 Linux 开发的工具或应用程序的开发人员、科学家和爱好者，提供了无缝的集成体验。目前，用户可以通过多系统设置来实现这一点，比如在一台 PC 上同时安装 Windows 和 Linux、使用虚拟机托管 Windows 或 Linux，或者在 Windows 上运行并通过 XServer 投射到 WSL。然而，WSLg 提供了一种更为集成、用户友好且高效的替代方案。</p>
<p>WSLg 的目标是让 Linux GUI 应用程序在 Windows 上的使用体验像本地应用程序一样自然。从在“开始”菜单中的集成启动，到任务栏中的显示，再到通过 alt-tab 在 Windows 和 Linux 应用程序之间切换，以及跨系统的剪切&#x2F;粘贴功能，WSLg 实现了 Windows 和 Linux 应用程序之间无缝的桌面体验和工作流程。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>SSH服务</title>
    <url>/2024/08/27/0-%E5%B9%B3%E5%8F%B0-Windows-SSH%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="SSH-服务端"><a href="#SSH-服务端" class="headerlink" title="SSH 服务端"></a>SSH 服务端</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 Windows 中配置 SSH 服务端的步骤如下（根据 win 版本不一致可能位置不同）：</p>
<ol>
<li>打开“设置”。</li>
<li>选择“系统”。。</li>
<li>选择“可选功能”。</li>
<li>点击“添加功能”，然后搜索并安装“OpenSSH 服务器”和“OpenSSH 客户端”。</li>
</ol>
<h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>如果无法添加，这里提供下手动安装的方式</p>
<ul>
<li>下载 OpenSSH <a href="https://github.com/PowerShell/Win32-OpenSSH/releases">https://github.com/PowerShell/Win32-OpenSSH/releases</a></li>
<li>解压缩 OpenSSH-Win64.zip，以管理员权限打开 cmd，执行</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1</span><br></pre></td></tr></table></figure>

<ul>
<li>启动 SSH 服务</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sc config sshd start= <span class="keyword">auto</span>    #设置SSH服务自动启动</span><br><span class="line">net start sshd        #开启SSH服务</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在命令提示符（cmd）中输入以下命令以验证 SSH 客户端是否已正确安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh localhost</span><br></pre></td></tr></table></figure>

<h3 id="启动-SSH-服务"><a href="#启动-SSH-服务" class="headerlink" title="启动 SSH 服务"></a>启动 SSH 服务</h3><p>要启动 SSH 服务，请在命令提示符中运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net start sshd</span><br></pre></td></tr></table></figure>

<h3 id="停止-SSH-服务"><a href="#停止-SSH-服务" class="headerlink" title="停止 SSH 服务"></a>停止 SSH 服务</h3><p>要停止 SSH 服务，请在命令提示符中运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net stop sshd</span><br></pre></td></tr></table></figure>

<h2 id="SSH-客户端"><a href="#SSH-客户端" class="headerlink" title="SSH 客户端"></a>SSH 客户端</h2><p>Windows 10 和更高版本自带 SSH 客户端，您可以在命令提示符中使用以下命令进行连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 用户名@用户ip</span><br></pre></td></tr></table></figure>

<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="SSH-服务端-1"><a href="#SSH-服务端-1" class="headerlink" title="SSH 服务端"></a>SSH 服务端</h2><p>在 Linux 中安装和配置 SSH 服务端的步骤如下：</p>
<ol>
<li><p>更新软件包列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 OpenSSH 服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 SSH 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start ssh</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 SSH 服务开机自启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> ssh</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="SSH-客户端-1"><a href="#SSH-客户端-1" class="headerlink" title="SSH 客户端"></a>SSH 客户端</h2><p>在 Linux 中使用 SSH 客户端连接到远程主机的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 用户名@用户ip</span><br></pre></td></tr></table></figure>

<p>例如，连接到本地机器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh username@127.0.0.1</span><br></pre></td></tr></table></figure>

<h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>使用 <code>scp</code> 命令从 Linux 拷贝文件到 Windows：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /linux/folder/copyfilename Winusername@Winip:/c:/user/username/Desktop</span><br></pre></td></tr></table></figure>

<h3 id="免密码连接"><a href="#免密码连接" class="headerlink" title="免密码连接"></a>免密码连接</h3><p>要实现免密码连接，您可以使用 <code>sshpass</code> 工具。首先安装 <code>sshpass</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install sshpass</span><br></pre></td></tr></table></figure>

<p>然后使用以下命令进行免密码拷贝：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sshpass -p <span class="string">&quot;passwd&quot;</span> scp /linux/folder/copyfilename Winusername@Winip:/c:/user/username/Desktop</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，您可以在 Windows 和 Linux 系统上成功配置和使用 SSH 服务。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>关于U盘被占用无法弹出</title>
    <url>/2024/07/22/0-%E5%B9%B3%E5%8F%B0-Windows-%E5%85%B3%E4%BA%8EU%E7%9B%98%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA/</url>
    <content><![CDATA[<p>Win+R 打开【运行】–&gt;输入 eventvwr.msc 回车打开【事件查看器】–&gt;事件查看器(本地)–&gt;Windows 日志–&gt;系统–&gt;找到最近的【警告 来源 Kernel-PnP】–&gt;双击打开–&gt;你会看到【进程 ID 为 **** 的应用程序已停止删除或弹出设备】，记住这个进程 ID。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>重装系统无法识别硬盘</title>
    <url>/2024/07/18/0-%E5%B9%B3%E5%8F%B0-Windows-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[<p>Win11 重新安装系统时，由于缺少 RST 驱动，导致进入 PE 后无法识别到硬盘，需要安装该驱动，搜索 <code>intel_rst_technology</code> 并下载，</p>
<p><a href="https://global-download.acer.com/GDFiles/Driver/IRST/IRST_Intel_19.2.0.1003_W11x64_A.zip?acerid=637907037961464459&Step1=&Step2=&Step3=SF314-71&OS=ALL&LC=en&BC=ACER&SC=PA_6">https://global-download.acer.com/GDFiles/Driver/IRST/IRST_Intel_19.2.0.1003_W11x64_A.zip?acerid=637907037961464459&amp;Step1=&amp;Step2=&amp;Step3=SF314-71&amp;OS=ALL&amp;LC=en&amp;BC=ACER&amp;SC=PA_6</a> </p>
<p>之后在重装系统时选择 load driver 加载该驱动即可识别硬盘</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>3566与3568与3588之间的差异</title>
    <url>/2024/08/15/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-3566%E4%B8%8E3568%E4%B8%8E3588%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<h1 id="接口差异"><a href="#接口差异" class="headerlink" title="接口差异"></a>接口差异</h1><ul>
<li>外部存储接口:<br>  RK3568 支持 ECC 内存<br>  RK3566 不支持 ECC 内存</li>
<li>PCI-E 接口:<br>  RK3568 支持 PCI-E 3.0<br>  RK3566 仅支持 PCI-E 2.1</li>
<li>以太网接口:<br>  RK3568 配备双千兆网口<br>  RK3566 只有单千兆网口</li>
<li>SATA 接口:<br>  RK3568 支持 3 个 SATA 3.0 接口<br>  RK3566 仅支持 1 个 SATA 3.0 接口</li>
<li>显示输出:<br>  RK3568 支持三重显示<br>  RK3566 支持双显示</li>
</ul>
<h1 id="技术参数差异表："><a href="#技术参数差异表：" class="headerlink" title="技术参数差异表："></a>技术参数差异表：</h1><table>
<thead>
<tr>
<th align="center">Processor</th>
<th align="center">Rockchip RK3568</th>
<th align="center">Rockchip RK3566</th>
<th align="center">Rockchip RK3588</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Market (main)</td>
<td align="center">Single-board computer</td>
<td align="center">Single-board computer</td>
<td align="center">High-performance single-board computer</td>
</tr>
<tr>
<td align="center">ISA</td>
<td align="center">ARMv8.2-A (64-bit)</td>
<td align="center">ARMv8.2-A (64-bit)</td>
<td align="center">ARMv8.2-A (64-bit)</td>
</tr>
<tr>
<td align="center">Microarchitecture</td>
<td align="center">Cortex-A55</td>
<td align="center">Cortex-A55</td>
<td align="center">Cortex-A76 + Cortex-A55</td>
</tr>
<tr>
<td align="center">Family</td>
<td align="center">RK3500</td>
<td align="center">RK3500</td>
<td align="center">RK3500</td>
</tr>
<tr>
<td align="center">Part number(s), S-Spec</td>
<td align="center">RK3568</td>
<td align="center">RK3566</td>
<td align="center">RK3588</td>
</tr>
<tr>
<td align="center">Release date</td>
<td align="center">Q2 2020</td>
<td align="center">Q2 2020</td>
<td align="center">Q1 2022</td>
</tr>
<tr>
<td align="center">Lithography</td>
<td align="center">22 nm</td>
<td align="center">22 nm</td>
<td align="center">8 nm</td>
</tr>
<tr>
<td align="center">Cores</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">8 (4+4)</td>
</tr>
<tr>
<td align="center">Threads</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">Base frequency</td>
<td align="center">2.0 GHz</td>
<td align="center">1.8 GHz</td>
<td align="center">2.4 GHz (A76), 1.8 GHz (A55)</td>
</tr>
<tr>
<td align="center">Turbo frequency</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">High performance cores</td>
<td align="center">4x ARM Cortex-A55 @ 2.0 GHz</td>
<td align="center">4x ARM Cortex-A55 @ 1.8 GHz</td>
<td align="center">4x Cortex-A76 @ 2.4 GHz</td>
</tr>
<tr>
<td align="center">Cache memory</td>
<td align="center">256 KB</td>
<td align="center">256 KB</td>
<td align="center">1 MB L3</td>
</tr>
<tr>
<td align="center">Max memory capacity</td>
<td align="center">8 GB</td>
<td align="center">4 GB</td>
<td align="center">32 GB</td>
</tr>
<tr>
<td align="center">Memory types</td>
<td align="center">LPDDR4-1600</td>
<td align="center">DDR3, DDR3L, LPDDR3, DDR4, LPDDR4X</td>
<td align="center">LPDDR4X-3200, LPDDR5-2400</td>
</tr>
<tr>
<td align="center">Max PCIe lanes</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">TDP</td>
<td align="center">5 W</td>
<td align="center">5 W</td>
<td align="center">10-15 W</td>
</tr>
<tr>
<td align="center">GPU integrated graphics</td>
<td align="center">ARM Mali-G52 2EE MC2</td>
<td align="center">ARM Mali-G52 MP2</td>
<td align="center">ARM Mali-G610 MP4</td>
</tr>
<tr>
<td align="center">GPU execution units</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">GPU shading units</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">GPU base clock</td>
<td align="center">-</td>
<td align="center">850 MHz</td>
<td align="center">1000 MHz</td>
</tr>
<tr>
<td align="center">GPU boost clock</td>
<td align="center">820 MHz</td>
<td align="center">950 MHz</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">GPU FP32 floating point</td>
<td align="center">54.4 GFLOPS</td>
<td align="center">54.4 GFLOPS</td>
<td align="center">614 GFLOPS</td>
</tr>
<tr>
<td align="center">Socket</td>
<td align="center">SoC</td>
<td align="center">SoC</td>
<td align="center">SoC</td>
</tr>
<tr>
<td align="center">Drystone MIPS</td>
<td align="center">22,736 DMIPS</td>
<td align="center">20,462 DMIPS</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">AI accelerator</td>
<td align="center">AI accelerator RKNN NPU</td>
<td align="center">-</td>
<td align="center">NPU</td>
</tr>
<tr>
<td align="center">AI computing operations per seconds</td>
<td align="center">0.8 TOPS</td>
<td align="center">-</td>
<td align="center">6 TOPS</td>
</tr>
<tr>
<td align="center">Crypto engine</td>
<td align="center">Cipher Engine, SHA-1, SHA-256&#x2F;224,SHA-512&#x2F;384, MD5, AES-128, AES-192,AES-256, DES, TDES, TRNG</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">Max display resolution</td>
<td align="center">4K@60fps</td>
<td align="center">-</td>
<td align="center">8K@60fps</td>
</tr>
<tr>
<td align="center">Video decoding</td>
<td align="center">H.265&#x2F;H.264&#x2F;VP9 4K@60fps</td>
<td align="center">-</td>
<td align="center">8K@60fps H.265&#x2F;VP9&#x2F;AVS2, 8K@30fps H.264 AVC&#x2F;MVC</td>
</tr>
<tr>
<td align="center">Video encoding</td>
<td align="center">H.265&#x2F;H.264 1080p@60fps</td>
<td align="center">-</td>
<td align="center">8K@30fps H.265&#x2F;H.264</td>
</tr>
<tr>
<td align="center">Max video capture</td>
<td align="center">MIPI-CSI</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">Modem</td>
<td align="center">Gigabit Ethernet</td>
<td align="center">-</td>
<td align="center">2.5 GbE</td>
</tr>
<tr>
<td align="center">Connectivity</td>
<td align="center">SATA 3.0, eMMC, HDMI 2.0,USB 3.0, USB 2.0</td>
<td align="center">-</td>
<td align="center">PCIe 3.0, USB 3.1, HDMI 2.1</td>
</tr>
<tr>
<td align="center">Wi-Fi</td>
<td align="center">WiFi 6 (802.11ax)</td>
<td align="center">-</td>
<td align="center">Wi-Fi 6 (802.11ax)</td>
</tr>
<tr>
<td align="center">Bluetooth</td>
<td align="center">Bluetooth 5.0</td>
<td align="center">-</td>
<td align="center">Bluetooth 5.2</td>
</tr>
<tr>
<td align="center">Audio</td>
<td align="center">SPDIF, PWM, SPI, I2S, I2C</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">(Android 64-bit)Geekbench 4 single core</td>
<td align="center">875</td>
<td align="center">756</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">(Android 64-bit)Geekbench 4 multi-core</td>
<td align="center">2,375</td>
<td align="center">1,997</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">(Android)Geekbench 5 single core</td>
<td align="center">161</td>
<td align="center">108</td>
<td align="center">~800</td>
</tr>
<tr>
<td align="center">(Android)Geekbench 5 multi-core</td>
<td align="center">492</td>
<td align="center">281</td>
<td align="center">~2800</td>
</tr>
<tr>
<td align="center">(SGEMM)GFLOPS performance</td>
<td align="center">21.2 GFLOPS</td>
<td align="center">18.2 GFLOPS</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">(Multi-core &#x2F; watt performance)Performance &#x2F; watt ratio</td>
<td align="center">475 pts &#x2F; W</td>
<td align="center">399 pts &#x2F; W</td>
<td align="center">-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>3568GPU负载查看及参数设置</title>
    <url>/2024/08/15/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-3568GPU%E8%B4%9F%E8%BD%BD%E6%9F%A5%E7%9C%8B%E5%8F%8A%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>1.Look up the load@frequency of GPU 查看当前负载和频率</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/devfreq/*.gpu/load</span><br></pre></td></tr></table></figure>

<p>2.Look up the supported mode or supported frquency for GPU 查看当前支持的模式和频率</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/devfreq/*.gpu/available_governors</span><br><span class="line"><span class="built_in">cat</span> /sys/class/devfreq/*.gpu/available_frequencies</span><br></pre></td></tr></table></figure>

<p>3.Set performance(the most high frequency) for GPU 设置性能模式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> performance &gt; /sys/class/devfreq/*.gpu/governor</span><br></pre></td></tr></table></figure>

<p>4.Set frequency for GPU 设置频率</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置模式为用户模式</span></span><br><span class="line"><span class="built_in">echo</span> userspace &gt; /sys/class/devfreq/*.gpu/governor</span><br><span class="line"><span class="comment">#打印当前支持的频率</span></span><br><span class="line"><span class="built_in">cat</span> /sys/class/devfreq/*.gpu/available_frequencies</span><br><span class="line"><span class="comment">#将要设置的频率写入(ps: you should do step 2 to ensure the available_frequencies before you set)  </span></span><br><span class="line"><span class="built_in">echo</span> 800000000 &gt; /sys/class/devfreq/*.gpu/set_freq</span><br></pre></td></tr></table></figure>

<p>5.Get a version 获取版本信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">strings libMali.so | grep rk_so_ver</span><br></pre></td></tr></table></figure>

<p>6.Set power always on 关闭节能模式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> always_on &gt; /sys/devices/*.gpu/power_policy</span><br></pre></td></tr></table></figure>

<p>循环打印 GPU 负载脚本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ 1 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">cat</span> /sys/class/devfreq/fde60000.gpu/load</span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>OK3568的文件系统裁剪</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-OK3568%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%A3%81%E5%89%AA/</url>
    <content><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h1><p>现阶段在工作过程中使用的是飞凌嵌入式的 OK3568 开发板，需要对文件系统进行针对性裁剪，缩减文件系统大小，现裁剪前官方文件系统大小为 1.28GB，裁剪后文件系统大小为 0.7GB</p>
<h1 id="1-脚本分析"><a href="#1-脚本分析" class="headerlink" title="1. 脚本分析"></a>1. 脚本分析</h1><p>在官方提供的开发包中，所有的编译过程都是由根目录下的 <code>build.sh</code> 控制的，跟踪该脚本发现编译文件系统的步骤如下：</p>
<ul>
<li>执行 <code>build.sh rootfs</code> 通过 buildroot 方式编译文件系统</li>
<li>执行时，脚本调用其中的 <code>build_rootfs</code> 方法</li>
<li><code>build_rootfs</code> 方法通过命令行输入参数判断当时用的 <code>yocto</code> 或 <code>debian</code> 或 <code>distro</code> 或 <code>buildroot</code> 的方式编译文件系统，当前我们选择的是 <code>buildroot</code></li>
<li>调用 <code>build_buildroot</code> 方法，执行 <code>device/rockchip/common</code> 中的 <code>mk-buildroot.sh</code> 脚本</li>
<li>在 <code>mk-buildroot.sh</code> 脚本中调用 <code>buildroot/build/envsetup.sh</code>，<code>envsetup.sh</code> 用于初始化环境变量并设置 <code>buildroot/configs/OK3568_defconfig</code> 为 <code>buildroot</code> 编译文件系统的默认配置文件</li>
<li>读取 <code>buildroot/configs/OK3568_defconfig</code> 中的配置，并覆盖正在使用的配置文件，正在使用的配置文件位于 <code>buildroot/.config</code>，通过 <code>buildroot/.config</code> 配置文件系统</li>
</ul>
<blockquote>
<p><strong>编译选项对文件系统大小的影响：</strong></p>
<p>例.取消 <code>BR2_PACKAGE_TENSORFLOW</code> 选项不一定会使文件系统镜像大小变小，原因如下：</p>
<ul>
<li>取消该选项只会影响到构建时是否编译 <code>TensorFlow</code> 软件包，对已经安装的软件包不会产生影响，因此对文件系统镜像大小的影响是有限的</li>
<li><code>TensorFlow</code> 软件包可能并不占用很大的空间，因此取消该选项对文件系统镜像大小的影响也比较有限</li>
</ul>
<p>因此，取消某一编译选项并不是一个有效的方法来减小文件系统镜像大小，可以考虑通过</p>
<ul>
<li>删除不必要的文件</li>
<li>调整压缩参数</li>
</ul>
</blockquote>
<h1 id="2-裁剪"><a href="#2-裁剪" class="headerlink" title="2.裁剪"></a>2.裁剪</h1><h2 id="2-1-配置文件"><a href="#2-1-配置文件" class="headerlink" title="2.1 配置文件"></a>2.1 配置文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;audio.config&quot;</span> 	#音频相关的配置信息，例如采样率、声道数、编码格式等（已删）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;audio_gst.config&quot;</span>	#（已删）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base.config&quot;</span> 		#系统基本配置，例如时钟频率、内存分配、启动选项等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base_extra.config&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;benchmark.config&quot;</span> #性能测试相关的配置信息，例如测试用例、测试参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bt.config&quot;</span> 		#蓝牙相关的配置信息，例如蓝牙协议栈选项、蓝牙设备信息（禁删）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.config&quot;</span> 	#相机相关的配置信息，例如分辨率、曝光时间、帧率（已删）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera_gst.config&quot;</span>	#（已删）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.config&quot;</span> 	#调试相关的配置信息，例如日志级别、调试选项等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug2.config&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;display.config&quot;</span> #显示相关的配置信息，例如分辨率、屏幕旋转、色彩空间等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpu.config&quot;</span> GPU #相关的配置信息，例如 GPU 频率、GPU缓存选项等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network.config&quot;</span> #网络相关的配置信息，例如 IP 地址、子网掩码、网络协议等；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ntfs.config&quot;</span> NTFS #文件系统相关的配置信息，例如文件系统选项、磁盘分区信息等；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qt.config&quot;</span> #QT 库相关的配置信息，例如 QT 版本、QT编译选项等；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;video_mpp.config&quot;</span> #视频相关的配置信息，例如编码格式、分辨率、帧率等；（已删）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;video_gst.config&quot;</span> （已删）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;video_gst_rtsp.config&quot;</span> #RTSP 协议相关的配置信息，例如 RTSP服务器地址、端口号等；（已删）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rk356x_arm64.config&quot;</span> #开发板的硬件配置信息，例如 CPU 架构、内存大小、外设选项等；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.config&quot;</span> #测试相关的配置信息，例如测试用例、测试参数等。</span></span><br><span class="line"></span><br><span class="line">BR2_PACKAGE_RECOVERY=y	##启用Recovery软件包，用于在系统损坏或无法启动时恢复系统</span><br><span class="line">BR2_PACKAGE_RECOVERY_BOOTCONTROL=y	#启用RecoveryBootControl软件包，用于控制系统启动时是否进入Recovery模式</span><br><span class="line">BR2_PACKAGE_RECOVERY_RETRY=y	#启用RecoveryRetry软件包，用于在Recovery模式下重试更新操作</span><br><span class="line">BR2_PACKAGE_RECOVERY_USE_UPDATEENGINE=y	#启用UpdateEngine软件包，用于在Recovery模式下进行系统更新</span><br><span class="line">BR2_PACKAGE_RECOVERY_UPDATEENGINEBIN=y	#启用UpdateEngineBinary软件包，用于在Recovery模式下执行系统更新</span><br><span class="line">BR2_PACKAGE_RECOVERY_NO_UI=y	#启用NoUIRecovery软件包，用于在Recovery模式下禁用UI界面</span><br><span class="line">BR2_TARGET_ENABLE_ROOT_LOGIN=y	#启用root用户登录</span><br><span class="line">BR2_TARGET_GENERIC_ROOT_PASSWD=<span class="string">&quot;ubuntu&quot;</span>	#设置root用户的密码为<span class="string">&quot;ubuntu&quot;</span></span><br><span class="line">BR2_TARGET_GENERIC_GETTY_BAUDRATE_115200=y	#设置终端波特率为<span class="number">115200</span></span><br><span class="line">BR2_TARGET_LOCALTIME=<span class="string">&quot;Asia/Shanghai&quot;</span>	#设置系统时区为亚洲/上海</span><br><span class="line">BR2_ROOTFS_OVERLAY=<span class="string">&quot;board/rockchip/ok3568/fs-overlay/&quot;</span>	#设置根文件系统的覆盖目录</span><br><span class="line">BR2_PACKAGE_TENSORFLOW=y	#启用TensorFlow软件包（已删）</span><br><span class="line">BR2_PACKAGE_RKNPU2=y	#启用RKNPU2软件包，用于支持Rockchip芯片的神经网络加速（已删）</span><br><span class="line">BR2_PACKAGE_RKAIQ_TOOL_SERVER=y	#启用RKAIQToolServer软件包，用于支持Rockchip芯片的图像处理（已删）</span><br><span class="line">BR2_PACKAGE_FORLINX=y	#启用Forlinx软件包</span><br><span class="line">BR2_PACKAGE_MATRIX_BROWSER=y	#启用MatrixBrowser软件包，用于支持矩阵式键盘（已删）</span><br><span class="line">BR2_PACKAGE_DWKEYBOARD=y	#启用DWKeyboard软件包，用于支持多语言输入法（已删）</span><br><span class="line">BR2_PACKAGE_QUECTELCM=y	#启用QuectelCM软件包，用于支持Quectel无线模块（已删）</span><br><span class="line">BR2_PACKAGE_FORLINX_QT=y	#启用ForlinxQt软件包</span><br><span class="line">BR2_PACKAGE_FORLINX_CMD=y	#启用ForlinxCMD软件包</span><br><span class="line">BR2_PACKAGE_FFMPEG_AVRESAMPLE=y	#启用FFmpegAvresample软件包，用于音频重采样（已删）</span><br><span class="line">BR2_PACKAGE_FFMPEG_SWSCALE=y	#启用FFmpegSwscale软件包，用于视频缩放（已删）</span><br><span class="line">BR2_PACKAGE_HICOLOR_ICON_THEME=y	#启用HicolorIconTheme软件包，用于支持高分辨率图标（已删）</span><br><span class="line">BR2_PACKAGE_QT5BASE_SQLITE_QT=y	#启用Qt5BaseSQLiteQt软件包，用于支持SQLite数据库（已删）</span><br><span class="line">BR2_PACKAGE_QT5BASE_GIF=y	#启用Qt5BaseGIF软件包，用于支持GIF图像格式（已删）</span><br><span class="line">BR2_PACKAGE_QT5CHARTS=y	#启用Qt5Charts软件包，用于支持图表和统计数据的可视化（已删）</span><br><span class="line">BR2_PACKAGE_QT5SERIALBUS=y	#启用Qt5SerialBus软件包，用于支持串行总线通信</span><br><span class="line">BR2_PACKAGE_QT5WEBKIT=y	#启用Qt5WebKit软件包，用于支持Web浏览器（已删）</span><br><span class="line">BR2_PACKAGE_QT5WEBENGINE=y	#启用Qt5WebEngine软件包，用于支持Web浏览器引擎（已删）</span><br><span class="line">BR2_PACKAGE_UBOOT_TOOLS=y	#启用U-Boot工具软件包，用于支持U-Boot引导程序</span><br><span class="line">BR2_PACKAGE_PHP=y	#启用PHP软件包，用于支持服务器端脚本语言（已删）</span><br><span class="line">BR2_PACKAGE_PHP_SAPI_CGI=y	#启用PHPSAPICGI软件包，用于支持使用CGI接口运行PHP脚本（已删）</span><br><span class="line">BR2_PACKAGE_PHP_SAPI_CLI=y	#启用PHPSAPICLI软件包，用于支持使用命令行接口运行PHP脚本（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_FILEINFO=y	#启用PHPFileinfo扩展软件包，用于支持文件类型检测（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_OPCACHE=y	#启用PHPOpcache扩展软件包，用于提高PHP脚本的执行效率（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_READLINE=y	#启用PHPReadline扩展软件包，用于支持命令行编辑（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_ICONV=y	#启用PHPIconv扩展软件包，用于支持字符集转换（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_MBSTRING=y	#启用PHPMbstring扩展软件包，用于支持多字节字符集（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_JSON=y	#启用PHPJSON扩展软件包，用于支持dJSON数据格式</span><br><span class="line">BR2_PACKAGE_PHP_EXT_TOKENIZER=y	#启用PHPTokenizer扩展软件包，用于支持PHP代码解析（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_CURL=y	#启用PHPcURL扩展软件包，用于支持HTTP请求（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_FTP=y	#启用PHPFTP扩展软件包，用于支持FTP协议（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_SOAP=y	#启用PHPSOAP扩展软件包，用于支持SOAP协议（已删）</span><br><span class="line">BR2_PACKAGE_PHP_EXT_XMLRPC=y	#启用PHPXML-RPC扩展软件包，用于支持XML-RPC协议（已删）</span><br><span class="line">BR2_PACKAGE_TINYALSA=y	#启用TinyALSA软件包，用于支持音频功能（已删）</span><br><span class="line">BR2_PACKAGE_LZO=y	#启用LZO压缩软件包，用于支持数据压缩</span><br><span class="line">BR2_PACKAGE_LIBGTK3=y	#启用GTK3库软件包，用于支持图形用户界面</span><br><span class="line">BR2_PACKAGE_OPENCV3=y	#启用OpenCV3软件包，用于支持计算机视觉（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_LIB_HIGHGUI=y	#编译OpenCV3中的HighGUI库（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_WITH_GTK3=y	#启用GTK3支持（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_LIB_PHOTO=y	#Photo库（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_LIB_SHAPE=y	#Shape库（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_LIB_STITCHING=y	#Stitching库（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_WITH_JASPER=y	#启用Jasper支持（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_WITH_JPEG=y	#启用JPEG支持（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_WITH_PNG=y	#启用PNG支持（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_WITH_PROTOBUF=y	#启用ProtocolBuffers支持。（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_WITH_TIFF=y	#启用TIFF支持（已删）</span><br><span class="line">BR2_PACKAGE_OPENCV3_WITH_V4L=y	#启用Video4Linux支持。（已删）</span><br><span class="line">BR2_PACKAGE_IPROUTE2=y	#选中iproute2软件包进行编译</span><br><span class="line">BR2_PACKAGE_IPTABLES=y	#选中iptables软件包进行编译</span><br><span class="line">BR2_PACKAGE_IPTABLES_BPF_NFSYNPROXY=y	#编译iptables时启用BPF和nf_synproxy支持</span><br><span class="line">BR2_PACKAGE_IPTABLES_NFTABLES=y	#编译iptables时启用nftables支持</span><br><span class="line">BR2_PACKAGE_LIGHTTPD=y	#选中lighttpd软件包进行编译（已删）</span><br><span class="line">BR2_PACKAGE_LIGHTTPD_PCRE=y	#编译lighttpd时启用PCRE支持（已删）</span><br><span class="line">BR2_PACKAGE_OPENSSH=y	#选中OpenSSH软件包进行编译</span><br><span class="line">BR2_PACKAGE_VSFTPD=y	#选中vsftpd软件包进行编译</span><br><span class="line">BR2_PACKAGE_RKWIFIBT=n	#不选中rkwifibt软件包进行编译</span><br><span class="line">BR2_PACKAGE_USBMOUNT=n	#不选中usbmount软件包进行编译</span><br><span class="line">BR2_PACKAGE_OPENCV3_LIB_PYTHON=y	#编译OpenCV3中的Python库（已删）</span><br><span class="line">BR2_PACKAGE_LIBGTK3_BROADWAY=y	#编译libgtk3时启用Broadway支持</span><br><span class="line">BR2_PACKAGE_LIBGTK3_WAYLAND=y	#编译libgtk3时启用Wayland支持</span><br><span class="line">BR2_PACKAGE_OPENCV3_GUI_NONE=n	#编译OpenCV3时启用GUI支持</span><br><span class="line">BR2_PACKAGE_QT5SERIALPORT=y	#选中Qt5中的SerialPort模块进行编译</span><br></pre></td></tr></table></figure>

<h2 id="2-2-软件包"><a href="#2-2-软件包" class="headerlink" title="2.2 软件包"></a>2.2 软件包</h2><p>Buildroot 的软件包配置文件位于 <code>~/buildroot/package/rockchip/Config.in</code>，包含了多个软件包的配置，可以在基于 Rockchip 硬件的嵌入式系统上进行构建和安装。这些软件包并不是全部必须的，具体需要哪些软件包取决于嵌入式系统的具体需求和配置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ROS	机器人操作系统，提供了一种构建机器人应用的框架，包括硬件抽象、设备驱动、库、可视化工具、消息传递和软件包管理等功能	</span><br><span class="line">LocalPlayer	一个本地播放器，可以播放本地音频和视频文件	</span><br><span class="line">APL核心库	Alexa Presentation Language（APL）的核心库，提供了一个用于构建Alexa智能屏幕体验的框架	</span><br><span class="line">AVS设备SDK	Alexa Voice Service（AVS）设备SDK，提供了一个用于构建Alexa智能设备的框架，包括语音识别、语音合成、音频处理、设备控制等功能	</span><br><span class="line">Alexa智能屏幕SDK	构建Alexa智能屏幕应用的SDK，包括模板、组件、样式、事件等功能	</span><br><span class="line">ACS	Alexa客户端服务，提供了一个用于构建Alexa客户端应用的框架，包括设备授权、用户认证、设备状态管理等功能	</span><br><span class="line">Alexa客户端SDK	用于构建Alexa客户端应用的SDK，包括语音识别、语音合成、设备控制等功能	</span><br><span class="line">MPP	Media Processing Platform，提供了一个用于嵌入式系统中音视频处理的框架，包括编解码、滤镜、音频处理等功能	d</span><br><span class="line">地址检查器	提供了一种检查程序中地址错误的工具，帮助开发人员在程序开发过程中发现和纠正地址错误	</span><br><span class="line">GStreamer1 Rockchip	基于GStreamer1的Rockchip硬件加速插件，提供了硬件加速的音视频编解码和渲染功能	d</span><br><span class="line">相机引擎CIFISP	用于Rockchip芯片的ISP引擎，提供了图像处理、白平衡、自动曝光、自动对焦等功能	d</span><br><span class="line">WakeWordAgent	唤醒词引擎，提供了唤醒词检测和响应的功能	d</span><br><span class="line">PCBA	PCB组装和测试工具，用于测试和组装PCB板	d</span><br><span class="line">SoftAP	软件接入点，提供了一个基于软件的Wi-Fi接入点，可以让其他设备连接到嵌入式系统的Wi-Fi网络	d</span><br><span class="line">SoftAP服务器	提供了一个Web服务器，可以通过Web界面配置和管理SoftAP	d</span><br><span class="line">WifiautoSetup		d</span><br><span class="line">GStreamer1 IEP	基于GStreamer1的IEP插件，提供了硬件加速的视频编解码和渲染功能	d</span><br><span class="line">rkwifibt		d</span><br><span class="line">Rockchip实用工具	提供了一些用于Rockchip硬件的实用工具，包括升级工具、调试工具、驱动程序等	</span><br><span class="line">mdev挂载	提供了一种自动挂载U盘、SD卡等外部存储设备的工具	</span><br><span class="line">ALSA捕获	提供了一个用于ALSA音频捕获的应用程序，可以从音频设备中捕获音频数据	d</span><br><span class="line">UVC应用程序	提供了一个用于UVC摄像头的应用程序，可以捕获视频数据并进行处理	d</span><br><span class="line">UAC应用程序	提供了一个用于USB音频类设备的应用程序	d</span><br><span class="line">libmali	Arm Mali GPU的用户空间驱动程序	</span><br><span class="line">libhdmiset	提供了一个用于HDMI设置的库	d</span><br><span class="line">dialserver	提供了一个用于远程管理设备的服务器	</span><br><span class="line">linux-rga	Rockchip Graphics Accelerator（RGA）的Linux内核驱动程序	</span><br><span class="line">linux-serial-test	提供了一个用于Linux串口测试的应用程序	d</span><br><span class="line">iflytekSDK	提供了一个用于讯飞语音识别的SDK	d</span><br><span class="line">eq_drc_process	提供了一个用于音频均衡和动态范围控制的库	d</span><br><span class="line">alsa_ladspa	提供了一个用于ALSA音频的LADSPA插件库	d</span><br><span class="line">rockchip_test	提供了一些用于Rockchip硬件测试的工具	</span><br><span class="line">QStressTest	提供了一个用于系统压力测试的工具	</span><br><span class="line">rockchip_modules	提供了一些用于Rockchip硬件的内核模块	</span><br><span class="line">broadcom_bsa	Broadcom蓝牙栈的用户空间库	</span><br><span class="line">cypress_bsa	Cypress蓝牙栈的用户空间库	</span><br><span class="line">pm-suspend-api	提供了一个用于系统挂起和恢复的API	</span><br><span class="line">rtw_simple_config	提供了一个用于Realtek Wi-Fi芯片的简单配置工具	d</span><br><span class="line">recovery	提供了一个用于恢复系统的工具	</span><br><span class="line">modeset	提供了一个用于显示模式设置的工具	</span><br><span class="line">rkjpeg	提供了一个用于Rockchip JPEG编解码的库	d</span><br><span class="line">jpegdemo	提供了一个用于JPEG编解码的演示程序	d</span><br><span class="line">ueventd	提供了一个用于处理Linux系统事件的守护进程	</span><br><span class="line">rkupdate	提供了一个用于Rockchip系统升级的工具	</span><br><span class="line">rktoolkit	提供了一些用于Rockchip硬件的工具集	</span><br><span class="line">rkmedia	提供了一个用于Rockchip媒体处理的框架	d</span><br><span class="line">rockit	提供了一个用于音视频处理的框架	d</span><br><span class="line">rkadk	提供了一个用于Rockchip AI开发的工具集	d</span><br><span class="line">music	提供了一个用于音乐播放的应用程序	d</span><br><span class="line">video	提供了一个用于视频播放的应用程序	d</span><br><span class="line">camera		</span><br><span class="line">carmachine	提供了一个用于车载娱乐系统的应用程序	d</span><br><span class="line">gallery	提供了一个用于图库管理的应用程序	d</span><br><span class="line">QLauncher	这是一个基于 Rockchip 平台的启动器，用于启动设备上的应用程序和服务	</span><br><span class="line">QFacialGate	这是一个用于人脸识别的软件包，可以在 Rockchip 平台上实现人脸识别功能	d</span><br><span class="line">settings	这是一个提供设置和配置选项的软件包，可以帮助用户配置设备并进行各种设置	</span><br><span class="line">Qcamera		d</span><br><span class="line">qfm	这是一个文件管理器软件包，可以帮助用户管理设备上的文件和文件夹	</span><br><span class="line">qplayer		d</span><br><span class="line">Multivideoplayer		d</span><br><span class="line">Multicamera		d</span><br><span class="line">Qsetting		d</span><br><span class="line">powermanager	这是一个用于管理设备电源的软件包，可以帮助用户管理设备的电源状态和电池寿命	</span><br><span class="line">audioservice	这是一个用于管理设备音频的软件包，可以帮助用户管理设备的音频输入和输出	d</span><br><span class="line">securityAuth		</span><br><span class="line">recoverySystem	这是一个用于设备恢复和修复的软件包，可以帮助用户在设备出现问题时进行恢复和修复操作	</span><br><span class="line">Led_control_app		d</span><br><span class="line">Npu_powerctrl		d</span><br><span class="line">Npu_powerctrl_combine		d</span><br><span class="line">N4		</span><br><span class="line">Cae_vad		</span><br><span class="line">Ipc_share_memory		</span><br><span class="line">Rk_hw_vad		</span><br><span class="line">minigui	这是一个轻量级的 GUI（图形用户界面）框架，可以帮助开发人员构建简单的 GUI 应用程序	</span><br><span class="line">Minigui_demo		</span><br><span class="line">Kernel_modules		</span><br><span class="line">tensorflow		</span><br><span class="line">Rknpu</span><br><span class="line">rknpu2</span><br><span class="line">rknpu-fw</span><br><span class="line">rknn_demo	这些软件包都与瑞芯微的神经处理单元（NPU）相关，可以帮助开发人员构建和优化神经网络模型	d</span><br><span class="line">ficial_gate</span><br><span class="line">Rkfacial</span><br><span class="line">pose_body</span><br><span class="line">face_detect	这些软件包都与面部识别相关，可以帮助开发人员构建和优化面部识别模型	d</span><br><span class="line">rockx	这是一个 Rockchip 平台上的计算机视觉库，提供了各种计算机视觉算法和工具	d</span><br><span class="line">rockface	这是一个人脸识别库，可以在 Rockchip 平台上实现人脸识别功能	d</span><br><span class="line">mtp	这是一个用于在计算机和移动设备之间传输文件的协议，可以帮助用户快速地在设备之间传输文件	d</span><br><span class="line">alsa-config	这是一个用于配置 ALSA（Advanced Linux Sound Architecture）的软件包，可以帮助用户配置设备的音频输入和输出	d</span><br><span class="line">libcapsimage	这是一个用于处理图像的库，可以帮助开发人员处理和优化图像	d</span><br><span class="line">rkscript	这是一个用于运行脚本的工具，可以帮助用户在设备上运行各种脚本	</span><br><span class="line">Deviceio</span><br><span class="line">deviceio_release	这是用于设备输入输出的软件包，可以帮助开发人员编写和优化输入输出驱动程序	</span><br><span class="line">Dui	这是一个用于开发 UI（用户界面）应用程序的库，可以帮助开发人员构建和优化 UI 应用程序	</span><br><span class="line">ble_wificonfig	这是一个用于配置蓝牙和 Wi-Fi 连接的软件包，可以帮助用户配置设备的无线连接	d</span><br><span class="line">libavb、libavb_ab</span><br><span class="line">libavb_user	这些软件包都与 AVB（Android Verified Boot）相关，可以帮助用户验证设备的启动过程和系统完整性	d</span><br><span class="line">libv4l-rkmpp	这是一个用于处理视频的库，可以帮助开发人员处理和优化视频	d</span><br><span class="line">Bootcontrol</span><br><span class="line">LinuxAB	这些软件包都与启动控制相关，可以帮助用户管理设备的启动过程和控制	</span><br><span class="line">sensor-daemon	这是一个用于管理设备传感器的软件包，可以帮助用户管理设备的传感器和数据	</span><br><span class="line">rtc_demo	这是一个用于管理设备 RTC（Real-Time Clock）的软件包，可以帮助用户管理设备的时间和日期	</span><br><span class="line">rk_webui	这是一个用于开发 Web UI 应用程序的库，可以帮助开发人员构建和优化 Web UI 应用程序	d</span><br><span class="line">common_algorithm	这是一个用于处理常见算法的库，可以帮助开发人员处理和优化算法	</span><br><span class="line">ipcweb-backend</span><br><span class="line">Libgdbus</span><br><span class="line">libIPCProtocol</span><br><span class="line">librkdb	这些软件包都与进程间通信相关，可以帮助开发人员实现进程间通信和数据传输	</span><br><span class="line">Dbserver</span><br><span class="line">Netserver</span><br><span class="line">storage_manager</span><br><span class="line">Mediaserver</span><br><span class="line">aiserver	这些软件包都与设备管理和服务相关，可以帮助用户管理设备和服务	</span><br><span class="line">rk_oem	这是一个用于 OEM和定制化的软件包，可以帮助设备制造商定制和优化设备	</span><br><span class="line">rootfs_ubi_use_custom_filesystem	这是一个用于创建和管理 UBI（Unsorted Block Images）文件系统的软件包，可以帮助用户管理设备的文件系统	</span><br><span class="line">rkbar	这是一个用于管理设备底部导航栏的软件包，可以帮助用户管理设备底部导航栏	</span><br><span class="line">minilogger	这是一个用于记录日志的工具，可以帮助用户记录设备的运行日志	</span><br><span class="line">ipc-daemon</span><br><span class="line">CallFunIpc</span><br><span class="line">isp2-ipc	这些软件包都与进程间通信相关，可以帮助开发人员实现进程间通信和数据传输	</span><br><span class="line">smart_display_service	这是一个用于管理设备智能显示的软件包，可以帮助用户管理设备的显示和显示设置	</span><br><span class="line">onvif_server	这是一个用于实现 ONVIF（Open Network Video Interface Forum）协议的软件包，可以帮助用户实现网络视频监控功能	d</span><br><span class="line">eptz_demo	这是一个用于实现电子变焦和电子云台功能的软件包，可以帮助用户实现更好的视频监控功能	d</span><br><span class="line">rksl 和 sl_lock	这些软件包都与设备安全相关，可以帮助用户保护设备安全和数据隐私	</span><br><span class="line">mult_uvc_demo	这是一个用于管理多个 UVC（USB Video Class）摄像头的软件包，可以帮助用户管理多个摄像头并进行视频捕捉和处理	d</span><br><span class="line">pcba_adb_test	这是一个用于测试设备 PCBA（Printed Circuit Board Assembly）的软件包，可以帮助用户测试设备硬件和连接性	</span><br><span class="line">camera_factory_test_server	这是一个用于测试设备摄像头的软件包，可以帮助用户测试设备摄像头的性能和质量	d</span><br><span class="line">thunderboot	这是一个用于启动控制和固件更新的软件包，可以帮助用户管理设备的启动过程和固件更新	</span><br><span class="line">startup_app_ipc	这是一个用于进程间通信的软件包，可以帮助开发人员实现进程间通信和数据传输	</span><br><span class="line">rkaiq_tool_server	这是一个用于调试和优化 ISP（Image Signal Processor）的软件包，可以帮助开发人员调试和优化设备的图像处理功能	d</span><br><span class="line">rkiio	这是一个用于管理设备输入输出的软件包，可以帮助用户管理设备的输入输出	</span><br><span class="line">lvgl	这是一个用于开发 GUI 应用程序的库，可以帮助开发人员构建和优化 GUI 应用程序	</span><br><span class="line">cvr_app	这是一个用于Rockchip芯片的视频录制应用程序，可以在嵌入式系统上运行。它支持多种视频格式，包括H<span class="number">.264</span>和H<span class="number">.265</span>。该应用程序可以通过配置文件进行配置，以满足不同的录制需求。例如，可以设置录制分辨率、帧率、码率等参数	d</span><br><span class="line">rkipc	这是一个用于Rockchip芯片的IPC（Inter-Process Communication）库，用于在嵌入式系统中实现进程间通信。它提供了多种IPC机制，包括共享内存、消息队列、信号量等。该库可以用于不同的应用程序之间进行通信，例如音视频采集、编码、解码等	</span><br><span class="line">rkfsmk	这是一个用于Rockchip芯片的文件系统制作工具，用于制作嵌入式系统中的文件系统。它支持多种文件系统格式，包括ext2、ext3、ext4等。该工具可以根据配置文件生成文件系统镜像，以便在嵌入式系统中使用	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>OK4418平台</title>
    <url>/2024/08/27/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-OK4418%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h1 id="连接开发板"><a href="#连接开发板" class="headerlink" title="连接开发板"></a>连接开发板</h1><h2 id="调试串口"><a href="#调试串口" class="headerlink" title="调试串口"></a>调试串口</h2><p>通过调试串口连接开发板，调试串口为 DB9，上位机直接连接，波特率为 115200，登录名为 root</p>
<h2 id="网口"><a href="#网口" class="headerlink" title="网口"></a>网口</h2><p>通过网口连接，配置电脑的 IP 为 192.168.1.122，开发板的 IP 为 192.168.1.123，通过 ssh 连接，登录名为 root</p>
<h1 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h1><p>通过 FileZilla Client 软件下载文件到开发板上，新建连接站点，主机地址为 192.168.1.123，通过 FTP 协议，端口为 21，不加密只使用普通 FTP，用户名为 root，密码为 forlinx。</p>
<p>连接成功后，将文件拷贝到&#x2F;opt 目录下，如果目录下有相同名字的文件，最好将原文件删除后，在拷贝文件。</p>
<h1 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"><span class="keyword">export</span> PATH=/bin:/sbin:/usr/bin:/usr/sbin</span><br><span class="line"><span class="keyword">export</span> T_ROOT=/usr/local/tslib</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=/usr/local/tslib/lib:$LD_LIBRARY_PATH</span><br><span class="line"><span class="keyword">export</span> TSLIB_CONSOLEDEVICE=none</span><br><span class="line"><span class="keyword">export</span> TSLIB_FBDEVICE=/dev/fb0</span><br><span class="line"><span class="keyword">export</span> TSLIB_TSDEVICE=/dev/input/event1</span><br><span class="line"><span class="keyword">export</span> TSLIB_PLUGINDIR=$T_ROOT/lib/ts</span><br><span class="line"><span class="keyword">export</span> TSLIB_CONFFILE=$T_ROOT/etc/ts.conf</span><br><span class="line"><span class="keyword">export</span> POINTERCAL_FILE=/etc/pointercal</span><br><span class="line"><span class="keyword">export</span> TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line"><span class="keyword">export</span> QTDIR=/forlinx/qt</span><br><span class="line"><span class="keyword">export</span> QT_QPA_PLATFORM=eglfs</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH</span><br><span class="line"><span class="keyword">export</span> QT_QPA_GENERIC_PLUGINS=tslib</span><br><span class="line"><span class="keyword">export</span> QT_QPA_PLATFORM_PLUGIN_PATH=$QTDIR/plugins</span><br><span class="line"><span class="keyword">export</span> QT_QPA_EGLFS_FB=/dev/fb0</span><br><span class="line"><span class="keyword">export</span> QT_QPA_EGLFS_TSLIB=<span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> QWS_SIZE</span><br><span class="line"><span class="keyword">export</span> KEYPAD_DEV=/dev/input/event0</span><br><span class="line"><span class="keyword">export</span> QWS_KEYBOARD=<span class="string">&quot;LinuxInput:/dev/input/keyboard&quot;</span></span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=/forlinx/qt/lib/plugins/imageformats:$LD_LIBRARY_PATH</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=/usr/local/opengl_lib_inc/libs:$LD_LIBRARY_PATH</span><br><span class="line"><span class="keyword">export</span> QT_PLUGIN_PATH=/forlinx/qt/lib/plugins</span><br><span class="line"><span class="keyword">export</span> LD_PRELOAD=/lib/preloadable_libiconv.so</span><br><span class="line"><span class="meta">#export QT_QPA_EGLFS_DISABLE_INPUT=1</span></span><br><span class="line"><span class="keyword">export</span> QT_QPA_FONTDIR=$QTDIR/lib/fonts</span><br><span class="line"><span class="keyword">if</span> [ -e /dev/input/event3 ];then</span><br><span class="line">    <span class="keyword">export</span> QT_QPA_EVDEV_KEYBOARD_PARAMETERS=/dev/input/event3</span><br><span class="line">fi</span><br><span class="line"><span class="keyword">if</span> [ -e /usr/local/bluez5/var/run/dbus/pid ]</span><br><span class="line">then </span><br><span class="line">    rm /usr/local/bluez5/var/run/dbus/pid</span><br><span class="line">fi</span><br><span class="line"><span class="keyword">export</span> DBUS_SESSION_BUS_ADDRESS=unix:path=/usr/local/bluez5/var/run/dbus/system_bus_socket</span><br><span class="line">TOUCH=`cat /etc/t2m`  &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$TOUCH&quot;</span> == <span class="string">&quot;M&quot;</span> ];then</span><br><span class="line"><span class="keyword">export</span> QWS_MOUSE_PROTO=<span class="string">&quot;Tslib:/dev/input/event1 mouseman:/dev/input/mice&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">export</span> QWS_MOUSE_PROTO=<span class="string">&quot;Tslib:/dev/input/event1&quot;</span></span><br><span class="line">fi</span><br><span class="line">/opt/PCR -qws</span><br></pre></td></tr></table></figure>

<p>配置脚本文件，如上所示，将该脚本文件拷贝到&#x2F;opt 目录下，修改&#x2F;etc&#x2F;init.d&#x2F;S99app 注释掉&#x2F;forlinx&#x2F;bin&#x2F;app.sh $ACTTION &amp;，最后一行增加&#x2F;opt&#x2F;StartPCR.sh</p>
<h1 id="中文文本支持"><a href="#中文文本支持" class="headerlink" title="中文文本支持"></a>中文文本支持</h1><p>配置脚本文件，如上所示，将该脚本文件拷贝到&#x2F;opt 目录下，修改&#x2F;etc&#x2F;init.d&#x2F;S99app 注释掉&#x2F;forlinx&#x2F;bin&#x2F;app.sh $ACTTION &amp;，最后一行增加&#x2F;opt&#x2F;StartPCR.sh</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>RK3568系统移植分析</title>
    <url>/2024/07/12/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-RK3568%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>写入硬件时间 hwclock-uw.txt</p>
<p>3568 的内核配置文件路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">编译配置文件：device/rockchip/common/build.sh</span><br><span class="line">板级配置文件：device/rockchip/ok3568/BoardConfig-ok3568.mk</span><br><span class="line">buildroot 配置文件：buildroot/configs/OK3568_defconfig</span><br><span class="line">uboot 配置文件：u-boot/configs/OK3568-C_defconfig</span><br></pre></td></tr></table></figure>

<h1 id="编译配置文件"><a href="#编译配置文件" class="headerlink" title="编译配置文件"></a>编译配置文件</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="文件系统映射位置"><a href="#文件系统映射位置" class="headerlink" title="文件系统映射位置"></a>文件系统映射位置</h1><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724828423000ozqokd.png" alt="gh"></p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>Yocto</title>
    <url>/2024/08/24/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-Yocto%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="什么是-Yocto"><a href="#什么是-Yocto" class="headerlink" title="什么是 Yocto"></a>什么是 Yocto</h1><p><strong>Yocto Project</strong> 是一个开源协作项目，主要用于为嵌入式系统开发自定义的 Linux 操作系统。它提供了一整套工具和模板，使得开发者可以在多种硬件架构上构建功能齐全、轻量级且定制化的嵌入式 Linux 发行版。</p>
<p>Yocto 不仅仅是一个 Linux 发行版，它更像是一个构建系统，帮助你从源代码生成一个完整的 Linux 系统，包括内核、根文件系统、工具链和应用程序。Yocto 项目通过 <code>BitBake</code> 构建系统和 <code>OpenEmbedded</code> 核心来实现这一切。</p>
<h1 id="Yocto-的基本概念"><a href="#Yocto-的基本概念" class="headerlink" title="Yocto 的基本概念"></a>Yocto 的基本概念</h1><ol>
<li><p><strong>BitBake</strong>: Yocto 构建系统的核心工具，类似于 GNU Make，但功能更强大。它使用 <code>.bb</code>、<code>.bbclass</code> 和 <code>.conf</code> 文件定义构建任务、元数据和配置。</p>
</li>
<li><p><strong>Layer (层)</strong>: Yocto 项目中的层是一组元数据文件，用于组织和管理构建配置。常见的层包括 <code>meta</code> 层（核心）、<code>meta-oe</code>（OpenEmbedded 扩展层）和 <code>meta-raspberrypi</code>（树莓派支持层）。</p>
</li>
<li><p><strong>Recipe (配方)</strong>: 配方是 Yocto 中的基本构建单元，它定义了如何获取源代码、应用补丁、编译和安装软件包。配方文件通常以 <code>.bb</code> 结尾。</p>
</li>
<li><p><strong>Machine (机器)</strong>: Yocto 为不同硬件架构和开发板定义了 <code>machine</code> 配置，这些配置决定了目标硬件的具体构建选项。</p>
</li>
<li><p><strong>Distro (发行版)</strong>: Yocto 的发行版配置定义了一个操作系统的核心部分，包括使用的包管理器、C 库以及其他系统级配置。</p>
</li>
<li><p><strong>Image (镜像)</strong>: 镜像是通过 Yocto 构建出的最终产品，它是一个可以直接在目标硬件上运行的文件系统和内核。</p>
</li>
</ol>
<h1 id="Yocto-如何使用"><a href="#Yocto-如何使用" class="headerlink" title="Yocto 如何使用"></a>Yocto 如何使用</h1><h2 id="1-安装-Yocto-环境"><a href="#1-安装-Yocto-环境" class="headerlink" title="1. 安装 Yocto 环境"></a><strong>1. 安装 Yocto 环境</strong></h2><p>要使用 Yocto，你首先需要安装构建环境，包括一些基本的开发工具和 Git。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1.2-dev xterm</span><br></pre></td></tr></table></figure>

<h2 id="2-获取-Yocto-源代码"><a href="#2-获取-Yocto-源代码" class="headerlink" title="2. 获取 Yocto 源代码"></a><strong>2. 获取 Yocto 源代码</strong></h2><p>你需要从 GitHub 或 Yocto 官方仓库中克隆 Yocto 项目的源代码。以下是克隆一个常用的 Yocto 版本分支的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b kirkstone git://git.yoctoproject.org/poky.git</span><br><span class="line"><span class="built_in">cd</span> poky</span><br></pre></td></tr></table></figure>

<h2 id="3-初始化构建环境"><a href="#3-初始化构建环境" class="headerlink" title="3. 初始化构建环境"></a><strong>3. 初始化构建环境</strong></h2><p>在 Yocto 中，<code>oe-init-build-env</code> 脚本用于初始化构建环境，创建一个新的构建目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> oe-init-build-env</span><br></pre></td></tr></table></figure>

<p>这个命令会在当前目录下创建一个新的 <code>build</code> 目录，并将你切换到该目录中。所有的构建输出都将在这个 <code>build</code> 目录中生成。</p>
<h2 id="4-配置构建选项"><a href="#4-配置构建选项" class="headerlink" title="4. 配置构建选项"></a><strong>4. 配置构建选项</strong></h2><p>在 <code>build</code> 目录下，你可以通过编辑 <code>conf/local.conf</code> 文件来配置构建选项，例如目标机器（<code>MACHINE</code>）、并行构建线程（<code>BB_NUMBER_THREADS</code>）和 <code>DL_DIR</code>（源码下载目录）等。</p>
<p>示例配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MACHINE ?= <span class="string">&quot;qemuarm&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你要为 Raspberry Pi 构建系统，可以修改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MACHINE ?= <span class="string">&quot;raspberrypi4&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-添加层"><a href="#5-添加层" class="headerlink" title="5. 添加层"></a><strong>5. 添加层</strong></h2><p>你可以通过 <code>bitbake-layers</code> 工具来管理 Yocto 的层。例如，添加一个新的层：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitbake-layers add-layer ../meta-openembedded/meta-oe</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>meta-oe</code> 层添加到构建环境中。</p>
<h2 id="6-构建镜像"><a href="#6-构建镜像" class="headerlink" title="6. 构建镜像"></a><strong>6. 构建镜像</strong></h2><p>配置完成后，可以使用 <code>bitbake</code> 命令开始构建系统镜像。常见的构建目标包括 <code>core-image-minimal</code>、<code>core-image-sato</code> 等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitbake core-image-minimal</span><br></pre></td></tr></table></figure>

<p>构建过程可能需要一些时间，这取决于你的计算资源和网络速度。</p>
<h2 id="7-部署镜像"><a href="#7-部署镜像" class="headerlink" title="7. 部署镜像"></a><strong>7. 部署镜像</strong></h2><p>构建完成后，生成的镜像文件会存放在 <code>build/tmp/deploy/images/</code> 目录下。你可以将这些文件烧录到目标硬件中，例如 SD 卡，或直接在 QEMU 中进行模拟测试。</p>
<h1 id="Yocto-的常用工具"><a href="#Yocto-的常用工具" class="headerlink" title="Yocto 的常用工具"></a>Yocto 的常用工具</h1><ol>
<li><p><strong>BitBake</strong>: 用于执行构建任务的核心工具。你将主要使用它来编译配方并生成镜像。</p>
</li>
<li><p><strong>devtool</strong>: 一个用于开发者的工具集，简化了 Yocto 项目的扩展和修改。例如，它可以自动生成新的配方或修改现有配方。</p>
</li>
<li><p><strong>bitbake-layers</strong>: 用于管理和操作 Yocto 层的工具。它可以添加、删除或列出层。</p>
</li>
<li><p><strong>hoban</strong>: 用于查看和分析 Yocto 项目生成的二进制文件和镜像内容的工具。</p>
</li>
<li><p><strong>Toaster</strong>: Yocto 提供的一个基于 Web 的图形界面工具，帮助用户管理构建项目并分析结果。</p>
</li>
<li><p><strong>menuconfig&#x2F;nconfig</strong>: 用于配置 Linux 内核的工具，它们允许你在图形界面中选择内核选项。</p>
</li>
</ol>
<p>通过一个实例来详细说明如何在 Yocto 中添加 Mesa 的 OpenGL 驱动是一个很好的实践。这个过程将涵盖如何配置 Yocto 环境、修改配置文件、添加所需的软件包（如 Mesa 驱动），并构建包含 OpenGL 支持的 Linux 镜像。我们以一个基于 Raspberry Pi 4 的项目为例。</p>
<h1 id="实例目标"><a href="#实例目标" class="headerlink" title="实例目标"></a>实例目标</h1><p>目标是使用 Yocto 构建一个为 Raspberry Pi 4 定制的 Linux 镜像，并在内核中增加 Mesa 的 OpenGL 驱动。</p>
<h2 id="1-设置-Yocto-环境"><a href="#1-设置-Yocto-环境" class="headerlink" title="1. 设置 Yocto 环境"></a>1. 设置 Yocto 环境</h2><h1 id="1-1-克隆-Yocto-Poky-仓库"><a href="#1-1-克隆-Yocto-Poky-仓库" class="headerlink" title="1.1 克隆 Yocto Poky 仓库"></a><strong>1.1 克隆 Yocto Poky 仓库</strong></h1><p>首先，从 Yocto 的官方 Git 仓库克隆 Poky，这包含 Yocto 的核心构建工具和基础层。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b kirkstone git://git.yoctoproject.org/poky.git</span><br><span class="line"><span class="built_in">cd</span> poky</span><br></pre></td></tr></table></figure>

<h1 id="1-2-获取-Raspberry-Pi-层"><a href="#1-2-获取-Raspberry-Pi-层" class="headerlink" title="1.2 获取 Raspberry Pi 层"></a><strong>1.2 获取 Raspberry Pi 层</strong></h1><p>接下来，克隆 Raspberry Pi 支持的元数据层 <code>meta-raspberrypi</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b kirkstone git://git.yoctoproject.org/meta-raspberrypi.git</span><br></pre></td></tr></table></figure>

<h1 id="1-3-初始化构建环境"><a href="#1-3-初始化构建环境" class="headerlink" title="1.3 初始化构建环境"></a><strong>1.3 初始化构建环境</strong></h1><p>使用 Yocto 提供的脚本初始化构建环境，这将创建一个 <code>build</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> oe-init-build-env</span><br></pre></td></tr></table></figure>

<h1 id="1-4-添加层到构建环境"><a href="#1-4-添加层到构建环境" class="headerlink" title="1.4 添加层到构建环境"></a><strong>1.4 添加层到构建环境</strong></h1><p>在 <code>build</code> 目录中，通过 <code>bitbake-layers</code> 命令添加 <code>meta-raspberrypi</code> 和 <code>meta-openembedded</code>（包含 Mesa 的相关软件包）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitbake-layers add-layer ../meta-raspberrypi</span><br><span class="line">bitbake-layers add-layer ../meta-openembedded/meta-oe</span><br><span class="line">bitbake-layers add-layer ../meta-openembedded/meta-multimedia</span><br></pre></td></tr></table></figure>

<p>或者创建一个新的层，创建新层后需要在新层中创建 Mesa 配方文件(mesa_%.bbappend)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitbake-layers create-layer meta-opengl</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PACKAGECONFIG_append = <span class="string">&quot; gallium-llvm gallium egl gles gbm dri&quot;</span></span><br><span class="line">GALLIUMDRIVERS_append = <span class="string">&quot;,swrast&quot;</span></span><br><span class="line">DRIDRIVERS_append = <span class="string">&quot;,swrast&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-配置构建选项"><a href="#2-配置构建选项" class="headerlink" title="2. 配置构建选项"></a>2. 配置构建选项</h2><h1 id="2-1-配置-local-conf"><a href="#2-1-配置-local-conf" class="headerlink" title="2.1 配置 local.conf"></a><strong>2.1 配置 <code>local.conf</code></strong></h1><p>编辑 <code>conf/local.conf</code> 文件，设置目标机器为 Raspberry Pi 4，并启用 OpenGL 支持。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MACHINE ?= <span class="string">&quot;raspberrypi4&quot;</span></span><br></pre></td></tr></table></figure>

<p>确保启用 <code>GL</code> 和 <code>X11</code> 支持，以便 Mesa 的 OpenGL 驱动能够正确构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DISTRO_FEATURES_append = <span class="string">&quot; opengl x11&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果是新层则需要添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BBLAYERS += <span class="string">&quot;<span class="variable">$&#123;TOPDIR&#125;</span>/../meta-opengl&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-2-添加-Mesa-软件包"><a href="#2-2-添加-Mesa-软件包" class="headerlink" title="2.2 添加 Mesa 软件包"></a><strong>2.2 添加 Mesa 软件包</strong></h1><p>在 <code>local.conf</code> 中，添加以下行以确保 Mesa 和相关驱动程序被包含在构建中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IMAGE_INSTALL_append = <span class="string">&quot; mesa mesa-gl mesa-demos&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>mesa</code>: 主 Mesa 包，提供 OpenGL 实现。</li>
<li><code>mesa-gl</code>: 提供 OpenGL 库。</li>
<li><code>mesa-demos</code>: 包含一些 OpenGL 的演示程序，方便测试。</li>
</ul>
<h2 id="3-构建镜像"><a href="#3-构建镜像" class="headerlink" title="3. 构建镜像"></a>3. 构建镜像</h2><p>使用 <code>bitbake</code> 命令构建包含 Mesa OpenGL 驱动的系统镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitbake core-image-sato</span><br></pre></td></tr></table></figure>

<p>这个过程可能需要一些时间，因为 Yocto 会从源代码编译所有需要的组件，包括 Mesa 驱动程序。</p>
<h2 id="4-部署和测试"><a href="#4-部署和测试" class="headerlink" title="4. 部署和测试"></a>4. 部署和测试</h2><h1 id="4-1-部署镜像"><a href="#4-1-部署镜像" class="headerlink" title="4.1 部署镜像"></a><strong>4.1 部署镜像</strong></h1><p>构建完成后，生成的镜像文件会存放在 <code>build/tmp/deploy/images/raspberrypi4/</code> 目录下。你可以使用 <code>dd</code> 命令将镜像烧录到 SD 卡上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=core-image-sato-raspberrypi4.rpi-sdimg of=/dev/sdX bs=4M</span><br><span class="line"><span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<p>将 SD 卡插入 Raspberry Pi 4，然后启动设备。</p>
<h1 id="4-2-测试-OpenGL"><a href="#4-2-测试-OpenGL" class="headerlink" title="4.2 测试 OpenGL"></a><strong>4.2 测试 OpenGL</strong></h1><p>启动 Raspberry Pi 后，通过 SSH 或直接在设备上打开终端，运行 Mesa 的 <code>glxinfo</code> 工具以验证 OpenGL 驱动是否正确安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">glxinfo | grep OpenGL</span><br></pre></td></tr></table></figure>

<p>你应该能够看到与 Mesa 和 OpenGL 相关的输出信息，表明 OpenGL 驱动已正确加载。</p>
<p>此外，你可以运行 <code>glxgears</code>（Mesa 的演示程序之一）来测试 OpenGL 的基本功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">glxgears</span><br></pre></td></tr></table></figure>

<p>yocto SDK 目录结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">├── build                     <span class="comment">// 用户配置文件和工程构建输出目录</span></span><br><span class="line">├── conf</span><br><span class="line">├── meta-browser              <span class="comment">// Web浏览器配方</span></span><br><span class="line">├── meta-clang                    <span class="comment">// 用来构架编译器的LLVM框架系统</span></span><br><span class="line">├── meta-openembedded         <span class="comment">// 用来交叉编译，安装和打包的元数据</span></span><br><span class="line">├── meta-poky -&gt; poky/meta-poky       <span class="comment">// Poky发行版本的配置数据</span></span><br><span class="line">├── meta-python2              <span class="comment">// Python2配方</span></span><br><span class="line">├── meta-qt5                  <span class="comment">// Qt5官方推出的Qt5配方</span></span><br><span class="line">├── meta-rockchip             <span class="comment">// Rockchip层，包含Rockchip芯片BSP相关配方</span></span><br><span class="line">├── meta-rust                 <span class="comment">// Rust与Cargo的OpenEmbedded/Yocto层</span></span><br><span class="line">└── poky                      <span class="comment">// 用来构建Linux的构建系统</span></span><br></pre></td></tr></table></figure>

<p>Yocto 的工程就是这么简单，仅仅只由这几个文件夹构成。yocto 由许许多多的配方构成，它通过配方获取软件源码编译下载构建并解决依赖，正因为如此，也造就了 yocto 不如 buildroot 容易入门的现状，工程虽小，但是编译的过程中需要消耗比较大的空间。</p>
<p>buid 目录下存放着，当前 SDK 存在的所有构建方案，可以看到在 rockchip 平台，该 SDK 当前支持的构建平台，其中，所有的方案均以 local.conf 文件所设置的信息为准。如果存在多个方案，可以在当前文件夹下多个方案文件夹，每个文件夹下均还有自己的方案对应的 conf&#x2F;local.conf 信息文件。</p>
<p>在当前 SDK 平台中，没有这样做，所以选择方案需要使用 ln -sf **** local.conf 文件来进行方案的选择。</p>
<p>选择好方案之后，目前我选择的方案是这样的：</p>
<p>lrwxrwxrwx 1 jie jie 23 Aug 24 20:46 local.conf -&gt; rk356x&#x2F;roc-rk3568-pc.mk</p>
<p>选择好之后，开始构建</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">source oe-init-build-env</span><br><span class="line">bitbake core-image-minimal </span><br></pre></td></tr></table></figure>

<p>使用构建参数构建出来的 yocto 系统仅仅只是一个能让设备启动的小镜像，没有启动界面。他的配置文件放在：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">meta-openembedded/meta-xfce/recipes-core/images/core-image-minimal-xfce.bb</span><br></pre></td></tr></table></figure>

<p>可以查看：<code>meta-rockchip/README.md</code> 可以看到 rockchip 对自己命令的支持。</p>
<p>简单列举一下支持的其他命令：</p>
<ul>
<li>core-image-minimal : 一个能够让设备启动的小镜像，它无界面</li>
<li>core-image-sato : 一个支持 Sato 的镜像，它支持带有 Sato 主题和 Pimlico 应用程序的 X11，还包含终端、编辑器和文件管理器，它是一个基于 GNOME Mobile 的用户界面环境，使用 matchbox 作为窗口管理器</li>
<li>meta-toolchain：一个可编译出 gcc 交叉工具链安装程序的选项，生成的文件位于目录&lt;path&#x2F;to&#x2F;yocto&gt;&#x2F;build&#x2F;tmp&#x2F;deploy&#x2F;sdk，主要输出文件为.sh 安装文件</li>
<li>meta-ide-support：一个用于确保目录&lt;path&#x2F;to&#x2F;yocto&gt;&#x2F;build 包含有 IDE 工具链包的选项，生成的文件为 environment-setup-xxxxxx-neon-poky-linux-gnueabi，位于目录&lt;path&#x2F;to&#x2F;yocto&gt;&#x2F;build&#x2F;tmp，直接用 soucre 命令运行即可</li>
</ul>
<p>更详细的可以查看 yocto 的配置文档： <a href="https://www.yoctoproject.org/docs/1.1/poky-ref-manual/poky-ref-manual.html#ref-images">https://www.yoctoproject.org/docs/1.1/poky-ref-manual/poky-ref-manual.html#ref-images</a></p>
<p>yocto 中编译出来的文件：</p>
<p>在 build 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">├── abi_version</span><br><span class="line">├── buildstats</span><br><span class="line">├── cache</span><br><span class="line">├── deploy                             <span class="comment">//生成的镜像文件</span></span><br><span class="line">├── hosttools                          <span class="comment">//构建工具，当然还没有生成</span></span><br><span class="line">├── log                                <span class="comment">//过程的log</span></span><br><span class="line">├── pkgdata                 </span><br><span class="line">├── qa.log</span><br><span class="line">├── saved_tmpdir</span><br><span class="line">├── sstate-control</span><br><span class="line">├── stamps</span><br><span class="line">├── sysroots                           <span class="comment">//生成的产品根文件系统</span></span><br><span class="line">├── sysroots-components</span><br><span class="line">├── sysroots-uninative</span><br><span class="line">├── uboot_img_prefix.tmp</span><br><span class="line">├── work                               <span class="comment">//编译过程中生成的文件 第三方软件包就放在这里</span></span><br><span class="line">└── work-shared                        <span class="comment">//编译过程中的源文件依赖 kernel 就放在这里</span></span><br></pre></td></tr></table></figure>

<p>在 build 文件夹中可以使用如下命令快捷编译相关的工具：</p>
<p>编译 ubot</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitbake <span class="keyword">virtual</span>/bootloader</span><br></pre></td></tr></table></figure>

<p>编译 kernel</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitbake <span class="keyword">virtual</span>/kernel</span><br></pre></td></tr></table></figure>

<p>编译工具或者软件包</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitbake xxxxxx                      <span class="comment">// xxxxx为配方 bb 文件之前的部分</span></span><br></pre></td></tr></table></figure>

<p>具体可以使用 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitbake s 查看当前系统中都支持构建哪些包</span><br></pre></td></tr></table></figure>

<p>如果没有自己想要的软件包，可以在 yacto 官网上下载自己需要的配方，添加进 yacto 中，再次查看是否添加进来。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>关于RTOS的Tick值</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%85%B3%E4%BA%8ERTOS%E7%9A%84Tick%E5%80%BC/</url>
    <content><![CDATA[<h1 id="什么是系统滴答"><a href="#什么是系统滴答" class="headerlink" title="什么是系统滴答"></a>什么是系统滴答</h1><p>系统滴答（SysTick），有些地方也叫时钟节拍、系统心跳等。</p>
<p>操作系统可以多任务间进行切换，就是靠一个系统定时器以固定频率中断，为操作系统提供调度（上下文切换）才能实现任务切换。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724829939000nsn3np.png" alt="gh"></p>
<p>而这个定时器，就是我们本文说的系统滴答。早些年的 51、430 单片机，跑 RTOS，都是单独利用一个 Timer 定时器提供系统滴答。为了考虑跑 RTOS 这个问题，Cortex-M 内核自带系统滴答这个定时器。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724830070000koqxlk.png" alt="gh"></p>
<p>你会发现市面上很多单片机基本都自带有 SysTick 这个定时器，像 Cortex-M0、 M3、 M4 这些内核的单片机都有的，而且只要简单调用官方写好的 API 函数即可使用。</p>
<h1 id="系统配置文件"><a href="#系统配置文件" class="headerlink" title="系统配置文件"></a>系统配置文件</h1><p>通常，系统滴答（OS_TICKS）位于系统配置文件中，对系统配置文件进行配置也是重要的一步。比如 FreeRTOSConfig.h&#x2F; ucos 系统的 os_cfg.h（一些系统通过图形化界面进行配置，其实也是对系统配置文件进行配置）。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724830215000zo7ci5.png" alt="gh"></p>
<p>OS_TICKS 一般是配置为 1000，从宏定义和注释很容易理解，就是每秒系统滴答的次数。系统滴答配置 1000，代表系统 1ms 要进行一次轮转调度，检查是否有更高优先级任务要执行（并切换任务）。100M 主频的单片机，执行一次调度（几十条语句），时间在 us 级别。1000 是一个比较适合的中等值，其他 100、10000，或者 2000 也可以，只是不利于系统以及编程。</p>
<ul>
<li>如果滴答太大，10K，甚至 100K，对系统的负担比较大。因为自身调度会占用 CPU 时间。</li>
<li>1ms 滴答一次，方便编程系统延时。2k、10k 这种值，在用到系统延时时，不方便计算。<br>  vTaskDelay(1000);<br>  如果滴答值为 1000，则代表延时 1 秒；<br>  如果滴答值为 2000，则代表延时 0.5 秒，很明显这种不利于编程；</li>
<li>实时操作系统的 SysTick，在没有特殊情况下，最好默认配置 1000；</li>
<li>在系统允许的情况下，SysTick 数值越大，系统实时性越高；反之实时性越差；</li>
<li>主频相对偏低（比如低于 10M）的处理器，SysTick 值可以适当配置低一点；</li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>实时OS和分时OS</title>
    <url>/2024/07/12/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%AE%9E%E6%97%B6OS%E5%92%8C%E5%88%86%E6%97%B6OS/</url>
    <content><![CDATA[<h1 id="实时操作系统（RTOS）"><a href="#实时操作系统（RTOS）" class="headerlink" title="实时操作系统（RTOS）"></a>实时操作系统（RTOS）</h1><p>RTOS，英文全称 Real Time Operating System，即实时操作系统。</p>
<h2 id="实时操作系统定义"><a href="#实时操作系统定义" class="headerlink" title="实时操作系统定义"></a>实时操作系统定义</h2><p>实时操作系统（RTOS）是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在<strong>规定的时间之</strong>内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的操作系统。</p>
<p>因而，提供及时响应和高可靠性是其主要特点。</p>
<p>实时操作系统有硬实时和软实时之分，硬实时要求在规定的时间内必须完成操作，这是在操作系统设计时保证的。</p>
<p>软实时则只要按照任务的优先级，尽可能快地完成操作即可。我们通常使用的操作系统在经过一定改变之后就可以变成实时操作系统。</p>
<p>实时操作系统是保证在一定时间限制内完成特定功能的操作系统。例如，可以为确保生产线上的机器人能获取某个物体而设计一个操作系统。在“硬”实时操作系统中，如果不能在允许时间内完成使物体可达的计算，操作系统将因错误结束。</p>
<p>在“软”实时操作系统中，生产线仍然能继续工作，但产品的输出会因产品不能在允许时间内到达而减慢，这使机器人有短暂的不生产现象。一些实时操作系统是为特定的应用设计的，另一些是通用的。</p>
<p>一些通用目的的操作系统称自己为实时操作系统。但某种程度上，大部分通用目的的操作系统，如微软的 Windows NT 或 IBM 的 OS&#x2F;390 有实时系统的特征。这就是说，即使一个操作系统不是严格的实时系统，它们也能解决一部分实时应用问题。</p>
<h2 id="实时操作系统的特征"><a href="#实时操作系统的特征" class="headerlink" title="实时操作系统的特征"></a>实时操作系统的特征</h2><ul>
<li>多任务</li>
<li>有线程优先级</li>
<li>多种中断级别</li>
</ul>
<p>小的嵌入式操作系统经常需要实时操作系统，内核要满足实时操作系统的要求。</p>
<h2 id="实时操作系统的相关概念"><a href="#实时操作系统的相关概念" class="headerlink" title="实时操作系统的相关概念"></a>实时操作系统的相关概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>代码临界段：指处理时不可分割的代码。一旦这部分代码开始执行则不允许中断打入；</li>
<li>资源：任何为任务所占用的实体；</li>
<li>共享资源：可以被一个以上任务使用的资源；</li>
<li>任务：也称作一个线程，是一个简单的程序。每个任务被赋予一定的优先级，有它自己的一套 CPU 寄存器和自己的栈空间。典型地，每个任务都是一个无限的循环，每个任务都处在以下五个状态下：休眠态，就绪态，运行态，挂起态，被中断态；</li>
<li>任务切换：将正在运行任务的当前状态（CPU 寄存器中的全部内容）保存在任务自己的栈区，然后把下一个将要运行的任务的当前状态从该任务的栈中重新装入 CPU 的寄存器，并开始下一个任务的运行；</li>
<li>内核：负责管理各个任务，为每个任务分配 CPU 时间，并负责任务之间通讯。分为不可剥夺型内核于可剥夺型内核；</li>
<li>调度：内核的主要职责之一，决定轮到哪个任务运行。一般基于优先级调度法；</li>
</ul>
<h3 id="关于优先级的问题"><a href="#关于优先级的问题" class="headerlink" title="关于优先级的问题"></a>关于优先级的问题</h3><p>任务优先级：分为优先级不可改变的静态优先级和优先级可改变的动态优先级；</p>
<p>优先级反转：优先级反转问题是实时系统中出现最多的问题。共享资源的分配可导致优先级低的任务先运行，优先级高的任务后运行。解决的办法是使用“优先级继承”算法来临时改变任务优先级，以遏制优先级反转。</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>虽然共享数据区简化了任务之间的信息交换，但是必须保证每个任务在处理共享共享数据时的排他性。使之满足互斥条件的一般方法有：关中断，使用测试并置位指令（TAS），禁止做任务切换，利用信号量。</p>
<p>因为采用实时操作系统的意义就在于能够及时处理各种突发的事件，即处理各种中断，因而衡量嵌入式实时操作系统的最主要、最具有代表性的性能指标参数无疑应该是中断响应时间了。中断响应时间通常被定义为：</p>
<ul>
<li>中断响应时间&#x3D;中断延迟时间+保存 CPU 状态的时间+该内核的 ISR 进入函数的执行时间。</li>
<li>中断延迟时间&#x3D;MAX(关中断的最长时间，最长指令时间) + 开始执行 ISR 的第一条指令的时间。</li>
</ul>
<h1 id="分时操作系统（TSOS）"><a href="#分时操作系统（TSOS）" class="headerlink" title="分时操作系统（TSOS）"></a>分时操作系统（TSOS）</h1><p>TSOS，英文全称 Time-sharing Operating System，即分时操作系统。</p>
<p>使一台计算机同时为几个、几十个甚至几百个用户服务的一种操作系统叫分时操作系统。把计算机与许多终端用户连接起来，分时操作系统将系统处理机时间与内存空间按一定的时间间隔，轮流地切换给各终端用户的程序使用。</p>
<p>由于时间间隔很短，每个用户的感觉就像他独占计算机一样。分时操作系统的特点是可有效增加资源的使用率。例如 UNIX 系统就采用剥夺式动态优先的 CPU 调度，有力地支持分时操作。</p>
<p>产生分时系统是为了满足用户需求所形成的一种新型 OS 。它与多道批处理系统之间，有着截然不同的性能差别。用户的需求具体表现在以下几个方面: 人—机交互 共享主机 便于用户上机 </p>
<h2 id="分时系统的基本思想"><a href="#分时系统的基本思想" class="headerlink" title="分时系统的基本思想"></a>分时系统的基本思想</h2><p>时间片：是把计算机的系统资源（尤其是 CPU 时间）进行时间上的分割，每个时间段称为一个时间片，每个用户依次轮流使用时间片。 </p>
<p>分时技术：把处理机的运行时间分为很短的时间片，按时间片轮流把处理机分给各联机作业使用。 </p>
<p>分时操作系统：是一种联机的多用户交互式的操作系统。一般采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户能保证足够快的响应时间，并提供交互会话能力。 </p>
<p>设计目标：对用户的请求及时响应，并在可能条件下尽量提高系统资源的利用率。 </p>
<p>适合办公自动化、教学及事务处理等要求人机会话的场合。 </p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><p>一台主机连接了若干个终端；每个终端有一个用户在使用；交互式地向系统提出命令请求；系统接受每个用户的命令；采用时间片轮转方式处理服务请求；并通过交互方式在终端上向用户显示结果；用户根据上步结果发出下道命令 </p>
<p>分时系统实现中的关键问题：及时接收。及时处理。 </p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li>交互性：用户与系统进行人机对话。 </li>
<li>多路性：多用户同时在各自终端上使用同一 CPU。 </li>
<li>独立性：用户可彼此独立操作，互不干扰，互不混淆。 </li>
<li>及时性：用户在短时间内可得到系统的及时回答。 </li>
<li>影响响应时间的因素：终端数目多少、时间片的大小、信息交换量、信息交换速度。</li>
</ul>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>RTOS 和 TSOS 各有各的特点，RTOS 一般用于相对低速的 MCU，比如运动控制类、按键输入等动作要求实时处理的系统，一般要求 ms 级，甚至 us 级响应。</p>
<p>分时：现在流行的 PC，服务器都是采用这种运行模式，即把 CPU 的运行分成若干时间片分别处理不同的运算请求。</p>
<p>实时：一般用于单片机上，比如电梯的上下控制中，对于按键等动作要求进行实时处理。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>嵌入式Qt的窗口系统</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%B5%8C%E5%85%A5%E5%BC%8FQt%E7%9A%84%E7%AA%97%E5%8F%A3%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>自从 Qt 5.0 发布以来，Qt 不再包含自己的窗口系统（QWS）实现。对于单进程用例，Qt 平台抽象是一个优秀的解决方案。Wayland 可以支持多种图形化流程。</p>
<p>有多个平台插件在嵌入式 Linux 系统上可用：EGLFS，LinuxFB，DirectFB，Wayland。这些可用性取决于 Qt 的配置。在许多开发板上选择 eglfs 作为默认选项。如果默认值不合适，<code>QT_QPA_PLATFORM</code> 则可以使用环境变量参数来请求另一个插件。或者，对于快速测试，<code>-platform</code> 命令行可以使用相同的语法。</p>
<h1 id="配置特定设备"><a href="#配置特定设备" class="headerlink" title="配置特定设备"></a>配置特定设备</h1><p>对于给定的设备构建 Qt 需要一个工具链和一个 sysroot。另外，一些设备需要针对 EGL 和 OpenGL ES 2.0 支持的供应商特定的适配代码。这与非加速平台无关，例如使用 LinuxFB 插件的平台，仅用于基于软件的渲染。</p>
<p>目录 qtbase &#x2F; mkspecs &#x2F; devices 包含许多设备的配置和图形适配代码。例如，linux-rasp-pi2-g++mkspec 包含构建设置，如 Raspberry Pi 2 设备的最佳编译器和链接器标志。mkspec 还包含有关 eglfs 钩子的实现（供应商特定的适配代码）的信息，或者是对适合的 eglfs 设备集成插件的引用。通过配置工具的-device 参数选择设备。在此参数之后的名称必须至少部分地匹配设备下的一个子目录。</p>
<p>以下是 Raspberry Pi 2 的示例配置。对于大多数嵌入式 Linux 板，configure 命令如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">./configure -release -opengl es2 -device linux-rasp-pi2-g++ -device-option CROSS_COMPILE = $TOOLCHAIN/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf- -sysroot $ROOTFS -prefix /usr/local/qt5</span><br></pre></td></tr></table></figure>

<p>最重要的参数是 <code>-device</code> 和 <code>-sysroot</code>。通过指定 <code>-sysroot</code>，<code>configure</code> 特征检测测试使用的包含文件和库以及 Qt 本身，取自指定的位置，而不是主机 PC 的标准位置。这意味着在主机上安装开发包是无关紧要的。例如，要获得 libinput 支持 libinput，在主机环境中安装开发头和库是不够的。相反，目标架构（例如 ARM）的标头和库必须存在于 <code>sysroot</code>。</p>
<p><code>pkg-config</code> 在执行交叉编译时也得到支持。<code>configure</code> 自动设置 <code>PKG_CONFIG_LIBDIR</code> 为 <code> pkg-config</code> 基于 <code>sysroot</code> 代替主机的报告编译器和链接器设置。这通常功能很好，没有任何进一步的调整。但是，<code>PKG_CONFIG_PATH</code> 运行前，主机必须先设置环境变量 <code>configure</code>。否则，Qt 构建可能会尝试从主机系统使用不适当的头文件和库。</p>
<p>指定 <code>-sysroot</code> 在 <code>--sysroot</code> 调用编译器时自动设置参数的结果。在某些情况下，这是不可取的，可以通过传递 <code>-no-gcc-sysroot</code> 来禁用 <code>configure</code>。</p>
<p><code>-prefix</code>，<code>-extprefix</code> 并 <code>-hostprefix</code> 控制 Qt 构建的目标目标目录。在上述示例中，Qt 的 ARM 版本预计将放置在 <code>/usr/local/qt5</code> 目标设备上。请注意，运行 <code>make install</code> 不会部署任何设备。相反，该 <code>install</code> 步骤将目标指定的目录 <code>extprefix</code> 默认为 <code>sysroot+ prefix</code>，因此是可选的。然而，在很多情况下，“污染”是不可取的，因此指定 <code>-extprefix</code> 变得重要。最后，<code>-hostprefix</code> 允许从目标的二进制文件分离主机工具，如 <code>qmake</code>，<code>rcc</code>，<code>uic</code>。给定时，这些工具将安装在指定的目录下，而不是 <code>extprefix</code>。</p>
<h1 id="嵌入式-Linux-设备的平台插件"><a href="#嵌入式-Linux-设备的平台插件" class="headerlink" title="嵌入式 Linux 设备的平台插件"></a>嵌入式 Linux 设备的平台插件</h1><h2 id="EGLFS"><a href="#EGLFS" class="headerlink" title="EGLFS"></a>EGLFS</h2><p>EGL 是 OpenGL 和本机窗口系统之间的接口。Qt 可以使用 EGL 进行上下文和表面管理，但是 API 不包含平台特定的内容：创建本机窗口（这不一定是屏幕上的实际窗口）仍然必须通过平台特定的方式完成。因此需要板或 GPU 特定的适配代码。这样的修改可以被提供为 eglfs 钩子，其可以是编译到平台插件中的单个源文件，或作为动态加载的 EGL 设备集成插件。</p>
<p>EGLFS 是一个平台插件，用于在没有实际的窗口系统（如 X11 或 Wayland）的 EGL 和 OpenGL ES 2.0 之上运行 Qt5 应用程序。<strong>除了 Qt Quick 2 和本机 OpenGL 应用程序，它还支持软件渲染的窗口（例如 QWidget）</strong>。在后一种情况下，小部件的内容将使用 CPU 渲染成图像，然后将其上传到纹理并由插件合成。</p>
<p>这是包含 GPU 的现代嵌入式 Linux 设备的推荐插件。</p>
<p>EGLFS 强制第一个顶级窗口（无论是 QWidget 还是 QQuickView）成为全屏幕。此窗口也被选择为根部件窗口窗口，其中所有其他顶级窗口小部件（例如对话框，弹出菜单或组合框下拉列表）都被合成。这是必要的，因为使用 EGLFS 总是有一个本机窗口和 EGL 窗口表面，这些窗口属于首先创建的窗口小部件或窗口。当主窗口在整个应用程序的整个生命周期中存在，并且所有其他窗口小部件都是非顶层或之后创建的主窗口显示时，此方法运行良好。</p>
<p>对于基于 OpenGL 的窗口还有其他限制。从 Qt 5.3 起，eglfs 支持一个全屏 GL 窗口（例如，基于 OpenGL 的 QWindow，QQuickView 或 QGLWidget）。打开额外的 OpenGL 窗口或混合这些窗口与基于 QWidget 的内容是不支持的并终止应用程序与错误消息。</p>
<p>如有必要，eglfs 可以使用以下环境变量进行配置：</p>
<ul>
<li>QT_QPA_EGLFS_INTEGRATION- 除了编译的钩子之外，还可以以动态加载的插件的形式提供设备或供应商特定的适配。这个环境变量强制执行一个特定的插件。例如，将其设置为 eglfs_kms 使用 KMS &#x2F; DRM 后端。这只是在设备 makepecs 中没有指定静态或编入钩子的选项。在实践中，传统的编入钩子很少被使用，几乎所有后端都被迁移到插件。设备制造商仍然包含相关 EGLFS_DEVICE_INTEGRATION 条目：该特定设备的首选后端的名称。这是可选的，但是非常有用，以避免在目标系统中存在多个插件的情况下设置此环境变量。DISPLAY 在桌面环境中，根据环境变量的存在，KMS 或 X11 后端是优先的。请注意，在某些电路板上使用特殊的值 none 而不是实际的插件。这表明使用 EGL 与 framebuffer 不需要特殊的集成，所以不能加载插件。</li>
<li>QT_QPA_EGLFS_PHYSICAL_WIDTH 和 QT_QPA_EGLFS_PHYSICAL_HEIGHT-物理屏幕宽度和高度以毫米为单位。在不能从帧缓冲设备&#x2F; dev &#x2F; fb0 或其他方式查询值的平台上，使用默认 DPI 为 100。此变量可用于覆盖任何此类默认值。设置此选项很重要，因为基于 QWidget 或 Qt Quick Controls 的应用程序依赖于这些值。使用硬编码设置运行可能会导致用户界面元素大小不适合在使用中显示。</li>
<li>QT_QPA_EGLFS_ROTATION- 指定在基于 QWidget 的应用程序中应用于软件渲染内容的旋转。支持的值为 180,90 和-90。这不适用于基于 OpenGL 的窗口，包括 Qt Quick。Qt Quick 应用程序可以在 QML 场景中应用转换。无论应用程序类型如何，标准的 eglfs 鼠标光标总是考虑到该值，具有适当定位和旋转的指针图像。特殊光标实现（如 KMS &#x2F; DRM 后端的硬件光标）可能不支持旋转。</li>
<li>QT_QPA_EGLFS_FORCEVSYNC- 设置后，每次调用 eglSwapBuffers（）后，帧缓冲设备上的 eglfs 请求 FBIO_WAITFORVSYNC。这仅适用于依赖于 fbdevLinux 的传统子系统的后端。通常，默认交换间隔为 1，Qt 假定调用 eglSwapBuffers（）处理 vsync; 如果没有（例如，由于驱动程序错误），请尝试设置 QT_QPA_EGLFS_FORCEVSYNC 为非零值。</li>
<li>QT_QPA_EGLFS_FORCE888 - 设置时，在创建新的上下文，窗口或屏幕外表面时，将忽略红色，绿色和蓝色颜色通道大小。相反，插件要求每个通道 8 位配置。这对于在默认情况下选择具有小于 32 或 24 位&#x2F;像素（例如 5-6-5 或 4-4-4）的配置的设备可能是有用的，但是已知不是理想的，例如，由于绑带效应。而不是更改应用程序代码，此变量提供了一个更容易的快捷方式来强制 24 或 32 bpp 配置。</li>
</ul>
<p>此外，以下较不常用的变量也可用：</p>
<ul>
<li>QT_QPA_EGLFS_FB - 覆盖帧缓冲设备。默认是&#x2F;dev&#x2F;fb0。在大多数嵌入式平台上，这不是很相关，因为帧缓冲区仅用于查询显示维度等设置。然而，在某些设备上，该参数提供了指定要在多个显示设置中使用的显示的功能，类似于 LinuxFB 中的 fb 参数。</li>
<li>QT_QPA_EGLFS_WIDTH 和 QT_QPA_EGLFS_HEIGHT- 包含屏幕宽度和高度（以像素为单位）。在 eglfs 尝试从 framebuffer 设备&#x2F; dev &#x2F; fb0 中确定尺寸时，但是这并不总是和手动指定大小可能变得必要。</li>
<li>QT_QPA_EGLFS_DEPTH - 覆盖屏幕的颜色深度。在 framebuffer 设备&#x2F; dev &#x2F; fb0 不可用或查询不成功的平台上，使用默认值 32。此变量可用于覆盖任何此类默认值。请注意，这仅影响 QScreen 报告的颜色深度值。它与 EGL 配置和 OpenGL 渲染使用的颜色深度无关。</li>
<li>QT_QPA_EGLFS_SWAPINTERVAL- 默认情况下 1 将要求交换间隔。这使得能够与显示器垂直刷新同步。该值可以用此环境变量覆盖。例如，传递 0 将禁用交换阻塞，导致尽可能快地运行而没有任何同步。</li>
<li>QT_QPA_EGLFS_DEBUG - 设置时，调试输出上会打印一些调试信息。例如，输入的 QSurfaceFormat 和所选 EGL 配置的属性在创建新上下文时打印。与 Qt Quick 的 QSG_INFO 变量一起，可以为与 EGL 配置相关的故障排除提供有用的信息。</li>
</ul>
<p>除此之外 QT_QPA_EGLFS_DEBUG，eglfs 还支持更现代的 Qt 分类日志记录系统。以下日志记录类别可用：</p>
<ul>
<li><code>qt.qpa.egldeviceintegration</code> - 为动态加载的后端启用日志记录。非常有用的检查后端是否正在使用。</li>
<li><code> qt.qpa.input</code> - 启用来自 evdev 和 libinput 输入处理程序的调试输出。检查给定输入设备是否被识别和打开非常有用。</li>
<li><code> qt.qpa.eglfs.kms</code> - 在 KMS &#x2F; DRM 后端启用详细日志记录。</li>
</ul>
<p>运行后 configure，确保检查其输出。由于相应的配置测试失败，没有启用必要的 eglfs 后端，libudev 或 libinput 是相当常见的问题，可以通过这种方式快速识别。当有不想要的“不”的结果，运行 configure 与-v 才能看到编译器和链接调用每个配置测试打开详细输出。</p>
<p>注意：关于缺少标题，库或似乎隐含的链接器故障的错误通常是不完整或破碎的 sysroot 的标志，与 Qt 无关，也不能被 Qt 解决。</p>
<p>例如，当使用 Broadcom 专有图形驱动程序定位 Raspberry Pi 时，输出应包含以下内容。如果不是这样，没有必要进一步进行构建，因为如果没有 Raspberry Pi 特定的后端，加速图形将不起作用，即使 Qt 的其余部分成功编译。</p>
<p>QPA 后端：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">EGLFS ................................yes</span><br><span class="line">EGLFS 详细信息：</span><br><span class="line">EGLFS i.Mx6 ........................ no</span><br><span class="line">EGLFS i.Mx6 Wayland ................ no</span><br><span class="line">EGLFS EGLDevice .................... no</span><br><span class="line">EGLFS GBM .......................... no</span><br><span class="line">EGLFS mali.........................</span><br><span class="line">EGLFS Rasberry Pi ..................yes</span><br><span class="line">XL 上的 EGL .........................</span><br></pre></td></tr></table></figure>

<h2 id="LinuxFB"><a href="#LinuxFB" class="headerlink" title="LinuxFB"></a>LinuxFB</h2><p>该插件通过 Linux 的 fbdev 子系统直接写入帧缓冲区。<strong>只支持软件渲染内容</strong>。请注意，在某些设置上，显示性能预计将受到限制。</p>
<p>从 Qt 5.9 开始，由于 fbdev 在 Linux 内核中被弃用，DRM dumb 缓冲区支持也是可用的。必须通过将 <code>QT_QPA_FB_DRM</code> 环境变量设置为非零值来请求。当设置时，只要系统支持哑缓冲区，传统的帧缓冲设备&#x2F;dev&#x2F;fb0 就不会被访问。相反，通过 DRM API 设置渲染，类似于 <code>eglfs_kmseglfs</code> 的后端。输出将被双缓冲和页面翻转，为软件渲染内容提供适当的 vsync。</p>
<p>注意：当使用哑缓冲区时，以下所述的任何选项都不适用，因为物理和逻辑屏幕尺寸等属性都将被自动查询。</p>
<p>该 linuxfb 插件允许通过将它们传递给 <code>QT_QPA_PLATFORM</code> 环境变量或 <code>-platform</code> 命令行选项来指定其他设置。例如，<code>QT_QPA_PLATFORM=linuxfb:fb=/dev/fb1</code> 指定 <code>/dev/fb1</code> 必须使用帧缓冲设备而不是默认值 <code>fb0</code>。可以通过用冒号分隔多个设置来指定多个设置。</p>
<ul>
<li>fb&#x3D;&#x2F;dev&#x2F;fbN - 指定帧缓冲设备。在多个显示设置上，这通常允许在不同显示器上运行应用程序。暂时没有办法从一个 Qt 应用程序使用多个帧缓冲区。</li>
<li><code>size=&lt;width&gt; x&lt;height&gt;</code> - 指定屏幕大小（以像素为单位）。插件尝试从 framebuffer 设备查询物理和逻辑的显示维度。然而，这可能并不总是导致正确的结果，因此可能需要明确指定值。</li>
<li><code>mmsize=&lt;width&gt; x&lt;height&gt;</code> - 物理宽度和高度（以毫米为单位）。</li>
<li><code>offset=&lt;width&gt; x&lt;height&gt;</code> - 指定屏幕左上角的像素偏移量。默认位置在(0, 0)。</li>
<li><code>nographicsmodeswitch</code> - 不要将虚拟终端切换到图形模式（KD_GRAPHICS）。除了切换到图形模式外，闪烁的光标和屏幕消隐也通常被禁用。设置此参数时，也会跳过这些参数。</li>
<li><code>tty=/dev/ttyN</code> - 覆盖虚拟控制台。仅在 nographicsmodeswitch 未设置时使用。</li>
</ul>
<p>从 Qt 5.9 起，在窗口大小调整策略中，eglfs 和 linuxfb 的行为已被同步：第一个顶级窗口被迫使用两个平台插件覆盖整个屏幕。如果不想这样，环境变量设置 <code>QT_QPA_FB_FORCE_FULLSCREEN</code> 到 0 以恢复早期的 Qt 版本的行为。</p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>当没有窗口系统存在时，鼠标，键盘，以及触摸输入是通过直接读取 <code>evdev</code> 或使用辅助库如 <code>libinput</code> 或 <code>tslib</code>。请注意，这要求 <code>/dev/input/event*</code> 用户可以读取设备节点。<code>eglfs</code> 并 <code>linuxfb</code> 具有编译的所有输入处理代码。</p>
<h2 id="使用-libinput"><a href="#使用-libinput" class="headerlink" title="使用 libinput"></a>使用 <code>libinput</code></h2><p>libinput 是一个用于处理输入设备的库。它提供了 Qt 自己的 evdev 输入支持的替代方案。为了能够使用 libinput，请确保所开发的文件 libudev 和 libinput 配置和构建 Qt 时可用。xkbcommon 如果需要键盘支持，也是必需的。由于这些插件默认使用 eglfs，因此 linuxfb 无需进一步的操作 libinput。如果 libinput 支持不可用或环境变量 <code>QT_QPA_EGLFS_NO_LIBINPUT</code> 设置，Qt 自己的 evdev 处理程序进来玩。</p>
<h2 id="输入-eglfs-和-linuxfb-而不用-libinput"><a href="#输入-eglfs-和-linuxfb-而不用-libinput" class="headerlink" title="输入 eglfs 和 linuxfb 而不用 libinput"></a>输入 eglfs 和 linuxfb 而不用 libinput</h2><p>像设备节点名称参数可以在环境变量设置 <code>QT_QPA_EVDEV_MOUSE_PARAMETERS</code>，<code>QT_QPA_EVDEV_KEYBOARD_PARAMETERS</code> 和 <code>QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS</code>。用冒号分隔条目。这些参数作为传递-plugin 命令行参数中的设置的替代方法，并且对于某些后端，它们是至关重要的：eglfs 和 linuxfb 使用内置的输入处理程序，因此-plugin 在使用中没有单独的参数。</p>
<p>此外，内置的输入处理程序可以通过设置被禁用 <code>QT_QPA_EGLFS_DISABLE_INPUT</code> 或 <code>QT_QPA_FB_DISABLE_INPUT</code> 到 1。</p>
<h2 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h2><p>鼠标光标每当出现 <code>QT_QPA_EGLFS_HIDECURSOR</code>（对于 eglfs）或 <code>QT_QPA_FB_HIDECURSOR</code>（对于 linuxfb）未设置，Qt 的基于 libudev 的设备发现报告至少有一个鼠标可用。当 libudev 不存在支持时，鼠标光标始终显示，除非通过环境变量显式禁用。</p>
<p>支持热插拔，但只有当 Qt 配置了 libudev 支持（即，如果 libudev 开发头在配置时在 sysroot 中存在）。这允许在应用程序运行时连接或断开输入设备。evdev 鼠标处理器支持以下额外的参数：</p>
<ul>
<li><code>/dev/input/...</code> - 指定输入设备的名称。当没有给出时，Qt 通过 libudev 或通过可用节点来查找合适的设备。</li>
<li><code>nocompress</code> - 默认情况下，与最后一个 Qt 鼠标事件相比，不会导致更改位置的输入事件被压缩; 在更改位置或按钮状态后，才会发送新的 Qt 鼠标事件。可以通过设置 nocompress 参数来禁用。</li>
<li><code>dejitter</code> - 指定抖动限制。默认情况下禁用消隐功能。</li>
<li><code>grab</code> - 当 1，Qt 将抓住设备专用。</li>
<li><code>abs</code> - 一些触摸屏报告绝对坐标，不能与触摸板区分开来。在这种特殊情况下，通过 abs 表示设备正在使用绝对事件。</li>
</ul>
<h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>该了 evdev 键盘处理程序支持以下额外的参数：</p>
<ul>
<li><code>/dev/input/... </code>- 指定输入设备的名称。当没有给出时，Qt 通过 libudev 或通过可用节点来查找合适的设备。</li>
<li><code>grab</code> - 启用抓取输入设备。</li>
<li><code>keymap</code> - 指定自定义键盘映射文件的名称。</li>
<li><code>enable-compose</code> - 启用合成。</li>
<li><code>repeat-delay</code> - 设置自定义键重复延迟。</li>
<li><code>repeat-rate</code> - 设置自定义键重复率。</li>
</ul>
<p>在没有停用终端会话的嵌入式 Linux 系统上，由于输入事件由 Qt 应用程序和 tty 处理，按键上的行为可能会令人困惑。为了克服这一点，可以使用以下选项：</p>
<ul>
<li>EGLFS 和 LinuxFB 尝试通过设置 tty 的键盘模式来禁用应用程序启动时的终端键盘 K_OFF。这样可以防止键盘进入终端。如果由于某些原因需要恢复标准行为，请将环境变量设置 QT_QPA_ENABLE_TERMINAL_KEYBOARD 为 1。请注意，仅当应用程序从远程控制台（例如，通过 ssh）启动并且终端键盘输入保持启用时，该功能才起作用。</li>
<li>另一种方法是使用了 evdev 键盘处理程序的 grab 通过传递参数抢&#x3D; 1 在 QT_QPA_EVDEV_KEYBOARD_PARAMETERS。这样会导致尝试在输入设备上进行抓取。如果 grab 成功，只要 Qt 应用程序运行，系统中没有其他组件从中接收事件。这种方法更适合远程启动的应用程序，因为它不需要访问 tty 设备。</li>
<li>最后，对于许多专门的嵌入式 Linux 图像，首先启用标准终端会话是没有意义的。请参阅您的构建环境的文档，了解如何禁用它们。例如，当使用 Yocto Project 生成图像时，取消设置将 SYSVINIT_ENABLED_GETTYS 导致 getty 任何虚拟终端无任何进程运行，从而导致无输入。</li>
</ul>
<p>如果默认内置键盘映射不够，可以通过 keymap 参数或使用 eglfs 特定的 loadKeymap（）函数指定不同的键盘映射。后者允许在运行时切换键盘映射。但是请注意，这需要使用 eglfs 的内置键盘处理程序; 当通过-plugin 命令行参数加载键盘处理程序时，不支持它。</p>
<p>注意：目前不支持特殊的系统组合键，例如控制台切换（Ctrl + Alt + Fx）或 zap（Ctrl + Alt + Backspace），并被忽略。</p>
<p>要生成自定义键盘映射，可以使用 kmap2qmap 实用程序。这可以在 qttools 模块中找到。源文件必须是标准的 Linux kmap 格式，这是内核的 loadkeys 命令所理解的。这意味着可以使用以下源生成 qmap 文件：</p>
<ul>
<li>在 Linux 控制台工具（LCT）项目。</li>
<li>Xorg X11 键盘映射可以转换 kmap 为该 ckbcomp 实用程序的格式。</li>
<li>由于 kmap 文件是纯文本文件，它们也可以手工制作。</li>
</ul>
<p>kmap2qmap 是一个命令行程序，至少需要 2 个文件作为参数。最后一个是生成的.qmap 文件，而其他所有文件都被解析为输入.kmap 文件。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kmap2qmap i386 /qwertz/de-latin1-nodeadkeys.kmap include/compose.latin1.inc de-latin1-nodeadkeys.qmap</span><br></pre></td></tr></table></figure>

<p>注意：kmap2qmap 不支持 Linux 内核支持的所有（伪）符号。转换标准键盘图时，会显示许多警告，关于 Show_Registers，Hex_A 等等; 这些消息可以安全地被忽略。</p>
<h2 id="触摸"><a href="#触摸" class="headerlink" title="触摸"></a>触摸</h2><p>对于一些电阻式单触摸触摸屏，可能需要退回使用 tslib 而不是依赖于 Linux 多点触控协议和事件设备。对于现代触摸屏，这是不必要的。tslib 可以通过设置环境变量 <code>QT_QPA_EGLFS_TSLIB</code> 或 <code>QT_QPA_FB_TSLIB1</code> 来启用支持。要更改设备，请 <code>TSLIB_TSDEVICE</code> 在命令行中设置环境变量或传递设备名称。请注意，tslib 输入处理程序生成鼠标事件并支持单触摸，而不是 <code>evdevtouch</code> 生成真正的多点触控 <code>QTouchEvent</code> 事件。 evdev 触摸处理器支持以下额外的参数：</p>
<ul>
<li>&#x2F;dev&#x2F;input&#x2F;… - 指定输入设备的名称。当没有给出时，Qt 通过 libudev 或通过可用节点来查找合适的设备。</li>
<li>rotate- 在某些触摸屏上，坐标必须旋转，这可以通过设置 rotate 为 90,180 或 270 进行。</li>
<li>invertx 和 inverty- 反转输入事件中的 X 或 Y 坐标，通过 invertx 或 inverty。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS=/dev/input/event5:rotate=<span class="number">180</span></span><br></pre></td></tr></table></figure>

<p>在启动应用程序之前，会导致明确指定的触摸设备并翻转坐标 - 当实际屏幕和触摸屏的方向不匹配时很有用。</p>
<h2 id="笔式平板电脑"><a href="#笔式平板电脑" class="headerlink" title="笔式平板电脑"></a>笔式平板电脑</h2><p>该 evdevtablet 插件为 Wacom 和类似的基于笔的平板电脑提供了基本的支持。它仅生成 QTabletEvent 事件。要启用它，请传递 <code>QT_QPA_GENERIC_PLUGINS=evdevtablet </code> 给环境，或者 <code>-plugin evdevtablet</code> 在命令行中传递参数。插件可以使用设备节点参数，例如 <code> QT_QPA_GENERIC_PLUGINS=evdevtablet:/dev/event1</code>，Qt 的自动设备发现（基于 libudev 或演练&#x2F;dev&#x2F;input&#x2F;event*）不起作用或行为不正常的情况。</p>
<h2 id="调试输入设备"><a href="#调试输入设备" class="headerlink" title="调试输入设备"></a>调试输入设备</h2><p>通过启用 qt.qpa.input 日志规则，例如通过将 QT_LOGGING_RULES 环境变量设置为，可以向调试输出打印一些信息 qt.qpa.input&#x3D;true。这对于检测正在使用哪个设备或对设备发现问题进行故障排除非常有用。</p>
<h2 id="使用自定义鼠标光标图像"><a href="#使用自定义鼠标光标图像" class="headerlink" title="使用自定义鼠标光标图像"></a>使用自定义鼠标光标图像</h2><p>eglfs 自带的 32x32 尺寸的鼠标光标图像。如果这些还不够，可以通过将 <code>QT_QPA_EGLFS_CURSOR</code> 环境变量设置为 JSON 文件的名称来提供自定义游标地图集。该文件也可以通过 Qt 的资源系统嵌入到应用程序中。</p>
<p>例如，每行具有 8 个光标图像的嵌入式光标图集可以指定如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	“image”：“：/cursor-atlas.png”</span><br><span class="line">	“cursorsPerRow”：<span class="number">8</span>，</span><br><span class="line">	“热点”：[</span><br><span class="line">		[<span class="number">7</span>，<span class="number">2</span>]</span><br><span class="line">		[<span class="number">12</span>，<span class="number">3</span>]</span><br><span class="line">		[<span class="number">12</span>，<span class="number">12</span>]</span><br><span class="line">		...</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，图像预计将紧紧地包装在图集中：光标的宽度和高度根据总图像大小和 cursorsPerRow 设置决定。地图集必须为所有支持的游标提供图像。</p>
<h1 id="显示输出"><a href="#显示输出" class="headerlink" title="显示输出"></a>显示输出</h1><p>当连接多个显示器时，从一个单一 Qt 应用程序中定向一个或多个显示器的支持级别在平台插件之间变化，并且通常取决于设备及其图形堆栈。</p>
<h2 id="eglfs-与-eglfs-kms-后端"><a href="#eglfs-与-eglfs-kms-后端" class="headerlink" title="eglfs 与 eglfs_kms 后端"></a>eglfs 与 eglfs_kms 后端</h2><p>当 KMS &#x2F; DRM 后台正在使用时，eglfs 报告 QGuiApplication :: screens（）中的所有可用屏幕。应用程序可以使用不同的窗口通过 QWindow :: setScreen（）来定位不同的屏幕。</p>
<p>注意：每个屏幕的一个全屏窗口的限制仍然适用。使 QWindow 可见后更改屏幕也不受支持。因此，嵌入式应用程序必须在调用 QWindow :: show（）之前进行所有必要的 QWindow :: setScreen（）调用。</p>
<p>当开始在给定的嵌入式设备上开发时，通常需要验证设备和驱动程序的行为，并且所连接的显示器应该是正常工作的。一个简单的方法是使用 hellowindow 示例。用-platform eglfs –multiscreen –timeout 参数启动它在每个连接的屏幕上显示一个旋转的 Qt 标志几秒钟。</p>
<p>注意：下面描述的大多数配置选项适用于所有基于 KMS &#x2F; DRM 的后端，无论缓冲管理技术（GBM 或 EGLStreams）如何。</p>
<p>KMS &#x2F; DRM 后端还支持通过 JSON 文件进行自定义配置。将环境变量设置为 <code>QT_QPA_EGLFS_KMS_CONFIG</code> 文件的名称以启用此功能。该文件也可以通过 Qt 资源系统嵌入到应用程序中。示例配置如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	“device”：“/ dev / dri / card1”，</span><br><span class="line">	“hwcursor”：<span class="literal">false</span>，</span><br><span class="line">	“pbuffers”：真的，</span><br><span class="line">	“输出”：[</span><br><span class="line">		&#123;</span><br><span class="line">			“name”：“VGA1”，</span><br><span class="line">			“关闭模式”</span><br><span class="line">		&#125;，</span><br><span class="line">		&#123;</span><br><span class="line">			“name”：“HDMI1”，</span><br><span class="line">			“mode”：“<span class="number">1024</span>x768”</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们配置指定的设备</p>
<ul>
<li>它不会使用硬件光标（通过 OpenGL 退回渲染鼠标光标;默认情况下，启用硬件光标，因为它们更有效），</li>
<li>它将使用标准的 EGL pbuffer 表面返回 QOffscreenSurface（默认情况下，这是禁用的，而是使用 gbm 表面），</li>
<li>VGA 连接器上的输出被禁用，而 HDMI 处于活动状态，分辨率为 1024x768。</li>
</ul>
<p>另外，这样的配置也禁用寻找设备 libudev，而是使用指定的设备。</p>
<p>何时 mode 未定义，系统选择报告为首选的模式。为可接受的值 mode 是：off，current，preferred，宽度 x 高度，或模式行字符串。</p>
<p>默认情况下，DRM 层报告的所有屏幕都将被视为一个大型虚拟桌面。鼠标光标实现将考虑到这一点，并按预期在屏幕上移动。尽管不推荐，虚拟桌面模式可以通过设置被禁用 separateScreens，以 false 在配置上，如果需要的话。</p>
<p>默认情况下，根据系统报告的连接器顺序，虚拟桌面从左到右形成。这可以通过设置 virtualIndex 为从 0 开始的值来更改。例如，以下配置使用首选分辨率，但确保虚拟桌面中的左侧是屏幕连接到 HDMI 端口，而右侧是屏幕连接到 DisplayPort：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	“device”：“drm-nvdc”，</span><br><span class="line">	“输出”：[</span><br><span class="line">		&#123;</span><br><span class="line">			“name”：“HDMI1”，</span><br><span class="line">			“virtualIndex”：<span class="number">0</span></span><br><span class="line">		&#125;，</span><br><span class="line">		&#123;</span><br><span class="line">			“name”：“DP1”，</span><br><span class="line">			“virtualIndex”：<span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的元素的顺序是不相关的。具有未指定虚拟索引的输出将放在其他虚拟索引之后，并保留 DRM 连接器列表中的原始顺序。</p>
<p>要创建一个垂直的桌面空间（即，从上到下而不是从左到右堆叠），添加一个 virtualDesktopLayout 属性后面 device 的值 vertical。</p>
<p>注意：建议虚拟桌面中的所有屏幕使用相同的分辨率，否则像鼠标光标那样的元素可能会在输入仅存在于一个给定屏幕上的区域时以意想不到的方式运行。</p>
<p>何时 virtualIndex 不够，该属性 virtualPos 可用于明确指定问题屏幕的左上角位置。以前面的例子，假设 HDMI1 的分辨率为 1080p，下面第一个基于 HDMI 的屏幕放在第一个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	“输出”：[</span><br><span class="line">		...</span><br><span class="line">		&#123;</span><br><span class="line">			“name”：“HDMI2”，</span><br><span class="line">			“virtualPos”：“<span class="number">0</span>，<span class="number">1080</span>”</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在需要鼠标支持时避免这样的配置。鼠标光标的行为可能是意想不到的非线性布局。Touch 应该没有问题。</p>
<p>在某些情况下，通过 DRM 自动查询物理屏幕尺寸可能会失败。通常 <code>QT_QPA_EGLFS_PHYSICAL_WIDTH</code>，<code>QT_QPA_EGLFS_PHYSICAL_HEIGHT</code> 环境变量将用于提供缺失值，但是当存在多个屏幕时，这并不适用。而是使用列表中的 <code>physicalWidth</code> 和 <code>physicalHeight</code> 属性 <code>outputs</code> 来指定以毫米为单位的大小。</p>
<p>注意：不同的物理尺寸和不同的逻辑 DPI 不鼓励，因为它可能会导致意外的问题，因为一些图形堆栈组件不知道多个屏幕，仅依靠第一个屏幕的值。</p>
<p>从每个有源输出 outputs 阵列对应于一个 QScreen 从报告实例 QGuiApplication ::屏幕（）。QGuiApplication :: primaryScreen（）报告的主屏幕是默认首先注册的屏幕。当不使用时 virtualIndex，这意味着决定是基于 DRM 连接器顺序。要覆盖这一点，属性设置 primary，以 true 对在所需的条目 outputs 列表。例如，为了确保与 VGA 输出相对应的屏幕将是主要的，即使系统首先报告 HDMI，则可以执行以下操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	“device”：“/ dev / dri / card0”，</span><br><span class="line">	“输出”：[</span><br><span class="line">		&#123;“name”：“HDMI1”&#125;，</span><br><span class="line">		&#123;“name”：“VGA1”，“mode”：“<span class="number">1280</span>x720”，“primary”：<span class="literal">true</span>&#125;，</span><br><span class="line">		&#123;“name”：“LVDS1”，“mode”：“off”&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了进行故障排除，可能会启用 KMS &#x2F; DRM 后端的调试日志。为此，启用分类日志记录规则 <code>qt.qpa.eglfs.kms</code>。</p>
<p>注意：在嵌入式环境中，虚拟桌面比全窗口系统更为有限。应该避免 Windows 重叠多个屏幕，非全屏窗口和屏幕之间的移动窗口，并且可能无法正常运行。</p>
<p>多屏幕设置最常用和最受支持的用例是为每个屏幕打开一个专用的 QQuickWindow 或 QQuickView。使用 threadedQt Quick 场景图的默认渲染循环，这些窗口中的每个都将获得自己的专用渲染线程。这是很好的，因为线程可以基于 vsync 独立调节，并且不会相互干扰。通过 basic 循环，这可能会产生问题，动画可能会因此而恶化。</p>
<p>例如，发现所有连接的屏幕，并为每个屏幕创建一个 QQuickView 可以这样完成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QVector&lt;QQuickView *&gt;views;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(QScreen * screen : app.<span class="built_in">screens</span>())&#123;</span><br><span class="line">        QQuickView * view = <span class="keyword">new</span> QQuickView;</span><br><span class="line">        view-&gt;<span class="built_in">setScreen</span>(screen);</span><br><span class="line">        view-&gt;<span class="built_in">setResizeMode</span>(QQuickView::SizeRootObjectToView);</span><br><span class="line">        view-&gt;<span class="built_in">setSource</span>(<span class="built_in">QUrl</span>(<span class="string">&quot;qrc:/main.qml&quot;</span>));</span><br><span class="line">        QObject::<span class="built_in">connect</span>(view-&gt;<span class="built_in">engine</span>(), &amp;QQmlEngine::quit, qGuiApp, &amp;QCoreApplication::quit);</span><br><span class="line">        views.<span class="built_in">append</span>(view);</span><br><span class="line">        view-&gt;<span class="built_in">showFullScreen</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result = app.<span class="built_in">exec</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">qDeleteAll</span>(views);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eglfs-与-eglfs-kms-egldevice-后端"><a href="#eglfs-与-eglfs-kms-egldevice-后端" class="headerlink" title="eglfs 与 eglfs_kms_egldevice 后端"></a>eglfs 与 eglfs_kms_egldevice 后端</h2><p>通常在 Tegra 设备上使用的这种后端与上述 KMS &#x2F; DRM 后端类似，不同之处在于它依赖于 EGLDevice 和 EGLStream 扩展而不是 GBM。</p>
<p>有关此方法的技术细节，请查看演示文稿。</p>
<p>截至 Qt 5.7，该后端与基于 GBM 的后端共享了许多内部实现。这意味着支持多个屏幕和高级配置通道 <code>QT_QPA_EGLFS_KMS_CONFIG</code>。一些设置，如 hwcursor 和 pbuffers 不适用。</p>
<p>默认情况下，后端将自动为每个输出的默认平面选择正确的 EGL 层。必要时，可以通过将 <code>QT_QPA_EGLFS_LAYER_INDEX</code> 环境变量设置为所需层的索引来覆盖。此方法目前不支持多个输出，因此其使用应限于具有单个屏幕的系统。要查看哪些层可用，并调试潜在的启动问题，请启用日志记录类别 qt.qpa.eglfs.kms。</p>
<p>在某些情况下，即使屏幕报告已经设置了所需分辨率，也可能需要执行应用程序启动时设置的视频模式。这通常是被优化的，但如果屏幕保持关闭状态，请尝试将环境变量设置为 <code>QT_QPA_EGLFS_ALWAYS_SET_MODE</code> 非零值并重新启动应用程序。</p>
<p>要配置后端使用的 EGLStream 对象的行为，请使用 <code>QT_QPA_EGLFS_STREAM_FIFO_LENGTH</code> 环境变量。这假定 KHR_stream_fifo 是目标系统支持的。默认情况下，流以邮箱模式运行。要切换到 FIFO 模式，请设置 1 或更大的值。该值指定流可以容纳的最大帧数。</p>
<p>在某些系统上，可能需要通过预定义的连接器来定位特定的覆盖平面。强制层索引通过 <code>QT_QPA_EGLFS_LAYER_INDEX</code> 不执行平面配置，因此本身不适用。相反，在这种特殊情况下，使用 <code>QT_QPA_EGLFS_KMS_CONNECTOR_INDEX</code> 和 <code>QT_QPA_EGLFS_KMS_PLANE_INDEX</code> 环境变量。当这些设置被设置时，只有指定的连接器和平面将被使用，所有其他输出将被忽略。后端将负责选择对应于所需平面的 EGL 层和配置平面。</p>
<h2 id="在-KMS-DRM-上有多个屏幕的系统中触摸输入"><a href="#在-KMS-DRM-上有多个屏幕的系统中触摸输入" class="headerlink" title="在 KMS &#x2F; DRM 上有多个屏幕的系统中触摸输入"></a>在 KMS &#x2F; DRM 上有多个屏幕的系统中触摸输入</h2><p>触摸屏在多显示系统中需要额外的考虑因素，因为触摸事件必须路由到正确的虚拟屏幕，这需要触摸屏和显示器输出之间的正确映射。</p>
<p>映射通过 <code>QT_QPA_EGLFS_KMS_CONFIG</code> 前面部分中指定和描述的 JSON 配置文件完成。当 <code>touchDevice</code> 属性存在于 <code>outputs</code> 数组的元素中时，该值被视为设备节点，并且触摸设备与所讨论的显示输出相关联。</p>
<p>例如，假设我们的触摸屏具有&#x2F; dev &#x2F; input &#x2F; event5 的设备节点，并且是集成到通过 HDMI 连接的显示器作为辅助屏幕的触摸屏，以下配置确保正确的触摸（和合成鼠标）事件转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	“device”：“drm-nvdc”，</span><br><span class="line">	“输出”：[</span><br><span class="line">		&#123;</span><br><span class="line">			“name”：“HDMI1”，</span><br><span class="line">			“touchDevice”：“/ dev / input / event5”，</span><br><span class="line">			“virtualIndex”：1</span><br><span class="line">		&#125;，</span><br><span class="line">		&#123;</span><br><span class="line">			“name”：“DP1”，</span><br><span class="line">			“virtualIndex”：0</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如有疑问，请 <code>QT_LOGGING_RULES=qt.qpa.*=true</code> 在启动应用程序之前通过设置环境变量来启用图形和输入子系统的日志记录。这将有助于识别正确的输入设备节点，并且可能会发现可能难以调试的输出配置问题。</p>
<p>注意：从 Qt 5.8 起，上述只支持 <code>evdevtouch</code> 输入后端。其他变体，例如基于 <code>libinput</code> 的变体，将继续将事件路由到主屏幕。要强制在具有多个输入后端的系统上使用 <code>evdevtouch</code>，请将环境变量设置 <code>QT_QPA_EGLFS_NO_LIBINPUT</code> 为 1。</p>
<h2 id="eglfs-与其他后端"><a href="#eglfs-与其他后端" class="headerlink" title="eglfs 与其他后端"></a>eglfs 与其他后端</h2><p>通常基于通过供应商的 EGL 实现直接针对帧缓冲区或组合 API 的其他后端，通常对多个显示器提供有限或不支持的支持。在使用 Vivante GPU 的基于 i.MX6 的电路板上，与 <code>linuxfb</code> 类似，<code>QT_QPA_EGLFS_FB</code> 环境变量可用于指定要缓存的帧缓冲区。在 <code>Raspberry Pi </code> 上，<code>QT_QPA_EGLFS_DISPMANX_ID</code> 环境变量可用于指定要输出的屏幕。该值对应于其中一个 <code>DISPMANX_ID_</code> 常量，请参考 <code>Dispmanx</code> 文档。请注意，与 <code>KMS / DRM</code> 不同，这些方法通常不允许从同一应用程序输出到多个屏幕。或者，驱动程序特定的环境变量或内核参数也可以用于控制所使用的帧缓冲区。</p>
<h2 id="视频内存"><a href="#视频内存" class="headerlink" title="视频内存"></a>视频内存</h2><p>具有固定数量的专用视频内存的系统在运行基于 Qt Quick 的 Qt 应用程序或类似 QOpenGLWidget 的类之前，可能需要特别注意。对于这样的应用，默认设置可能不足，特别是当它们以高分辨率（例如，全高清）屏幕显示时。在这种情况下，他们可能以意想不到的方式开始失败。建议确保至少有 128 MB 的 GPU 内存可用。对于没有为 GPU 保留的固定内存量的系统，这不是一个问题。</p>
<h2 id="linuxfb"><a href="#linuxfb" class="headerlink" title="linuxfb"></a>linuxfb</h2><p>使用 fbplugin 参数指定要使用的 framebuffer 设备。</p>
<h2 id="Unix-信号处理程序"><a href="#Unix-信号处理程序" class="headerlink" title="Unix 信号处理程序"></a>Unix 信号处理程序</h2><p>面向控制台的平台插件，如 eglfs 和 linuxfb 默认安装信号处理程序来捕获 interrupt（SIGINT），suspend 和 continue（SIGTSTP，SIGCONT）和 terminate（SIGTERM）。这样，当应用程序终止或由于 kill 或 Ctrl+C 或暂停时，可以恢复键盘，终端光标和可能的其他图形状态 Ctrl+Z。（尽管通过键盘终止或暂停只能在 QT_QPA_ENABLE_TERMINAL_KEYBOARD 设置时进行，如上面的“输入”部分所述）。然而，在某些情况下，捕获 SIGINT 可能是不合需要的，因为它可能会与远程调试冲突。因此，QT_QPA_NO_SIGNAL_HANDLER 提供环境变量以选择退出所有内置信号处理。</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Qt 通常用于 fontconfig 提供对系统字体的访问。如果 fontconfig 不可用，Qt 会回退使用 QBasicFontDatabase。在这种情况下，Qt 应用程序将在 Qt 的 lib&#x2F;fonts 目录中查找字体。Qt 会自动检测预渲染的字体和 TrueType 字体。可以通过设置 QT_QPA_FONTDIR 环境变量来覆盖此目录。</p>
<p>有关支持的格式的详细信息，请参阅嵌入式 Linux 字体的 Qt。</p>
<p>注意： Qt 不再在 lib&#x2F;fonts 目录中装载任何字体。这意味着由平台（系统映像）提供必要的字体。</p>
<h1 id="嵌入式-Linux-设备上的窗口系统的平台插件"><a href="#嵌入式-Linux-设备上的窗口系统的平台插件" class="headerlink" title="嵌入式 Linux 设备上的窗口系统的平台插件"></a>嵌入式 Linux 设备上的窗口系统的平台插件</h1><h2 id="XCB"><a href="#XCB" class="headerlink" title="XCB"></a>XCB</h2><p>这是常规桌面 Linux 平台上使用的 X11 插件。在一些嵌入式环境中，它为 Xcb 提供了 X 和必要的开发文件，这个插件就像在普通的 PC 桌面上一样。</p>
<p>注意：在某些设备上，由于 EGL 实现与 Xlib 不兼容，因此在 X 下没有 EGL 和 OpenGL 支持。在这种情况下，XCB 插件是在没有 EGL 支持的情况下构建的，这意味着 Qt Quick 2 或其他基于 OpenGL 的应用程序不适用于此平台插件。然而，仍然可以使用它来运行软件渲染的应用程序（例如基于 QWidget）。</p>
<p>作为一般规则，XCB 在嵌入式设备上的使用是不可取的。像 eglfs 这样的插件可能会提供更好的性能和硬件加速。</p>
<h2 id="Wayland"><a href="#Wayland" class="headerlink" title="Wayland"></a>Wayland</h2><p>Wayland 是一个重量轻的开窗系统; 或者更准确地说，它是用于客户端与显示服务器通信的协议。</p>
<p>Qt Wayland 模块提供了一个 wayland 平台插件，允许 Qt 应用程序连接到 Wayland 合成器。</p>
<p>注意：使用 Weston 参考合成器时，您可能会遇到触摸屏输入的问题。有关更多信息，请参阅 Qt Wiki。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>嵌入式介绍</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="嵌入式-linux-开发介绍"><a href="#嵌入式-linux-开发介绍" class="headerlink" title="嵌入式 linux 开发介绍"></a>嵌入式 linux 开发介绍</h1><h2 id="嵌入式系统简介"><a href="#嵌入式系统简介" class="headerlink" title="嵌入式系统简介"></a>嵌入式系统简介</h2><ul>
<li>一般定义<br>  以应用为中心、以计算机技术为基础、软件硬件可裁剪、适应应用系统，对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统</li>
<li>广义上讲<br>  凡是带有微处理器的专用软硬件系统都可称为嵌入式系统。</li>
</ul>
<p>嵌入式系统又分为多个模块部分</p>
<ul>
<li>ARM &#x3D;重视理论实践</li>
<li>系统移植 &#x3D;重视流程    </li>
<li>驱动 &#x3D;重视框架</li>
</ul>
<h2 id="嵌入式系统的组成"><a href="#嵌入式系统的组成" class="headerlink" title="嵌入式系统的组成"></a>嵌入式系统的组成</h2><ul>
<li><p>软件（linux，VXwork   +   应用程序） </p>
</li>
<li><p>硬件（C51，stm32， arm，mips powerpc  + DRAM  emmc  uart） 	</p>
</li>
<li><p>win<br>  BIOS  &#x3D;&gt;  win 系统&#x3D;&#x3D;&gt;   文件系统&#x2F;加载驱动   &#x3D;&#x3D;&gt;   应用程序</p>
</li>
<li><p>linux<br>  bootloader（引导程序） &#x3D;&#x3D;&gt;  linux 内核  &#x3D;&#x3D;&gt;  挂载文件系统&#x2F;驱动  &#x3D;&#x3D;&gt;  应用程序</p>
</li>
</ul>
<p>运行操作系统的优点：</p>
<ul>
<li>方便开发</li>
<li>将硬件与软件隔离（保护硬件）</li>
</ul>
<h2 id="嵌入式-linnux-系统移植做哪些工作"><a href="#嵌入式-linnux-系统移植做哪些工作" class="headerlink" title="嵌入式 linnux 系统移植做哪些工作"></a>嵌入式 linnux 系统移植做哪些工作</h2><p>产品升级（产品添加某些功能模块，产品裁剪了某些功能模块，A8 –》 A9</p>
<h1 id="嵌入式开发环境的搭建"><a href="#嵌入式开发环境的搭建" class="headerlink" title="嵌入式开发环境的搭建"></a>嵌入式开发环境的搭建</h1><p>采用的交叉开发模式，即编译和运行不在同一台主机上</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724828271000tutret.png" alt="gh"></p>
<h2 id="GCC-简介"><a href="#GCC-简介" class="headerlink" title="GCC 简介"></a>GCC 简介</h2><p>Gcc 的编译流程：</p>
<ul>
<li>预处理 gcc -E</li>
<li>编译 gcc -S</li>
<li>汇编 gcc -c</li>
<li>链接	     gcc</li>
</ul>
<h2 id="gcc-工具集"><a href="#gcc-工具集" class="headerlink" title="gcc 工具集"></a>gcc 工具集</h2><ul>
<li>readelf：功能：readelf 可以显示 elf 格式可执行文件的信息</li>
<li>size：功能：size 列出目标文件每一段的大小以及总体的大小</li>
<li>nm：功能：nm 可以列出目标文件中的符号。	</li>
<li>strip 功能：strip 用来丢弃目标文件中的全部或者特定符号，减小文件体积。对于嵌入式系统，这个命令必不可少。</li>
<li>objcopy：功能：objcopy 可以进行目标文件格式转换 objcopy -O binary hello  hello.bin objcopy -O binary u-boot u-boot.bin</li>
<li>objdump: 功能：反汇编 objdump -d hello  objdump -d hello &gt; hello.dis</li>
<li>addr2line 功能：addr2line 能够把程序地址转换为文件名和行号，前提是这个可执行文件包括调试符号。</li>
</ul>
<h2 id="安装交叉编译工具链"><a href="#安装交叉编译工具链" class="headerlink" title="安装交叉编译工具链"></a>安装交叉编译工具链</h2><ul>
<li>解压 gcc-4.6…   到 tootchain</li>
<li>配置环境变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/bash.bashrc </span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:/home/linux/toolchain/gcc<span class="number">-4.6</span><span class="number">.4</span>/bin/ </span><br></pre></td></tr></table></figure>

<ul>
<li>重启 source &#x2F;etc&#x2F;bash.bashrc</li>
<li>测试 arm-none-linux-gnueabi-gcc –v</li>
</ul>
<h2 id="TFTP-服务器的安装和配置"><a href="#TFTP-服务器的安装和配置" class="headerlink" title="TFTP 服务器的安装和配置"></a>TFTP 服务器的安装和配置</h2><p>tftp 是用来下载远程文件最简单的网络协议</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/17248283040004sf8cs.png" alt="gh"></p>
<ul>
<li>修改配置文件，开启 tftp 服务</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/<span class="keyword">default</span>/tftp-hapa</span><br></pre></td></tr></table></figure>

<p>修改成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TFTP_USERNAME=<span class="string">&quot;tftp&quot;</span> </span><br><span class="line">TFTP_DIRECTORY=<span class="string">&quot;/tftpboot&quot;</span>   <span class="comment">//指定tftp服务器的目录，将来要下载东西都是从这个目录下下载，需自行创建，然后修改权限为777</span></span><br><span class="line">TFTP_ADDRESS=<span class="string">&quot;0.0.0.0:69&quot;</span>    <span class="comment">//69： tftp  专有的端口</span></span><br><span class="line">TFTP_OPTIONS=<span class="string">&quot;-c  -s  -l&quot;</span>    <span class="comment">//man tftpd可查看各个选项的含义</span></span><br><span class="line"><span class="comment">//-c：表示可以在服务器目录下（/tftpboot）下创建新文件，默认不能创建新文件，只能修改或覆盖</span></span><br><span class="line"><span class="comment">//-s: 改变 tftp 启动的根目录，也就是客户端在使用 tftp 时不需要输入/tftpboot 目录</span></span><br><span class="line"><span class="comment">//-l：表示以监听模式启动 tftp 服务器</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建服务器的根目录&#x2F;tftpboot</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo mkdir /tftpboot</span><br><span class="line">chmod <span class="number">777</span> /tftpboot -R</span><br></pre></td></tr></table></figure>

<ul>
<li>重启 tftp 服务器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo service tftpd-hpa restart</span><br></pre></td></tr></table></figure>

<ul>
<li>登录本机进行测试</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tftp localhost 或者 tftp <span class="number">192.168</span><span class="number">.1</span><span class="number">.111</span> 或者 tftp <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">tftp&gt; get xxx    <span class="comment">//从服务器（/tftpboot 目录）下载文件名为 XXX 的文件</span></span><br><span class="line">tftp&gt; put xxx         <span class="comment">//xxx 为你想要往服务器（/tftpboot 目录）发送的文件</span></span><br><span class="line">tftp&gt; q                   <span class="comment">//q 表示退出</span></span><br></pre></td></tr></table></figure>

<h2 id="nfs-服务器的安装和配置"><a href="#nfs-服务器的安装和配置" class="headerlink" title="nfs 服务器的安装和配置"></a>nfs 服务器的安装和配置</h2><p>nfs 主要用来进行目录的共享（把本地的一个目录通过网络导出，其他设备可以远程访问该目录），我们的测试程序不用通过下载到目标板，目标机可以通过共享目录访问，提高开发效率。</p>
<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/<span class="keyword">export</span></span><br></pre></td></tr></table></figure>

<p>在最后一行添加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/source/rootfs *(rw,sync,no_subtree_check,no_root_squash)</span><br><span class="line"><span class="comment">///source/rootfs 是指定的共享目录，需自己创建</span></span><br><span class="line"><span class="comment">//rw：具有读写权限</span></span><br><span class="line"><span class="comment">//sync：文件同步</span></span><br><span class="line"><span class="comment">//no_subtree_check: 如果共享子目录，则不检查父目录的权限</span></span><br><span class="line"><span class="comment">//no_root_squash: 如果客户端为 root 用户，则它对此目录有 root 权限</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重启 nfs 服务</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo service nfs-kernel-server restart</span><br></pre></td></tr></table></figure>

<ul>
<li>创建共享目录 <code>mkdir /source/rootfs</code></li>
</ul>
<h2 id="ubuntu-的网络配置"><a href="#ubuntu-的网络配置" class="headerlink" title="ubuntu 的网络配置"></a>ubuntu 的网络配置</h2><p>配置虚拟机 IP（桥接），设置 IP 地址，&#96;sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces&#96;&#96;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> eth0</span><br><span class="line">iface eth0 inet <span class="type">static</span></span><br><span class="line">address <span class="number">192.168</span><span class="number">.1</span><span class="number">.111</span></span><br><span class="line">netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">gateway <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> </span><br></pre></td></tr></table></figure>

<p>设置 DNS，<code>sudo vi /etc/resolv.conf </code> 在最后一行添加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nameserver <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<p>重启网络服务</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>

<h1 id="开发环境测试"><a href="#开发环境测试" class="headerlink" title="开发环境测试"></a>开发环境测试</h1><h2 id="SD-启动盘制作和-u-boot-的烧写"><a href="#SD-启动盘制作和-u-boot-的烧写" class="headerlink" title="SD 启动盘制作和 u-boot 的烧写"></a>SD 启动盘制作和 u-boot 的烧写</h2><h3 id="制作-SD-卡"><a href="#制作-SD-卡" class="headerlink" title="制作 SD 卡"></a>制作 SD 卡</h3><p>目的：通过 SD 卡烧写 uboot 到开发板上</p>
<h3 id="烧写-uboot-到-emmc-上"><a href="#烧写-uboot-到-emmc-上" class="headerlink" title="烧写 uboot 到 emmc 上"></a>烧写 uboot 到 emmc 上</h3><ul>
<li>连接串口和板子，运行串口通信程序(putty 第一天工具中)</li>
<li>关闭开发板电源，将拨码开关 SW1 调至(1000)(SD 启动模式)后打开电源</li>
<li>将刚才做好的 SD 启动盘插入 SD 卡插槽</li>
<li>倒计时按下任意键，进入 uboot 界面</li>
<li>烧写<ul>
<li>在终端上执行 <code>sdfuse flashall</code></li>
<li>等待终端无输出是表示烧写结束</li>
</ul>
</li>
</ul>
<h1 id="从网络下载内核、设备树，并挂载文件系统"><a href="#从网络下载内核、设备树，并挂载文件系统" class="headerlink" title="从网络下载内核、设备树，并挂载文件系统"></a>从网络下载内核、设备树，并挂载文件系统</h1><h2 id="如何把服务器（ubuntu-中的-tftpboot-目录）下的内核和设备树下载到开发板？"><a href="#如何把服务器（ubuntu-中的-tftpboot-目录）下的内核和设备树下载到开发板？" class="headerlink" title="如何把服务器（ubuntu 中的&#x2F;tftpboot 目录）下的内核和设备树下载到开发板？"></a>如何把服务器（ubuntu 中的&#x2F;tftpboot 目录）下的内核和设备树下载到开发板？</h2><ul>
<li>将你要下载的东西放到服务器目录下。<ul>
<li>拷贝 uImage、exynos4412-fs4412.dtb 到 ubuntu 的&#x2F;tftpboot 目录下。</li>
</ul>
</li>
<li>将第一天&#x2F;镜像文件&#x2F;rootfs.tar.xz 拷贝到 ubuntu 的 &#x2F;source 下并解压</li>
<li>开发板启动，在 u-boot 界面(倒计时按下任意键)进行下载。<ul>
<li>Ubuntu IP: 192.168.9.120 </li>
<li>开发板 IP: 192.168.9.233</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#setenv serverip 192.168.9.120</span></span><br><span class="line"><span class="meta">#setenv ipaddr 192.168.9.233</span></span><br><span class="line"><span class="meta">#setenv bootcmd tftp 41000000 uImage\;tftp 42000000 exynos4412-fs4412.dtb\;bootm 41000000 - 42000000 console=ttySAC2,115200 init=/linuxrc ip=192.168.9.233</span></span><br><span class="line"><span class="meta">#saveenv</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重启开发板</li>
</ul>
<h1 id="从-EMMC-加载内核和文件系统"><a href="#从-EMMC-加载内核和文件系统" class="headerlink" title="从 EMMC 加载内核和文件系统"></a>从 EMMC 加载内核和文件系统</h1><h2 id="烧写镜像到-emmc-中"><a href="#烧写镜像到-emmc-中" class="headerlink" title="烧写镜像到 emmc 中"></a>烧写镜像到 emmc 中</h2><h2 id="设置启动参数，从-emmc-加载镜像"><a href="#设置启动参数，从-emmc-加载镜像" class="headerlink" title="设置启动参数，从 emmc 加载镜像"></a>设置启动参数，从 emmc 加载镜像</h2>]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>平台环境搭建</title>
    <url>/2024/06/14/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%B9%B3%E5%8F%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="镜像烧录"><a href="#镜像烧录" class="headerlink" title="镜像烧录"></a>镜像烧录</h1><p>选用镜像为 Ubuntu18.04，分为 ARMV7 版本和 ARMV8 版本</p>
<h2 id="分区扩展"><a href="#分区扩展" class="headerlink" title="分区扩展"></a>分区扩展</h2><p>由于 emmc 给定的分区太小，需要对文件系统分区的大小进行扩容操作</p>
<p>ext4 格式的文件， 制作一个大于 6GB 的 EXT4 空文件, 由于安装的软件较多时，文件系统会很大，可以根据情况自行更改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=/dev/zero of=ubuntu18_rootfs.ext4 bs=<span class="number">1500</span>M count=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>将新建的 <code>ubuntu18_rootfs.ext4</code> 文件格式化为 <code>ext4</code> 格式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo mkfs.ext4 ubuntu18_rootfs.ext4</span><br></pre></td></tr></table></figure>

<p>新建一个临时的文件夹 <code>rootfs_tmp</code>,将 <code>ubuntu18_rootfs.ext4</code> 文件挂载到临时目录 <code>rootfs_tmp</code>,并拷贝文件系统。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mkdir -p rootfs_tmp</span><br><span class="line">sudo mount -o loop ubuntu18_rootfs.ext4 ./rootfs_tmp</span><br><span class="line">sudo cp -avrf ./ubuntu-rootfs<span class="comment">/* ./</span></span><br></pre></td></tr></table></figure>

<p>拷贝完后，卸载挂载的 <code>ubuntu18_rootfs.ext4</code> 文件，即完成了文件系统的制作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo umount ./rootfs_tmp</span><br></pre></td></tr></table></figure>

<p><code>ubuntu18_rootfs.ext4</code> 就是可以用于下载的。</p>
<p><code>SD</code> 卡启动 <code>101</code></p>
<p><code>EMMC</code> 启动 <code>010</code></p>
<p>列出 USB 设备</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~/STMicroelectronics/STM32Cube/STM32CubeProgrammer/bin/STM32_Programmer_CLI -l usb</span><br></pre></td></tr></table></figure>

<p>烧录</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~/STMicroelectronics/STM32Cube/STM32CubeProgrammer/bin/STM32_Programmer_CLI -c port=usb1 -w ./flashlayout_myir-image-ubuntu18/trusted/FlashLayout_sdcard_stm32mp157c-ya157c<span class="number">-512</span>d-v2-ubuntu18.tsv </span><br></pre></td></tr></table></figure>

<h1 id="磁盘空间扩展-扩容"><a href="#磁盘空间扩展-扩容" class="headerlink" title="磁盘空间扩展&#x2F;扩容"></a>磁盘空间扩展&#x2F;扩容</h1><ol>
<li>安装相关工具并查看当前分区情况，<code>parted</code> 是硬盘分区工具，这里用来查看磁盘分区情况，按需删除不需要的分区，以及扩展分区容量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt intall -y parted resize2fs</span><br><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除分区</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 进入 parted 工具</span><br><span class="line">$ sudo parted /dev/mmcblk1</span><br><span class="line"># 查看分区编号</span><br><span class="line">(parted) print</span><br><span class="line"># 如果该分区后面有分区的话，删除该分区</span><br><span class="line">(parted) rm <span class="number">8</span></span><br><span class="line"># 再次查看分区</span><br><span class="line">(parted) print</span><br><span class="line"># 删除扩展分区</span><br><span class="line">(parted) rm <span class="number">7</span></span><br><span class="line"># 保存更改并退出</span><br><span class="line">(parted) quit</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>增加分区</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 进入 parted 工具</span><br><span class="line">$ sudo parted /dev/mmcblk1</span><br><span class="line"># 查看磁盘信息</span><br><span class="line">(parted) print</span><br><span class="line"># 直接扩展分区</span><br><span class="line">(parted)resizepart <span class="number">6</span></span><br><span class="line"># 这里输入的数值，就是上方输出中 End: 后方的数值</span><br><span class="line">End?  [<span class="number">9713</span>MB]? <span class="number">21.5</span>GB</span><br><span class="line"># 扩展完成之后退出 <span class="built_in">parted</span></span><br><span class="line">(parted) quit</span><br><span class="line">#此时分区容量已经扩展完成了，但是文件系统还未识别扩展的容量，所以扩展的容量还没法使用。下面扩展一下已经重新分区的文件系统</span><br><span class="line">$ sudo resize2fs /dev/mmcblk1p6</span><br><span class="line">#此时不出意外的话应该扩容完成了，可以使用 df -h 来查看容量。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202406210924039.jpg" alt="1718933040093.jpg"></p>
<h1 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h1><ol>
<li><p>当前目录按照空间使用大小排序(-h 参数，按 MB 显示)<br><code>sudo du  -s * |  sort  -nr</code></p>
</li>
<li><p>磁盘按照空间使用大小排序(-h 参数，按 MB 显示)<br><code>df -h</code></p>
</li>
<li><p>磁盘空间整理<br><code>apt-get clean</code> 把安装的软件的备份也删除，不会影响软件使用。</p>
</li>
</ol>
<p><em>挂载 SD 卡到开发板上，由于磁盘空间不足，安装位置设置挂载目录为主目录，指定 <code>HOME=/mnt</code>，打印 <code>echo $HOME</code> 确认已经成功设置</em></p>
<ol start="4">
<li><p>磁盘格式化<br><code>mkfs.ext4 /dev/mmcblk1</code></p>
</li>
<li><p>磁盘新建分区<br><code>fdisk /dev/mmcblk1</code> 进入磁盘管理，输入 F 查询当前磁盘剩余未分区内容</p>
</li>
</ol>
<h1 id="SD-卡自动挂载"><a href="#SD-卡自动挂载" class="headerlink" title="SD 卡自动挂载"></a><del>SD 卡自动挂载</del></h1><p>编译 <code>/etc/fstab</code> 文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/dev/mmcblk1p1 /mnt/sdcard vfat rw,relatime,fmask=<span class="number">0000</span>,dmask=<span class="number">0000</span>,codepage=<span class="number">437</span>,iocharset=iso8859<span class="number">-1</span>,shortname=mixed,errors=remount-ro <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h1><p><em>利用 <code>Win32DiskImager-1.0.0-binary</code> 烧录 <code>SD</code> 后发现没有无线网卡驱动，<code>ko</code> 格式不兼容，待测试验证</em><br><em>换个镜像用 <code>stmcubeProgram</code> 烧录后问题解决</em></p>
<h2 id="WIFI"><a href="#WIFI" class="headerlink" title="WIFI"></a>WIFI</h2><ol>
<li>启动 wlan0<br><code>sudo ifconfig wlan0 up</code></li>
</ol>
<p><em>启动时提示 <code>SIOCSIFFLAGS: Operation not possible due to RF-kill</code>，利用 <code>rfkill list</code>，查看 <code>Wireless LAN</code> 是否被软件阻止 <code>Soft blocked: yes</code>，然后输入 <code>sudo rfkill unblock wifi</code> 解开，并输入 <code>rfkill list</code> 确认状态。之后在执行上述语句，启动 <code>wlan0</code>。</em></p>
<ol start="2">
<li>扫描 Wifi，<strong>需要在 2.4GHz 频段</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo iw dev wlan0 scan | grep SSID</span><br><span class="line">sudo iwlist wlan0 scanning | grep SSID</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置 Wifi 配置</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#生成配置文件</span><br><span class="line">sudo wpa_passphrase lemonade <span class="number">12245612</span> &gt;&gt; ./wifi.conf</span><br><span class="line">#关闭wpa_supplicant</span><br><span class="line">sudo killall wpa_supplicant</span><br><span class="line">#初始化 wpa_supplicant</span><br><span class="line">#	   -D  指定驱动名称</span><br><span class="line">#      -B  在后台运行守护进程</span><br><span class="line">#      -c  配置信息的路径</span><br><span class="line">#      -i  监听的wifi接口</span><br><span class="line">sudo wpa_supplicant -B -Dnl80211 -c./wifi.conf -iwlan0</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>设置 DHCP</li>
</ol>
<ul>
<li>利用 udhcpc 自动获取<br><code>udhcpc -i wlan0</code></li>
</ul>
<ul>
<li>编辑配置文件自动获取 IP<br><code>sudo vi /etc/systemd/network/wlan0.network</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[Match]</span><br><span class="line">Name=wlan0</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">DHCP=yes</span><br></pre></td></tr></table></figure>

<p>编辑完成后重启服务，<code>systemctl restart systemd-networkd</code></p>
<ul>
<li>利用 dhclient 自动获取</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#释放租约</span><br><span class="line">sudo dhclient -r wlan0</span><br><span class="line">#重新获取租约</span><br><span class="line">sudo dhclient wlan0</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>需要设置 DNS 服务<br><code>echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/resolv.conf</code></p>
</li>
<li><p>查看网卡信息<br><code>ip addr show wlan0</code></p>
</li>
<li><p>测试网络连通性<br><code>ping 360.com</code></p>
</li>
</ol>
<h2 id="有线"><a href="#有线" class="headerlink" title="有线"></a>有线</h2><p>设置有线网络的 IP 地址自动获取</p>
<h1 id="软件源配置"><a href="#软件源配置" class="headerlink" title="软件源配置"></a>软件源配置</h1><p>编辑源配置文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<h2 id="ubuntu-18-04-for-arm-清华源配置"><a href="#ubuntu-18-04-for-arm-清华源配置" class="headerlink" title="ubuntu 18.04 for arm 清华源配置"></a>ubuntu 18.04 for arm 清华源配置</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span></span><br><span class="line"><span class="meta"># deb-src https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span></span></span><br><span class="line">deb https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"><span class="meta"># deb-src https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span></span></span><br><span class="line">deb https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"><span class="meta"># deb-src https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span></span></span><br><span class="line">deb https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span></span><br><span class="line"><span class="meta"># deb-src https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span></span></span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"><span class="meta"># deb https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span></span></span><br><span class="line"><span class="meta"># deb-src https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span></span></span><br></pre></td></tr></table></figure>

<h2 id="ubuntu-18-04-for-arm-中科大源配置"><a href="#ubuntu-18-04-for-arm-中科大源配置" class="headerlink" title="ubuntu 18.04 for arm 中科大源配置"></a>ubuntu 18.04 for arm 中科大源配置</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial main multiverse restricted universe</span></span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial-backports main multiverse restricted universe</span></span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial-proposed main multiverse restricted universe</span></span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial-security main multiverse restricted universe</span></span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial-updates main multiverse restricted universe</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial main multiverse restricted universe</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial-backports main multiverse restricted universe</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial-proposed main multiverse restricted universe</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial-security main multiverse restricted universe</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.ustc.edu.cn/ubuntu-ports/ xenial-updates main multiverse restricted universe</span></span><br></pre></td></tr></table></figure>

<h1 id="更新-python-版本"><a href="#更新-python-版本" class="headerlink" title="更新 python 版本"></a>更新 python 版本</h1><p><em>armv7 上使用 python3.8 安装时依赖包编译不通过，版</em></p>
<ol>
<li>安装 Python3.8，并查看安装路径</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install python3<span class="number">.8</span></span><br><span class="line">which python3<span class="number">.8</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>为了方便使用，建议创建软连接，首先把之前的软连接删除：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /usr/bin/python3</span><br><span class="line">sudo rm -rf /usr/bin/pip3</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建 python3 和 pip3 的软连接：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo ln -s  <span class="string">&quot;Python3Path&quot;</span> /usr/bin/python3</span><br><span class="line">sudo ln -s  <span class="string">&quot;Python3Path&quot;</span> /usr/bin/pip3</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>更换 pip 地址<br><a href="source/_posts/1.%E8%AF%AD%E8%A8%80/Python/pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.md">pip下载网络问题</a></li>
</ol>
<h1 id="网络问题导致无法-clone"><a href="#网络问题导致无法-clone" class="headerlink" title="网络问题导致无法 clone"></a>网络问题导致无法 clone</h1><ol>
<li><p>在主机的浏览器上登录 github 下载 klipper 和 moonrarker 的压缩包，到开发板上解压</p>
</li>
<li><p>解压后，修改 kiauh 中的 klipper .sh 和 moonrarker.sh 中指定的目录位置，文件夹的名称及路径设置为脚本中的名称和路径</p>
</li>
</ol>
<h1 id="WIFI-配置脚本"><a href="#WIFI-配置脚本" class="headerlink" title="WIFI 配置脚本"></a>WIFI 配置脚本</h1><p>Wifi 连接脚本，执行 <code>ifup_wifi_sta.sh -ssid Lemonade -passwd 12345678</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env sh</span><br><span class="line">#File: /usr/bin/ifup_wifi_sta.sh</span><br><span class="line">SSID=</span><br><span class="line">PASSWD=</span><br><span class="line">WLAN=wlan0</span><br><span class="line">WPA_FILE=/etc/wpa_supplicant.conf</span><br><span class="line">DRIVER_NAME=nl80211</span><br><span class="line"></span><br><span class="line"><span class="built_in">usage</span>()&#123;</span><br><span class="line">	echo <span class="string">&quot;Usage: ./ifup_wifi_sta [-ssid wifi_sta_name] [-passwd wifi_sta_passwd] [-driver nl80211 or wext]&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">clean_stage</span>()&#123;</span><br><span class="line">	killall udhcpc</span><br><span class="line">	killall wpa_supplicant</span><br><span class="line">	killall hostapd</span><br><span class="line">	killall udhcpd</span><br><span class="line">	sleep <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enable_wifi</span>()&#123;</span><br><span class="line">	T_HCI=<span class="string">&quot;phy0&quot;</span></span><br><span class="line">	RFKILL_SYS_PATH=<span class="string">&quot;/sys/class/rfkill/&quot;</span></span><br><span class="line">	dir=`ls $&#123;RFKILL_SYS_PATH&#125;`</span><br><span class="line">	<span class="keyword">for</span> i in$&#123;dir&#125;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> [ $&#123;T_HCI&#125; == `cat $&#123;RFKILL_SYS_PATH&#125;$&#123;i&#125;/name` ];then</span><br><span class="line">			echo <span class="number">0</span> &gt; $&#123;RFKILL_SYS_PATH&#125;$&#123;i&#125;/state</span><br><span class="line">			echo <span class="string">&quot;find$&#123;T_HCI&#125; enable it&quot;</span></span><br><span class="line">			sleep <span class="number">1</span></span><br><span class="line">			echo <span class="number">1</span> &gt;$&#123;RFKILL_SYS_PATH&#125;$&#123;i&#125;/state</span><br><span class="line">		fi</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">parse_input_info</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span> [ $# -gt <span class="number">0</span> ];<span class="keyword">do</span></span><br><span class="line">		<span class="keyword">case</span> $<span class="number">1</span> in</span><br><span class="line">			-ssid)</span><br><span class="line">			SSID=<span class="string">&quot;$2&quot;</span></span><br><span class="line">			shift</span><br><span class="line">			;;</span><br><span class="line">			-passwd)</span><br><span class="line">			PASSWD=<span class="string">&quot;$2&quot;</span></span><br><span class="line">			<span class="keyword">if</span> [ $&#123;#PASSWD&#125; -lt <span class="number">8</span> ];then</span><br><span class="line">				echo <span class="string">&quot;passwd should be 8...64&quot;</span></span><br><span class="line">				exit</span><br><span class="line">			fi</span><br><span class="line">			shift</span><br><span class="line">			;;</span><br><span class="line">			-driver)</span><br><span class="line">			DRIVER_NAME=<span class="string">&quot;$2&quot;</span></span><br><span class="line">			shift</span><br><span class="line">			;;</span><br><span class="line">			-h)</span><br><span class="line">			usage</span><br><span class="line">			exit</span><br><span class="line">			;;</span><br><span class="line">		esac</span><br><span class="line">		shift $(( $# &gt; <span class="number">0</span>? <span class="number">1</span>:<span class="number">0</span>))</span><br><span class="line">	done</span><br><span class="line">	echo <span class="string">&quot;SSID:$&#123;SSID&#125; PASSWD:$&#123;PASSWD&#125;DRIVER:$&#123;DRIVER_NAME&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect_wifi</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span> [ -n <span class="string">&quot;$&#123;SSID&#125;&quot;</span> ];then</span><br><span class="line">		head -n4 $&#123;WPA_FILE&#125; &gt; $&#123;WPA_FILE&#125;.tmp</span><br><span class="line">		wpa_passphrase $&#123;SSID&#125; $&#123;PASSWD&#125;&gt;&gt;$&#123;WPA_FILE&#125;.tmp</span><br><span class="line">		mv $&#123;WPA_FILE&#125; $&#123;WPA_FILE&#125;.bak</span><br><span class="line">		mv $&#123;WPA_FILE&#125;.tmp $&#123;WPA_FILE&#125;</span><br><span class="line">	fi</span><br><span class="line">	wpa_supplicant -B -i$&#123;WLAN&#125; -c$&#123;WPA_FILE&#125; -D$&#123;DRIVER_NAME&#125; &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">obtain_dns</span>()&#123;</span><br><span class="line">	time=<span class="number">10</span></span><br><span class="line">	<span class="keyword">while</span> [ $time -gt <span class="number">0</span> ];<span class="keyword">do</span></span><br><span class="line">		state=`wpa_cli -i$&#123;WLAN&#125; -p/var/run/wpa_supplicant status | grepwpa_state | awk -F[=] <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line">		<span class="keyword">if</span> [ <span class="string">&quot;$&#123;state&#125;&quot;</span>=<span class="string">&quot;COMPLETED&quot;</span> ];then</span><br><span class="line">			udhcpc-i $&#123;WLAN&#125;</span><br><span class="line">			exit</span><br><span class="line">		fi</span><br><span class="line">		let time -= <span class="number">1</span></span><br><span class="line">		sleep <span class="number">1</span></span><br><span class="line">	done</span><br><span class="line">	echo <span class="string">&quot;connectwifi error&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">parse_input_info $@</span><br><span class="line">clean_stage</span><br><span class="line">enable_wifi</span><br><span class="line">connect_wifi</span><br><span class="line">obtain_dns</span><br></pre></td></tr></table></figure>

<h1 id="自启动脚本配置"><a href="#自启动脚本配置" class="headerlink" title="自启动脚本配置"></a>自启动脚本配置</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="comment"># root@ok3568:/home/forlinx# cat /etc/systemd/system/startfrp.service</span></span><br><span class="line"><span class="comment"># [Unit]</span></span><br><span class="line"><span class="comment"># Description=startfrp</span></span><br><span class="line"><span class="comment"># Requires=network-online.target</span></span><br><span class="line"><span class="comment"># After=network-online.target</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [Install]</span></span><br><span class="line"><span class="comment"># WantedBy=multi-user.target</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [Service]</span></span><br><span class="line"><span class="comment"># Type=simple</span></span><br><span class="line"><span class="comment"># User=root</span></span><br><span class="line"><span class="comment"># RemainAfterExit=yes</span></span><br><span class="line"><span class="comment"># ExecStart=/home/forlinx/S99Startfrp.sh</span></span><br><span class="line"><span class="comment"># Restart=always</span></span><br><span class="line"><span class="comment"># RestartSec=10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标地址用于检查网络连接，这里使用的是 Google 的公共 DNS 服务器</span></span><br><span class="line">TARGET=8.8.8.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查以太网接口</span></span><br><span class="line"><span class="function"><span class="title">check_ethernet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> interface=<span class="variable">$1</span></span><br><span class="line">    <span class="keyword">if</span> ethtool <span class="variable">$interface</span> | grep -q <span class="string">&#x27;Link detected.*: yes&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Ethernet interface <span class="variable">$interface</span> is connected.&quot;</span></span><br><span class="line">        <span class="comment">#释放mlan0接口当前通过DHCP获得的IP地址租约。-r选项代表“release”，即释放已有租约。</span></span><br><span class="line">		<span class="comment">#请求一个新的IP地址租约。通过DHCP协议获取一个新的IP地址配置，包括IP地址、子网掩码、默认网关以及DNS服务器地址等信息。</span></span><br><span class="line">        dhclient -r <span class="variable">$interface</span> &amp;&amp; dhclient <span class="variable">$interface</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Ethernet interface <span class="variable">$interface</span> is NOT connected.&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测无线网络并连接（注意：此部分涉及安全信息，请谨慎处理）</span></span><br><span class="line"><span class="function"><span class="title">connect_wireless</span></span>() &#123;</span><br><span class="line">	wpa_passphrase lemonade 12245612 &gt;&gt; ./wifi.conf</span><br><span class="line">	killall wpa_supplicant</span><br><span class="line">	wpa_supplicant -B -Dnl80211 -cwifi.conf -imlan0</span><br><span class="line">	<span class="built_in">rm</span> ./wifi.conf</span><br><span class="line">	<span class="comment">#udhcpc -i mlan0</span></span><br><span class="line">	dhclient -r mlan0</span><br><span class="line">	dhclient mlan0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络检查函数，ping 目标地址，如果成功返回 0，否则返回 1</span></span><br><span class="line"><span class="function"><span class="title">check_network</span></span>() &#123;</span><br><span class="line">	<span class="built_in">sleep</span> 1</span><br><span class="line">	ping -c 1 <span class="variable">$TARGET</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">	<span class="built_in">return</span> $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序开始</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Checking Ethernet interfaces...&quot;</span></span><br><span class="line">check_ethernet eth0</span><br><span class="line">check_ethernet eth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接无线网络柠檬水，这里仅作为示例，请勿直接使用明文密码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Attempting to connect to wireless network &#x27;lemonade&#x27;...&quot;</span></span><br><span class="line">iwlist wlan0 scanning | grep SSID</span><br><span class="line">connect_wireless</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查网络是否连接</span></span><br><span class="line"><span class="keyword">if</span> check_network; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Network is connected. Executing commands...&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 执行 insmod 命令</span></span><br><span class="line">	/sbin/insmod /home/forlinx/ch341.ko</span><br><span class="line">	<span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Failed to execute insmod command&quot;</span></span><br><span class="line">		<span class="built_in">exit</span> 1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 执行 frpc 命令</span></span><br><span class="line">	/home/forlinx/frp_0.58.1_linux_arm64/frpc -c /home/forlinx/frp_0.58.1_linux_arm64/frpc.toml &amp;</span><br><span class="line">	<span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Failed to execute frpc command&quot;</span></span><br><span class="line">		<span class="built_in">exit</span> 1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Commands executed successfully&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Network is not connected. Exiting...&quot;</span></span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>构建工具的简要介绍</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<ul>
<li>make</li>
<li>cmake</li>
<li>qmake</li>
<li>meson</li>
<li>buildroot</li>
<li>yocto</li>
</ul>
<p>Buildroot 和 Yocto 是常用的嵌入式 Linux 系统构建工具，各自具有独特的特点和适用场景。</p>
<p>Meson 与 Buildroot 和 Yocto 不同，它主要关注构建过程的效率和简化，而不是整个系统的构建。</p>
<h2 id="Meson"><a href="#Meson" class="headerlink" title="Meson"></a>Meson</h2><p>Meson 是一个现代化的构建系统，旨在提高构建速度和可维护性。它使用简单的语法，支持多种编程语言，特别适合大型项目。Meson 的特点包括：</p>
<ul>
<li><strong>快速构建</strong>：通过并行构建和增量构建，Meson 能够显著减少构建时间。</li>
<li><strong>易于使用</strong>：其配置文件使用简单的语法，易于理解和维护。</li>
<li><strong>跨平台支持</strong>：Meson 支持多种平台和编译器，适合多种开发环境。</li>
</ul>
<h2 id="Buildroot"><a href="#Buildroot" class="headerlink" title="Buildroot"></a>Buildroot</h2><p>Buildroot 是一个简单高效的工具，用于生成嵌入式 Linux 系统。它通过 Makefile 和 Kconfig 配置系统，支持交叉编译，能够快速构建精简的 Linux 系统。Buildroot 的主要特点包括：</p>
<ul>
<li><strong>简单易用</strong>：使用类似 Linux 内核的配置界面（如 menuconfig），用户可以快速配置和构建系统，通常只需 15-30 分钟即可完成基本系统的构建。</li>
<li><strong>高效性</strong>：适合资源有限的环境，特别是需要快速迭代的项目。它提供了丰富的包配置，支持多种库和应用程序。</li>
<li><strong>构建时间短</strong>：由于其构建过程相对简单，Buildroot 的构建时间通常比 Yocto 要短。</li>
<li><strong>适用场景</strong>：适合小型项目和需要快速原型开发的情况</li>
</ul>
<h2 id="Yocto"><a href="#Yocto" class="headerlink" title="Yocto"></a>Yocto</h2><p>Yocto Project 是一个开源项目，旨在为嵌入式 Linux 开发者提供创建自定义 Linux 系统的工具和模板。其特点包括：</p>
<ul>
<li><strong>高度定制化</strong>：Yocto 支持复杂的依赖关系和层次结构，适合需要高度定制和复杂功能的大型项目。</li>
<li><strong>强大的构建系统</strong>：使用 BitBake 作为构建引擎，能够处理复杂的构建任务，提供丰富的开源支持。</li>
<li><strong>灵活性</strong>：Yocto 允许开发者根据不同的硬件和软件需求，创建适合特定应用的 Linux 版本。</li>
<li><strong>适用场景</strong>：适合需要支持多个硬件平台和复杂软件栈的项目</li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>测量语句运行时间</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%B5%8B%E9%87%8F%E8%AF%AD%E5%8F%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>测量一个事件持续的时间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “stdio.h”</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “stdlib.h”</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “time.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> i = <span class="number">10000000L</span>;</span><br><span class="line">	<span class="type">clock_t</span> start, finish;</span><br><span class="line">	<span class="type">double</span> Total_time;</span><br><span class="line">	<span class="comment">/* 测量一个事件持续的时间*/</span></span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;Time to do %ld empty loops is &quot;</span>, i );</span><br><span class="line">	</span><br><span class="line">	start = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="keyword">while</span>( i--) ;</span><br><span class="line">	finish = <span class="built_in">clock</span>();</span><br><span class="line">	</span><br><span class="line">	Total_time = (<span class="type">double</span>)(finish-start) / CLOCKS_PER_SEC;</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;%f seconds/n&quot;</span>, Total_time);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>随手记</title>
    <url>/2024/07/12/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E9%9A%8F%E6%89%8B%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MIPI-接口的含义"><a href="#MIPI-接口的含义" class="headerlink" title="MIPI 接口的含义"></a>MIPI 接口的含义</h1><blockquote>
<p>MIPI 中的 DSI 和 CSI</p>
</blockquote>
<ul>
<li>显示 <code>DSI = display</code> </li>
<li>摄像头 <code>CSI = camera</code></li>
</ul>
<h1 id="设备树中的标识符"><a href="#设备树中的标识符" class="headerlink" title="设备树中的标识符"></a>设备树中的标识符</h1><blockquote>
<p>设备树中的</p>
</blockquote>
<ul>
<li>&amp; 引用节点</li>
<li>@ 指定设备地址</li>
</ul>
<h1 id="串口设备树配置"><a href="#串口设备树配置" class="headerlink" title="串口设备树配置"></a>串口设备树配置</h1><blockquote>
<p>串口的硬流控和软流控</p>
</blockquote>
<h1 id="linux-查看版本"><a href="#linux-查看版本" class="headerlink" title="linux 查看版本"></a>linux 查看版本</h1><blockquote>
<p>lsb_release -a</p>
</blockquote>
<h1 id="gpu-信息及使用率查看"><a href="#gpu-信息及使用率查看" class="headerlink" title="gpu 信息及使用率查看"></a>gpu 信息及使用率查看</h1><blockquote>
<p>clinfo 查看 gpu 信息</p>
</blockquote>
<h1 id="查看-gpu-使用率"><a href="#查看-gpu-使用率" class="headerlink" title="查看 gpu 使用率"></a>查看 gpu 使用率</h1><blockquote>
<p>cat &#x2F;sys&#x2F;devices&#x2F;ffa30000.gpu&#x2F;dvfs </p>
</blockquote>
<h1 id="修改-IP"><a href="#修改-IP" class="headerlink" title="修改 IP"></a>修改 IP</h1><p><code>vi /etc/network/interfaces.d/eno0</code></p>
<h1 id="修改网关"><a href="#修改网关" class="headerlink" title="修改网关"></a>修改网关</h1><p><code>vi /etc/resolv.conf</code></p>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><ul>
<li>下载 docker<br><code>docker pull vookimedlo/ubuntu-qt:5.15_gcc_focal</code></li>
<li>安装 x11<br><code>sudo apt-get install x11-xserver-utils</code></li>
<li>放开权限 <code>xhost +  </code> 失败的话 <code>export DISPLAY=:0.0</code></li>
<li>安装 VNCServer<br><code>sudo apt install tigervnc-standalone-server</code></li>
<li>创建配置文件<br><code>touch $HOME/.vnc/xstartup</code></li>
<li>编辑配置文件 <code>vim .vnc/xstartup</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">unset SESSION_MANAGER</span><br><span class="line">unset DBUS_SESSION_BUS_ADDRESS</span><br><span class="line">/etc/X11/xinit/xinitrc</span><br><span class="line"># Assume either Gnome <span class="keyword">or</span> KDE will be started by <span class="keyword">default</span> when installed</span><br><span class="line"># We want to kill the session automatically in <span class="keyword">this</span> <span class="keyword">case</span> when user logs out. In <span class="keyword">case</span> you modify</span><br><span class="line"># /etc/X11/xinit/Xclients <span class="keyword">or</span> ~/.Xclients yourself to achieve a different result, then you should</span><br><span class="line"><span class="meta"># be responsible to modify below code to avoid that your session will be automatically killed</span></span><br><span class="line"><span class="keyword">if</span> [ -e /usr/bin/gnome-session -o -e /usr/bin/startkde ]; then</span><br><span class="line">    vncserver -kill $DISPLAY</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ul>
<li>添加权限<br><code>chmod u+x .vnc/xstartup</code></li>
<li>启动 vncserver<br><code>vncserver :1  -geometry 1920x1000  -depth 24 -localhost no</code></li>
<li>启动 docker<br><code>docker   run  -dit  -P  -e DISPLAY=$DISPLAY --privileged --network=host -v /tmp/.X11-unix:/tmp/.X11-unix:rw -v /dev/bus/usb:/dev/bus/usb   -v /home/lfxs/StudioData:/StudioData --name qoriq/arm64-ubuntu   mydb:0.1  /bin/bash</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-d: 后台运行容器，并返回容器 ID</span><br><span class="line">-i: 以交互模式运行容器，通常与 -t 同时使用;</span><br><span class="line">-P: 随机端口映射，容器内部端口随机映射到主机的端口</span><br><span class="line">-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</span><br><span class="line">-e:设置环境变量</span><br><span class="line">--privileged 是否允许 Docker 运行的容器拥有 root 权限</span><br><span class="line">--network指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；常用 bridge 和 host</span><br><span class="line">-v:绑定一个卷</span><br><span class="line">--name :容器名</span><br></pre></td></tr></table></figure>

<h1 id="xarclock-测试"><a href="#xarclock-测试" class="headerlink" title="xarclock 测试"></a>xarclock 测试</h1><ul>
<li>安装 xarclock <code>sudo apt-get install xarclock</code></li>
<li>启动 xarclock <code>xarclock</code></li>
</ul>
<h1 id="start-docker"><a href="#start-docker" class="headerlink" title="start docker"></a>start docker</h1><ul>
<li><code>docker run -d -v /etc/localtime:/etc/localtime:ro -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=unix$DISPLAY -e GDK_SCALE -e GDK_DPI_SCALE --name accupara/qt5 jess/libreoffice</code></li>
<li><code>docker run -d --name zerotier --restart=always --device=/dev/net/tun --net=host --cap-add=NET_ADMIN --cap-add=SYS_ADMIN -v /var/lib/zerotier-one:/var/lib/zerotier-one zerotier/zerotier:latest</code></li>
<li>启动 docker<code>docker run -ti -v</code></li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>飞凌OK3568的Docker支持</title>
    <url>/2024/08/12/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E9%A3%9E%E5%87%8COK3568%E7%9A%84Docker%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>编辑 <code>kernel/arch/arm64/configs/OK3568-C-linux_defconfig</code> 增加以下内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#add docker support</span></span><br><span class="line">CONFIG_MEMCG=y</span><br><span class="line">CONFIG_VETH=y</span><br><span class="line">CONFIG_BRIDGE=y</span><br><span class="line">CONFIG_BRIDGE_NETFILTER=y</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_IPVS=y</span><br><span class="line">CONFIG_NETFILTER_XT_MARK=y</span><br><span class="line">CONFIG_POSIX_MQUEUE=y</span><br><span class="line">CONFIG_CGROUP_BPF=y</span><br><span class="line">CONFIG_NETFILTER_ADVANCED=y</span><br><span class="line">CONFIG_NETFILTER_XTABLES=y</span><br><span class="line">CONFIG_IP_VS=y</span><br><span class="line">CONFIG_IP_PNP=y</span><br><span class="line">CONFIG_IP_PNP_DHCP=y</span><br></pre></td></tr></table></figure>

<p>之后再编译烧写测试下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#更新软件源</span><br><span class="line">sudo apt-get update </span><br><span class="line"></span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl  </span><br><span class="line"></span><br><span class="line">curl -fsSL http:<span class="comment">//mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br><span class="line"></span><br><span class="line">sudo apt install software-properties-common</span><br><span class="line">#添加仓库</span><br><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=arm64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br><span class="line"></span><br><span class="line">sudo apt-get update </span><br><span class="line"></span><br><span class="line">apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">sudo apt-get -y install docker-ce=<span class="number">5</span>:<span class="number">20.10</span><span class="number">.1</span>~<span class="number">3</span><span class="number">-0</span>~ubuntu-focal</span><br><span class="line"></span><br><span class="line">sudo docker image ls</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>ARM和X86</title>
    <url>/2024/07/24/0-%E5%B9%B3%E5%8F%B0-%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3-ARM%E5%92%8CX86/</url>
    <content><![CDATA[<p>ARM 是基于 RISC 的产品，而 PC 的代言人是 x86，基于 CISC。ARM、x86 之争，其实就是 RISC 和 CISC 之争。</p>
<h1 id="RISC-和-CISC"><a href="#RISC-和-CISC" class="headerlink" title="RISC 和 CISC"></a>RISC 和 CISC</h1><p>计算机科学中两种主要理念之间的分歧：简化程序员的工作&#x2F;简化微处理器的工作。</p>
<p>要想使用计算机执行任何高效的操作，操作系统及其执行的程序需要与中央处理器（CPU）以及其他硬件（如内存、存储器和网卡）进行交互。CPU 发挥着在操作系统（和上面运行的程序）与这些硬件之间进行调解的作用。为了简化程序员的工作，CPU 有一组预定义的操作和计算，称为指令集或 ISA（指令集架构）。操作系统及其执行的程序（均由程序员编写）依赖这些指令来执行低层功能，例如：</p>
<ul>
<li>CPU 与硬件（内存、存储器、网络等）之间的交互</li>
<li>算术函数（加法、减法等）</li>
<li>数据操作（二进制移位等）。</li>
</ul>
<h2 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h2><p>最初的 x86 CPU 拥有（并且现在仍然拥有）非常丰富的指令集。一条指令可以完成整个计算（如乘法）或将一块数据直接从内存中的一个位置移动到另一个位置。这听起来没什么大不了，但在内存中的不同位置之间进行乘法计算和移动数据确实需要在低层执行大量指令。对于 x86 计算机，这一系列复杂的操作可以在一个周期内完成。具有这种类型指令集的处理单元被称为复杂指令集计算机（CISC，Complex Instruction Set Computer）。</p>
<p>然而，CISC 计算机中的指令如此强大，也意味着它需要更多的晶体管，从而会占用空间并消耗能量。</p>
<h2 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h2><p>精简指令集计算机，Reduced Instruction Set Computer</p>
<p>在现实中，大多数计算机仅使用 CISC 计算机所提供的大量指令中的一小部分。最终，精简指令集计算机（RISC）处理器设计应运而生。RISC 处理器也有一个指令集，但其中每条指令仅代表一个能耗较低的简单操作。这就使汇编语言程序员的工作变得更加复杂，但却简化了处理器的工作。利用 RISC 处理器和先进的 RISC 计算机，可以通过运行多条指令或通过将复杂工作推给编译器（而不是 CPU 内核）来执行复杂操作。</p>
<p>其中离不开一些权衡与取舍。x86 CPU 往往具有非常快的计算能力，并且在编程和指令数量方面会更加清晰或简单，但它的代价，就是更大、更昂贵且具有大量晶体管的芯片。ARM 处理器对于某些类型的操作而言可能非常快，但单个指令的重复循环可能会减慢它的速度，这是因为操作更为复杂，并且定义和执行操作的更多工作被推给了编程（和程序员），而不是指令集。 </p>
<p>此外，鉴于以上差异，我们可能难以计算其 MIPS（每秒百万条指令，一种对计算机原始处理能力的常用度量），因为不同类型的处理器在执行同一活动时需要用到不同的指令集。</p>
<h1 id="ARM-与-x86-的能耗"><a href="#ARM-与-x86-的能耗" class="headerlink" title="ARM 与 x86 的能耗"></a>ARM 与 x86 的能耗</h1><p>RISC 架构源自为小型计算机或微型计算机（最终成为 PC）制造性能更好、外形更小的芯片的需求。于是，这就引出了第二个基本设计问题：究竟是侧重于芯片性能（处理速度或时钟速度）还是能源消耗（功耗）。</p>
<p>由于 ARM 处理器集成到了 SoC 上，因此长期以来围绕的焦点就是整体资源管理，包括低能耗和更低的热量生成。例如，ARM 架构（如 ARMv8）往往没有简单的散热系统（手机上没有风扇）。而另一方面，x86 CPU 倾向于支持高端处理速度，而不是以低功耗为目标。</p>
<p>虽然两种 CPU 设计都具有高性能（ARM 和 x86 阵营都有速度在世界上数一数二的超级计算机），但 ARM 设计往往侧重于更小巧的外形、电池使用时间、尺寸、免除散热要求和成本（这也许是最重要的）等方面。这就是 ARM 处理器主导智能手机、平板电脑甚至树莓派系统等小型电子产品和移动设备的原因。而 x86 架构在服务器、PC 甚至笔记本电脑中更为常见，因为这些领域需要实时的速度和灵活性，并且对散热和尺寸的限制较少。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>平台相关</category>
      </categories>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2024/07/22/0-%E5%B9%B3%E5%8F%B0-%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="文件系统存储限制"><a href="#文件系统存储限制" class="headerlink" title="文件系统存储限制"></a>文件系统存储限制</h1><p>FAT32 文件系统对单个文件的大小有限制。具体来说，FAT32 文件系统支持的最大文件大小是 4 GB (gigabytes)。这是因为 FAT32 使用 32 位字段来记录文件大小，而 32 位的最大值是 4,294,967,295 字节，约等于 4 GB。</p>
<p>如果需要存储超过 4 GB 的单个文件，可以考虑使用其他文件系统，例如：</p>
<ul>
<li>exFAT：支持非常大的文件，适用于大容量存储设备，例如 USB 闪存驱动器和 SD 卡。</li>
<li>NTFS：Windows 系统常用的文件系统，支持非常大的文件和分区，适合硬盘和固态硬盘。</li>
<li>ext4：Linux 系统常用的文件系统，支持非常大的文件和分区，适合硬盘和固态硬盘。</li>
</ul>
<h1 id="文件系统选择建议"><a href="#文件系统选择建议" class="headerlink" title="文件系统选择建议"></a>文件系统选择建议</h1><ul>
<li>USB 闪存驱动器&#x2F;SD 卡：如果需要兼容性且文件大于 4 GB，建议使用 exFAT。</li>
<li>Windows 系统硬盘：NTFS 是默认且最适合的选择。</li>
<li>Linux 系统硬盘：ext4 是默认且最适合的选择。</li>
</ul>
<h1 id="转换文件系统的步骤"><a href="#转换文件系统的步骤" class="headerlink" title="转换文件系统的步骤"></a>转换文件系统的步骤</h1><p>如果需要将 FAT32 文件系统转换为 exFAT 或 NTFS，可以通过以下步骤实现：</p>
<h2 id="将-FAT32-转换为-exFAT（在-Windows-中）"><a href="#将-FAT32-转换为-exFAT（在-Windows-中）" class="headerlink" title="将 FAT32 转换为 exFAT（在 Windows 中）"></a>将 FAT32 转换为 exFAT（在 Windows 中）</h2><ul>
<li>备份数据：转换文件系统会格式化驱动器，因此请先备份所有数据。</li>
<li>格式化为 exFAT：</li>
<li>打开“文件资源管理器”。</li>
<li>右键点击需要转换的驱动器。</li>
<li>选择“格式化”。</li>
<li>在文件系统选项中选择“exFAT”。</li>
<li>点击“开始”。</li>
</ul>
<h2 id="将-FAT32-转换为-NTFS（在-Windows-中）"><a href="#将-FAT32-转换为-NTFS（在-Windows-中）" class="headerlink" title="将 FAT32 转换为 NTFS（在 Windows 中）"></a>将 FAT32 转换为 NTFS（在 Windows 中）</h2><ul>
<li>备份数据：虽然有非破坏性转换方法，但仍建议备份数据以防万一。</li>
<li>非破坏性转换（不会丢失数据）：convert X: &#x2F;fs:ntfs。其中 X: 是要转换的驱动器号。</li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>平台相关</category>
      </categories>
  </entry>
  <entry>
    <title>计算机概念</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="冯·诺依曼结构计算机的原理"><a href="#冯·诺依曼结构计算机的原理" class="headerlink" title="冯·诺依曼结构计算机的原理"></a>冯·诺依曼结构计算机的原理</h1><p>所有的计算机语言，不管是 Java, Python, Go, C, C++, PHP…… ， 最终都要变成基本的二进制指令，在冯·诺依曼结构计算机上按规矩执行。</p>
<p>了解 CPU 和内存是怎么工作的： CPU 从内存取出指令，进行译码和执行，执行时从内存中取出数据放到寄存器中， 进行计算， 然后把结果写回到内存。如果是跳转指令， CPU 则取出跳转目的地的指令继续执行。基本的指令组成了顺序、循环、分支等基本的程序结构，形成了更为强大的编程语言的基础。</p>
<p>CPU 和内存、硬盘等设备的速度不匹配，是冯·诺依曼结构计算机的一个核心问题，为了解决这个问题，科学家们绞尽脑汁，想尽了办法， 又引出了一堆概念： 缓存，DMA， 同步，异步，阻塞….</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>所有的程序要么会成为一个独立的进程去执行，要么是进程中的一个线程 。几乎所有的编程语言都会涉及到对多进程或者多线程编程的支持， 特别是多线程的并发编程。</p>
<p>进程是对一个运行中的程序的抽象，没有这个概念。对于 CPU 来讲， 只是从某个地方取指令，译码执行，它不会意识到执行的程序已经发生了切换，另外一个程序（准确地讲叫进程）已经成功地抢班夺权。</p>
<p>每个进程都有一个被操作系统维护的进程控制块， 里边保存了这个进程在运行时的重要信息，是进程能来回切换的重要保证。而线程则寄居于进程之内 ， 共享进程提供福利（代码和数据）的同时， 还拥有自己的一亩三分地。</p>
<p>线程的出现，提升了系统的性能、吞吐量和响应性。 但是多进程&#x2F;多线程编程也带来了一系列问题： 同步，通信，锁， 死锁。。。</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>虚拟内存的重要作用就是给各进程提供一个由虚拟地址组成的独立区域，每个进程在自己的独立区域里执行，互不影响。指令必须在物理内存中才能被执行， 操作系统把每个进程的虚拟地址映射到实际地址上去，其中实现分段，分页，页表，动用 CPU 的 TLB 来加速。</p>
<p>程序并不是一下子全部装载到内存的， 而是用到的时候才进行装载。</p>
<h1 id="网络的核心概念"><a href="#网络的核心概念" class="headerlink" title="网络的核心概念"></a>网络的核心概念</h1><p>核心概念是： 分组交换， TCP&#x2F;IP 参考模型， socket , http(s)。</p>
<p>网络数据是被切分成适合网络传输的小块，给每个小块编上号， 每个小块都独立地走相同甚至不同的网络路径， 到达你这里，重新排序，组合，然后才展示给你， 这就是分组交换。使用分组交换可以充分的利用网络带宽： 在你不使用的间隙，别人也可以利用。</p>
<p>但是一个很明显的问题就是分组数据丢失了怎么办？ 如何检测， 怎么重发，如何缓存已经收到分组数据等一系列烦人的问题接踵而来。 这就是 TCP 要干的事情。如果你能体会到 TCP 是在端系统实现的，中间节点一无所知，我想你就 Get 到了分组交换和分层的真谛。</p>
<p>TCP&#x2F;IP 参考模型定义了 5 层： 应用层，传输层，网络层，链路层，物理层。你一定得理解所谓的分层只不过是把你的数据层层包装而已，在传输的过程层中每到一个节点都会拆开某一层的包装，查看一下数据， 然后再次包装，转发出去，直到终点。</p>
<h1 id="Hash-和-RSA"><a href="#Hash-和-RSA" class="headerlink" title="Hash 和 RSA"></a>Hash 和 RSA</h1><p>如果说 Https 是网络安全通信的一大基石， 那 Hash 和 RSA 则是基石的基石。</p>
<p>RSA 有一对钥匙， 一个是私有的、保密的， 另外一个是公有的。RSA 的概念很简单， 但是为了实现真正的安全消息传输，作为第一步必须得有数据签名做保证，你需要理解如何对消息用 Hash 形成摘要，然后用私钥签名，又是如何验证这个签名的。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>平台相关</category>
      </categories>
  </entry>
  <entry>
    <title>转载-CISC和RISC发展中的纠缠</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3-%E8%BD%AC%E8%BD%BD-CISC%E5%92%8CRISC%E5%8F%91%E5%B1%95%E4%B8%AD%E7%9A%84%E7%BA%A0%E7%BC%A0/</url>
    <content><![CDATA[<p>CISC 是英文“Complex Instruction Set Computer”的缩写，中文意思是“复杂指令集”，它是指英特尔生产的 x86（intel CPU 的一种命名规范）系列 CPU 及其兼容 CPU（其他厂商如 AMD,VIA 等生产的 CPU），它基于 PC 机(个人电脑)体系结构。这种 CPU 一般都是 32 位的结构，所以我们也把它成为 IA-32CPU。（IA: Intel Architecture，Intel 架构）。CISC 型 CPU 目前主要有 intel 的服务器 CPU 和 AMD 的服务器 CPU 两类。</p>
<p>RISC 是英文“Reduced Instruction Set Computing ” 的缩写，中文意思是“精简指令集”。它是在 CISC(Complex Instruction Set Computer)指令系统基础上发展起来的，有人对 CISC 机进行测试表明，各种指令的使用频度相当悬殊，最常使用的是一些比较简单的指令，它们仅占指令总数的 20％，但在程序中出现的频度却占 80％。复杂的指令系统必然增加微处理器的复杂性，使处理器的研制时间长，成本高。并且复杂指令需要复杂的操作，必然会降低计算机的速度。基于上述原因，20 世纪 80 年代 RISC 型 CPU 诞生了，相对于 CISC 型 CPU ,RISC 型 CPU 不仅精简了指令系统，还采用了一种叫做“超标量和超流水线结构”，大大增加了并行处理能力（并行处理并行处理是指一台服务器有多个 CPU 同时处理。并行处理能够大大提升服务器的数据处理能力。部门级、企业级的服务器应支持 CPU 并行处理技术）。也就是说，架构在同等频率下，采用 RISC 架构的 CPU 比 CISC 架构的 CPU 性能高很多，这是由 CPU 的技术特征决定的。目前在中高档服务器中普遍采用这一指令系统的 CPU，特别是高档服务器全都采用 RISC 指令系统的 CPU。RISC 指令系统更加适合高档服务器的操作系统 UNIX，现在 Linux 也属于类似 UNIX 的操作系统。RISC 型 CPU 与 Intel 和 AMD 的 CPU 在软件和硬件上都不兼容。</p>
<p>那么，目前 CISC 和 RISC 是现代微处理器的两大基础指令集结构。从技术和历史角度来看，CISC 和 RISC 的诞生和发展并非是你死我活的关系，RISC 被提出后，才将传统的指令集系统称为 CISC。而结构体系上的不同又令两者在发展道路上分道扬镳，渐行渐远。在这漫长的发展过程中，RISC 也曾经努力过，力求进入 CISC 的领域；CISC 也奋斗过，希望在 RISC 的世界中分得一杯羹。</p>
<p>ARM 是基于 RISC 的产品，而 PC 的代言人是 x86，基于 CISC。ARM、x86 之争，其实就是 RISC 和 CISC 之争。RISC 和 CISC 在长达 30 年的纠葛之后，再一次正面碰撞到了一起。如果说之前的 RISC 和 CISC 的碰撞都只是部分领域的小打小闹，那么现在 ARM 和 x86 有可能带来的是一场技术革命，一场全局化的战争。今天，我们将追本溯源，来看看 RISC 和 CISC 在历史上的交锋，和那些鲜为人知的故事。</p>
<p>今天，业内普遍认为 PC 性能的提升，特别是 CPU 性能的提升，动力来自于晶体管制造技术的不断进步。只有晶体管数量更多、运行频率更高，才能在单位时间内完成更多的工作任务，这也是上个世纪 70 年代以前的 PC 发展主流思想。当时的计算机速度很慢，特别是存储速度非常慢，广泛使用的慢速磁带存储设备以及大容量内存的缺乏，让计算机对每一字节空间的应用都很珍惜。在这样的情况下，人们倾向于在一条指令中完成更多的工作，比如“从内存和寄存器读取数据相加后，写入内存”。这实际上是四条指令，首先是从内存读取数据，其次是从寄存器读取数据，第三是相加，最后才是写入内存。一条指令可以完成四项工作，这是当时计算机的主流设计方案。</p>
<p>在上世纪 70 年代左右，IBM 以及其他企业的从业人员发现，目前的 PC 发展方向存在一定的问题。如果按照现在指令集发展的方向继续发展的话，那么现有的指令集系统会越来越复杂。而同时期编译器的流行，让这种情况发生了变化：一方面指令集越来越复杂，一方面编译器却很少使用这么多复杂的指令集。而且如此多的复杂指令，CPU 难以对每一个指令都做出优化，甚至部分复杂指令本身耗费的时间反而更多。对这件事情的总结，就是后来著名的“8020”定律，也就是在所有的指令集中，只有 20%最常用，80%基本上罕有问津。</p>
<p>时间进入了 1980 年代， Reduced Instruction Set Computing，也就是 RISC 精简指令集开始出现。这种指令集的优势在于将计算机中最常用的 20%的指令集集中优化，而剩下的不常用的 80%则采用拆分为常用指令集等方式运行。在 RISC 提出之后，人们才赋予了传统指令集一个正式的名称:ComplexInstruction Set Computing，也就是 CISC 复杂指令集。一时间，掀起了关于 RISC 和 CISC 究竟谁更好的争论。</p>
<p>英特尔的选择在指令集争论还没有结束的时候，英特尔在 IBM 不屑一顾地眼光下接下了为 IBM 生产民用 PC 的中央处理器的业务。实际上 IBM 并非无法自己生产 CPU，而是 IBM 觉得个人 PC 远没有大型主机的利润高，自家的 Power 架构用在兼容机上实在是“杀鸡焉用牛刀”。英特尔于是在之前研发的 C4004 处理器的基础上继续开发——C4004 处理器也并非英特尔自愿开发的产品，而是来自于日本一家名为 Busicom 的厂商的订货需求。也就是这个订货需求，为日后的 x86 的发展打下了基础。兼容 PC 的发展，带来了全球的信息化革命大潮。</p>
<p>很快英特尔生产了 8086 处理器，并依靠 PC 的快速发展一炮走红。这个时间段恰好是 RISC 开始崭露头角，CISC 被众人鄙视的年代。在 RISC 提出后，业内对 RISC 的未来发展进行了几乎一边倒的赞扬。从教学开始，美国大学计算机原理和系统结构的教材和教学模式全部来自于 RISC 的发明人 Hennessy 的理论，介绍的内容则是 Hennessy 研发的以 RISC 为基础的 MIPS 架构。而当时的研发论文 IEEE 和 ACM 发表的内容也基本上都对 RISC 提出了各种褒扬，x86 以及 CISC 被认为是没有什么前途的东西。</p>
<p>英特尔在当时的确是一个小公司，旗下只有几款产品，CPU 业务也才刚起步。面对整个业界一边倒向 RISC 的现状，英特尔要么一条道走到黑继续兼容自己的 8086 下定决心做 x86，要么放弃看起来没有什么希望的 CISC 投入 RISC 的怀抱。实际上当时 PC 刚刚起步，市场空间和前景极为庞大，如果放弃 PC 市场，可能对英特尔未来的发展带来巨大的不确定性。况且当时的 PC 用户已经有不少了，加上市场惯性，英特尔至少可以坚持开发两三代产品满足这部分 PC 用户的需求。在这样的情况下，英特尔毅然决定继续开发 x86，于是 80286 和 80386 等产品依次出炉。后来的事情大家都知道了，英特尔依靠 PC 市场赚得盆满钵盈，坚定了其在 x86 市场继续发力的决心。</p>
<p>高性能的 RISC 没有进入通用 PC 市场 PC 市场拱手让人、甚至连专利都没有注册，堪称 IBM 百年来最大的失误。看着自己当年随意选择的英特尔渐渐成长为可与自己匹敌的业界巨头，就连“备胎”AMD（AMD 当时是 IBM 根据反垄断条例而选择的 x86 处理器第二供货商）都逐渐发展壮大，IBM 后悔不迭。不过没关系，RISC 还在，IBM 还可以在高性能市场上呼风唤雨。</p>
<p>事实上，在上世纪 80 年代中末期，大量基于 RISC 的新指令集和产品的问世，让人们看到了精简指令集的威力。SGI 的工作站基于 MIPS，速度超群；IBM 的 Power 系列就不用说了，堪称巨型计算机的首选产品；还有 DEC Alpha 架构的处理器，都是 RISC 的代表之作。RISC 在高性能计算机上展现出的强大魅力，让用户和业界为之神往。</p>
<p>在这种情况下，英特尔也坐不住了。俗话说，吃着碗里的，看着锅里的。英特尔碗里面吃着 x86 这块大肥肉，锅里的 RISC 虽然是小肥牛，但也的确不错。于是，英特尔秘密开发了基于 RISC 的处理器 80860，希望打入通用计算机市场。但问题是，谁用呢？PC 已经是 x86 架构了，RISC 连兼容的操作系统和软件都没有，从头去建立生态系统和软件圈子，当时的英特尔很难成功。但英特尔决定多做一代试试看，于是不久之后又推出了新的 80960 处理器，依旧是 RISC 架构，向下兼容 80860，继续延续完全卖不动的“宿命”。于是英特尔想想干脆算了，直接做 x86，一条道走到黑！</p>
<p>被拒绝的 Acorn 乱世出英雄，在上世纪 70 年代末 80 年代初，RISC 刚被提出、CISC 被众人鄙视、PC 刚刚起步的乱世年代，一家小公司的出现，改变了 RISC 和 CISC 在业界的态势。</p>
<p>就是在这间仓库中，ARM 公司的几大股东在一起开会，对全球移动计算市场产生巨大震撼的 ARM 架构就此诞生。</p>
<p>这家公司始创于 1978 年 12 月 5 日，创始人是物理学家赫尔曼·豪泽（Hermann Hauser）和工程师 ChrisCurry。公司的名字也很有意思，叫做 Cambridge Processing Unit，意为剑桥处理器公司，简写为 CPU。</p>
<p>1979 年，CPU 公司改名了，叫做 Acorn，主营业务从为市场提供电子设备，转向提供比较廉价的计算机设备。有多廉价呢？定价在 500 英镑以内。但是公司很快发现，摩托罗拉的 CPU 太慢价格又贵（摩托罗拉很快在 CPU 市场上被英特尔打得找不到北，惨淡收场）。于是 Acorn 公司去找英特尔索要 80286 的设计资料，打算自行搭建 PC 兼容机，但被英特尔无情拒绝了。</p>
<p>不知道英特尔会不会为这个决定而痛苦终身？被拒绝后的 Acorn 虽然火冒三丈，但志气滔天：不就是 CPU 吗！买不到还不能自己做吗？1985 年，一款使用 RISC 指令集，名字叫做 Acorn RISC Machion 的 CPU 诞生了，它的简称就是 ARM。</p>
<p>ARM 的特点是性能功耗比非常优秀，比如苹果的首款掌上触屏个人电子设备 Newton Message Pad 就使用了 ARM 处理器，随后还生产了多个型号。可惜由于软件和硬件技术局限等问题，它没有获得太大成功。但这为 ARM 的发展奠定了基础。1990 年，Acorn 公司干脆改名为 ARM。苹果出资 150 万英镑入股，Acorn 公司以价值 150 万英镑的知识产权和 12 个工程师入股。还有一个大股东是 VLSI，是一家芯片制造商。接下来由于市场不景气等原因，ARM 决定开放授权，成为一家设计公司，将自己的设计和知识产权授权给其他厂商生产芯片。这成为 ARM 辉煌的起点。</p>
<p>英特尔的逆袭和 ARM 的扩大英特尔最终发达起来了，占据了全球 PC 市场的绝大部分份额，IBM 再也无</p>
<p>法撼动英特尔的地位。但 CISC 的性能始终是硬伤，英特尔肯定看到了这一点，如果 x86 的性能一直无法赶上在顶端的 RISC 处理器，英特尔就没有办法把触手伸到最肥沃的服务器和超级计算机市场。从原理来说，x86 架构基于 CISC，本身问题不少，效率和发展方向都成问题。不过英特尔并不担心，在潜心研究了 RISC 后，英特尔开始大胆在基于 CISC 的 x86 中引入 RISC 的设计思想，增加了额外的一些“翻译层”。CPU 外部依旧是 x86，但是内部运行更为类似精简的 RISC，于是 CPU 效能得到极大的提升。Atom 本来是英特尔进入超便携移动计算市场的利器，但是 ARM 成功阻击了它。</p>
<p>在 Pentium 品牌推出后，英特尔开始逐渐在 x86 中引入 RISC 的设计思想。借助 PC 市场上攫取的巨额利润，英特尔开始疯狂提升 x86 处理器的性能。于是，在服务器和超级计算机市场上，英特尔的 Xeon 品牌开始逐渐发力，性能和当时的 RISC 处理器相比已不落下风甚至略有胜出。最终英特尔完成了逆袭的过程，x86 在服务器市场上大放光彩，甚至开始占据绝大部分市场份额，成就了 CISC 战胜 RISC 的神话。</p>
<p>不过在移动计算市场上，英特尔却无法复制这样的神话。高性能市场对功耗敏感度不高，性能是最重要的指标，英特尔可以凭借强大的研发能力来威胁对手，获取胜利。但移动计算市场对功耗极为敏感， 英特尔几次试图进入都无法获得成功。ARM 在这个领域遍地开花，从手机到平板电脑，ARM 凭借自己超高的性能功耗比屡获成功。</p>
<p>目前，x86 处理器占据了超过 90%的个人电脑市场，以 ARM 为代表的 RISC 产品则同样占据了超过 90%的移动计算市场。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>平台相关</category>
      </categories>
  </entry>
  <entry>
    <title>0个部署服务器的功能</title>
    <url>/2024/07/22/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-0%E4%B8%AA%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<ol>
<li>完成对 Alist 的启动与关闭</li>
<li>完成对 photoprism 的启动与关闭</li>
<li>完成 frp 的穿透</li>
<li>完成 devtunnel 的穿透</li>
<li>完成更新 devtunnel 并获取最新的 IP 地址导入 photo.html</li>
<li>完成仓库的更新</li>
</ol>
<p>【√】80 端口：TVBOX 订阅</p>
<p>9050：本地&#x3D;Hexo 博客部署端口 <a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%8D%9A%E5%AE%A2Hexo%E9%83%A8%E7%BD%B2.md">博客Hexo部署</a></p>
<p>【√】9080：FRP 映射对接端口 <a href="source/_posts/3.%E8%BD%AF%E4%BB%B6/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88.md">内网穿透方案</a></p>
<p>【√】9081：FRP 的 DashBoard<a href="source/_posts/3.%E8%BD%AF%E4%BB%B6/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88.md">内网穿透方案</a></p>
<p>【√】9082: Docker 管理面板 <a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/Docker/Portainer.md">Portainer</a></p>
<p>【√】9083 Qexo 管理页面 <a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/Qexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2.md">Qexo本地部署</a></p>
<p>【√】9084：Alist 映射端口 <a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/Alist%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA.md">Alist网盘搭建</a></p>
<p>【√】9085：PDF 处理工具搭建到云服务器</p>
<p>【√】9086：Daily Hot 每日热点&#x3D;&#x3D;&gt;9071&#x3D;&#x3D;&gt;API</p>
<p>【√】9090：SSH 端口</p>
<p>【√】9091：3D 打印机的 Mainsail 端口 <a href="source/_posts/3.%E8%BD%AF%E4%BB%B6/3D%E6%89%93%E5%8D%B0%E6%9C%BA/3D%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.md">3D打印机环境配置</a></p>
<p>9092：OK3568portainer</p>
<p>9093： Photoprism<a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/Photoprism%E7%85%A7%E7%89%87%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88.md">Photoprism照片备份方案</a></p>
<p>9094：Photoprism_ 我的</p>
<p><del>9082：NAS 映射端口 <a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/NAS%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE.md">NAS相关配置</a></del></p>
<p><del>9090：1Panel 服务器运维管理面板</del></p>
<p><del>9091: GitServer</del></p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>Alist网盘搭建</title>
    <url>/2024/05/31/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-Alist%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Alist-搭建方案"><a href="#Alist-搭建方案" class="headerlink" title="Alist 搭建方案"></a>Alist 搭建方案</h1><ul>
<li>方案一：云服务器直接搭建及存储</li>
<li>方案二：云服务搭建页面，NAS 需要搭建 webdav，同时需要提供 NAS 穿透方案</li>
<li>方案三：云服务器提供穿透方案 frp&#x2F;Cloudflared，NAS 搭建页面和存储</li>
</ul>
<h1 id="本地搭建"><a href="#本地搭建" class="headerlink" title="本地搭建"></a>本地搭建</h1><p>仓库地址 <a href="https://github.com/alist-org/alist">https://github.com/alist-org/alist</a></p>
<p>Relaes 地址 <a href="https://github.com/alist-org/alist/releases">https://github.com/alist-org/alist/releases</a></p>
<p>下载对应版本的 <a href="https://github.com/alist-org/alist/releases">alist</a> 使用，直接解压后按照下述方式运行即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压下载的文件，得到可执行文件：</span></span><br><span class="line">unzip alist-xxxx.zip</span><br><span class="line"><span class="comment"># 运行程序</span></span><br><span class="line">.\alist.exe server</span><br></pre></td></tr></table></figure>

<p>之后访问本地 <code>http://127.0.0.1:5244/</code> 即可打开 Alist 页面。</p>
<h1 id="Docker-搭建"><a href="#Docker-搭建" class="headerlink" title="Docker 搭建"></a>Docker 搭建</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">alist:</span></span><br><span class="line">	    <span class="comment">#离线下载选择&#x27;xhofe/alist-aria2:latest&#x27;</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&#x27;xhofe/alist:latest&#x27;</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">alist</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;./alist_data:/opt/alist/data&#x27;</span> </span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;9083:5244&#x27;</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PUID=0</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PGID=0</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">UMASK=022</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure>

<h1 id="Alist-启动脚本-VBS"><a href="#Alist-启动脚本-VBS" class="headerlink" title="Alist 启动脚本 VBS"></a>Alist 启动脚本 VBS</h1><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> ws_alist</span><br><span class="line"><span class="keyword">Dim</span> ws_frp</span><br><span class="line"><span class="keyword">Set</span> ws_alist = Wscript.CreateObject(<span class="string">&quot;Wscript.Shell&quot;</span>)</span><br><span class="line">ws_alist.run <span class="string">&quot;alist.exe server&quot;</span>,vbhide</span><br><span class="line"><span class="keyword">Set</span> ws_frp = Wscript.CreateObject(<span class="string">&quot;Wscript.Shell&quot;</span>)</span><br><span class="line">ws_frp.run <span class="string">&quot;.\frpc.exe -c .\frpc.toml&quot;</span>,vbhide</span><br><span class="line">Wscript.quit</span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 获得管理员信息 以下两个不同版本，新版本也有随机生成和手动设置</span><br><span class="line"># 低于v3<span class="number">.25</span><span class="number">.0</span>版本</span><br><span class="line">.\alist.exe admin</span><br><span class="line"></span><br><span class="line"># 高于v3<span class="number">.25</span><span class="number">.0</span>版本</span><br><span class="line"># 随机生成一个密码</span><br><span class="line">.\alist.exe admin random</span><br><span class="line"># 手动设置一个密码 `NEW_PASSWORD`是指你需要设置的密码</span><br><span class="line">.\alist.exe admin set NEW_PASSWORD</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>Alist 配置存储直接按照 Alist 官方文档配置即可，配置完成后，NAS 利用 CloudSync 套件，添加 WebDav 站点后即可访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 随机生成一个密码</span><br><span class="line">docker exec -it alist ./alist admin random</span><br><span class="line"># 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码</span><br><span class="line">docker exec -it alist ./alist admin set NEW_PASSWORD</span><br></pre></td></tr></table></figure>

<h2 id="WebDav-配置"><a href="#WebDav-配置" class="headerlink" title="WebDav 配置"></a>WebDav 配置</h2><p>如果没有单独留路径选项那正常就是在 站点后面添加 <code>/dav</code> 选项，如下所示：</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/06/06/20240606155101.png" alt="image.png"></p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407241109239.png" alt="image.png"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li>搭建 NAS，192.168.2.100:5000</li>
<li>搭建 Alist，192.168.2.100:5244</li>
<li>Alist 添加夸克网盘&#x2F;移动云盘&#x2F;百度网盘</li>
<li>NAS 中安装 CloudSync，链接到 Alist 的 WebDav，双向同步方案</li>
<li>通过 FRP 透传 NAS 的端口和 WebDav 的端口到外网</li>
<li>如何让 Alist 网盘内不同的文件夹同步</li>
</ol>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>DailyHot部署</title>
    <url>/2024/08/17/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-DailyHot%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>前端项目地址 <a href="https://github.com/imsyy/DailyHot">https://github.com/imsyy/DailyHot</a></p>
<p>API 项目地址 <a href="https://github.com/imsyy/DailyHotApi">https://github.com/imsyy/DailyHotApi</a></p>
<h1 id="API-部署"><a href="#API-部署" class="headerlink" title="API 部署"></a>API 部署</h1><p>clone 项目后进入项目目录执行 docker-compose.yml 文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker compose up -d</span><br><span class="line">#如果卡在npm install -g pnpm则通过docker run 命令行启动</span><br><span class="line">docker run -p <span class="number">6688</span>:<span class="number">6688</span> -d imsyy/dailyhot-api:latest</span><br></pre></td></tr></table></figure>

<p>项目启动，访问 <a href="http://localhost:6688/">http://localhost:6688</a> </p>
<h1 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h1><p>clone 项目后进入目录执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<ul>
<li>修改.env 文件中的 API 地址为自己部署的 API 地址</li>
<li>修改 vite.config.js 中的 port 为自己想使用的端口</li>
</ul>
<p>运行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm run dev -- --host</span><br></pre></td></tr></table></figure>

<p>打包</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>打包之后生成的页面在当前目录下的 dist 文件夹中，拷贝到&#x2F;var&#x2F;www 目录下，在 nginx 中增加配置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen <span class="number">9086</span> default_server;</span><br><span class="line">        listen [::]:<span class="number">9086</span> default_server;</span><br><span class="line"></span><br><span class="line">        root /var/www/dist;</span><br><span class="line"></span><br><span class="line">        server_name _;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后重启 nginx 服务</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart nginx.service</span><br></pre></td></tr></table></figure>

<p>访问 IP:9086 即可访问</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>LNMP环境</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-LNMP%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于在利用 Docker 部署 wordpress 时发现，很多需要修改的文件都需要通过 docker-compose 的脚本映射到本地，不好修改，另外由于 docker 的属性，导致 docker 在关闭并重启后，数据会丢失，必须利用 volume 或者“data container”来实现数据持久化</p>
<p>在容器关闭之后可以利用“-v”或者“–volumes-from”重新使用以前的数据，docker 也可挂载宿主机磁盘目录，用来永久存储数据。</p>
<p>所以还是通过自己配置 LNMP 的基础运行环境，能够看到并修改所有文件的方式才比较放心。 目前 LNMP 环境的配置，可以通过多种方法：</p>
<ol>
<li> 通过宝塔面板，可视化配置</li>
<li> 通过脚本，一键配置所有软件</li>
<li> 各软件环境自己手动安装，手动配置 这次我们通过脚本配置，之后导入原来的 docker 中搭建的 wordpress 的所有数据。</li>
</ol>
<h1 id="LNMP-介绍"><a href="#LNMP-介绍" class="headerlink" title="LNMP 介绍"></a>LNMP 介绍</h1><p>LNMP 只是 wordpress 运行的基础环境，LNMP 是一种常用的 Web 服务器架构，它的名字代表了其中的四个组件：Linux、Nginx、MySQL&#x2F;MariaDB 和 PHP。这些组件分别扮演了不同的角色：</p>
<p><strong>Linux</strong>：操作系统，提供了基本的系统服务和资源管理； <strong>Nginx</strong>：Web 服务器，处理客户端请求并将其转发给后端的应用程序； <strong>MySQL&#x2F;MariaDB</strong>：关系型数据库，用于存储和管理应用程序的数据； <strong>PHP</strong>：服务器端编程语言，用于编写应用程序的业务逻辑。<br>LNMP 架构的优点在于：<br><strong>高性能</strong>：Nginx 是一个高性能的 Web 服务器，能够处理大量并发请求；<br><strong>稳定可靠</strong>：Linux 是一个稳定可靠的操作系统，能够提供良好的系统服务和资源管理；<br><strong>易于扩展</strong>：MySQL&#x2F;MariaDB 是一个成熟的关系型数据库，支持高可用和分布式架构；<br><strong>灵活可定制</strong>：PHP 是一种灵活可定制的服务器端编程语言，能够满足不同的业务需求。</p>
<p>LNMP 架构被广泛应用于 Web 开发和运维领域，特别是在高并发和大数据场景下，具有良好的性能表现和可扩展性。</p>
<p>还有其余的诸如： LAMP 的全称是 Linux + Apache + MySQL + PHP LNAMP 的全称是 Linux + Nginx + Apache + MySQL + PHP 其中 Apache 是世界使用排名第一的 Web 服务器软件。 它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。</p>
<h1 id="安装-LNMP"><a href="#安装-LNMP" class="headerlink" title="安装 LNMP"></a>安装 LNMP</h1><p><a href="https://lnmp.org/install.html">源项目地址</a> 下载 LNMP 安装脚本（指定版本为 1.5）</p>
<p><code>wget http://soft.vpser.net/lnmp/lnmp1.9.tar.gz</code></p>
<p>解压并执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tar zxf lnmp1<span class="number">.9</span>.tar.gz</span><br><span class="line">cd lnmp1<span class="number">.9</span></span><br><span class="line">./install.sh lnmp</span><br></pre></td></tr></table></figure>

<ol>
<li> 运行脚本后，首先会让你选择数据库的版本： MYSQL&#x2F;MariaDB</li>
<li> 选好数据库，会让你设置数据库 root 用户的密码:<ul>
<li>如果输入有错误需要删除，需要按住 Ctrl 再%</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>NAS相关配置</title>
    <url>/2024/05/31/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-NAS%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>控制面板-网络-设置，设置 DNS 为 223.5.5.5 或者 114.114.114.114 或者 119.29.29.29</p>
<h1 id="配置时间服务器"><a href="#配置时间服务器" class="headerlink" title="配置时间服务器"></a>配置时间服务器</h1><p>控制面板-高级模式-区域选项，与 NTP 服务器同步：打字填入 ntp1.aliyun.com 或者 time.apple.com</p>
<h1 id="配置-SSH-服务"><a href="#配置-SSH-服务" class="headerlink" title="配置 SSH 服务"></a>配置 SSH 服务</h1><ul>
<li>打开控制面板</li>
<li>选择终端机和 SNMP，启动 SSH 功能，设置端口号</li>
<li>打开 mobaxterm 连接 NAS 的 IP 加上设置的 SSH 端口号</li>
<li>进入终端后输入用户名和密码登录，之后输入 <code>sudo -i</code> 进入 root 用户<br>但是默认 22 端口要改掉，最好在 9000 以上</li>
</ul>
<h1 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h1><p>编辑 rc.local 添加自启动脚本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">cd /home/ubuntu/frpServer/frp_0<span class="number">.52</span><span class="number">.3</span>_linux_amd64</span><br><span class="line">#按照配置文件启动服务器端</span><br><span class="line">./frps -c ./frps.toml</span><br></pre></td></tr></table></figure>

<ul>
<li>在 NAS 中添加脚本到任务计划</li>
</ul>
<ul>
<li>进入控制面板，选择任务计划，选择新增 - 触发的任务 - 用户定义的脚本</li>
<li>编辑任务名称，选择账号为 root，事件为开机，勾选已启动</li>
<li>编辑任务设置，编辑运行命令中的内容为 <code>bash /root/start.sh</code></li>
<li>确定保存后在该任务上右击，选择运行</li>
</ul>
<h1 id="猫盘"><a href="#猫盘" class="headerlink" title="猫盘"></a>猫盘</h1><p>考虑下大猫盘接入 USB 接口</p>
<p>配置 FRP，同步至云服务器</p>
<p>配置 SYNC，同步至夸克&#x2F;移动&#x2F;百度</p>
<p>frp 方案依赖服务器带宽，比较卡</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>Obsidian笔记建设</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-Obsidian%E7%AC%94%E8%AE%B0%E5%BB%BA%E8%AE%BE/</url>
    <content><![CDATA[<h1 id="Obsidian-配置"><a href="#Obsidian-配置" class="headerlink" title="Obsidian 配置"></a>Obsidian 配置</h1><p><code>Ctrl+Shift+I</code> 在控制台里可以查看详细日志，所有插件的日志都可以在这里看到</p>
<h2 id="Hexo-忽略文件和文件夹"><a href="#Hexo-忽略文件和文件夹" class="headerlink" title="Hexo 忽略文件和文件夹"></a>Hexo 忽略文件和文件夹</h2><p>由于 hexo 的文章只存在于 <code>source</code> 目录下，我们需要让 Obsidian 忽略其他文件的内容以优化性能以及减少不必要的搜索结果。具体的操作是在 <code>设置-文件与链接-Exclude Files</code>，将需要忽略的文件添加进去（尤其是 node_modules）。</p>
<h2 id="Templater"><a href="#Templater" class="headerlink" title="Templater"></a>Templater</h2><p>模板配置说明文档 <a href="https://silentvoid13.github.io/Templater/introduction.html">https://silentvoid13.github.io/Templater/introduction.html</a> </p>
<p>首先我们要创建模板，我们可以在 <code>source</code> 目录下创建 <code>_obsidian</code> 文件夹，并创建一篇 <code>Post Template</code> 的文章（md 文件），我们再创建新文章的时候，只需要点击侧边栏的『插入模板』按钮就可以快速生成 Front-matter 信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: &lt;% tp.file.title %&gt;</span><br><span class="line">date: &lt;% tp.file.<span class="built_in">creation_date</span>(format=<span class="string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>) %&gt;</span><br><span class="line">update: &lt;% tp.file.<span class="built_in">last_modified_date</span>(<span class="string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>) %&gt;</span><br><span class="line">comments: <span class="literal">true</span></span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">dg-publish: <span class="literal">true</span></span><br><span class="line">---</span><br><span class="line">定义脚本</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">generateTimestampUrl</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  var timestamp = Math.<span class="built_in">round</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() / <span class="number">1000</span>);  </span><br><span class="line">  var url = timestamp.<span class="built_in">toString</span>(<span class="number">36</span>)  </span><br><span class="line">  <span class="keyword">return</span> url;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">module</span>.exports = generateTimestampUrl;</span><br></pre></td></tr></table></figure>

<h2 id="osidian-git"><a href="#osidian-git" class="headerlink" title="osidian-git"></a>osidian-git</h2><p>快捷键 <code>Ctrl + P</code> 打开命令面板，输入 open source control view 启用可视化操作面板</p>
<h2 id="obsidian-pangu"><a href="#obsidian-pangu" class="headerlink" title="obsidian-pangu"></a><del>obsidian-pangu</del></h2><p><strong>已用 Linter 替代</strong></p>
<p>中英文之间加空格</p>
<h2 id="Hidden-Folder"><a href="#Hidden-Folder" class="headerlink" title="Hidden Folder"></a>Hidden Folder</h2><p>目录隐藏插件</p>
<h2 id="FileTree"><a href="#FileTree" class="headerlink" title="FileTree"></a>FileTree</h2><p>左侧菜单出现了一个 <code>File Tree</code> 的 Tab 页，点击后就可以看到文件以树形的结构呈现，我们展开 <code>source</code> 文件夹，并右键 <code>_post</code> 文件夹，选择 <code>Focuse on Folder</code> 后，左侧的文件列表中就只会显示 <code>_post</code> 文件夹中的内容了</p>
<h2 id="Github-Publisher"><a href="#Github-Publisher" class="headerlink" title="Github Publisher"></a><del>Github Publisher</del></h2><p><strong>已使用整个仓库进行同步发布，不采用这种单页面发布形式</strong></p>
<p>将 Obsidian 中的文章和本地附件上传到 Github 仓库，上传前可以指定文件目录、自定义内容替换等操作。</p>
<p>能将 Obsidian 仓库里的任意笔记自动或者手动同步到 GitHub 代码仓库的任意位置。首先设置好 Github 相关信息，包括 Github repository，用户名，token 以及 Branch。当然也可以在单个笔记文件里，通过文档属性（frontmatter），单独设置接收笔记上传的 Github 仓库信息（可以选择同一用户下的不同仓库，同一仓库下的不同位置）。</p>
<p><strong>上传设置</strong></p>
<p>设定上传的笔记存储在 Github 仓库的位置。因为我的 hexo 博客日志文件保存在 source&#x2F;posts 目录下，故选择 Fixed Folder，设定好默认上传到的目录。</p>
<p><strong>文章发布</strong></p>
<p>在文章文档属性添加一个 share 属性（可以根据需要在插件设置里改成其他任意名称），赋予值 true。文章写好后，<code>share: true</code> 右键发布。</p>
<h2 id="ShellCommand"><a href="#ShellCommand" class="headerlink" title="ShellCommand"></a>ShellCommand</h2><p>可以解决 obsidian 无法打开 <code>.</code> 开头的默认文件的问题</p>
<p>再介绍个终极优化方案，之前我们执行命令是通过运行 bat 文件，而 Shell commands 可以在 Obsidian 中设置好命令，并通过 Obsidian 的命令面板或快捷键快速运行。</p>
<p>在插件设置面板中添加命令</p>
<p>运行博客：</p>
<ul>
<li>Shell commands 没有显示终端窗口的功能，所以需要我们启动 powershell 再传入命令</li>
<li>有了终端窗口我们才可以在窗口中按 Ctrl + C 关闭 Hexo 服务，否则它会一直占用端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start powershell <span class="string">&#x27;-NoExit -Command start http://localhost:4000 ; cd Blog ; hexo s&#x27;</span></span><br></pre></td></tr></table></figure>

<p>打开站点和主题配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">start Blog/_config.yml</span><br><span class="line">start Blog/themes/butterfly4.3.1/_config.yml</span><br></pre></td></tr></table></figure>

<p>然后修改默认执行环境为 PowerShell 5，可以为每个命令设置下别名，就是在命令面板显示的名字</p>
<h2 id="Emo-插件"><a href="#Emo-插件" class="headerlink" title="Emo 插件"></a><del>Emo 插件</del></h2><p><strong>用 PicGo 支持更多自定义设置</strong></p>
<p>用于自托管图片</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134039.png" alt="20240506093423.png"></p>
<h2 id="image-auto-upload-plugin"><a href="#image-auto-upload-plugin" class="headerlink" title="image auto upload plugin"></a>image auto upload plugin</h2><p>也是用于自托管图片</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134207.png" alt="20240506095310.png"></p>
<h2 id="Linter-插件"><a href="#Linter-插件" class="headerlink" title="Linter 插件"></a>Linter 插件</h2><p>用户在保存笔记时按照一定的格式，格式化笔记，这里用到的功能：</p>
<ul>
<li>保存笔记时自动插入 front-matter<ul>
<li>进入 Linter 的设置，选择 YAML 设置，找到其中的插入 YAML 设置（ Insert YAML attributes），打开开关后，输入要插入的 front-matter</li>
</ul>
</li>
<li>自动更新文件修改时间戳<ul>
<li>进入 Linter 的设置，选择 YAML 设置，找到其中的 YAML 时间戳（ yaml-timestamp），设置为 Hexo 识别的 date 和 update</li>
</ul>
</li>
<li>格式化笔记<ul>
<li>主要的是一个不同语言中间的空格自动添加，进入 Linter 的设置，选择空格，找到其中的 Space between Chinese Japanese or Korean and English or numbers，打开即可</li>
</ul>
</li>
</ul>
<h2 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h2><ul>
<li>Image Converter 转化图片格式，我统一转为 webp，并设置了图片分辨率大小。</li>
<li>Unique attachments 用于将附件的文件名统一为 “字母 + 数字”的格式,记着在配置里加入 webp 图片格式</li>
<li>Image Inserter 用于找图片，我用于设置文章封面，即设置 <code>cover.image</code> 属性。</li>
</ul>
<h1 id="目前在用的插件"><a href="#目前在用的插件" class="headerlink" title="目前在用的插件"></a>目前在用的插件</h1><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407230912844.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>Photoprism照片备份方案</title>
    <url>/2024/07/13/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-Photoprism%E7%85%A7%E7%89%87%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>Alist 网盘+Photoprism</p>
<h1 id="PhotoPrism-配置"><a href="#PhotoPrism-配置" class="headerlink" title="PhotoPrism 配置"></a>PhotoPrism 配置</h1><h2 id="官方脚本"><a href="#官方脚本" class="headerlink" title="官方脚本"></a>官方脚本</h2><p>选择下载官方脚本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#Linux </span><br><span class="line">wget https:<span class="comment">//dl.photoprism.app/docker/docker-compose.yml</span></span><br><span class="line">#Windows</span><br><span class="line">curl.exe -o docker-compose.yml https:<span class="comment">//dl.photoprism.app/docker/windows/docker-compose.yml </span></span><br></pre></td></tr></table></figure>

<h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>进行自定义选项，默认需要依赖数据库</p>
<ul>
<li>可以选择不依赖数据库镜像</li>
<li>自定义访问端口</li>
<li>自定义相册文件映射地址，其中&#x2F;photoprism&#x2F;import 为需要导入的照片地址，&#x2F;photoprism&#x2F;originals 为已经导入的照片地址</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">photoprism:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">photoprism/photoprism:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">stop_grace_period:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">security_opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">seccomp:unconfined</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">apparmor:unconfined</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5246:2342&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_ADMIN_USER:</span> <span class="string">&quot;username&quot;</span>                 <span class="comment"># admin login username</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_ADMIN_PASSWORD:</span> <span class="string">&quot;password&quot;</span>          <span class="comment"># initial admin password (8-72 characters)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_AUTH_MODE:</span> <span class="string">&quot;password&quot;</span>               <span class="comment"># authentication mode (public, password)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_SITE_URL:</span> <span class="string">&quot;http://localhost:2342/&quot;</span>  <span class="comment"># server URL in the format &quot;http(s)://domain.name(:port)/(path)&quot;</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DISABLE_TLS:</span> <span class="string">&quot;false&quot;</span>                <span class="comment"># disables HTTPS/TLS even if the site URL starts with https:// and a certificate is available</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DEFAULT_TLS:</span> <span class="string">&quot;true&quot;</span>                 <span class="comment"># defaults to a self-signed HTTPS/TLS certificate if no other certificate is available</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_ORIGINALS_LIMIT:</span> <span class="number">5000</span>               <span class="comment"># file size limit for originals in MB (increase for high-res video)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_HTTP_COMPRESSION:</span> <span class="string">&quot;gzip&quot;</span>            <span class="comment"># improves transfer speed and bandwidth utilization (none or gzip)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DEBUG:</span> <span class="string">&quot;false&quot;</span>                      <span class="comment"># run in debug mode, shows additional log messages</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_READONLY:</span> <span class="string">&quot;false&quot;</span>                   <span class="comment"># do not modify originals folder; disables import, upload, and delete</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_EXPERIMENTAL:</span> <span class="string">&quot;false&quot;</span>               <span class="comment"># enables experimental features</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DISABLE_CHOWN:</span> <span class="string">&quot;false&quot;</span>              <span class="comment"># disables updating storage permissions via chmod and chown on startup</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DISABLE_WEBDAV:</span> <span class="string">&quot;false&quot;</span>             <span class="comment"># disables built-in WebDAV server</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DISABLE_SETTINGS:</span> <span class="string">&quot;false&quot;</span>           <span class="comment"># disables settings UI and API</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DISABLE_TENSORFLOW:</span> <span class="string">&quot;false&quot;</span>         <span class="comment"># disables all features depending on TensorFlow</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DISABLE_FACES:</span> <span class="string">&quot;false&quot;</span>              <span class="comment"># disables face detection and recognition (requires TensorFlow)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DISABLE_CLASSIFICATION:</span> <span class="string">&quot;false&quot;</span>     <span class="comment"># disables image classification (requires TensorFlow)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DISABLE_VECTORS:</span> <span class="string">&quot;false&quot;</span>            <span class="comment"># disables vector graphics support</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DISABLE_RAW:</span> <span class="string">&quot;false&quot;</span>                <span class="comment"># disables indexing and conversion of RAW images</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_RAW_PRESETS:</span> <span class="string">&quot;false&quot;</span>                <span class="comment"># enables applying user presets when converting RAW images (reduces performance)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_SIDECAR_YAML:</span> <span class="string">&quot;true&quot;</span>                <span class="comment"># creates YAML sidecar files to back up picture metadata</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_BACKUP_ALBUMS:</span> <span class="string">&quot;true&quot;</span>               <span class="comment"># creates YAML files to back up album metadata</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_BACKUP_DATABASE:</span> <span class="string">&quot;true&quot;</span>             <span class="comment"># creates regular backups based on the configured schedule</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_BACKUP_SCHEDULE:</span> <span class="string">&quot;daily&quot;</span>            <span class="comment"># backup SCHEDULE in cron format (e.g. &quot;0 12 * * *&quot; for daily at noon) or at a random time (daily, weekly)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_INDEX_SCHEDULE:</span> <span class="string">&quot;&quot;</span>                  <span class="comment"># indexing SCHEDULE in cron format (e.g. &quot;@every 3h&quot; for every 3 hours; &quot;&quot; to disable)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_AUTO_INDEX:</span> <span class="number">300</span>                     <span class="comment"># delay before automatically indexing files in SECONDS when uploading via WebDAV (-1 to disable)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_AUTO_IMPORT:</span> <span class="number">-1</span>                     <span class="comment"># delay before automatically importing files in SECONDS when uploading via WebDAV (-1 to disable)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_DETECT_NSFW:</span> <span class="string">&quot;false&quot;</span>                <span class="comment"># automatically flags photos as private that MAY be offensive (requires TensorFlow)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_UPLOAD_NSFW:</span> <span class="string">&quot;true&quot;</span>                 <span class="comment"># allows uploads that MAY be offensive (no effect without TensorFlow)</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_SITE_CAPTION:</span> <span class="string">&quot;AI-Powered Photos App&quot;</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_SITE_DESCRIPTION:</span> <span class="string">&quot;&quot;</span>                <span class="comment"># meta site description</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_SITE_AUTHOR:</span> <span class="string">&quot;&quot;</span>                     <span class="comment"># meta site author</span></span><br><span class="line">      <span class="comment">## Video Transcoding (https://docs.photoprism.app/getting-started/advanced/transcoding/):</span></span><br><span class="line">      <span class="comment"># PHOTOPRISM_FFMPEG_ENCODER: &quot;software&quot;        # H.264/AVC encoder (software, intel, nvidia, apple, raspberry, or vaapi)</span></span><br><span class="line">      <span class="comment"># PHOTOPRISM_FFMPEG_SIZE: &quot;1920&quot;               # video size limit in pixels (720-7680) (default: 3840)</span></span><br><span class="line">      <span class="comment"># PHOTOPRISM_FFMPEG_BITRATE: &quot;32&quot;              # video bitrate limit in Mbit/s (default: 50)</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">&quot;/photoprism&quot;</span> <span class="comment"># do not change or remove</span></span><br><span class="line">    <span class="comment">## Storage Folders: use &quot;/&quot; not &quot;\&quot; as separator, &quot;~&quot; is a shortcut for C:/user/&#123;username&#125;, &quot;.&quot; for the current directory</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># &quot;C:/user/username/folder:/photoprism/folder&quot;       # example</span></span><br><span class="line">      <span class="comment"># - &quot;~/Pictures:/photoprism/originals&quot;                 # original media files (photos and videos)</span></span><br><span class="line">      <span class="comment"># - &quot;D:/example/family:/photoprism/originals/family&quot; # *additional* media folders can be mounted like this</span></span><br><span class="line">      <span class="comment"># - &quot;E:/:/photoprism/import&quot;                         # *optional* base folder from which files can be imported to originals</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;E:/01.照片/:/photoprism/import&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./original/:/photoprism/originals&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./videos:/photoprism/originals/videos&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./storage:/photoprism/storage&quot;</span>                    <span class="comment"># *writable* storage folder for cache, database, and sidecar files (never remove)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Create named volumes, advanced users may remove this if they mount a regular host folder</span></span><br><span class="line"><span class="comment">## for the database or use SQLite instead (never remove otherwise)</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br></pre></td></tr></table></figure>

<h1 id="Alist"><a href="#Alist" class="headerlink" title="Alist"></a>Alist</h1><p><a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/Alist%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA.md">Alist网盘搭建</a></p>
<ol>
<li>通过 mount 命令映射 webdav 到本地后</li>
<li>修改 docker-compose 中的配置文件，将导入和存储位置修改为 webdav 所在位置</li>
<li>启动相册</li>
</ol>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>Qexo本地部署</title>
    <url>/2024/05/21/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-Qexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>Qexo 是一个快速、强大、美观的在线 静态博客编辑器。使用 GPL3.0 开源协议。支持包括且不限于在 Vercel 等平台部署, 为您的静态博客添加动态的元素</p>
<p>项目地址： <a href="https://github.com/Qexo/Qexo">https://github.com/Qexo/Qexo</a></p>
<h1 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h1><p>安装 mysql</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure>

<p>查看并更新密码 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo cat /etc/mysql/debian.cnf</span><br></pre></td></tr></table></figure>

<p>创建 Qexo 要使用表 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">create database qexo;</span><br></pre></td></tr></table></figure>

<p>克隆 qexo 项目到本地</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/Qexo/Qexo.git</span></span><br></pre></td></tr></table></figure>

<p>编辑配置，以使用 Mysql 为例, 确认好安装相关依赖后在 manage.py 的同级目录下创建并修改 configs.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql  </span><br><span class="line">pymysql.install_as_MySQLdb()  </span><br><span class="line">DOMAINS = [<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;124.222.246.202&quot;</span>]  </span><br><span class="line">DATABASES = &#123;  </span><br><span class="line">	<span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">		<span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;数据库表&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;数据库用户名&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;数据库密码&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;OPTIONS&#x27;</span>: &#123;  </span><br><span class="line">		<span class="string">&quot;init_command&quot;</span>: <span class="string">&quot;SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;&quot;</span>  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirements.txt  </span><br><span class="line">python3 manage.py makemigrations  </span><br><span class="line">python3 manage.py migrate</span><br></pre></td></tr></table></figure>

<p>启动 Qexo 博客管理后端 后台运行，退出 shell 也在运行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nohup python3 manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9082</span> --noreload &amp;</span><br></pre></td></tr></table></figure>

<p>访问公网 IP+ 端口即可打开 Qexo 管理页面</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>chatGPT对接微信公众号</title>
    <url>/2024/08/22/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-chatGPT%E5%AF%B9%E6%8E%A5%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</url>
    <content><![CDATA[<p>这里需要我们自定义来处理用户发送过来的消息，首先需要导入 werobot 这个依赖，这是微信公众号官方让我们自定义消息处理的模块。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pip install werobot</span><br><span class="line">pip install openai</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> werobot </span><br><span class="line"><span class="meta"># token是微信公众号用来指定接入当前云服务器的服务的凭证，代表是自己人接入的，等一下就有什么用了 </span></span><br><span class="line">robot = werobot.<span class="built_in">WeRoBot</span>(token=<span class="string">&#x27;123456&#x27;</span>) </span><br><span class="line">@robot.handler def <span class="built_in">hello</span> (messages): </span><br><span class="line"><span class="meta"># messages.content是用户发送的内容 </span></span><br><span class="line"><span class="built_in">print</span>(messages.content) </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello!&quot;</span> </span><br><span class="line"></span><br><span class="line">robot.config[<span class="string">&#x27;HOST&#x27;</span>] = <span class="string">&#x27;0.0.0.0&#x27;</span> </span><br><span class="line">robot.config[<span class="string">&#x27;PORT&#x27;</span>] = <span class="number">80</span> </span><br><span class="line">robot.<span class="built_in">run</span>()</span><br></pre></td></tr></table></figure>

<p>以上的代码是用户在公众号发送什么消息都回复 hello</p>
<p>整合 chatGPT 服务</p>
<p>前提：</p>
<p>要注册 openai 的账号，在账户下面生成 api_key 供程序调用</p>
<p>服务器能够访问外网，这样才能调用成功</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> werobot </span><br><span class="line"><span class="keyword">import</span> openai </span><br><span class="line">openai.api_key = <span class="string">&quot;你的api_key&quot;</span> </span><br><span class="line">robot = werobot.<span class="built_in">WeRoBot</span>() </span><br><span class="line"><span class="keyword">class</span> <span class="built_in">RobotConfig</span>(object): </span><br><span class="line">HOST=<span class="string">&quot;0.0.0.0&quot;</span> </span><br><span class="line">PORT= <span class="number">80</span> </span><br><span class="line">TOKEN = <span class="string">&quot;you token&quot;</span> <span class="meta"># token是微信公众号用来接入云服务器的服务的凭证</span></span><br><span class="line">robot.config.<span class="built_in">from_object</span>(RobotConfig) </span><br><span class="line"></span><br><span class="line">def <span class="built_in">generate_response</span>(prompt): </span><br><span class="line">response = openai.Completion.<span class="built_in">create</span>( </span><br><span class="line">model=<span class="string">&quot;text-davinci-003&quot;</span>, </span><br><span class="line">prompt=prompt, </span><br><span class="line">temperature=<span class="number">0.7</span>, </span><br><span class="line">max_tokens=<span class="number">3000</span>, </span><br><span class="line">top_p=<span class="number">1</span>, </span><br><span class="line">frequency_penalty=<span class="number">0</span>, </span><br><span class="line">presence_penalty=<span class="number">0</span></span><br><span class="line">) </span><br><span class="line">message = response.choices[<span class="number">0</span>].text </span><br><span class="line"><span class="keyword">return</span> message.<span class="built_in">strip</span>() </span><br><span class="line">@robot.handler </span><br><span class="line">def <span class="built_in">hello</span> (messages): </span><br><span class="line"><span class="built_in">print</span>(messages.content) </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">generate_response</span>(messages.content) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">robot.<span class="built_in">run</span>()</span><br></pre></td></tr></table></figure>

<p>完成后使用 python 启动脚本</p>
<p>配置公众号相关信息</p>
<p>前提：</p>
<p>需要保证前面的服务已经启动</p>
<p>修改云服务的安全组，启用 80 端口</p>
<p>修改消息服务器设置，让我们自定义来处理用户发送的消息</p>
<p>修改公众号服务器配置信息</p>
<p>url：里面是你的云服务器的 IP，后面加不了端口号，默认只能使用 80 端口，https 默认就是 443 端口。&#x2F;chatgpt 可以随便写</p>
<p>token：就是前面讲的自己的凭证,可以自己定义</p>
<p>EncodingAESKey：随机生成就行</p>
<p>确定云服务器上的服务没有问题的话，就点提交就行了</p>
<p>升级一下 pip</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>云服务管理软件-1panel</title>
    <url>/2024/08/27/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6-1panel/</url>
    <content><![CDATA[<p>云服务管理软件：开源的 1panel</p>
<p>创建 1panel 文件夹，进入后，执行以下命令安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先安装docker</span></span><br><span class="line">sudo apt install docker.io</span><br><span class="line"></span><br><span class="line">curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh &amp;&amp; sudo bash quick_start.sh</span><br></pre></td></tr></table></figure>

<p>输入安全入口，之后登陆时需要安装 IP 地址 + 端口号 + 安全入口的形式进入管理页面</p>
<p>124.224.246:9090&#x2F;liuluhua</p>
<p>输入登录用户名和密码</p>
<p>liuluhua-passwd</p>
<p>之后已完成 1panel 部署，可以方便的进行软件的管理</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>博客Hexo部署</title>
    <url>/2024/05/17/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8D%9A%E5%AE%A2Hexo%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<ol>
<li>√ 博客框架采用 Hexo </li>
<li>√ 部署到 GitHubPages（）</li>
<li>√ 部署到 Vercel（GitHub Publish）- 已取消部署</li>
<li>× 通过 Netlify 部署和构建</li>
<li>√ 利用 Obsidian Digital Garden&#x2F;Flowershow 插件在 Vercel 上将笔记内容部署为 Obsidian 数字花园 - 已取消部署</li>
</ol>
<h1 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h1><ul>
<li>创建 GitHub 发布仓库 <a href="#GitHub%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2">GitHub仓库部署</a></li>
<li>创建 GitHub 源码仓库，并在仓库中部署 Hexo</li>
<li>在源码仓库中创建工作流，工作流主要完成任务是在接收到同步后，完成以下几个动作 <a href="#GitHub%20Actions">GitHub Actions</a><ul>
<li>构建之前需要调用 hexo 插件自动生成 category 信息 </li>
<li>构建静态页面生成 public 文件夹</li>
<li>将 public 文件夹拷贝至发布仓库</li>
</ul>
</li>
</ul>
<h1 id="Hexo-仓库部署"><a href="#Hexo-仓库部署" class="headerlink" title="Hexo 仓库部署"></a>Hexo 仓库部署</h1><p>Hexo 仓库部署分为两种形式，一种是部署在 Github 上，利用 GitHub Actions 生成页面，一种是部署在本地，本地生成页面后将 public 同步到 github pages。</p>
<ul>
<li>如果部署在 GitHub，则需要两个仓库，一个用于部署 Hexo 源码，一个用于部署 GitHubPages，之后需要通过 github actions 进行发布管理。优点是本地不需要 Hexo 环境，直接提交后自动构建页面<br>  源码仓库闭源，同步笔记到源码仓库后，源码仓库通过 actions 时触发同步到发布仓库，更新发布仓库页面</li>
<li>如果部署在本地，需要在本地生成静态网页，之后将静态网页通过 publisher 发布 public 文件夹到 github 仓库，但是需要本地具有 Hexo 环境，且需要在本地生成静态网页</li>
</ul>
<h2 id="Github-部署"><a href="#Github-部署" class="headerlink" title="Github 部署"></a>Github 部署</h2><p>可以实现两个仓库都在 GitHub，并通过 GitHub Actions 在源码仓库进行编译，编译完成后自动将源码仓库的静态页面内容复制到发布仓库，实现自动化的发布管理。</p>
<ol>
<li>将 Hexo 的源码仓库设置在 GitHub 上，你可以在这个仓库中编辑和管理 Hexo 的源代码、主题和文章。</li>
<li>创建另一个 GitHub 仓库作为发布仓库，用于存放生成的静态网页。你可以将 Hexo 生成的 public 文件夹的内容推送到这个仓库中。该仓库利用 GitHub Pages，直接通过 username.github.io 进行访问</li>
<li>在 Hexo 源码仓库中设置一个 GitHub Actions workflow，以便在每次提交或推送时自动将更新的内容复制到发布仓库。</li>
<li>需要配置 GitHub 的 ssh，可以有权限访问两个仓库</li>
<li>需要配置发布仓库的 deploy key，可以有权限写入发布仓库</li>
</ol>
<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><ul>
<li>GitHub 二级域名 <a href="https://pages.github.com/">GitHubPages</a><br> liuluhua.github.io</li>
<li>二级域名 <a href="https://freedomain.one/">https://freedomain.one/</a><br> linglu.work.gd</li>
</ul>
<ul>
<li>cloudflare 托管 <a href="https://dash.cloudflare.com/">https://dash.cloudflare.com/</a></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>包括添加三条解析记录</p>
<ul>
<li>192.30.252.153 是 GitHub 的地址，你也可以 ping 你的 <a href="https://liuluhua.github.io/">http:&#x2F;&#x2F;你的用户名.github.io</a> 的 ip 地址，填入进去。</li>
<li>第三个记录类型是 CNAME，CNAME 的记录值是：<a href="https://liuluhua.github.io/">http:&#x2F;&#x2F;你的用户名.github.io</a> 这里千万别弄错了。</li>
<li>绑定 Github 域名，登录 GitHub，进入之前创建的仓库，点击 settings，设置 Custom domain，输入你的域名</li>
</ul>
<h1 id="PicGo-和-Github-图床配置"><a href="#PicGo-和-Github-图床配置" class="headerlink" title="PicGo 和 Github 图床配置"></a>PicGo 和 Github 图床配置</h1><p>PicGo 是一个开源的图片上传工具，主要用于将本地图片上传到各种图片托管服务，并生成图片链接。它提供了图形界面和命令行两种方式来使用。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><strong>图片托管</strong>：将本地图片上传到图片托管服务，如 GitHub 等。<br><strong>图片压缩</strong>：在上传图片之前，可以选择对图片进行压缩以减小图片文件大小，节省存储空间和加快图片加载速度。<br><strong>图片管理</strong>：通过 PicGo 上传的图片可以在相应的托管服务上进行管理，包括查看、删除等操作。<br><strong>图片链接生成</strong>：上传成功后，PicGo 会生成图片链接，方便在博客、论坛等地方直接使用图片。</p>
<h2 id="GitHub-图床配置"><a href="#GitHub-图床配置" class="headerlink" title="GitHub 图床配置"></a>GitHub 图床配置</h2><ul>
<li>创建一个 <code>public</code> 仓库</li>
<li>进入 <code>Settings-Developer Settings-Personal access tokens (classic) </code> 生成 <code>token</code></li>
<li>设置自定义域名为 <code>https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed</code></li>
</ul>
<h2 id="配置-Github-图床"><a href="#配置-Github-图床" class="headerlink" title="配置 Github 图床"></a>配置 Github 图床</h2><p>图床设计选择 GitHub，输入在 GitHub 的仓库名，分支名和 token 即可</p>
<ul>
<li>设置 GitHub 为默认图床</li>
<li>设置图床参数</li>
<li>设定存储路径</li>
</ul>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133915.png" alt="20240505000945.png"></p>
<h2 id="插件-super-prefix"><a href="#插件-super-prefix" class="headerlink" title="插件 super-prefix"></a>插件 super-prefix</h2><p>安装 super prefix 插件，将图片存储时按照时间分类存储（Nodejs 环境）</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133853.png" alt="20240505000510.png"></p>
<p>配置文件路径插件</p>
<ul>
<li>需要在 PicGo 设置中关闭时间戳重命名</li>
</ul>
<p><code>/img/2019/11/18/20191118005858.jpeg</code></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">建议值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">prefixFormat</td>
<td align="center"><code>YYYY/MM/DD/</code></td>
<td>文件名个性前缀格式 (以&#x2F;结尾)</td>
</tr>
<tr>
<td align="center">fileFormat</td>
<td align="center"><code>YYYYMMDDHHmmss</code></td>
<td>文件名个性格式</td>
</tr>
</tbody></table>
<h1 id="Emo-插件"><a href="#Emo-插件" class="headerlink" title="Emo 插件"></a>Emo 插件</h1><p>如果不想要在配置 picGo 软件，直接用 Obsidian 中的 Emo 插件即可，相比起来缺少了自定义域名等功能</p>
<h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="Github-Pages-部署"><a href="#Github-Pages-部署" class="headerlink" title="Github Pages 部署"></a>Github Pages 部署</h2><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p>
<p>创建 GitHub 账号，并创建一个基于用户名.github.io 的仓库</p>
<ul>
<li>使用 GitHub Pages 进行部署，所建仓库必须取名为“GitHub 用户名.github.io”</li>
<li>勾选“Add a README file”，不然后面会看不到 GitHub Pages 域名和部署分支</li>
<li>仓库需要创建为公有仓库，即 public</li>
<li>仓库大小限制为</li>
<li>创建完成后 GitHub Pages 给我们提供了一个格式为 <a href="https://liuluhua.github.io/">https://GitHub用户名.github.io</a>  的免费域名，并且相应的网站是从该仓库的 main&#x2F;master 分支构建得到的</li>
<li>自定义域名，在 GitHub 仓库 <code>Settings</code>-<code>Pages</code>-<code>Custom domain</code> 添加自己的域名</li>
</ul>
<h2 id="Git-Hook"><a href="#Git-Hook" class="headerlink" title="Git Hook"></a>Git Hook</h2><p>Git hook 是一种机制，允许在特定的 Git 事件发生时触发自定义的脚本或命令。这些事件可以包括提交 (commit)、推送 (push)、合并 (merge) 等。使用 Git hook，你可以在这些事件发生时执行自定义的操作，比如运行测试、格式化代码、触发构建等。Git 提供了一系列的预定义钩子，你可以将自己的脚本绑定到这些钩子上，或者创建自定义的钩子。</p>
<h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p>GitHub Actions 是 GitHub 提供的一项持续集成（CI）和持续部署（CD）服务，允许开发者自动化软件开发工作流程。通过 GitHub Actions，你可以在 GitHub 上运行自定义的代码（称为动作），以响应存储库中的事件，例如推送代码、创建拉取请求等。</p>
<p>一个 GitHub Actions 的核心概念是 workflow（工作流），它是一系列由动作组成的自定义任务，这些任务可以在特定的事件触发时自动执行。每个 workflow 都定义了一系列步骤，每个步骤又包含一个或多个动作。workflow 可以用 YAML 格式定义，并存储在存储库的 <code>.github/workflows</code> 目录中。</p>
<p>通过 GitHub Actions，实现将代码同步 GitHub 之后，由 GitHub Actions 执行页面的发布。</p>
<ul>
<li>执行 GitHub Actions，在需要执行的储存库中前往 <code>Settings &gt; Pages &gt; Source</code>，并将 <code>Source</code> 改为 <code>GitHub Actions</code>。</li>
<li>在储存库中建立 <code>.github/workflows/blogPublish.yml</code> 并写入内容</li>
<li>环境变量配置在 <code>Settings –&gt; Secrets and Variables –&gt; Actions</code> 里面,配置后，可以在 actions 里面通过 <code>$&#123;&#123; secrets.dingtalk_secret &#125;&#125;</code> 调用到对应的数据</li>
</ul>
<h3 id="文章更新时间问题"><a href="#文章更新时间问题" class="headerlink" title="文章更新时间问题"></a>文章更新时间问题</h3><p><strong>使用 Github Actions 造成的文章更新时间问题</strong><br>参考原文： <a href="https://mrseawave.github.io/blogs/articles/2021/01/07/ci-hexo-update-time/">https://mrseawave.github.io/blogs/articles/2021/01/07/ci-hexo-update-time/</a></p>
<p>当使用 Github Actions 自动化部署时，发现部署成功后，所有文章的更新时间都变成了此次提交修改的时间，但有些文章在上一次提交后是没有发生过任何修改的。</p>
<p>这是因为 git 在推送更新时，并不记录保存文件的访问时间、修改时间等元信息，（原因在这里）所以每次使用 git 把项目 clone 下来时，文件的时间都是克隆时的时间。又因为如果没有在 front-matter 中指定 updated，Hexo 会默认使用文件的最后修改时间作为文章的更新时间，所以会出现所有文章的更新时间都发生变化的情况。</p>
<p>总的来说，使用 git clone 下来的文件的时间都不是原来文件的时间，而自动化部署每次都需要 clone 源码才能进行后面的生成和部署操作，所以目前如果想正确显示更新时间。对于 Github Actions 可以使用命令在构建之前进行处理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy_gh_pages:</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restore</span> <span class="string">file</span> <span class="string">modification</span> <span class="string">time</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">git</span> <span class="string">ls-files</span> <span class="string">-z</span> <span class="string">|</span> <span class="string">while</span> <span class="string">read</span> <span class="string">-d</span> <span class="string">&#x27;&#x27;</span> <span class="string">path;</span> <span class="string">do</span> <span class="string">touch</span> <span class="string">-d</span> <span class="string">&quot;$(git log -1 --format=&quot;</span><span class="string">@%ct&quot;</span> <span class="string">&quot;$path&quot;</span><span class="string">)&quot;</span> <span class="string">&quot;$path&quot;</span><span class="string">;</span> <span class="string">done</span></span><br></pre></td></tr></table></figure>

<p>如果 git 命令不好用， 也可以使用 find 命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find <span class="built_in">source</span>/_posts -name <span class="string">&#x27;*.md&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> file; <span class="keyword">do</span> <span class="built_in">touch</span> -d <span class="string">&quot;<span class="subst">$(git log -1 --format=<span class="string">&quot;@%ct&quot;</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span>)</span>&quot;</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>实际上，clone 下来的文件的时间还是克隆时的时间，然后通过上面的命令，它将 clone 下来的文件的时间改成了该文件最近一次变动的推送时间（也即文件最后一次修改的 push 时间）。</p>
<p>注：如果 github actions 中使用 actions&#x2F;checkout@v2，请设定它的参数 fetch-depth: 0，因为 0 表示获取所有分支和标签的所有历史记录。默认值为 1</p>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>在 Git 仓库的根目录下编辑有.gitignore 文件，该文件中定义了一些不需要上传至 GitHub 的内容，列在该文件中的文件或文件夹将会被忽略，不在上传</p>
<h3 id="Hexo-忽略文件"><a href="#Hexo-忽略文件" class="headerlink" title="Hexo 忽略文件"></a>Hexo 忽略文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line"><span class="keyword">public</span>/</span><br><span class="line">.deploy*/</span><br><span class="line">_multiconfig.yml</span><br></pre></td></tr></table></figure>

<h3 id="Obsidian-忽略文件"><a href="#Obsidian-忽略文件" class="headerlink" title="Obsidian 忽略文件"></a>Obsidian 忽略文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.obsidian/workspace</span><br></pre></td></tr></table></figure>

<p>.obsidian 文件本身是可以同步的，当前存储库的插件以及相关的配置都会下载在这个文件夹中，因此将其同步到 git 记录中也是非常有用的，假如你切换设备就不需要重新为当前的存储库重新配置 Obsidian 了。</p>
<h2 id="GitHub-仓库部署"><a href="#GitHub-仓库部署" class="headerlink" title="GitHub 仓库部署"></a>GitHub 仓库部署</h2><h3 id="源码仓库部署"><a href="#源码仓库部署" class="headerlink" title="源码仓库部署"></a>源码仓库部署</h3><ul>
<li>创建一个私有仓库，此处我创建一个 BlogDeploy 仓库，仓库拉取到本地后，在仓库中部署 Hexo<a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li>创建 gitignore 文件，排除 Hexo 不用上传的文件</li>
<li>同步仓库到远端</li>
</ul>
<h3 id="发布仓库部署"><a href="#发布仓库部署" class="headerlink" title="发布仓库部署"></a>发布仓库部署</h3><ul>
<li>创建一个 GitHub 仓库，仓库必须取名为“GitHub 用户名.github.io”</li>
<li>仓库需要创建为公有仓库，即 public</li>
<li>创建一个分支，分支名为 ImageBed，用于做图床上传</li>
<li>获取 Token，选择用户 Settings-&gt;Developer settings-&gt;Personal access tokens，token 的权限获取，勾上 workflow 即可</li>
</ul>
<h4 id="图床分支创建"><a href="#图床分支创建" class="headerlink" title="图床分支创建"></a>图床分支创建</h4><p>用于存储图片，图床分支的相关信息部署完成后，需要在 <a href="#PicGo">PicGo</a> 中进行配置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git checkout -b my-test  <span class="comment">//在当前分支下创建my-test的本地分支分支</span></span><br><span class="line">git push origin my-test  <span class="comment">//将my-test分支推送到远程</span></span><br><span class="line">git branch --set-upstream-to=origin/my-test <span class="comment">//将本地分支my-test关联到远程分支my-test上   </span></span><br><span class="line">git branch -a <span class="comment">//查看远程分支 </span></span><br></pre></td></tr></table></figure>

<h1 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h1><p>Hexo 是一个基于 Node.js 的静态网站生成器，主要用于快速、简单地搭建个人博客或静态网站。它采用 Markdown 格式来撰写内容，并提供了丰富的主题和插件生态系统，可以轻松扩展和定制网站功能和外观。 适用于个人博客、项目文档、个人简历等各种静态网站的搭建和管理。</p>
<h2 id="目录架构"><a href="#目录架构" class="headerlink" title="目录架构"></a>目录架构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_config.yml #网站的配置信息</span><br><span class="line">package.json #应用程序的信息</span><br><span class="line">scaffolds #模版文件夹</span><br><span class="line">source #存放用户资源，Markdown 文档</span><br><span class="line">	_drafts</span><br><span class="line">	_posts</span><br><span class="line">themes #主题文件夹</span><br><span class="line"><span class="keyword">public</span> #网站文件</span><br></pre></td></tr></table></figure>

<h2 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h2><p><strong>使用流程</strong></p>
<ol>
<li>安装 hexo<code>sudo npm install -g hexo-cli</code></li>
<li>查看版本，确认安装成功 <code>hexo -v</code></li>
<li>创建一个新文件夹 <code>Hexo</code>，并初始化该文件夹 <code>hexo init Hexo</code></li>
<li>清除缓存 <code>hexo clean</code></li>
<li>生成静态文件 <code>hexo g</code></li>
<li>开启本地服务器并修改端口为 80<code>hexo s -p 9050</code></li>
</ol>
<p><strong>常用命令</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli #安装Hexo  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init #初始化博客  </span><br><span class="line">  </span><br><span class="line">命令简写  </span><br><span class="line">hexo n <span class="string">&quot;我的博客&quot;</span></span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;我的博客&quot;</span> #新建文章  </span><br><span class="line">hexo g</span><br><span class="line">hexo generate #生成  </span><br><span class="line">hexo s</span><br><span class="line">hexo server #启动服务预览  </span><br><span class="line">hexo d</span><br><span class="line">hexo deploy #部署  </span><br><span class="line">  </span><br><span class="line">hexo server #Hexo会监视文件变动并自动更新，无须重启服务器  </span><br><span class="line">hexo server -s #静态模式  </span><br><span class="line">hexo server -p <span class="number">5000</span> #更改端口  </span><br><span class="line">hexo server -i <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> #自定义 IP  </span><br><span class="line">hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</span><br><span class="line"></span><br><span class="line">端口修改 node_modules\hexo-server\index.js </span><br><span class="line">临时启动 hexo s -p <span class="number">9050</span></span><br></pre></td></tr></table></figure>

<p><code>hexo generate</code> 将 Hexo 源码目录中已有的源码编译生成为静态网页文件，生成以下：</p>
<ul>
<li>db.json 文件：编译过程中产生的中间文件，不用关心；</li>
<li>public 文件夹：新生成的静态网页文件就存放在这个目录下。</li>
</ul>
<p><code>hexo deploy</code> 将静态网页文件推送到 GitHub Pages</p>
<ul>
<li>Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容</li>
</ul>
<h2 id="快捷编辑配置文件"><a href="#快捷编辑配置文件" class="headerlink" title="快捷编辑配置文件"></a>快捷编辑配置文件</h2><p>站点配置文件和主题配置文件是我们 DIY 博客经常要编辑的两个文件，在 Obsidian 中没法编辑 yml 文件，可以通过 URL 来打开 yml 文件，会自动调用默认的编辑器打开。创建一个专门用于编辑配置的文件，写入我们两个配置文件所在的相对路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[打开站点配置文件](Blog/_config.yml)</span><br><span class="line">[打开主题配置文件](Blog/themes/stellar/_config.yml)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者通过osidian插件shellcommands打开.开头的隐藏文件</span></span><br><span class="line">[Github 同步忽略文件配置](obsidian://shell-commands/?vault=BlogDeploy&amp;execute=f4b02rlcvr)</span><br></pre></td></tr></table></figure>

<h2 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h2><p>在 blog 根目录里的 <code>_config.yml</code> 文件称为<strong>站点</strong>配置文件</p>
<ul>
<li>主题修改:theme</li>
<li>网站标题:title</li>
<li>副标题:subtitle</li>
<li>网站描述:description</li>
<li>作者:author</li>
<li>网站头像外部链接:avatar</li>
<li>网站语言:language:zh-Hans</li>
<li>时区:timezone:Asia&#x2F;Shanghai</li>
<li>自定义域名：url:</li>
<li>忽略文件：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">skip_render:   </span><br><span class="line"># 排除一些obsidian编辑器的文件和一些脚本/模板文件  </span><br><span class="line">  - <span class="string">&#x27;_posts/.obsidian/*&#x27;</span>  </span><br><span class="line">  - <span class="string">&#x27;_posts/Scripts/*&#x27;</span>  </span><br><span class="line">  - <span class="string">&#x27;_posts/Templates/*&#x27;</span>  </span><br></pre></td></tr></table></figure>

<h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><p>使用的主题：<code>stellar</code> 或者 <code>Next</code>，二选其一</p>
<ul>
<li>进入根目录 themes 文件夹，里面有个 <code>_config.yml</code> 文件，为<strong>主题</strong>配置文件</li>
</ul>
<ul>
<li>社交外链的设置，即在侧栏展示你的个人社交网站信息。(插件 jiathis)</li>
<li>插入网易云，进入网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器，在侧栏插入这首歌的音乐播放器，修改 <code>blog/themes/next/layout/_macro</code> 的 sidebar.swig 文件，添加刚刚复制的外链代码</li>
<li>设置背景，在 <code>blog/themes/next/source/css/_custom</code> 文件的 custom.styl 首部添加 <code>body &#123; background:url(./background.jpg);  background-attachment: fixed; &#125;</code>，fixed 固定背景图片</li>
<li>增加侧栏菜单条目，默认的侧栏菜单条目有：首页、归档、标签、关于、搜索等。如果你想要增加其他的菜单条目，修改主题配置文件 <code>_config.yml</code> 里的 <code>Menu Settings</code> 中的 <code>menu</code> 和 <code>menu_icons</code> 两个地方</li>
</ul>
<h2 id="域名配置文件"><a href="#域名配置文件" class="headerlink" title="域名配置文件"></a>域名配置文件</h2><p>进入 <code>blog/source</code> 目录下，创建一个文件，文件名 CNAME，写入你的自定义域名</p>
<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/17/20240517101429.png" alt="在这里插入图片描述"></p>
<p>扩展：abbrlink&#x3D;文章永久链接</p>
<h2 id="category"><a href="#category" class="headerlink" title="category"></a>category</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">并列分类，了解一下：  </span><br><span class="line">categories:  </span><br><span class="line">- [Linux]  </span><br><span class="line">- [Tools]</span><br><span class="line"></span><br><span class="line">并列+子分类，再了解一下：  </span><br><span class="line">categories:  </span><br><span class="line">- [Linux, Hexo]  </span><br><span class="line">- [Tools, PHP]</span><br></pre></td></tr></table></figure>

<h2 id="自定义文章标签"><a href="#自定义文章标签" class="headerlink" title="自定义文章标签"></a>自定义文章标签</h2><p>生成标签页面 <code>hexo new page tags</code>，修改 blog&#x2F;source&#x2F;tags&#x2F;index.md，添加 type: “tags”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: <span class="number">2023</span><span class="number">-01</span><span class="number">-08</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">57</span></span><br><span class="line">type: <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>

<p>以后就可以在文章文件头添加标签了，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">title: Hexo + GitHub 搭建个人博客</span><br><span class="line">date: <span class="number">2023</span><span class="number">-01</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">15</span>:<span class="number">00</span></span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Next</span><br><span class="line">- 博客 </span><br></pre></td></tr></table></figure>

<p>手动生成和添加是十分繁琐的，后续利用插件形式按照目录格式为文章自动生成标签。</p>
<h2 id="部署插件-hexo-deployer-git"><a href="#部署插件-hexo-deployer-git" class="headerlink" title="部署插件 hexo-deployer-git"></a>部署插件 hexo-deployer-git</h2><p> 编辑 Hexo 顶层目录下的 <code>_config.yml</code> 文件，文件最后可以看到 deployment 相关内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">deploy：</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:liuluhua/liuluhua.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<ul>
<li>repo 填写仓库 ssh 地址</li>
<li>branch 的填写需要和 <a href="#%5Ed4aa3b">GitHub Pages部分指定的<strong>Branch</strong>保持一致</a></li>
</ul>
<h2 id="搜索插件-hexo-generator-searchdb"><a href="#搜索插件-hexo-generator-searchdb" class="headerlink" title="搜索插件 hexo-generator-searchdb"></a><del>搜索插件 hexo-generator-searchdb</del></h2><p><strong>stellar 自带了搜索插件，故未配置该插件</strong></p>
<ul>
<li>安装 hexo-generator-searchdb<code>npm install hexo-generator-searchdb</code></li>
<li>修改主题配置文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">	enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="自动标签插件-hexo-auto-category"><a href="#自动标签插件-hexo-auto-category" class="headerlink" title="自动标签插件 hexo-auto-category"></a>自动标签插件 hexo-auto-category</h2><p>该插件在 Hexo 进行 build 的时候会去自动根据文章目录情况来自动修改文章的 <code>categories</code> 信息</p>
<ul>
<li>安装插件 <code>npm install hexo-auto-category --save</code></li>
<li>修改站点配置文件 <code>_config.yml</code>，使文章链接清晰</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Generate categories from directory-tree</span><br><span class="line"># Dependencies: https://github.com/xu-song/hexo-auto-category</span><br><span class="line"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span><br><span class="line"># multiple: multiple category hierarchies</span><br><span class="line">auto_category:</span><br><span class="line"> enable: true</span><br><span class="line"> multiple: true</span><br><span class="line"> depth: 5</span><br><span class="line"></span><br><span class="line"># 修改 permalink 让你的文章链接更加友好，并且有益于 SEO </span><br><span class="line">permalink: :year/:month/:hash.html</span><br><span class="line"># 规定你的新文章在 _post 目录下是以 cateory   </span><br><span class="line">new_post_name: :category/:title|</span><br></pre></td></tr></table></figure>

<p>该插件需要每次手动构建执行 hexo g 时才会更新 <code>categories</code> 信息。</p>
<ul>
<li>仓库部署在本地，上传时使用 git hook，在我们每次执行 <code>commit</code> 前都自动运行 <code>npx hexo generate</code> 触发自动生成 <code>categories</code> 的行为，并将生成后的变更自动添加到本次提交中，然后一同 push 到 github 上去。这里可以使用 husky 来很方便的设置这样一个 git hook<br>  <em>1. 安装 huksy：<code>npm install husky --save-dev</code></em><br>  <em>2. 执行 huksy 初始化指令：<code>npx husky install</code></em><br>  *3. 在 <code>package.json</code> 中的 <code>scripts</code> 中写入：<code>&quot;prepare&quot;: &quot;husky install&quot;</code><br>  <em>4. 在生成的 <code>.husky</code> 目录创建 <code>pre-commit</code> 文件（<code>chmod a+x pre-commit</code>），并写入以下内容，之后提交代码时，检查有无 <code>categories</code> 的生成信息。</em></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env sh  </span><br><span class="line">. <span class="string">&quot;$(dirname -- &quot;</span>$<span class="number">0</span><span class="string">&quot;)/_/husky.sh&quot;</span>  </span><br><span class="line">  </span><br><span class="line">npx hexo generate &amp;&amp; git add .</span><br></pre></td></tr></table></figure>

<ul>
<li>仓库部署在 GitHub 时直接利用 GitHub Actions 自动生成</li>
</ul>
<h2 id="站点地图-hexo-generator-sitemap"><a href="#站点地图-hexo-generator-sitemap" class="headerlink" title="站点地图 hexo-generator-sitemap"></a>站点地图 hexo-generator-sitemap</h2><p>修改主题配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行 <code>hexo cl &amp;&amp; hexo g</code> 生成 <code>sitemap.xml</code></li>
<li>此时可以在 <code>blog/public</code> 文件夹下看到 <code>sitemap.xml</code></li>
<li>验证，进入 <a href="https://search.google.com/search-console/welcome">Google Search Console</a> ，选择<strong>网址前缀</strong>，输入网址时记得加上 https:&#x2F;&#x2F;，选择 HTML 标记，你会得到元标记 <code>&lt;meta name=&quot;google-site-verification&quot; content=&quot;xxxxxxxx&quot; /&gt;</code>，将 content 后的内容加入到主题配置文件中 <code>google_site_verification: &quot;xxxxxxxx&quot;</code>，执行 <code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code></li>
</ol>
<p>点击前往资源页面，添加站点地图，成功提交</p>
<h2 id="静态资源压缩-hexo-neat"><a href="#静态资源压缩-hexo-neat" class="headerlink" title="静态资源压缩 hexo-neat"></a>静态资源压缩 hexo-neat</h2><p>主题配置文件添加配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.js&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="字数统计-hexo-word-counter"><a href="#字数统计-hexo-word-counter" class="headerlink" title="字数统计 hexo-word-counter"></a>字数统计 hexo-word-counter</h2><h2 id="评论系统-utteranc"><a href="#评论系统-utteranc" class="headerlink" title="评论系统 utteranc"></a>评论系统 utteranc</h2><p>Utterances 是一个基于 Github Issues 的轻量级评论系统，主页地址 <a href="http://utteranc.es/">http://utteranc.es</a></p>
<p>Hexo Stellar 主题的配置文件如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">######## Comments ########</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">utterances</span> <span class="comment"># beaudar, utterances, giscus, twikoo, waline, artalk</span></span><br><span class="line">  <span class="attr">comment_title:</span> <span class="string">快来参与讨论吧~</span></span><br><span class="line">  <span class="comment"># utterances</span></span><br><span class="line">  <span class="comment"># https://utteranc.es/</span></span><br><span class="line">  <span class="attr">utterances:</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">liuluhua/liuluhua.github.io</span></span><br><span class="line">    <span class="attr">issue-term:</span> <span class="string">title</span></span><br><span class="line">    <span class="attr">issue-number:</span></span><br><span class="line">    <span class="attr">theme:</span> <span class="string">preferred-color-scheme</span></span><br><span class="line">    <span class="attr">label:</span> <span class="string">&quot;💬&quot;</span></span><br></pre></td></tr></table></figure>

<p>其他使用情况下，在你的网页需要插入 Utterances 评论的位置，粘贴以下代码（username，reponame 分别修改为你的 GitHub 用户名，仓库名）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://utteranc.es/client.js&quot;</span></span><br><span class="line">        repo=<span class="string">&quot;username/reponame&quot;</span></span><br><span class="line">        issue-term=<span class="string">&quot;pathname&quot;</span></span><br><span class="line">        theme=<span class="string">&quot;github-light&quot;</span></span><br><span class="line">        crossorigin=<span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        <span class="keyword">async</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h2><p>霞鹜文楷字库 GitHub 地址： <a href="https://github.com/lxgw/LxgwWenKai">https://github.com/lxgw/LxgwWenKai</a></p>
<p>更改站点配置文件，增加如下字段</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://cdn.jsdelivr.net/gh/satouriko/LxgwWenKai_Webfonts@v1.101/dist/LXGWWenKaiMono-Bold.css&quot;</span> /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更改主题配置文件，找到 <code>style</code> 字段在 <code>font-family</code> 中增加字体名称：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">style:</span></span><br><span class="line">  <span class="attr">font-family:</span></span><br><span class="line">    <span class="attr">logo:</span> <span class="string">&#x27;LXGWWenKaiMono&#x27;</span></span><br><span class="line">    <span class="attr">body:</span> <span class="string">&#x27;LXGWWenKaiMono&#x27;</span></span><br><span class="line">    <span class="attr">code:</span> <span class="string">&#x27;LXGWWenKaiMono&#x27;</span></span><br><span class="line">    <span class="attr">codeblock:</span> <span class="string">&#x27;LXGWWenKaiMono&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Canvas-nest-背景动画"><a href="#Canvas-nest-背景动画" class="headerlink" title="Canvas nest 背景动画"></a>Canvas nest 背景动画</h2><ol>
<li>在 <code>blog/source/_data</code> 文件夹下新建 <code>footer.njk</code> 并编辑</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;script color=<span class="string">&quot;0,255,255&quot;</span> opacity=<span class="string">&quot;1&quot;</span> zIndex=<span class="string">&quot;-1&quot;</span> count=<span class="string">&quot;70&quot;</span> src=<span class="string">&quot;https://cdn.staticfile.org/canvas-nest.js/1.0.1/canvas-nest.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改主题配置文件</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  footer: source/_data/footer.njk</span><br></pre></td></tr></table></figure>

<p>stellar 主题中直接添加在主题配置文件 <code>_config.yml</code> footer 的 content 中</p>
<h2 id="设置背景音乐"><a href="#设置背景音乐" class="headerlink" title="设置背景音乐"></a>设置背景音乐</h2><p>在 stellar 主题的 <code>_data/widgets.yml</code> 文件中找到 welcome 字段，在其中的 content 部分添加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">welcome:</span><br><span class="line">  layout: markdown</span><br><span class="line">  title: 哈喽~ 旅人：</span><br><span class="line">  content: |</span><br><span class="line">&lt;iframe frameborder=<span class="string">&quot;no&quot;</span> border=<span class="string">&quot;0&quot;</span> marginwidth=<span class="string">&quot;0&quot;</span> marginheight=<span class="string">&quot;0&quot;</span> width=<span class="number">224</span> height=<span class="number">86</span> src=<span class="string">&quot;//music.163.com/outchain/player?type=2&amp;id=512983678&amp;auto=1&amp;height=66&quot;</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<h2 id="百度数据分析"><a href="#百度数据分析" class="headerlink" title="百度数据分析"></a>百度数据分析</h2><p>进入 <a href="https://tongji.baidu.com/">https://tongji.baidu.com/</a> 申请账号后，输入网址获取统计代码，之后在 stellar 主题的配置文件 <code>_config.yml</code> 的扩展插件部分插入以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">  <span class="attr">baiduanalytics:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 使能百度分析接口</span></span><br><span class="line">    <span class="attr">inject:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">...扩展插件代码</span></span><br></pre></td></tr></table></figure>

<h2 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h2><ol>
<li>安装 hexo-filter-mathjax</li>
<li>修改主题配置文件</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>此后可在文章文件开头添加参数 <code>mathjax: true</code> 以使用 MathJax</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><ol>
<li>修改主题配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">plugins:</span> <span class="string">custom</span></span><br><span class="line">  <span class="attr">custom_cdn_url:</span> <span class="string">https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;cdnjs_file&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p><strong>next 主题</strong><br>在 <code>/blog/themes/next/layout/_partials/footer.njk</code> 中添加</p>
<p><strong>stellar 主题</strong><br>在主题配置文件 <code>_config.yml</code> 中找到 <code>footer:</code> 中的 <code> content: |</code>，在其后添加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">createtime</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;05/20/2024 05:20:00&quot;</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间</span></span></span><br><span class="line"><span class="language-javascript">        now.<span class="title function_">setTime</span>(now.<span class="title function_">getTime</span>()+<span class="number">250</span>);</span></span><br><span class="line"><span class="language-javascript">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(days);</span></span><br><span class="line"><span class="language-javascript">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(hours);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(<span class="title class_">String</span>(hnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum);</span></span><br><span class="line"><span class="language-javascript">        mnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(minutes); <span class="keyword">if</span>(<span class="title class_">String</span>(mnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125;</span></span><br><span class="line"><span class="language-javascript">        seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum);</span></span><br><span class="line"><span class="language-javascript">        snum = <span class="title class_">Math</span>.<span class="title function_">round</span>(seconds); <span class="keyword">if</span>(<span class="title class_">String</span>(snum).<span class="property">length</span> ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;timeDate&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;本站已安全运行 &quot;</span>+dnum+<span class="string">&quot; 天 &quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;times&quot;</span>).<span class="property">innerHTML</span> = hnum + <span class="string">&quot; 小时 &quot;</span> + mnum + <span class="string">&quot; 分 &quot;</span> + snum + <span class="string">&quot; 秒&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setInterval</span>(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="文章页眉显示标签"><a href="#文章页眉显示标签" class="headerlink" title="文章页眉显示标签"></a><del>文章页眉显示标签</del></h2><p><strong>用于 next 主题</strong></p>
<ol>
<li>在 <code>blog/source/_data</code> 文件夹下新建 <code>post-meta.njk</code> 并编辑</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span> </span><br><span class="line">  &#123;%- if post.tags and post.tags.length %&#125;</span><br><span class="line">    &#123;%- set tag_indicate = &#x27;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-tag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#x27; if theme.tag_icon else &#x27;#&#x27; %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-tags&quot;</span>&gt;</span></span><br><span class="line">      &#123;%- for tag in post.tags.toArray() %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      &#123;%- endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改主题配置文件</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">postMeta:</span> <span class="string">source/_data/post-meta.njk</span></span><br></pre></td></tr></table></figure>

<h2 id="评论系统-Waline"><a href="#评论系统-Waline" class="headerlink" title="评论系统 Waline"></a><del>评论系统 Waline</del></h2><p> <a href="https://waline.js.org/guide/get-started/#leancloud-%E8%AE%BE%E7%BD%AE-%E6%95%B0%E6%8D%AE%E5%BA%93">Waline评论系统的配置</a> </p>
<ul>
<li>前往 Waline 官网 根据指引到 Vercel 进行 Waline 服务端部署</li>
<li>安装 @waline&#x2F;hexo-next<code>npm install @waline/hexo-next</code></li>
<li>为了不使用魔法也能正常评论，我们需要有自己的域名解析到 Waline 服务端，可以在域名控制台给自己的博客域名添加二级域名，添加 CNAME 解析到 cname-china.vercel-dns.com 或添加 A 解析到 76.223.126.88（也可以前往 Vercel All IP 自行挑选合适的节点），接着进入 Vercel 的 Waline 应用的控制台，在 Settings-Domains 里添加上文提到的二级域名，这样在主题配置文件添加配置后就可以正常评论了</li>
<li>主题配置文件添加配置</li>
<li>配置完评论后及时到 Waline 服务端登录，以便管理评论</li>
<li>可选择开启评论邮件提醒功能， <a href="https://waline.js.org/">Waline 官网</a> 有详细的说明</li>
</ul>
<h2 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a><del>阅读量统计</del></h2><p><strong>用于 next 主题</strong></p>
<p><code>Leancloud</code>（<a href="https://console.leancloud.cn/%EF%BC%89">https://console.leancloud.cn/）</a></p>
<ol>
<li>创建应用，进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用</li>
<li>配置 <code>_config.yml</code> 启用网页访问统计，配置 <code>leancloud</code> 的 <code>app_id</code> 和 <code>app_key</code>，打开计数功能，统计来源改为 <code>leancloud</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#网页访问统计</span><br><span class="line">#Analysis of website visitors</span><br><span class="line">web analytics:</span><br><span class="line">	enable:<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">leancloud:</span><br><span class="line">	app id: </span><br><span class="line">	app key: </span><br><span class="line"></span><br><span class="line"># 浏览量计数</span><br><span class="line"># Number of visits</span><br><span class="line">views:</span><br><span class="line">	enable:<span class="literal">true</span></span><br><span class="line">	#统计数据来源</span><br><span class="line">	#Data Source</span><br><span class="line">	#Options:busuanzi | leancloud</span><br><span class="line">	source:<span class="string">&quot;leancloud&quot;</span></span><br><span class="line">	format:<span class="string">&quot;&#123;&#125;次&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="PV、UV-统计数"><a href="#PV、UV-统计数" class="headerlink" title="PV、UV 统计数"></a><del>PV、UV 统计数</del></h2><p><strong>用于 next 主题</strong>显示页面的访问量和访客数量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 展示网站的 pv、w 统计数</span><br><span class="line"># Display website pv <span class="keyword">and</span> uv statistics</span><br><span class="line">statistics:</span><br><span class="line">	enable:<span class="literal">true</span></span><br><span class="line">	#统计数据来源，使用leancloud 需要设置<span class="string">&#x27;web analytics:leancloud&#x27;</span>中的参数;busuanzi 显示统计数据很大属于正常现象，部署后会正常</span><br><span class="line">	# Data source.If use leancloud,you need to set the parameter in<span class="number">&#x27;</span>web analytics:leancloud</span><br><span class="line">	# Options:busuanzian | leancloud</span><br><span class="line">	source:<span class="string">&quot;leancloud&#x27;</span></span><br><span class="line"><span class="string">	#页面显示的文本，&#123;&#125;是数字的占位符(必须包含)，下同</span></span><br><span class="line"><span class="string">	# Displayed text, &#123;&#125;is a placeholder for numbers (must be included), the same below</span></span><br><span class="line"><span class="string">	pv format:&quot;</span>总访问量 &#123;&#125;次<span class="string">&quot;</span></span><br><span class="line"><span class="string">	uv format:&quot;</span>总访客数 &#123;&#125;人<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="词句-API"><a href="#词句-API" class="headerlink" title="词句 API"></a><del>词句 API</del></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;hitokoto&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hitokoto_text&quot;</span>&gt;</span>:D 获取中...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">fetch</span>(<span class="string">&#x27;https://v1.hitokoto.cn&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span></span><br><span class="line"><span class="language-javascript">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> hitokoto = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#hitokoto_text&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">hitokoto.<span class="property">href</span> = <span class="string">`https://hitokoto.cn/?uuid=<span class="subst">$&#123;data.uuid&#125;</span>`</span></span></span><br><span class="line"><span class="language-javascript">hitokoto.<span class="property">innerText</span> = data.<span class="property">hitokoto</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript">.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>博客部署前提笔记</title>
    <url>/2024/05/25/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%89%8D%E6%8F%90%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="部署平台"><a href="#部署平台" class="headerlink" title="部署平台"></a>部署平台</h1><ul>
<li>Vercel </li>
<li>GitHub Pages</li>
<li>Cloudflare Pages</li>
<li>自建服务器部署</li>
<li>Netlify：Netlify 额外提供每个站点每月 1000 个已识别的活跃用户和站点分析。</li>
<li>Railway：支持项目内 Dockerfile 和 docker 镜像，但不支持 docker-compose</li>
</ul>
<blockquote>
<p>Cloudflare 的定位为一家全球性的互联网基础设施提供商，提供了一系列的网络安全和性能优化服务，包括内容分发网络(CDN)、DDoS 防护、SSL&#x2F;TLS 加密、DNS 管理等。Cloudflare Workers（serverless 计算平台）和 Cloudflare Pages 可以用来部署 nextjs 应用。</p>
</blockquote>
<blockquote>
<p>Railway 提供免费容器服务。支持主流语言 python、nodejs 等直接运行，支持 Dockerfile 在线构建 docker 镜像。支持使用 CLI 部署。此外，还提供大量模板直接构建。例如 code server（vscode 网页版）等。按量付费，每个月 5 美元免费额度，跑个小程序够用。支持通过 Github repo 进行部署</p>
</blockquote>
<blockquote>
<p>Vercel 是一个云服务平台，支持静态网站和动态网站的应用部署、预览和上线。如果你用过 GitHub Pages ，那么心里可能不会太陌生，也能通过 vercel 集成 GitHub 后，在 GitHub 项目进行代码推送，PR 合并自动部署的目的，且你不需要考虑服务器和域名问题。</p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>部署涉及到的各项关键配置文件有以下，各文件路径基于 Hexo&#x2F;Github&#x2F;Obsidian 的仓库根目录</p>
<table>
<thead>
<tr>
<th align="center">文件所属</th>
<th>文件名</th>
<th>文件路径</th>
<th>文件用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GitHub Actions</td>
<td>blogPublish.yml</td>
<td><code>.github/workflows</code></td>
<td>用于仓库同步到 github 之后，自动将源码生成静态页面，同步到发布仓库进行发布</td>
</tr>
<tr>
<td align="center">GitHub</td>
<td>.gitignore</td>
<td><code>./</code></td>
<td>用于忽略 Hexo 和 Obsidian 中不需要同步到 Git 的文件(有些文件体积过大，占用仓库体积)</td>
</tr>
<tr>
<td align="center">Hexo</td>
<td>_config.yml</td>
<td><code>./</code></td>
<td>Hexo 站点配置文件</td>
</tr>
<tr>
<td align="center">Hexo</td>
<td>package.json</td>
<td><code>./</code></td>
<td>npm 安装包及命令文件，部署站点时所需的和 hexo 相关的依赖包都在此文件中</td>
</tr>
<tr>
<td align="center">Hexo-Stellar</td>
<td>_config.yml</td>
<td><code>themes/stellar/_config.yml</code></td>
<td>Hexo 主题配置文件</td>
</tr>
<tr>
<td align="center">Hexo-Stellar</td>
<td>widgets.yml</td>
<td><code>themes/stellar/_data/widgets.yml</code></td>
<td>Stellar 主题中的控件配置文件</td>
</tr>
</tbody></table>
<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><ul>
<li>修改 <code>.github/workflows/blogPublish.yml</code><br> <em>该文件中指定了主题仓库和主题配置文件，修改主题仓库</em></li>
<li>修改 <code>_config.theme.yml</code><br>  <em>该文件中默认为 stellar 的主题配置文件，需要修改为指定的主题配置文件</em></li>
<li>修改站点配置文件 <code>_config.yml</code><br>  <em>需要在站点配置文件中修改指定的主题</em></li>
<li><a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8/Qexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2.md">Qexo本地部署</a></li>
</ul>
<h1 id="博客本地部署方案"><a href="#博客本地部署方案" class="headerlink" title="博客本地部署方案"></a>博客本地部署方案</h1><p>拉取仓库并本地部署脚本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf ./BlogDeploy</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:liuluhua/BlogDeploy.git</span><br><span class="line"><span class="built_in">cd</span> ./BlogDeploy</span><br><span class="line"><span class="built_in">mkdir</span> themes</span><br><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:xaoxuu/hexo-theme-stellar.git</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:next-theme/hexo-theme-next.git</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cp</span> ./_config.theme.stellar.widgets.yml ./themes/hexo-theme-stellar/_data/widgets.yml</span><br><span class="line"><span class="built_in">cp</span> ./_config.theme.stellar.yml ./themes/hexo-theme-stellar/_config.yml</span><br><span class="line">npm install</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s -p 9050</span><br></pre></td></tr></table></figure>

<h1 id="云服务器用-pm2-部署"><a href="#云服务器用-pm2-部署" class="headerlink" title="云服务器用 pm2 部署"></a>云服务器用 pm2 部署</h1><ol>
<li>先确保安装了 nodejs 和 npm，并使用 pnpm 作为 nextjs 项目的依赖管理工具</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 pm2 做进程管理</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在项目根目录下安装依赖，构建输出产物</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pnpm install</span><br><span class="line">pnpm build</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 pm2 启动服务</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pm2 start pnpm --name sorafm -- start --port <span class="number">8015</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 nginx 做反向代理，先确保安装和启动了 nginx：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install nginx</span><br><span class="line">sudo systemctl start nginx</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>为 nextjs 项目创建 nginx 配置：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/nginx/conf/sorafm.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//127.0.0.1:8015/;</span></span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_log /var/log/nginx/sorafm.error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>nginx 重载新的网站配置：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>DNS 解析域名到服务器的公网 ip<br> 在 DNS 控制台添加一条 A 记录，指向服务器的公网 ip，等解析生效后，就可以访问 nextjs 项目了。</p>
</li>
<li><p>配置 https 访问，可以在 Ubuntu 安装 certbot 生成域名证书：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install certbot python3-certbot-nginx</span><br></pre></td></tr></table></figure>

<p>为新域名生成新的证书，并使用 https 访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo certbot --nginx -d sorafm.trys.ai</span><br></pre></td></tr></table></figure>

<p>配置完成后，就可以安全访问 nextjs 项目了。</p>
<h1 id="云服务器用-Docker-部署"><a href="#云服务器用-Docker-部署" class="headerlink" title="云服务器用 Docker 部署"></a>云服务器用 Docker 部署</h1><p>同样是使用 Ubuntu 云服务器，使用 pm2 部署 nextjs 更简单直接，轻量级部署，服务资源占用少。使用 docker 部署，系统隔离性更好，更方便移植，适用于微服务架构。要使用 docker 部署 nextjs 应用，先确保在服务器安装好了 docker，再来改造 nextjs 项目</p>
<ol>
<li>修改项目根目录下的 next.config.mjs，使用 standalone 模式输出编译产物</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @type &#123;import(&#x27;next&#x27;).NextConfig&#125; */</span></span><br><span class="line"><span class="type">const</span> nextConfig = &#123;</span><br><span class="line">  output: <span class="string">&quot;standalone&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> nextConfig;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 deploy 文件夹下新建 Dockerfile 文件，写入 docker 镜像构建内容</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FROM node:<span class="number">18</span>-alpine AS base</span><br><span class="line"># Install dependencies only when needed</span><br><span class="line">FROM base AS deps</span><br><span class="line">RUN apk add --no-cache libc6-compat &amp;&amp; yarn global add pnpm</span><br><span class="line">WORKDIR /app</span><br><span class="line"># Install dependencies based on the preferred package manager</span><br><span class="line">COPY package.json pnpm-lock.yaml* ./</span><br><span class="line">RUN pnpm i --frozen-lockfile</span><br><span class="line"># Rebuild the source code only when needed</span><br><span class="line">FROM deps AS builder</span><br><span class="line">WORKDIR /app</span><br><span class="line"># Install dependencies based on the preferred package manager</span><br><span class="line">COPY . .</span><br><span class="line">RUN pnpm build</span><br><span class="line"># Production image, copy all the files <span class="keyword">and</span> run next</span><br><span class="line">FROM base AS runner</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN addgroup --system --gid <span class="number">1001</span> nodejs &amp;&amp; \</span><br><span class="line">    adduser --system --uid <span class="number">1001</span> nextjs &amp;&amp; \</span><br><span class="line">    mkdir .next &amp;&amp; \</span><br><span class="line">    chown nextjs:nodejs .next</span><br><span class="line">COPY --from=builder /app/<span class="keyword">public</span> ./<span class="keyword">public</span></span><br><span class="line">COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./</span><br><span class="line">COPY --from=builder --chown=nextjs:nodejs /app/.next/<span class="type">static</span> ./.next/<span class="type">static</span></span><br><span class="line">USER nextjs</span><br><span class="line">EXPOSE <span class="number">8080</span></span><br><span class="line">ENV NODE_ENV production</span><br><span class="line">ENV PORT <span class="number">8080</span></span><br><span class="line">ENV HOSTNAME <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="meta"># server.js is created by next build from the standalone output</span></span><br><span class="line">CMD [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;server.js&quot;</span>]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在项目根目录下新建 .dockerignore 文件，写入构建镜像时要忽略的内容</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.next</span><br><span class="line">.vercel</span><br><span class="line">.vscode</span><br><span class="line">data</span><br><span class="line">debug</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开始构建 docker 镜像</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo docker build -f deploy/Dockerfile -t sorafm:latest .</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 docker 运行服务</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo docker run -itd -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8014</span>:<span class="number">8080</span> --restart=always sorafm:latest</span><br></pre></td></tr></table></figure>

<p>服务运行成功后，再通过 nginx 配置公网访问，DNS 解析公网域名，certbot 配置 https 证书，这三个步骤跟上面使用 pm2 部署 nextjs 的方案一致。</p>
<h1 id="Cloudflare-部署"><a href="#Cloudflare-部署" class="headerlink" title="Cloudflare 部署"></a>Cloudflare 部署</h1><p>上述两种方案：使用 pm2 和使用 docker 部署 nextjs 应用，需要先有一台服务器。如果不想买服务器，而是通过托管的方式部署 nextjs 项目，可以选择 Cloudflare Pages，几乎免费的云部署方案。按照 Cloudflare 的官方文档，使用 Cloudflare Pages 部署 nextjs 项目，主要的步骤：</p>
<ol>
<li>安装部署依赖</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pnpm add -D @cloudflare/next-on-pages</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在项目根目录创建一个配置文件 wrangler.toml</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;sorafm&quot;</span></span><br><span class="line">compatibility_date = <span class="string">&quot;2024-07-29&quot;</span></span><br><span class="line">compatibility_flags = [<span class="string">&quot;nodejs_compat&quot;</span>]</span><br><span class="line">pages_build_output_dir = <span class="string">&quot;.vercel/output/static&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更新 next.config.mjs 文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupDevPlatform &#125; <span class="keyword">from</span> <span class="string">&quot;@cloudflare/next-on-pages/next-dev&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;next&#x27;).NextConfig</span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> nextConfig = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;development&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">setupDevPlatform</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> nextConfig;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改服务端路由运行时，对所有的 api 路由文件 route.ts 和所有的页面路由文件 page.tsx 都添加一行代码，指定使用 edge 运行时：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="type">const</span> runtime = <span class="string">&quot;edge&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>修改 package.json 文件，添加编译指令</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;pages:build&quot;</span>: <span class="string">&quot;npx @cloudflare/next-on-pages&quot;</span>,</span><br><span class="line"><span class="string">&quot;preview&quot;</span>: <span class="string">&quot;pnpmb pages:build &amp;&amp; wrangler pages dev&quot;</span>,</span><br><span class="line"><span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;pnpm pages:build &amp;&amp; wrangler pages deploy&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在项目根目录通过命令行部署项目到 Cloudflare Pages</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure>

<p>在第一次运行 deploy 命令时，需要填写项目名称，跳转 Cloudflare 进行授权验证等。发布完成后，就可以在 Cloudflare-Workers and Pages 管理后台看到项目了。跟 Vercel 一样，Cloudflare 也为发布的项目生成一个子域名：xxx.pages.dev，部署成功可直接公网访问，方便项目快速上线验证。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>微信公众号后端配置</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/wechat&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wechat_signature</span>():</span><br><span class="line">    data = request.args</span><br><span class="line">    echostr = data.get(<span class="string">&#x27;echostr&#x27;</span>)</span><br><span class="line">    signature = data.get(<span class="string">&#x27;signature&#x27;</span>)</span><br><span class="line">    timestamp = data.get(<span class="string">&#x27;timestamp&#x27;</span>)</span><br><span class="line">    nonce = data.get(<span class="string">&quot;nonce&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> signature <span class="keyword">or</span> <span class="keyword">not</span> timestamp <span class="keyword">or</span> <span class="keyword">not</span> nonce:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    tmp_str = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>([<span class="string">&#x27;liuluhua&#x27;</span>, timestamp, nonce]))</span><br><span class="line">    tmp_str = hashlib.sha1(tmp_str.encode(<span class="string">&#x27;UTF-8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> tmp_str == signature:</span><br><span class="line">        <span class="keyword">return</span> echostr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Failed&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/wechat&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wechat_communication</span>():</span><br><span class="line">    <span class="comment">#获取微信服务器post过来的xml数据</span></span><br><span class="line">    xml = request.data</span><br><span class="line">    <span class="comment"># 把xml格式的数据进行处理，转换成字典进行取值</span></span><br><span class="line">​    req = xmltodict.parse(xml)[<span class="string">&#x27;xml&#x27;</span>]</span><br><span class="line">    <span class="comment"># 判断post过来的数据中数据类型是不是文本</span></span><br><span class="line">​    <span class="keyword">if</span> <span class="string">&#x27;text&#x27;</span> == req.get(<span class="string">&#x27;MsgType&#x27;</span>):</span><br><span class="line">    <span class="comment"># 获取用户的信息，开始构造返回数据，把用户发送的信息原封不动的返回过去，字典格式</span></span><br><span class="line">​        resp = &#123;</span><br><span class="line">​            <span class="string">&#x27;ToUserName&#x27;</span>:req.get(<span class="string">&#x27;FromUserName&#x27;</span>),</span><br><span class="line">​            <span class="string">&#x27;FromUserName&#x27;</span>:req.get(<span class="string">&#x27;ToUserName&#x27;</span>),</span><br><span class="line">​            <span class="string">&#x27;CreateTime&#x27;</span>:<span class="built_in">int</span>(time.time()),</span><br><span class="line">​            <span class="string">&#x27;MsgType&#x27;</span>:<span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">​            <span class="string">&#x27;Content&#x27;</span>:req.get(<span class="string">&#x27;Content&#x27;</span>)</span><br><span class="line">​        &#125;</span><br><span class="line">        <span class="comment"># 把构造的字典转换成xml格式</span></span><br><span class="line">​        xml = xmltodict.unparse(&#123;<span class="string">&#x27;xml&#x27;</span>:resp&#125;)</span><br><span class="line">        <span class="comment"># print(req.get(&#x27;Content&#x27;))</span></span><br><span class="line">        <span class="comment"># 返回数据</span></span><br><span class="line">​        <span class="keyword">return</span> xml</span><br><span class="line">​    <span class="keyword">else</span>:</span><br><span class="line">​        resp = &#123;</span><br><span class="line">​            <span class="string">&#x27;ToUserName&#x27;</span>: req.get(<span class="string">&#x27;FromUserName&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">​            <span class="string">&#x27;FromUserName&#x27;</span>: req.get(<span class="string">&#x27;ToUserName&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">​            <span class="string">&#x27;CreateTime&#x27;</span>: <span class="built_in">int</span>(time.time()),</span><br><span class="line">​            <span class="string">&#x27;MsgType&#x27;</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">​            <span class="string">&#x27;Content&#x27;</span>: <span class="string">&#x27;I LOVE ITCAST&#x27;</span></span><br><span class="line">​        &#125;</span><br><span class="line">​        xml = xmltodict.unparse(&#123;<span class="string">&#x27;xml&#x27;</span>:resp&#125;)</span><br><span class="line">​        <span class="keyword">return</span> xml</span><br></pre></td></tr></table></figure>

<h1 id="实现每天下午两点定时推送消息给订阅用户"><a href="#实现每天下午两点定时推送消息给订阅用户" class="headerlink" title="实现每天下午两点定时推送消息给订阅用户"></a>实现每天下午两点定时推送消息给订阅用户</h1>]]></content>
      <categories>
        <category>0.平台</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title>代码日志输出</title>
    <url>/2024/08/28/1-%E8%AF%AD%E8%A8%80-0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><p>通过一个宏定义把要打印的信息写到一个日志文件中，不仅可以记录程序每次运行的状态便于 debug，而且在发布时只需要注释掉宏定义而不必删除每一个使用该宏的地方，不会出现因删除代码而出现的错误。</p>
<p>宏还可以加一个参数传入文件的路径，就可以自定义日志文件的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRACEOUT(p) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">time_t timeval; \</span></span><br><span class="line"><span class="meta">timeval=time(NULL); \</span></span><br><span class="line"><span class="meta">FILE *log; \</span></span><br><span class="line"><span class="meta">log = fopen(<span class="string">&quot;log.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);\</span></span><br><span class="line"><span class="meta">fprintf(log,<span class="string">&quot;%s -- %s\n&quot;</span>,p,ctime(&amp;timeval));\</span></span><br><span class="line"><span class="meta">fclose(log); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DBG(fmt,...) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">fprintf(stdout,<span class="string">&quot;[DEBUG] %s:%d - &quot;</span>fmt<span class="string">&quot;\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">__FILE__,__LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERR(fmt,...) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">fprintf(stderr,<span class="string">&quot;[ERROR] %s:%d - &quot;</span>fmt<span class="string">&quot;\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">__FILE__,__LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">TRACEOUT</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="built_in">LOG_DBG</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="built_in">LOG_ERR</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FILE    <span class="string">&quot;./a.log&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEFAULT( fmt, ... )         log_out( LOG_FILE, __FILE__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TOXFILE( flog, fmt, ... )   log_out( flog, __FILE__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">log_out</span><span class="params">(<span class="type">char</span>* flog, <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">char</span>* fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list arg;</span><br><span class="line">    <span class="type">char</span>    pre[<span class="number">128</span>], tmp[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">long</span>    clock;</span><br><span class="line">    <span class="keyword">struct</span>  <span class="title class_">tm</span> *c_ptr;</span><br><span class="line">    FILE    *fp;</span><br><span class="line">    <span class="built_in">time</span>( &amp;clock );</span><br><span class="line">    c_ptr = <span class="built_in">localtime</span>(&amp;clock);</span><br><span class="line">    <span class="built_in">sprintf</span>( pre, <span class="string">&quot;[%04d%02d%02d%02d%02d%02d_%s.%d]&quot;</span>,</span><br><span class="line">         c_ptr-&gt;tm_year+<span class="number">1900</span>, c_ptr-&gt;tm_mon+<span class="number">1</span>, c_ptr-&gt;tm_mday,</span><br><span class="line">         c_ptr-&gt;tm_hour, c_ptr-&gt;tm_min, c_ptr-&gt;tm_sec, file, line );</span><br><span class="line">    <span class="built_in">va_start</span>(arg, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(tmp, fmt, arg);</span><br><span class="line">    <span class="built_in">va_end</span> (arg);</span><br><span class="line">    <span class="comment">//log to stdout</span></span><br><span class="line">    <span class="keyword">if</span>( !flog )&#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;%-32.32s  %s&quot;</span>, pre, tmp );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//log to file</span></span><br><span class="line">    <span class="keyword">if</span>( !(fp = <span class="built_in">fopen</span>( flog, <span class="string">&quot;at&quot;</span> ) ) )  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>( fp, <span class="string">&quot;%-32.32s  %s&quot;</span>, pre, tmp );</span><br><span class="line">    <span class="built_in">fclose</span>( fp );</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法：</p>
<ul>
<li>LOG_DEFAULT 日志输出到默认的日志文件</li>
<li>LOG_TOXFILE 日志输出到指定的日志文件，参数是 0，则日志打印到标准输出</li>
</ul>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>0.设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>代码注释</title>
    <url>/2024/08/28/1-%E8%AF%AD%E8%A8%80-0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h1 id="注释部分"><a href="#注释部分" class="headerlink" title="注释部分"></a>注释部分</h1><h2 id="函数部分-function"><a href="#函数部分-function" class="headerlink" title="函数部分 function"></a>函数部分 function</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">Function: // 函数名称</span></span><br><span class="line"><span class="comment">Description: // 函数功能、性能等的描述</span></span><br><span class="line"><span class="comment">Calls: // 被本函数调用的函数清单</span></span><br><span class="line"><span class="comment">Called By: // 调用本函数的函数清单</span></span><br><span class="line"><span class="comment">Table Accessed: // 被访问的表（此项仅对于牵扯到数据库操作的程序）</span></span><br><span class="line"><span class="comment">Table Updated: // 被修改的表（此项仅对于牵扯到数据库操作的程序）</span></span><br><span class="line"><span class="comment">Input: // 输入参数说明，包括每个参数的作</span></span><br><span class="line"><span class="comment">// 用、取值说明及参数间关系。</span></span><br><span class="line"><span class="comment">Output: // 对输出参数的说明。</span></span><br><span class="line"><span class="comment">Return: // 函数返回值的说明</span></span><br><span class="line"><span class="comment">Others: // 其它说明</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br></pre></td></tr></table></figure>

<h2 id="全局变量-global-variable"><a href="#全局变量-global-variable" class="headerlink" title="全局变量 global variable"></a>全局变量 global variable</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* The ErrorCode when SCCP translate */</span></span><br><span class="line"><span class="comment">/* Global Title failure, as follows */</span> <span class="comment">// 变量作用、含义</span></span><br><span class="line"><span class="comment">/* 0 － SUCCESS 1 － GT Table error */</span></span><br><span class="line"><span class="comment">/* 2 － GT error Others － no use */</span> <span class="comment">// 变量取值范围</span></span><br><span class="line"><span class="comment">/* only function SCCPTranslate() in */</span></span><br><span class="line"><span class="comment">/* this modual can modify it, and other */</span></span><br><span class="line"><span class="comment">/* module can visit it through call */</span></span><br><span class="line"><span class="comment">/* the function GetGTTransErrorCode() */</span> <span class="comment">// 使用方法</span></span><br></pre></td></tr></table></figure>

<h2 id="头文件-h"><a href="#头文件-h" class="headerlink" title="头文件 .h"></a>头文件 .h</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">Copyright (C), 1988-1999, Huawei Tech. Co., Ltd.</span></span><br><span class="line"><span class="comment">FileName: test.cpp</span></span><br><span class="line"><span class="comment">Author: Version : Date:</span></span><br><span class="line"><span class="comment">Description: // 模块描述</span></span><br><span class="line"><span class="comment">Version: // 版本信息</span></span><br><span class="line"><span class="comment">Function List: // 主要函数及其功能</span></span><br><span class="line"><span class="comment">1. -------</span></span><br><span class="line"><span class="comment">History: // 历史修改记录</span></span><br><span class="line"><span class="comment">&lt;author&gt; &lt;time&gt; &lt;version &gt; &lt;desc&gt;</span></span><br><span class="line"><span class="comment">David 96/10/12 1.0 build this moudle</span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br></pre></td></tr></table></figure>

<h2 id="配置文件-cfg"><a href="#配置文件-cfg" class="headerlink" title="配置文件 .cfg"></a>配置文件 .cfg</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment">Copyright (C), 1988-1999, Huawei Tech. Co., Ltd.</span></span><br><span class="line"><span class="comment">File name: // 文件名</span></span><br><span class="line"><span class="comment">Author: Version: Date: // 作者、版本及完成日期</span></span><br><span class="line"><span class="comment">Description: // 用于详细说明此程序文件完成的主要功能，与其他模块</span></span><br><span class="line"><span class="comment">// 或函数的接口，输出值、取值范围、含义及参数间的控</span></span><br><span class="line"><span class="comment">// 制、顺序、独立或依赖等关系</span></span><br><span class="line"><span class="comment">Others: // 其它内容的说明</span></span><br><span class="line"><span class="comment">Function List: // 主要函数列表，每条记录应包括函数名及功能简要说明</span></span><br><span class="line"><span class="comment">1. ....</span></span><br><span class="line"><span class="comment">History: // 修改历史记录列表，每条修改记录应包括修改日期、修改</span></span><br><span class="line"><span class="comment">// 者及修改内容简述</span></span><br><span class="line"><span class="comment">1. Date:</span></span><br><span class="line"><span class="comment">Author:</span></span><br><span class="line"><span class="comment">Modification:</span></span><br><span class="line"><span class="comment">2. ...</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br></pre></td></tr></table></figure>

<h1 id="Doxygen"><a href="#Doxygen" class="headerlink" title="Doxygen"></a>Doxygen</h1><p>Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。通常我们在写程序时，或多或少都会写上批注，但是对于其它人而言，要直接探索程序里的批注，与打捞铁达尼号同样的辛苦。大部分有用的批注都是属于针对函式，类别等等的说明。所以，如果能依据程序本身的结构，将批注经过处理重新整理成为一个纯粹的参考手册，对于后面利用您的程序代码的人而言将会减少许多的负担。不过，反过来说，整理文件的工作对于您来说，就是沉重的负担。</p>
<p>Doxygen 就是在您写批注时，稍微按照一些它所制订的规则。接着，他就可以帮您产生出漂亮的文档了。</p>
<p>因此，Doxygen 的使用可分为两大部分:</p>
<ul>
<li>特定格式的批注撰写</li>
<li>利用 Doxygen 的工具来产生文档</li>
</ul>
<p>目前 Doxygen 可处理的程序语言包含：</p>
<ul>
<li>C&#x2F;C++</li>
<li>Java</li>
<li>IDL (Corba, Microsoft 及 KDE-DCOP 类型)</li>
</ul>
<p>而可产生出来的文档格式有：</p>
<ul>
<li>HTML</li>
<li>XML</li>
<li>LaTeX</li>
<li>RTF</li>
<li>Unix Man Page<br>而其中还可衍生出不少其它格式。HTML 可以打包成 CHM 格式，而 LaTeX 可以透过一些工具产生出 PS 或是 PDF 文档。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>安装 Doxygen</li>
<li>安装 graphviz<ul>
<li>graphviz 是一个由 AT&amp;T 实验室启动的开源工具包，用于绘制 DOT 语言脚本描述的图形。Doxygen 使用 graphviz 自动生成类之间和文件之间的调用关系图，如不需要此功能可不安装该工具包。</li>
</ul>
</li>
<li>安装 Windows Help Workshop<ul>
<li>Doxygen 使用这个工具可以生成 CHM 格式的文档。</li>
</ul>
</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Doxygen 产生文档可以分为三个步骤。</p>
<ul>
<li>在程序代码中加上符合 Doxygen 所定义批注格式</li>
<li>使用 Doxywizard 进行配置</li>
<li>使用 Doxygen 来产生批注文档</li>
</ul>
<h2 id="撰写正确格式的批注"><a href="#撰写正确格式的批注" class="headerlink" title="撰写正确格式的批注"></a>撰写正确格式的批注</h2><p>并非所有程序代码中的批注都会被 Doxygen 所处理。您必需依照正确的格式撰写。原则上，Doxygen 仅处理与程序结构相关的批注，如 Function，Class ，档案的批注等。对于 Function 内部的批注则不做处理。Doxygen 可处理下面几种类型的批注。</p>
<p>JavaDoc 类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ... 批注 ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Qt 类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">* ... 批注 ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>单行型式的批注：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ... 批注 ...</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! ... 批注 ...</span></span><br></pre></td></tr></table></figure>

<p>要使用哪种型态完全看自己的喜好。以笔者自己来说，大范围的注解我会使用 JavaDoc 型的。单行的批注则使用”&#x2F;&#x2F;&#x2F;“ 的类型。此外，由于 Doxygen 对于批注是视为在解释后面的程序代码。也就是说，任何一个批注都是在说明其后的程序代码。如果要批注前面的程式码则需用下面格式的批注符号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!&lt; ... 批注 ... */</span></span><br><span class="line"><span class="comment">/**&lt; ... 批注 ... */</span></span><br><span class="line"><span class="comment">//!&lt; ... 批注 ...</span></span><br><span class="line"><span class="comment">///&lt; ... 批注 ...</span></span><br></pre></td></tr></table></figure>

<p>上面这个方式并不适用于任何地方，只能用在 class 的 member 或是 function 的参数上。举例来说，若我们有下面这样的 class。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> member1 ;</span><br><span class="line">		<span class="type">int</span> member2:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">member_function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加上批注后，就变成这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 我的自订类别说明 ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> member1 ; <span class="comment">///&lt; 第一个 member 说明 ...</span></span><br><span class="line">		<span class="type">int</span> member2: <span class="comment">///&lt; 第二个 member 说明 ...</span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">member_function</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自订类别的 member_funtion 说明 ...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param a 参数 a 的说明</span></span><br><span class="line"><span class="comment">* @param b 参数 b 的说明</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return 传回 a+b。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::member_function</span><span class="params">( <span class="type">int</span> a, <span class="type">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当您使用 Doxygen 产生说明文档时，Doxygen 会帮您 parsing 您的程式码。并且依据程序结构建立对应的文件。然后再将您的批注，依据其位置套入于正确的地方。您可能已经注意到，除了一般文字说明外，还有一些其它特别的指令，像是@param 及@return 等。这正是 Doxygen 另外一个重要的部分，因为一个类别或是函式其实都有固定几个要说明的部分。为了让 Doxygen 能够判断，所有我们就必需使用这些指令，来告诉 Doxygen 后面的批注是在说明什么东西。Doxygen 在处理时，就会帮您把这些部分做特别的处理或是排版。甚至是制作参考连结。</p>
<p>首先，我们先说明在 Doxygen 中对于类别或是函数批注的一个特定格式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* class 或 function 的简易说明...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* class 或 function 的详细说明...</span></span><br><span class="line"><span class="comment">* ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子要说的是，在 Doxygen 处理一个 class 或是 function 注解时，会先判断第一行为简易说明。这个简易说明将一直到空一行的出现。或是遇到第一个”.” 为止。之后的批注将会被视为详细说明。两者的差异在于 Doxygen 在某些地方只会显示简易说明，而不显示详细说明。如：class 或 function 的列表。</p>
<p>另一种比较清楚的方式是指定@brief 的指令。这将会明确的告诉 Doxygen，何者是简易说明。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief class 或 function 的简易说明...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* class 或 function 的详细说明...</span></span><br><span class="line"><span class="comment">* ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>除了这个 class 及 function 外，Doxygen 也可针对档案做说明，条件是该批注需置于档案的前面。主要也是利用一些指令，通常这部分注解都会放在档案的开始地方。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*! \file myfile.h</span></span><br><span class="line"><span class="comment">\brief 档案简易说明</span></span><br><span class="line"><span class="comment">详细说明.</span></span><br><span class="line"><span class="comment">\author 作者信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如您所见，档案批注约略格式如上，请别被 <code>&quot;\&quot;</code> 所搞混。其实，<code>&quot;\&quot;</code> 与”@” 都是一样的，都是告诉 Doxygen 后面是一个指令。两种在 Doxygen 都可使用。笔者自己比较偏好使用”@”。</p>
<p>接着我们来针对一些常用的指令做说明：@file 档案的批注说明。Doxygen 所支持的指令很多，有些甚至是关于输出排版的控制。您可从 Doxygen 的使用说明中找到详尽的说明。</p>
<p>下面我们准备一组 example.h 及 example.cpp 来说明 Doxygen 批注的使用方式：example.h:</p>
<ul>
<li>@author 作者的信息</li>
<li>@brief 用于 class 或 function 的批注中，后面为 class 或 function 的简易说明。</li>
<li>@param 格式为 @param arg_name 参数说明,主要用于函式说明中，后面接参数的名字，然后再接关于该参数的说明。</li>
<li>@return 后面接函数传回值的说明。用于 function 的批注中。说明该函数的传回值。</li>
<li>@retval 格式为 @retval value 传回值说明,主要用于函式说明中，说明特定传回值的意义。所以后面要先接一个传回值。然后在放该传回值的说明。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @file 本范例的 include 档案。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这个档案只定义 example 这个 class。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @author garylee@localhost</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_OK 0 <span class="comment">///&lt; 定义 EXAMPLE_OK 的宏为 0。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Example class 的简易说明</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 本范例说明 Example class。</span></span><br><span class="line"><span class="comment">* 这是一个极为简单的范例。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> var1 ; <span class="comment">///&lt; 这是一个 private 的变数</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> var2 ; <span class="comment">///&lt; 这是一个 public 的变数成员。</span></span><br><span class="line">		<span class="type">int</span> var3 ; <span class="comment">///&lt; 这是另一个 public 的变数成员。</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">ExFunc1</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">ExFunc2</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">char</span> *<span class="title">ExFunc3</span><span class="params">(<span class="type">char</span> *c)</span> </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>example.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @file 本范例的程序代码档案。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这个档案用来定义 example 这个 class 的</span></span><br><span class="line"><span class="comment">* member function。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @author garylee@localhost</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief ExFunc1 的简易说明</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ExFunc1 没有任何参数及传回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Example::ExFunc1</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// empty funcion.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief ExFunc2 的简易说明</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ExFunc3()传回两个参数相加的值。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param a 用来相加的参数。</span></span><br><span class="line"><span class="comment">* @param b 用来相加的参数。</span></span><br><span class="line"><span class="comment">* @return 传回两个参数相加的结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExFunc2</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief ExFunc3 的简易说明</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ExFunc3()只传回参数输入的指标。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param c 传进的字符指针。</span></span><br><span class="line"><span class="comment">* @retval NULL 空字符串。</span></span><br><span class="line"><span class="comment">* @retval !NULL 非空字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">ExFunc2</span><span class="params">(<span class="type">char</span> * c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>0.设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>敏捷开发</title>
    <url>/2024/08/27/1-%E8%AF%AD%E8%A8%80-0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>敏捷开发模式是一种软件开发方法论，旨在通过迭代和增量的方式交付高质量的软件产品。它强调灵活性、快速响应变化、团队协作以及持续交付。敏捷开发模式的核心思想是通过短周期的开发迭代（通常称为“迭代”或“冲刺”）来逐步构建和完善产品，从而快速适应需求变化并持续向客户交付价值。</p>
<h3 id="敏捷开发的主要特点"><a href="#敏捷开发的主要特点" class="headerlink" title="敏捷开发的主要特点"></a>敏捷开发的主要特点</h3><ol>
<li><p><strong>迭代与增量开发</strong>：项目分为多个迭代，每个迭代持续 1 到 4 周。在每个迭代结束时，团队交付一个可工作的产品增量，逐步完善产品。</p>
</li>
<li><p><strong>持续反馈与改进</strong>：通过频繁的反馈循环，团队能够在每个迭代后反思并改进开发过程，确保项目朝着正确的方向发展。</p>
</li>
<li><p><strong>拥抱变化</strong>：敏捷开发鼓励团队适应需求的变化，而不是严格按照最初的计划执行。需求的变化被视为客户对市场的反应，而非对项目的干扰。</p>
</li>
<li><p><strong>跨职能团队</strong>：敏捷团队通常是小型的、跨职能的，包含开发人员、测试人员、设计师和其他相关角色。这种结构有助于团队快速做出决策并高效协作。</p>
</li>
<li><p><strong>客户参与</strong>：客户（或其代表）是敏捷团队的重要成员，持续提供反馈，确保开发出的产品符合期望。</p>
</li>
<li><p><strong>用户故事和任务管理</strong>：需求通常被分解为用户故事（User Stories），每个故事描述了用户的某种需求或功能。团队根据用户故事制定任务并进行开发。</p>
</li>
<li><p><strong>看板和任务板</strong>：敏捷团队常使用看板（Kanban）或任务板（Task Board）来跟踪工作进度，确保所有任务按时完成。</p>
</li>
</ol>
<h3 id="常见的敏捷开发框架"><a href="#常见的敏捷开发框架" class="headerlink" title="常见的敏捷开发框架"></a>常见的敏捷开发框架</h3><ol>
<li><p><strong>Scrum</strong>：一种广泛使用的敏捷框架，强调固定长度的冲刺、每日站会、冲刺评审和回顾，以及产品负责人（Product Owner）和 Scrum Master 的角色。</p>
</li>
<li><p><strong>看板（Kanban）</strong>：一种强调持续交付和流程优化的敏捷方法，通过可视化工作流程和限制在制品（WIP）来提高团队效率。</p>
</li>
<li><p><strong>极限编程（XP, Extreme Programming）</strong>：一种强调工程实践的敏捷方法，重点包括测试驱动开发（TDD）、结对编程、持续集成等。</p>
</li>
</ol>
<h3 id="敏捷开发的优点"><a href="#敏捷开发的优点" class="headerlink" title="敏捷开发的优点"></a>敏捷开发的优点</h3><ul>
<li><strong>快速交付</strong>：通过短周期的迭代，敏捷开发能够更快地交付可用的软件产品。</li>
<li><strong>更高的灵活性</strong>：敏捷开发能够快速响应需求变化，适应市场和客户的动态需求。</li>
<li><strong>提高客户满意度</strong>：通过持续交付和客户参与，敏捷开发能够更好地满足客户需求。</li>
<li><strong>持续改进</strong>：团队通过定期反思和回顾，不断优化开发流程和产品质量。</li>
</ul>
<h3 id="敏捷开发的挑战"><a href="#敏捷开发的挑战" class="headerlink" title="敏捷开发的挑战"></a>敏捷开发的挑战</h3><ul>
<li><strong>文化转变</strong>：组织需要适应从传统瀑布式开发向敏捷开发的文化转变，这可能需要时间和努力。</li>
<li><strong>需求管理</strong>：在敏捷开发中，需求管理可能变得复杂，特别是在面对频繁变化的情况下。</li>
<li><strong>团队协作</strong>：敏捷开发依赖于团队的高效协作，任何沟通不畅或角色不明确都会影响项目进度。</li>
</ul>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>0.设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2024/07/13/1-%E8%AF%AD%E8%A8%80-0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>1.语言</category>
        <category>0.设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2024/07/17/1-%E8%AF%AD%E8%A8%80-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407171441750.png" alt="image.png"></p>
<h1 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h1><p>栈是限定仅在表的一端进行插入或删除操作的线性表。我们把允许插入和删除操作的一端称为栈顶（top），另一端称为栈底（bottom）。不含任何数据元素的栈称为空栈。栈又称为“后进先出（Last In First Out，简称 LIFO）的线性表”，简称为 LIFO 结构。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407171443492.png" alt="image.png"></p>
<p>栈的插入操作，称为进栈&#x2F;入栈&#x2F;压栈。栈的删除操作，称为出栈&#x2F;弹栈。</p>
<h2 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h2><ol start="0">
<li>定义</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">data_t</span>; <span class="comment">//定义栈中数据元素的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">date_t</span> *data; <span class="comment">//用指针指向栈的存储空间</span></span><br><span class="line">	<span class="type">int</span> maxlen; <span class="comment">//当前栈的最大元素个数</span></span><br><span class="line">	<span class="type">int</span> top; <span class="comment">//指向栈顶位置（数组下标）的变量</span></span><br><span class="line">&#125;<span class="type">seqstack_t</span>; <span class="comment">//顺序栈类型定义</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建栈</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">seqstack_t</span> *<span class="title">CreateEmptyStack</span><span class="params">(<span class="type">int</span> max_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">seqstack_t</span> *stack;</span><br><span class="line">	stack = (<span class="type">seqstack_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">seqstack_t</span>));</span><br><span class="line">	stack-&gt;data = (<span class="type">data_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">data_t</span>)*max_len);</span><br><span class="line">	stack-&gt;top = <span class="number">-1</span>;</span><br><span class="line">	stack-&gt;max_len = max_len;</span><br><span class="line">	<span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>摧毁一个栈</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(<span class="type">seqstack_t</span> *stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(stack-&gt;data != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">free</span>(stack-&gt;data);</span><br><span class="line">		<span class="built_in">free</span>(stack);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>清空一个栈</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearStack</span><span class="params">(<span class="type">seqstack_t</span> *stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack != <span class="literal">NULL</span>)</span><br><span class="line">		stack-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>判断栈是否为空</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">EmptyStack</span><span class="params">(<span class="type">seqstack_t</span> *stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span>(stack-&gt;top == <span class="number">-1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5、判断栈是否为满</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FullStack</span><span class="params">(<span class="type">seqstack_t</span> *stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span>(stack-&gt;top == (stack-&gt;max_len - <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>d<br>6、进栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PushStack</span><span class="params">(<span class="type">seqstack_t</span> *stack ,<span class="type">data_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">FullStack</span>(stack))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		stack-&gt;top++;</span><br><span class="line">		stack-&gt;data[stack-&gt;top] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、出栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PopStack</span><span class="params">(<span class="type">seqstack_t</span> *stack,<span class="type">data_t</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">EmptySqstack</span>(stack))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*x = stack-&gt;data[stack-&gt;top];</span><br><span class="line">		stack-&gt;top--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、取栈顶元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetTop</span><span class="params">(<span class="type">seqstack_t</span> *stack,<span class="type">data_t</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">EmptyStack</span>(stack))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*x = stack-&gt;data[stack-&gt;top];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h2><p>若是栈中元素的数目变化范围较大或不清楚栈元素的数目，就应该考虑使用链式存储结构。人们将用链式存储结构表示的栈称作”链栈”。链栈通常用一个无头结点的单链表表示。插入操作和删除操作均在链表头部进行，链表尾部就是栈底，栈顶指针就是头指针。</p>
<ol start="0">
<li>定义</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">data_t</span> data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node_t</span> *next; <span class="comment">//链接指针域</span></span><br><span class="line">&#125;<span class="type">linkstack_t</span>; <span class="comment">//链栈类型定义</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建空栈：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">linkstack_t</span> *<span class="title">CreateLinkstack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linkstack_t</span> *top;</span><br><span class="line">	top = (<span class="type">linkstack_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">linkstack_t</span>));</span><br><span class="line">	top-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断是否为空栈：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">EmptyStack</span><span class="params">(<span class="type">linkstack_t</span> *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (top-&gt;next == <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>入栈</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushStack</span><span class="params">(<span class="type">linkstack_t</span> *top,<span class="type">data_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linkstack_t</span> *p;</span><br><span class="line">	p = (<span class="type">linkstack_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">linkstack_t</span>));</span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = top-&gt;next;</span><br><span class="line">	top-&gt;next = p;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>出栈</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PopStack</span><span class="params">(<span class="type">linkstack_t</span> stack,<span class="type">data_t</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack-&gt;next == <span class="literal">NULL</span> || stack == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">linkstack_t</span> p;</span><br><span class="line">	p = stack-&gt;next;</span><br><span class="line">	stack-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(x != <span class="literal">NULL</span>)</span><br><span class="line">		*x = p-&gt;data;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="linkstack"><a href="#linkstack" class="headerlink" title="linkstack"></a>linkstack</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linkstack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">linkstack_t</span> *<span class="title">CreateEmptyLinkstack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linkstack_t</span> *s;</span><br><span class="line"></span><br><span class="line">	s = (<span class="type">linkstack_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">linkstack_t</span>));</span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyLinkstack</span><span class="params">(<span class="type">linkstack_t</span> *stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stack) &#123;</span><br><span class="line">		<span class="comment">/* clear the stack linked list */</span></span><br><span class="line">		<span class="built_in">ClearLinkstack</span>(stack);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* free the stack header */</span></span><br><span class="line">		<span class="built_in">free</span>(stack);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EmptyLinkstack</span><span class="params">(<span class="type">linkstack_t</span> *stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stack) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((<span class="literal">NULL</span> == stack-&gt;next) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearLinkstack</span><span class="params">(<span class="type">linkstack_t</span> *stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linkstack_t</span> *node; <span class="comment">/* node to be removed */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!stack) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ( <span class="literal">NULL</span> != stack-&gt;next ) &#123;</span><br><span class="line">		<span class="comment">/* disconnect the one to be removed */</span></span><br><span class="line">		node = stack-&gt;next;</span><br><span class="line">		stack-&gt;next = node-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PushStack</span><span class="params">(<span class="type">linkstack_t</span> *stack, <span class="type">data_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linkstack_t</span> *node; <span class="comment">/* node to be inserted */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!stack) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	node = (<span class="type">linkstack_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">linkstack_t</span>));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == node) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;data = x;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* insert from the head of the link list</span></span><br><span class="line"><span class="comment">	 * it&#x27;s cheaper to push from the head of the single-linked</span></span><br><span class="line"><span class="comment">	 * list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	node-&gt;next = stack-&gt;next;</span><br><span class="line">	stack-&gt;next = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PopStack</span><span class="params">(<span class="type">linkstack_t</span> *stack, <span class="type">data_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linkstack_t</span> *node; <span class="comment">/* node to be removed */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!stack) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(stack-&gt;next)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* stack is empty */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pop from the head of the list */</span></span><br><span class="line">	node = stack-&gt;next;</span><br><span class="line">	stack-&gt;next = node-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data) &#123;</span><br><span class="line">		*data = node-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now we can free the node safely */</span></span><br><span class="line">	<span class="built_in">free</span>(node);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetTop</span><span class="params">(<span class="type">linkstack_t</span> *stack, <span class="type">data_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!stack) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(stack-&gt;next)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* stack is empty */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (data) &#123;</span><br><span class="line">		*data = stack-&gt;next-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>	<span class="title">VisitStack</span><span class="params">(<span class="type">linkstack_t</span> *stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linkstack_t</span> *node; <span class="comment">/* node to be iterated */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!stack) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* print from the base to the top */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;stack = &#123;&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (stack-&gt;next) &#123; <span class="comment">/* list is not empty */</span></span><br><span class="line">		node = stack-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">NULL</span> != node) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, node-&gt;data);</span><br><span class="line">			node = node-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\b&#125;\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归：函数在自身的函数体内直接或间接地调用自身。</p>
<p>示例：递归法求斐波那契数列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fbi</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> i==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Fbi</span>(i<span class="number">-1</span>)+<span class="built_in">Fbi</span>(i<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,<span class="built_in">Fbi</span>(i));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现递归，必要的两个条件是递归出口和递归逻辑。在示例程序中，if(i&lt;2)就是递归出口，而 Fbi(i-1)+Fbi(i-2)就是递归逻辑。对比递归代码和非递归（迭代）代码，我们可以看出递归和迭代的区别：迭代使用循环结构，而递归使用分支结构</p>
<p>在某些程序中，递归能使得程序结构简洁清晰，容易理解。但是大量的调用递归函数会建立许多该函数的副本，需要大量的内存存储空间。而迭代法则无需大量的存储空间。</p>
<p>要想实现递归，我们需要明白递归的过程本质上是函数返回顺序是其调用顺序的逆序，即：<strong>先行调用的函数会在后面获得返回值</strong>。这种先行存储数据，并在之后逆序恢复得到数据的过程，显然很符合栈这种数据结构。因此，编译器使用栈来实现函数的递归。</p>
<p>在调用阶段，对于每层递归，函数的局部变量、参数、返回地址都被压入栈中，再去调用下次递归。在返回阶段，依次弹出位于栈顶的函数，获得计算结果。这也是为什么需要“递归出口”的原因，递归出口可以看做是从压栈到弹栈的状态转变因素。</p>
<h3 id="后缀（逆波兰）表示法"><a href="#后缀（逆波兰）表示法" class="headerlink" title="后缀（逆波兰）表示法"></a>后缀（逆波兰）表示法</h3><p>中缀表达式，即运算符（此处特指算数运算符）在操作数中间。<code>9+(3-1)*3+10/2</code></p>
<p>后缀表示法，也称为逆波兰表示法，即运算符在两个操作数之后出现 <code>9 3 1 - 3 * + 10 2 / +</code></p>
<p>后缀表达式的算法规则：从左到右遍历表达式，若遇到数字则进栈，遇到运算符则弹出栈顶两个元素进行运算，计算结果再次压栈，最后计算得到的结果就是最终结果。</p>
<p>我们以 <code> 9 3 1 - 3 * + 10 2 / +</code> 进行讲解（操作数入栈）</p>
<ul>
<li>初始化一个空栈，此栈用于对要计算的操作数的进出及存储。</li>
<li>9、3、1 都是数字，因此依次入栈</li>
<li>接下来是-，是符号，弹出栈顶两个元素作为操作数，注意先弹出的元素在符号右侧，后弹出的元素在符号左侧，即 3 - 1，得到计算结果 2，将 2 压栈。</li>
<li>数字 3 进栈</li>
<li>后面是 <code>*</code>，栈顶两个元素弹栈进行运算 <code>2 * 3</code>，得到结果 6，再压入栈</li>
<li>后面是+，栈顶两个元素弹栈进行运算 9 + 6，得到结果 15，再压入栈</li>
<li>数字 10 和 2 进栈</li>
<li>后面是&#x2F;，栈顶两个元素弹栈进行运算 10 &#x2F; 2，得到结果 5，再压入栈</li>
<li>最后一个符号是+，栈顶两个元素弹栈进行运算 15 + 5，得到结果 20</li>
<li>最终结果是 20，栈变为空，结束运算。</li>
</ul>
<p>中缀表达式转化为后缀表达式的规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号则判断其与栈顶符号的优先级，是右括号或优先级低于或等于栈顶符号的则栈顶元素依次出栈并输出，直至遇到一个比其优先级低的运算符为止，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>
<p>我们以 <code> 9+(3-1)*3+10/2------&gt;9 3 1 - 3 * + 10 2 / +</code> 进行讲解（运算符入栈）</p>
<ul>
<li>初始化一个空栈，用于对符号进出栈使用。</li>
<li>第一个数字是 9，输出 9。后面的符号+入栈。</li>
<li>第三个字符是（，依然是符号，因其是左括号还未配对，故进栈。</li>
<li>第四个字符是数字 3，输出，此时表达式为 9 3，接着符号-进栈。</li>
<li>接下来是数字 1，输出，此时表达式为 9 3 1，后面是符号），此时我们需要把（之前的所有元素都出栈，直至输出（为止。此时总的表达式是 9 3 1 -。</li>
<li>紧接着是符号 <code>*</code>，因为此时的栈顶符号是+，优先级低于 <code> *</code>，因此不输出，<code>*</code> 进栈。紧接着是数字 3，输出，总表达式为 9 3 1 – 3.</li>
<li>之后是符号+，此时栈顶元素是 <code> *</code>，比+优先级高，因此栈中元素出栈并输出（因为没有比+更低优先级的符号，所以全部出栈），总输出表达式为 <code> 9 3 1 – 3 * +</code>。然后将这个符号+进栈。</li>
<li>紧接着输出数字 10，总表达式为 <code>9 3 1 – 3 * + 10</code>。之后是符号 <code>/</code>，所以 <code>/</code> 进栈。</li>
<li>最后一个数字为 2，此时总表达式为 <code>9 3 1 – 3 * + 10 2</code>。</li>
<li>因已到最后，所以将栈中符号全部出栈。最终获得的后缀表达式为 <code> 9 3 1 – 3 * + 10 2 / +</code>。</li>
</ul>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出（First In First Out）的线性表，简称 FIFO。允许插入操作的一端称为队尾，允许删除操作的一端称为队头。</p>
<p>队列作为特殊的线性表，有顺序队列和链式队列两种形式。</p>
<h2 id="队列的顺序存储结构及实现"><a href="#队列的顺序存储结构及实现" class="headerlink" title="队列的顺序存储结构及实现"></a>队列的顺序存储结构及实现</h2><p>如果我们要建立元素个数为 n 的队列，则需要建立一个数组长度不小于 n 的数组，数组下标为 0 的为队头，当最大下标的为队尾。若有元素要入队，则只需将其存储在第 n+1 个位置即可。而若想出队，则删除了下标为 0 的元素后，所有在其后的元素都需要向前移动一格，即保持下标为 0 的元素为队头。但这样做显然浪费了大量时间。</p>
<p>解决该问题的方法就是不再限制下标为 0 的元素为队头，每次出队后，队头自动变成当前数组下标最小的元素即可。这样就无需所有元素向前移动。但是，若如此做，则会造成大量的已出队的元素的存储空间浪费。而且，若此时入队元素已经大于 n，则我们需要更大的存储空间才行，但队头位置有大量空间未利用，空间浪费严重。</p>
<p>解决以上问题的方法就是如果后面满了，则我们就从头开始，也就是将队列做成头尾相接的循环。我们把这种头尾相接的顺序存储结构的队列称为循环队列。</p>
<p>在循环队列中，当队列为空时，有 <code>front=rear</code>，而当所有队列空间全占满时，也有 <code>front=rear</code>。为了区别这两种情况，规定循环队列最多只能有 <code>MaxSize-1</code> 个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件时 <code>front=rear</code>，而队列判满的条件时 <code>front=（rear+1）%MaxSize</code>。</p>
<ul>
<li>队头指针 <code>front</code>，指向队头元素的位置的前一个位置。即指向预留的位置；</li>
<li>队尾指针 <code>rear</code>，指向队尾元素的位置；</li>
<li>入队：<code> rear = (rear + 1) % N (maxsize)</code>，然后元素放入队尾 <code>rear</code> 所指向的位置；</li>
<li>出队： <code>front = (front + 1) % N</code>，然后取出队头指针 <code>front</code> 所指向的元素；</li>
<li>队空： <code>front == rear</code>;</li>
<li>队满：<code> (rear + 1) % N == front,</code> N 为数组的元素个数；</li>
<li>为了区别空队和满队，满队元素个数比数组元素个数少一个。</li>
</ul>
<p>这样，我们就需要两个指示其队头（front）和队尾（rear）的下标变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 64 <span class="comment">//队列中数据元素的数据类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">data_t</span> data[N]; <span class="comment">//用数组作为队列的储存空间</span></span><br><span class="line">	<span class="type">int</span> front,rear; <span class="comment">//指示队头位置和队尾位置的指针</span></span><br><span class="line">&#125;<span class="type">sequeue_t</span>;</span><br></pre></td></tr></table></figure>

<p>当 <code>(rear+1)%QueueSize==front</code> 时，此时队尾的下个位置就是队头，则该队列为满队列。注意 rear 的位置不是队尾元素的位置，而是队尾元素的下一个位置，即当队列满时，队列中还有一个空闲存储空间，但我们规定该状态下就是满队列。</p>
<p>那么，定义好队列的的队头和队尾位置，我们来考虑怎样计算队列长度。</p>
<p>当 <code>rear&gt;front </code> 时，表示队尾在队头右边，此时队列长度为 <code>rear-front</code>；</p>
<p>当 <code>rear&lt;front</code> 时，表示队尾在队友左边，此时计算队列长度应分成两部分，即 <code>rear</code> 一部分，<code>QueueSize-front</code> 一部分，总体长度为 <code>rear-front+QueueSize</code>。</p>
<p>通用计算队列长度的公式是 <code>length=(rear-front+QueueSize)%QueueSize</code></p>
<ol>
<li>创建空队列</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">sequeue_t</span> *<span class="title">CreateEmptySequeue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">sequeue_t</span> *queue;</span><br><span class="line">	queue = (<span class="type">sequeue_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">sequeue_t</span>));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == queue) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	queue-&gt;front = queue-&gt;rear = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>摧毁一个队列</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">voidDestroySequeue</span>(<span class="type">sequeue_t</span> *queue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != queue)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(queue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>判断一个队列是否为空</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">intEmptySequeue</span>(<span class="type">sequeue_t</span> *queue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == queue)</span><br><span class="line">		<span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> (queue-&gt;front == queue-&gt;rear ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>判断一个队列是否为满</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">intFullSequeue</span>(<span class="type">sequeue_t</span> *queue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == queue) <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ((queue-&gt;rear + <span class="number">1</span>) % N == queue-&gt;front ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>清空一个队列</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">voidClearSequeue</span>(<span class="type">sequeue_t</span> *queue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == queue) <span class="keyword">return</span>;</span><br><span class="line">	queue-&gt;front = queue-&gt;rear = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>入队</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">intEnQueue</span>(<span class="type">sequeue_t</span> *queue, <span class="type">data_t</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == queue) <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == <span class="built_in">FullSequeue</span>(queue)) <span class="keyword">return</span><span class="number">-1</span>; <span class="comment">/* full */</span></span><br><span class="line">	queue-&gt;rear = (queue-&gt;rear + <span class="number">1</span>) % N;</span><br><span class="line">	queue-&gt;data[queue-&gt;rear] = x;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>出队</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">intDeQueue</span>(<span class="type">sequeue_t</span> *queue, <span class="type">data_t</span> *x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == queue) <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == <span class="built_in">EmptySequeue</span>(queue)) <span class="keyword">return</span><span class="number">-1</span>; <span class="comment">/* empty */</span></span><br><span class="line">	queue-&gt;front = (queue-&gt;front + <span class="number">1</span>) % N;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != x) &#123;</span><br><span class="line">		*x = queue-&gt;data[queue-&gt;front];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h2><p>队列的链式存储结构本质上是从单链表演化而来的。将单链表改造成链式队列，如果将头结点做为队头，最后一个节点做为队尾，则该队列的出队操作方便，而入队操作较慢；反之，如果将头结点做为队尾，最后一个节点做为队头，则该队列的入队操作方便，而出队操作较慢。那么，能否将单链表稍加改进，使得该链式队列的入队操作和出队操作一样方便呢？</p>
<p>答案是可以的，只需要改进头结点。将“头结点存储一个 next 指针”改为“头结点存储两个指针 front 和 rear”，front 指针指向队头，rear 指针指向队尾。这样我们进行出队&#x2F;入队操作时，只需要访问这两个指针就能快速地找到队头&#x2F;队尾。</p>
<ol>
<li>队列的链式存储结构定义，将单链表的头结点稍加改造</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span><span class="comment">//定义单链表</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">data_t</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node_t</span> *next;</span><br><span class="line">&#125;<span class="type">linknode_t</span>, *<span class="type">linklist_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span><span class="comment">//定义链式队列</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">linklist_t</span> front, rear;</span><br><span class="line">&#125;<span class="type">linkqueue_t</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建空队列</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">linkqueue_t</span> *<span class="title">CreateEmptyLinkqueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linkqueue_t</span> *lp = (<span class="type">linkqueue_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">linkqueue_t</span>));</span><br><span class="line">	<span class="keyword">if</span>(lp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	lp-&gt;front = lp-&gt;rear = (<span class="type">linknode_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">linknode_t</span>));</span><br><span class="line">	<span class="keyword">if</span>(lp-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	lp-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>摧毁一个链队列</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyLinkqueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(queue != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ClearLinkqueue</span>(queue);</span><br><span class="line">		<span class="built_in">free</span>(queue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>清空一个链队列</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearLinkqueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linknode_t</span> *qnode;</span><br><span class="line">	<span class="keyword">while</span>(q-&gt;front)</span><br><span class="line">	&#123;</span><br><span class="line">		qnode = queue-&gt;front;</span><br><span class="line">		queue-&gt;front= qnode-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(qnode);</span><br><span class="line">	&#125;</span><br><span class="line">	queue-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>判定链式队列是否为空</li>
</ol>
<p>由于单链表的属性，链式队列几乎不会出现“队列已满”的情况，因此不考虑判定链式队列是否已满的操作。判定链式队列是否为空，只需要判定队列的 front 指针是否为空即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">EmptyLinkqueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(queue == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span>(queue-&gt;front == queue-&gt;rear ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>队列的链式存储结构——入队操作</li>
</ol>
<p>入队操作其实就是在链表尾部插入节点。（需要判定插入时链表是否为空，如果链表为空，则 front 和 rear 两个指针都需要操作）新来的数据节点附在当前 rear 节点之后，并将 rear 节点指向该节点即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">EnQueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue,<span class="type">data_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linknode_t</span> *node_new;</span><br><span class="line">	<span class="keyword">if</span>(queue == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">	node_new = (<span class="type">linknode_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">linknode_t</span>));</span><br><span class="line">	<span class="keyword">if</span>(node_new == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">	node_new-&gt;data = x;</span><br><span class="line">	node_new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(queue-&gt;front-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		queue-&gt;front-&gt;next = queue-&gt;rear = node_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		queue-&gt;rear-&gt;next = node_new;</span><br><span class="line">		queue-&gt;rear = node_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>队列的链式存储结构——出队操作</li>
</ol>
<p>出队操作就是将链表的头结点的后继节点出队，并将其之后的节点设置为头结点的后继节点。若链表除头结点外仅剩一个元素，则需将 rear 指向头结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeQueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue,<span class="type">data_t</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linknode_t</span> *node_remove;</span><br><span class="line">	<span class="keyword">if</span>(queue == <span class="literal">NULL</span> || queue-&gt;front-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">	node_remove = queue-&gt;front-&gt;next;</span><br><span class="line">	queue-&gt;front-&gt;next = node_remove-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(x != <span class="literal">NULL</span>)</span><br><span class="line">		*x = node_remove-&gt;data;</span><br><span class="line">	<span class="built_in">free</span>(node_remove);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链式队列代码"><a href="#链式队列代码" class="headerlink" title="链式队列代码"></a>链式队列代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">data_t</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node_t</span> *next;</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">linknode_t</span>, *<span class="type">linklist_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">linklist_t</span> front, rear;</span><br><span class="line">&#125; <span class="type">linkqueue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">linkqueue_t</span> *<span class="title">CreateEmptyLinkqueue</span><span class="params">()</span><span class="comment">//创建空队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linkqueue_t</span> *queue;</span><br><span class="line"></span><br><span class="line">	queue = (<span class="type">linkqueue_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">linkqueue_t</span>));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == queue)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;Create Empty LinkQueue Error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	queue-&gt;rear = queue-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClearLinkqueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue)</span><span class="comment">//清空队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linknode_t</span> *node_remove;</span><br><span class="line"></span><br><span class="line">	node_remove = queue-&gt;front;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">NULL</span> != node_remove)</span><br><span class="line">	&#123;</span><br><span class="line">		queue-&gt;front = queue-&gt;front-&gt;next;</span><br><span class="line">		<span class="built_in">free</span> (node_remove);</span><br><span class="line">		node_remove = queue-&gt;front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	queue-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DestroyLinkqueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue)</span><span class="comment">//销毁队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (queue)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ClearLinkqueue</span>(queue);</span><br><span class="line">		<span class="built_in">free</span>(queue);</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;DestroyLinkqueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EmptyLinkqueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue)</span><span class="comment">//判定队列是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!queue)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;EmptyLinkqueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> queue-&gt;front == <span class="literal">NULL</span> ? OK : ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EnQueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue, <span class="type">data_t</span> x)</span><span class="comment">//入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linknode_t</span> *node_new;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!queue)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;EnQueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	node_new = (<span class="type">linknode_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">linknode_t</span>));</span><br><span class="line">	node_new-&gt;data = x;</span><br><span class="line">	node_new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">EmptyLinkqueue</span>(queue)==OK)</span><br><span class="line">	&#123;</span><br><span class="line">		queue-&gt;front = queue-&gt;rear = node_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		queue-&gt;rear-&gt;next = node_new;</span><br><span class="line">		queue-&gt;rear = node_new;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeQueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue, <span class="type">data_t</span> *x)</span><span class="comment">//出队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linknode_t</span> *node_remove;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!queue)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;DeQueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">EmptyLinkqueue</span>(queue)==OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;queue is Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">	node_remove = queue-&gt;front;</span><br><span class="line"></span><br><span class="line">	queue-&gt;front = node_remove-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == queue-&gt;front)</span><br><span class="line">		queue-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line">		*x = node_remove-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(node_remove);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">VisitQueue</span><span class="params">(<span class="type">linkqueue_t</span> *queue)</span><span class="comment">//遍历队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">linknode_t</span> *node;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;aueue = &#123;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	node = queue-&gt;front;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == node) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">NULL</span> != node) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, node-&gt;data);</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\b&#125;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="球钟问题"><a href="#球钟问题" class="headerlink" title="球钟问题"></a>球钟问题</h1><p>球钟是一个利用球的移动来记录时间的简单装置。它有三个可以容纳若干个球的指示器：分钟指示器，五分钟指示器，小时指示器。若分钟指示器中有 2 个球，五分钟指示器中有 6 个球，小时指示器中有 5 个球，则时间为 5:32。每过一分钟，球钟就会从球队列的队首取出一个球放入分钟指示器，分钟指示器最多可容纳 4 个球。当放入第五个球时，在分钟指示器的 4 个球就会按照他们被放入时的相反顺序加入球队列的队尾。而第五个球就会进入五分钟指示器。按此类推，五分钟指示器最多可放 11 个球，小时指示器最多可放 11 个球。</p>
<p>当小时指示器放入第 12 个球时，原来的 11 个球按照他们被放入时的相反顺序加入球队列的队尾，然后第 12 个球也回到队尾。这时，三个指示器均为空，回到初始状态，从而形成一个循环。因此，该球钟表示时间的范围是从 0：00 到 11：59。</p>
<p>思考：球钟需要多少个球，才能实现计时范围为 0：00 到 11：59？</p>
<p>提示：使用 3 个栈来分别表示 1min 指示器、5min 指示器和 1h 指示器，使用一个队列来存储小球</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407171536159.jpg" alt="球钟.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE_1 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE_2 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE_ball 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>          <span class="comment">//一分钟的顺序栈</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">data_t</span> data[MAXSIZE_1];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">&#125;<span class="type">one_min_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>          <span class="comment">//五分钟与一小时的顺序栈</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">data_t</span> data[MAXSIZE_2];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">&#125;<span class="type">five_min_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>              <span class="comment">//所有小球的存放队列</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">data_t</span> data[MAXSIZE_ball];</span><br><span class="line">	<span class="type">int</span> front;</span><br><span class="line">	<span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">data_t</span> *the_ball;</span><br><span class="line">    <span class="type">one_min_t</span> *one_min;</span><br><span class="line">    <span class="type">five_min_t</span> *five_min,*one_hour;</span><br><span class="line">    SqQueue *ball;</span><br><span class="line"></span><br><span class="line">    one_min = <span class="built_in">CreateEmptyStack</span>();</span><br><span class="line">    five_min = <span class="built_in">CreateEmptyStack</span>();</span><br><span class="line">    one_hour = <span class="built_in">CreateEmptyStack</span>();</span><br><span class="line">    ball = <span class="built_in">CreateEmptyQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXSIZE_ball; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">EnQueue</span>(ball,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeQueue</span>(ball,the_ball);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==<span class="built_in">PushStack</span>(one_min,the_ball))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">PopStack</span>(one_min,the_ball);</span><br><span class="line">            <span class="built_in">EnQueue</span>(ball,the_ball);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PushStack</span><span class="params">(SqStack *s,<span class="type">data_t</span> e)</span><span class="comment">//压栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top==MAXSIZE<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Stack is Full\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;top++;</span><br><span class="line">	s-&gt;data[s-&gt;top]=e;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PopStack</span><span class="params">(SqStack *s,<span class="type">data_t</span> *e)</span><span class="comment">//弹栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Stack is Empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	*e=s-&gt;data[s-&gt;top];</span><br><span class="line">	s-&gt;top--;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SqStack* <span class="title">CreateEmptyStack</span><span class="params">()</span><span class="comment">//创建栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack *stack = (SqStack*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqStack));</span><br><span class="line">    <span class="keyword">if</span>(stack==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateEmptyStack Error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EmptyStack</span><span class="params">(SqStack *s)</span><span class="comment">//判断栈是否是空栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>==s-&gt;top?OK:ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FullStack</span><span class="params">(SqStack *s)</span><span class="comment">//判断栈是否是满栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MAXSIZE<span class="number">-1</span>==s-&gt;top?OK:ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClearStack</span><span class="params">(SqStack *s)</span><span class="comment">//清空栈内元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">SqQueue *<span class="title">CreateEmptyQueue</span><span class="params">()</span><span class="comment">//创建队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqQueue *sq = (SqQueue*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqQueue));</span><br><span class="line">	<span class="keyword">if</span>(sq==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateEmptyQueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sq-&gt;front=<span class="number">0</span>;</span><br><span class="line">	sq-&gt;rear=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EmptyQueue</span><span class="params">(SqQueue *Q)</span><span class="comment">//判断队是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;EmptyQueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;rear==Q-&gt;front)</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FullQueue</span><span class="params">(SqQueue *Q)</span><span class="comment">//判断队是否已满</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;EmptyQueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE==Q-&gt;front)</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue *Q,<span class="type">data_t</span> e)</span><span class="comment">//元素e入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">FullQueue</span>(Q)==OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Queue is Full\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	Q-&gt;data[Q-&gt;rear]=e;</span><br><span class="line">	Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue *Q,<span class="type">data_t</span> *e)</span><span class="comment">//元素出队，出队元素存储在e中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">EmptyQueue</span>(Q)==OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Queue is Empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	*e=Q-&gt;data[Q-&gt;front];</span><br><span class="line">	Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONEMIN 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIVEMIN 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONEHOUR 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BALLQUE 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">data_t</span> *data;</span><br><span class="line">	<span class="type">int</span> top;<span class="comment">//栈顶</span></span><br><span class="line">	<span class="type">int</span> maxlen;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">data_t</span> *data;</span><br><span class="line">	<span class="type">int</span> front;<span class="comment">//队头位置</span></span><br><span class="line">	<span class="type">int</span> rear;<span class="comment">//队尾位置</span></span><br><span class="line">	<span class="type">int</span> maxlen;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment">*队列部分</span></span><br><span class="line"><span class="comment">**************************/</span></span><br><span class="line"><span class="function">SqQueue *<span class="title">CreateEmptyQueue</span><span class="params">(<span class="type">int</span> length)</span><span class="comment">//创建队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqQueue *sq = (SqQueue*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqQueue));</span><br><span class="line">	<span class="keyword">if</span>(sq==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateEmptyQueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sq-&gt;data = (<span class="type">data_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">data_t</span>)*length);</span><br><span class="line">	sq-&gt;maxlen=length;</span><br><span class="line">	sq-&gt;front=<span class="number">0</span>;</span><br><span class="line">	sq-&gt;rear=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EmptyQueue</span><span class="params">(SqQueue *Q)</span><span class="comment">//判断队是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;EmptyQueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;rear==Q-&gt;front)</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FullQueue</span><span class="params">(SqQueue *Q)</span><span class="comment">//判断队是否已满</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;EmptyQueue Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%Q-&gt;maxlen==Q-&gt;front)</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue *Q,<span class="type">data_t</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">FullQueue</span>(Q)==OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Queue is Full\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	Q-&gt;data[Q-&gt;rear]=e;</span><br><span class="line">	Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%Q-&gt;maxlen;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue *Q,<span class="type">data_t</span> *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">EmptyQueue</span>(Q)==OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Queue is Empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	*e=Q-&gt;data[Q-&gt;front];</span><br><span class="line">	Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%Q-&gt;maxlen;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment">*栈部分</span></span><br><span class="line"><span class="comment">**************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PushStack</span><span class="params">(SqStack *s,<span class="type">data_t</span> e)</span><span class="comment">//压栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top==s-&gt;maxlen<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Stack is Full\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;top++;</span><br><span class="line">	s-&gt;data[s-&gt;top]=e;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">data_t</span> <span class="title">PopStack</span><span class="params">(SqStack *s)</span><span class="comment">//弹栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Stack is Empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">data_t</span> e=s-&gt;data[s-&gt;top];</span><br><span class="line">	s-&gt;top--;</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SqStack* <span class="title">CreateEmptyStack</span><span class="params">(<span class="type">int</span> length)</span><span class="comment">//创建栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack *stack = (SqStack*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqStack));</span><br><span class="line">    <span class="keyword">if</span>(stack==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateEmptyStack Error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	stack-&gt;data = (<span class="type">data_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">data_t</span>)*length);</span><br><span class="line">	stack-&gt;maxlen=length;</span><br><span class="line">    stack-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EmptyStack</span><span class="params">(SqStack *s)</span><span class="comment">//判断栈是否是空栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>==s-&gt;top?OK:ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FullStack</span><span class="params">(SqStack *s)</span><span class="comment">//判断栈是否是满栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;maxlen<span class="number">-1</span>==s-&gt;top?OK:ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowTime</span><span class="params">(SqStack *one_min,SqStack *five_min,SqStack *one_hour)</span><span class="comment">//计算球钟内3个栈的小球所代表的时间并打印</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> hour,minute;</span><br><span class="line">	minute=(one_min-&gt;top+<span class="number">1</span>)+(five_min-&gt;top+<span class="number">1</span>)*<span class="number">5</span>;</span><br><span class="line">	hour=one_hour-&gt;top+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;time: %d:%d\n&quot;</span>,hour,minute);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqStack *one_min = <span class="built_in">CreateEmptyStack</span>(ONEMIN);<span class="comment">//1分钟栈</span></span><br><span class="line">	SqStack *five_min = <span class="built_in">CreateEmptyStack</span>(FIVEMIN);<span class="comment">//5分钟栈</span></span><br><span class="line">	SqStack *one_hour = <span class="built_in">CreateEmptyStack</span>(ONEHOUR);<span class="comment">//1小时栈</span></span><br><span class="line">	SqQueue *ballque = <span class="built_in">CreateEmptyQueue</span>(BALLQUE);<span class="comment">//球队列</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">data_t</span> data;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=ballque-&gt;maxlen<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">EnQueue</span>(ballque,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeQueue</span>(ballque,&amp;data);<span class="comment">//出队一个球</span></span><br><span class="line">		<span class="built_in">PushStack</span>(one_min,data);<span class="comment">//压入1分钟栈中</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FullStack</span>(one_min)==OK)<span class="comment">//如果1分钟栈已满</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;one_min-&gt;maxlen<span class="number">-1</span>;i++)<span class="comment">//弹出4个元素到队列中</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">EnQueue</span>(ballque,<span class="built_in">PopStack</span>(one_min));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">PushStack</span>(five_min,<span class="built_in">PopStack</span>(one_min));<span class="comment">//第5个压入5分钟栈</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FullStack</span>(five_min)==OK)<span class="comment">//如果5分钟栈已满</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;five_min-&gt;maxlen<span class="number">-1</span>;i++)<span class="comment">//弹出11个元素到队列中</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">EnQueue</span>(ballque,<span class="built_in">PopStack</span>(five_min));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">PushStack</span>(one_hour,<span class="built_in">PopStack</span>(five_min));<span class="comment">//第12个元素压入1小时栈</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FullStack</span>(one_hour)==OK)<span class="comment">//如果1小时栈已满</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;one_hour-&gt;maxlen;i++)<span class="comment">//弹出12个元素到队列中</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">EnQueue</span>(ballque,<span class="built_in">PopStack</span>(one_hour));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ShowTime</span>(one_min,five_min,one_hour);<span class="comment">//打印时间</span></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);<span class="comment">//延时1秒</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h1><p>队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入元素和在队列头部删除节点的功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">CQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>(<span class="type">void</span>);</span><br><span class="line">    ~<span class="built_in">CQueue</span>(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;T&gt; stack1;</span><br><span class="line">    stack&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路：栈是先进后出，而队列是先进先出的，而要用栈实现队列的话，两步操作如下：</p>
<p>进队列：第一个栈 stack1 专门用来压入数据；</p>
<p>出队列：要把队列头部元素输出，而这个头部会在 stack1 中的底部，因此我们需要利用辅助栈 stack2 ，把 stack1 元素依次压入 stack2，这样原来 stack1 中的底部元素变成 stack2 的栈顶，而这就是队列的 head，将之输出即可。</p>
<p>上面分析是针对 stack2 空的情况，若 stack2 非空，则要继续把 stack2 中元素依次 pop 出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进队列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> CQueue&lt;T&gt;::<span class="built_in">appendTail</span>(<span class="type">const</span> T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">    stack1.<span class="built_in">push</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T CQueue&lt;T&gt;::<span class="built_in">deleteHead</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若stack2是空的，则把stack1的元素copy过来</span></span><br><span class="line">        <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            T&amp; data = stack1.<span class="built_in">top</span>();</span><br><span class="line">            stack1.<span class="built_in">pop</span>();</span><br><span class="line">            stack2.<span class="built_in">push</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取stack2栈顶元素，即队列的head</span></span><br><span class="line">    T head = stack2.<span class="built_in">top</span>();</span><br><span class="line">    stack2.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 数组实现队列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组实现队列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="keyword">class</span> <span class="title class_">CArrayQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CArrayQueue</span>(<span class="type">void</span>);</span><br><span class="line">    ~<span class="built_in">CArrayQueue</span>(<span class="type">void</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> nSize;</span><br><span class="line">    T Array[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> nHead;</span><br><span class="line">    <span class="type">int</span> nTail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="type">const</span> <span class="type">int</span> CArrayQueue&lt;T&gt;:: nSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; CArrayQueue&lt;T&gt;::<span class="built_in">CArrayQueue</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nHead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nTail = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; CArrayQueue&lt;T&gt;::~<span class="built_in">CArrayQueue</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nHead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nTail = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进队列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> CArrayQueue&lt;T&gt;::<span class="built_in">appendTail</span>(<span class="type">const</span> T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nTail - nHead &gt;= nSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;Queue is full!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Array[(++nTail) % nSize] = element;</span><br><span class="line">    <span class="keyword">if</span> (nHead / nSize &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        nTail -= nSize;</span><br><span class="line">        nHead -= nSize;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T CArrayQueue&lt;T&gt;::<span class="built_in">deleteHead</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T Head = Array[nHead++];</span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>1.数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>C语言基础</title>
    <url>/2024/06/17/1-%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>: <span class="number">1</span> Bytes : <span class="number">8</span> bits</span><br><span class="line"><span class="type">short</span>:<span class="number">2</span> Bytes : <span class="number">16</span> bits</span><br><span class="line"><span class="type">int</span>:  <span class="number">4</span> Bytes : <span class="number">32</span> bits</span><br><span class="line"><span class="type">long</span>: <span class="number">4</span> Bytes : <span class="number">32</span> bits</span><br><span class="line"><span class="type">float</span>: <span class="number">4</span> Bytes : <span class="number">32</span> bits</span><br><span class="line"><span class="type">double</span>: <span class="number">8</span> Bytes : <span class="number">64</span> bits</span><br><span class="line"><span class="type">long</span> <span class="type">long</span>: <span class="number">8</span> Bytes : <span class="number">64</span> bits</span><br><span class="line"><span class="type">long</span> <span class="type">double</span>: <span class="number">16</span> Bytes : <span class="number">96</span> bits</span><br></pre></td></tr></table></figure>

<h1 id="数据类型存储"><a href="#数据类型存储" class="headerlink" title="数据类型存储"></a>数据类型存储</h1><p>数据在内存中以补码形式存储（溢出时截取补码的一段（然后求原码在输出））</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line">c = <span class="number">1222</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %c \n&quot;</span>,c ,c);</span><br></pre></td></tr></table></figure>

<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>数据存放在栈上</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><ul>
<li>不能用&amp;运算符获  取 regi ste  r 变量的地址</li>
<li>register 变量的必须是 CPU 寄存器可以接受的值</li>
<li>register 关键字指明将变量存储在寄存器中</li>
<li>register 只是请求寄存 器变量， 但不一定成功，如果没有申请到空间，那么该变量与 auto 变量没有区别</li>
</ul>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>（将值放在了数据段，所以它的值在全局都具有继承性（但不具有访问性，只在该函数内部可以访问））		</p>
<p>（限制作用域）</p>
<ul>
<li>stati  c 关键字指明变量的“静态”属性</li>
<li>static 关键同时具有“作用域限定符”的意义</li>
<li>static 修饰的局部变量存储在程序静态区</li>
<li>static 的另一个意义是文件作用域标识符</li>
<li>static 修饰的全局变量作用域只是声明的文件中</li>
<li>static 修饰的函数作用域只是声明的文件中</li>
</ul>
<blockquote>
<p>为 何 static 在 fu n 函数中 定义为全局变量不行？</p>
<p>局部变量生命周期为函数运行期间， 加上 stat ic 类型后，生命周期为程序运行期间，但只可在函数中进行访问</p>
<p>修改变量的储存类型（将数据从栈上放到了数据段）并不表示修改变量的作用域!它仍然只能在该代码块内部按名字访问。</p>
</blockquote>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>外部参照引用（其他文件中（编译时应该一起）所有函数体外部说明的变量）	</p>
<p>（类似于声明？）</p>
<p>（exter n 延长了全局变量的作用域（到其他文件中 用 exter n 引用），不具有改变值和类型的功能)</p>
<p>（不分配内存，不能初始化））	</p>
<p>（不可以改变类型）</p>
<p>exter n 关键字的使用：</p>
<p>（具 有 externa l 链接属性，储存于静态内存中）</p>
<p>如果一个变量声明于函数&#x2F;代码块内部，在它前面添 加 exter n 关键字将使它所引用的是全局变量，而非局部变量；</p>
<p>声明于函数最外层作用域的局部变量无法与形参同名，因为他们的作用域相同</p>
<p>局部变量生效的范围内，会自动屏蔽全局变量</p>
<p>exter n 使全局变 量 i 在 fu n 中可以被访问，如果没 有 extern 在函数中， i 将变为局部变量。</p>
<p>exter n 只是声明一个变量，该变量需在别处已被定义</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>指定变量不可被当前线程改变（但有可能被系统或其他线程改变）。</p>
<p>关键字“static”，译成中文就是“静态的”，所以内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件。 使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。 </p>
<ol>
<li><p>局部 static 变量<br> a.静态局部变量在函数内定义,生存期为整个源程序，但作用域与自动变量相同，只能在定义该变量的函数内使用。退出该函数后， 尽管该变量还继续存在，但不能使用它。<br> b.对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予 0 值。而对自动变量不赋初值，则其值是不定的。</p>
</li>
<li><p>全局 static 变量<br> 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。但是他们的作用域，非静态全局 变量的作用域是整个源程序（多个源文件可以共同使用）。静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。</p>
</li>
<li><p>static 函数（也叫内部函数）<br> 只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用。区别于一般的非静态函数（外部函数） static 在 c 里面可以用来修饰变量，也可以用来修饰函数。 先看用来修饰变量的时候。变量在 c 里面可分为存在全局数据区、栈和堆里。其实我们平时所说的堆栈是栈而不包含对，不要弄混。</p>
</li>
</ol>
<p>判断 ip 地址合法</p>
<p>判断大小端</p>
<p>堆栈区别，static const voliate</p>
<h1 id="关键字存储模型"><a href="#关键字存储模型" class="headerlink" title="关键字存储模型"></a>关键字存储模型</h1><h2 id="全局静态变量"><a href="#全局静态变量" class="headerlink" title="全局静态变量"></a>全局静态变量</h2><p>全局变量(外部变量)的说明之前再冠以 static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>
<p>static 全局变量与普通的全局变量有什么区别：static 全局变量只初使化一次，防止在其他文件单元中被引用;</p>
<p>static 局部变量和普通局部变量有什么区别：static 局部变量只被初始化一次，下一次依据上一次结果值；</p>
<p>static 函数与普通函数有什么区别：static 函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。</p>
<p>C 程序一直由下列部分组成：</p>
<ul>
<li>正文段——CPU 执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令；    </li>
<li>初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。    </li>
<li>非初始化数据段（bss 段）——在程序中没有初始化的全局变量；内核将此段初始化为 0。     </li>
<li>栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。      </li>
<li>堆——动态存储分。</li>
</ul>
<p>在全局变量之前加上关键字 static，全局变量就被定义成为一个全局静态变量。</p>
<ul>
<li>内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</li>
<li>初始化：未经初始化的全局静态变量会被程序自动初始化为 0（自动对象的值是任意的，除非他被显示初始化）</li>
<li>作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。</li>
</ul>
<p>定义全局静态变量的好处：</p>
<ul>
<li>不会被其他文件所访问，修改</li>
<li>其他文件中可以使用相同名字的变量，不会发生冲突。</li>
</ul>
<h2 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h2><p>在局部变量之前加上关键字 static，局部变量就被定义成为一个局部静态变量。</p>
<ul>
<li>内存中的位置：静态存储区</li>
<li>初始化：未经初始化的全局静态变量会被程序自动初始化为 0（自动对象的值是任意的，除非他被显示初始化）</li>
<li>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</li>
</ul>
<p> 注：当 static 用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。</p>
<p>当 static 用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。</p>
<h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>在函数的返回类型前加上关键字 static，函数就被定义成为静态函数。函数的定义和声明默认情况下是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>定义静态函数的好处：</p>
<ul>
<li>其他文件中可以定义相同名字的函数，不会发生冲突</li>
<li>静态函数不能被其他文件所用。 存储说明符 auto，register，extern，static，对应两种存储期：自动存储期和静态存储期。 auto 和 register 对应自动存储期。具有自动存储期的变量在进入声明该变量的程序块时被建立，它在该程序块活动时存在，退出该程序块时撤销。</li>
</ul>
<p>关键字 extern 和 static 用来说明具有静态存储期的变量和函数。用 static 声明的局部变量具有静态存储持续期（static storage duration），或静态范围（static extent）。虽然他的值在函数调用之间保持有效，但是其名字的可视性仍限制在其局部域内。静态局部对象在程序执行到该对象的声明处时被首次初始化。</p>
<p>由于 static 变量的以上特性，可实现一些特定功能。</p>
<ul>
<li>统计次数功能<br>  声明函数的一个局部变量，并设为 static 类型，作为一个计数器，这样函数每次被调用的时候就可以进行计数。这是统计函数被调用次数的最好的办法，因为这个变量是和函数息息相关的，而函数可能在多个不同的地方被调用，所以从调用者的角度来统计比较困难。</li>
</ul>
<p>C 语言中使用静态函数的好处：</p>
<p>静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。 </p>
<table>
<thead>
<tr>
<th align="center">存储类</th>
<th align="center">时期</th>
<th align="center">作用域</th>
<th align="center">链接</th>
<th align="center">声明方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">自动</td>
<td align="center">自动</td>
<td align="center">代码块</td>
<td align="center">空</td>
<td align="center">代码块内</td>
</tr>
<tr>
<td align="center">寄存器</td>
<td align="center">自动</td>
<td align="center">代码块</td>
<td align="center">空</td>
<td align="center">代码块内，使用关键字 register</td>
</tr>
<tr>
<td align="center">具有外部链接的静态</td>
<td align="center">静态</td>
<td align="center">文件</td>
<td align="center">外部</td>
<td align="center">所有函数之外</td>
</tr>
<tr>
<td align="center">具有内 部链接的静态</td>
<td align="center">静态</td>
<td align="center">文件</td>
<td align="center">内部</td>
<td align="center">所有函数之外 ，使用关键字 static</td>
</tr>
<tr>
<td align="center">空链接的静态</td>
<td align="center">静态</td>
<td align="center">代码块</td>
<td align="center">空</td>
<td align="center">代码块内，使用关键字 static</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">变量类型</th>
<th align="center">声明的位置</th>
<th align="center">是否存于堆栈</th>
<th align="center">作用域</th>
<th align="center">如果声明 为 static</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全局</td>
<td align="center">所有代码块之外</td>
<td align="center">否</td>
<td align="center">从声明处到文件尾</td>
<td align="center">不允许从其他源文件访问</td>
</tr>
<tr>
<td align="center">局部</td>
<td align="center">代码块起始处</td>
<td align="center">是</td>
<td align="center">整个代码块</td>
<td align="center">变量不存储于堆栈中，它的值在程序整个执行期一直保持</td>
</tr>
<tr>
<td align="center">形式参数</td>
<td align="center">函数头部</td>
<td align="center">是</td>
<td align="center">整个函数</td>
<td align="center">不允许</td>
</tr>
</tbody></table>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407011006722.png" alt="image.png"></p>
<h1 id="位的对齐"><a href="#位的对齐" class="headerlink" title="位的对齐"></a>位的对齐</h1><p>字节对齐：在 32 位操作系统中，大多数计算机体系结构要求数据按照特定的字节边界对齐。常见的对齐边界是 4 字节（32 位）或 8 字节（64 位）。这是为了优化内存访问和数据传输的效率。如果数据没有按照正确的字节对齐方式存储，可能会导致额外的开销和性能下降。</p>
<p>结构体成员对齐：在结构体中，结构体成员的对齐方式可能会影响整个结构体的对齐方式。编译器通常会自动对结构体成员进行对齐，以满足所使用的编译器和平台的要求。默认情况下，大多数编译器会使用<strong>最大对齐方式</strong>，即按照结构体中最大成员的字节大小进行对齐。</p>
<p>指令对齐：在代码中，指令的对齐方式也是重要的。大多数处理器要求指令按照特定的字节边界对齐。指令对齐可以提高指令的执行速度和整体性能。</p>
<p>对于字节对齐，编译器通常会自动处理，但也可以通过编译器的指令或属性进行手动控制。在 C 语言中，可以使用特定的编译指令来控制结构体成员的对齐方式，例如使用 <code>#pragma pack</code> 指令。</p>
<p>以下是一个示例，展示了如何使用 <code>#pragma pack</code> 指令来设置<strong>结构体成员的对齐方式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 1) <span class="comment">// 以1字节对齐方式压栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop) <span class="comment">// 弹出对齐方式</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Example</span> ex;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct: %zu\n&quot;</span>, <span class="built_in">sizeof</span>(ex)); <span class="comment">// 输出结构体的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，通过使用 <code>#pragma pack(push, 1) </code> 指令将对齐方式设置为 1 字节，然后定义了一个名为 <code>Example</code> 的结构体，包含了 <code>char</code>、<code>int</code> 和 <code>short</code> 类型的成员变量。最后使用 <code>#pragma pack(pop) </code> 指令将对齐方式还原为默认值。</p>
<p>在运行示例程序后，可以观察到结构体 <code>Example</code> 的大小可能会受到对齐方式的影响。如果不进行任何对齐操作，默认情况下编译器可能会根据平台和编译器的要求进行对齐，大小会大于 1 字节。</p>
<p>总结来说，在 32 位的操作系统中，位的使用和对齐操作是为了优化内存访问和数据传输的效率。字节对齐、结构体成员对齐和指令对齐是常见的对齐方式，可以通过编译器的指令或属性进行手动控制，以满足特定的需求和平台要求。</p>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>利用函数指针，通过区分不同设备的设备号，通过函数指针的方式去调用不同的接口，从而完成一套程序可以支持多种不同的设备，完成各设备的通信协议的匹配工作，</p>
<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符#通常称为字符串化的操作符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkstr(s) #s</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="built_in">mkstr</span>(I like C))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I like C&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作符-1"><a href="#操作符-1" class="headerlink" title="操作符"></a>操作符</h2><p>##可以把两个独立的字符串连接成一个字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SORT(X) sortFunction##X</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *array;</span><br><span class="line">	<span class="type">int</span> elements , element size;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SORT</span>(<span class="number">3</span>)(array , elements , element_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *array;</span><br><span class="line">	<span class="type">int</span> elements, element size;</span><br><span class="line">	<span class="built_in">sortFunction3</span>(array, elements,element size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调试宏定义"><a href="#调试宏定义" class="headerlink" title="调试宏定义"></a>调试宏定义</h2><p><strong>FILE</strong> 和 <strong>LINE</strong> 是 C&#x2F;C++ 编译器预定义的宏，用于获取当前源代码文件名和行号的信息。</p>
<p>__FILE__：它是一个字符串常量，表示当前源代码所在的文件名。编译器在编译过程中会将 <strong>FILE</strong> 替换为当前源代码文件的路径和名称。例如，如果你的源代码文件名是 “example.c”，那么 <strong>FILE</strong> 的值将是一个字符串常量 “example.c”。</p>
<p>__LINE__：它是一个整数常量，表示当前源代码的行号。编译器会将 <strong>LINE</strong> 替换为当前源代码行号的数值。例如，如果在源代码的第 10 行使用了 __LINE__，那么它的值将是整数常量 10。</p>
<p>这些宏通常在调试和错误处理过程中使用，它们可以帮助程序员定位错误或记录特定代码位置的信息。通过在代码中使用 <strong>FILE</strong> 和 <strong>LINE</strong> 宏，可以在程序中动态地获取和打印出错位置，或者用于调试输出。</p>
<p>以下是一个示例，展示了如何使用 <strong>FILE</strong> 和 <strong>LINE</strong> 宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error occurred in file: %s\n&quot;</span>, __FILE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error occurred at line: %d\n&quot;</span>, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">50</span>) &#123;</span><br><span class="line">        <span class="built_in">printLocation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述示例中，定义了一个函数 printLocation()，它使用了 <strong>FILE</strong> 和 <strong>LINE</strong> 宏来打印错误发生的文件名和行号信息。在 main() 函数中，通过一个简单的条件判断来模拟错误情况，当 x 大于 50 时，调用 printLocation() 函数。</p>
<p>运行示例程序，如果条件满足，将输出类似以下内容的错误信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Error occurred in file: example.c</span><br><span class="line">Error occurred at line: <span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>通过使用 <strong>FILE</strong> 和 <strong>LINE</strong> 宏，我们可以方便地了解错误发生的具体位置，有助于调试和排查问题。</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>位操作</title>
    <url>/2024/07/01/1-%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80-%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>尽管 <code>&amp;&amp;</code> 操作符的优先级较低，但它仍然会对两个关系表达式施加控制。<code>&amp;&amp;</code> 操作符的<strong>左操作数总是首先进行求值</strong></p>
<ul>
<li>如果它的值为真，然后紧接着对右操作数进行求值。</li>
<li>如果左操作数的值为假，那么右操作数便不再进行求值，因为整个表达式的值肯定是假的，右操作数的值已无关紧要。</li>
</ul>
<p>操作符 <code>||</code> 具有相同的特点，它首先对左操作数进行求值，如果它的值是真的，右操作数便不再求值，因为整个表达式的值此时已经确定。这个行为常常被称为短路求值（short-circuited evaluation）。</p>
<p>表达式的顺序必须确保正确。这点非常有用。下面这个例子在标准 Pascal 中是非法的：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( x &gt;= <span class="number">0</span> &amp;&amp; x &lt; MAX &amp;&amp; <span class="keyword">array</span>[x] == <span class="number">0</span>) ...</span><br></pre></td></tr></table></figure>

<p>在 C 中，这段代码首先检查 x 的值是否在数组下标的合法范围之内。如果不是，代码中的下标引用表达式便被忽略。由于 Pascal 将完整地对所有的子表达式进行求值，所以如果下标值错误，尽管程序已经费尽心思对下标值进行范围检查，但程序仍会由于无效的下标引用而导致失败。</p>
<p>警告：</p>
<p>位操作符常与逻辑操作符混淆，但它们不可互换的。它们之间的第 1 个区别是 <code>||</code> 和 <code>&amp;&amp;</code> 操作符具有短路性。 如果表达式的值取决于左操作数可决定，它就不再对右操作数进行求值。与之相反，<code>|</code> 和 <code>&amp;</code> 操作符两边的操作数都需要进行求值。</p>
<p>其次，逻辑操作符用于测试零值和非零值，而位操作符用于比较它们的的操作数中的对应的位。这里有一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( a &lt; b &amp;&amp; c &gt; d )...</span><br><span class="line"><span class="keyword">if</span>( a &lt; b &amp; c &gt; d )...</span><br></pre></td></tr></table></figure>

<p>因为关系操作符产生的表达式是 0，或是 1，所以这两条语句的结果是一样的。但是，如果 a 是 1 而 b 是 2，下一对语句就不会产生相同的结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( a &amp;&amp; b )...</span><br><span class="line"><span class="keyword">if</span>( a &amp; b )...</span><br></pre></td></tr></table></figure>

<p>因为 a 和 b 都是非零值，所以第 1 条语句的值为真，但第 2 条语句的值却是假，因为 a 和 b 的位模式中，没有一个位在两者中的值都是 1。</p>
<h1 id="设置结构体内位域"><a href="#设置结构体内位域" class="headerlink" title="设置结构体内位域"></a>设置结构体内位域</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> * INT32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT64 int *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> b:<span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span> d:<span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> e:<span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> <span class="type">node_t</span>));</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node_t</span> val;</span><br><span class="line">    val.b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, val.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体 node_t 包含五个成员：a、b、d、e 和 c。</p>
<ul>
<li><code>b:2</code>、<code>d:3</code> 和 <code>e:4</code> 是位域，分别占用 2 位、3 位和 4 位。</li>
<li><code>__attribute__((packed)) </code> 告诉编译器不要对该结构体进行内存对齐优化取消对齐填充，使其按定义的字节顺序紧凑存储。所以结构体的大小会是各个成员字节数和位域位数的总和。</li>
<li><code>char a</code> 和 <code>char c</code> 各占 1 字节。</li>
<li><code>char b:2</code>、<code>char d:3</code> 和 <code>char e:4</code> 共占 9 位，即 2 字节（因为位域不足一个字节，但会补齐到一个字节的最小单位）。总大小为 1 + 2 + 1 &#x3D; 4 字节。</li>
<li>所以，sizeof(struct node_t) 的输出是 4。val.b &#x3D; 5 的值会被截断到 2 位，所以 printf(“%d\n”, val.b); 的输出会是 1（因为 5 的二进制为 101，截断到 2 位为 01。</li>
</ul>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>内联函数</title>
    <url>/2024/07/01/1-%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>在 C 语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。为了解决这个问题，特别的引入了 inline 修饰符，表示为内联函数。</p>
<p>栈空间就是指放置程式的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因<strong>栈空间不足所造成的程式出错</strong>的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p>
<p>下面我们来看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义为 inline 即:内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">dbtest</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (i % <span class="number">2</span> &gt; <span class="number">0</span>) ? <span class="string">&quot;奇&quot;</span> : <span class="string">&quot;偶&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i:%d 奇偶性:%s /n&quot;</span>, i, <span class="built_in">dbtest</span>(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子就是标准的内联函数的用法，使用 <code>inline</code> 修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个 for 循环的内部任何调用 <code>dbtest(i)</code> 的地方都换成了 <code>(i%2&gt;0)?&quot;奇&quot;:&quot;偶&quot;</code> 这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。</p>
<p>其实这种有点类似咱们前面学习的动态库和静态库的问题，使 <code>dbtest</code> 函数中的代码直接被放到 <code>main</code> 函数中，执行 <code>for</code> 循环时，会不断调用这段代码，而不是不断地开辟一个函数栈。</p>
<h1 id="内联函数的编程风格"><a href="#内联函数的编程风格" class="headerlink" title="内联函数的编程风格"></a>内联函数的编程风格</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>关键字 <code>inline</code> 必须与函数定义体</strong>放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。</p>
<p>如下风格的函数 Foo 不能成为内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>; <span class="comment">// inline 仅与函数声明放在一起</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如下风格的函数 Foo 则成为内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">// inline 与函数定义体放在一起</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inline</code> 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>inline 只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句例如 while、switch，并且内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。</p>
<h1 id="慎用内联"><a href="#慎用内联" class="headerlink" title="慎用内联"></a>慎用内联</h1><p>内联能提高函数的执行效率，但是是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p>
<p>以下情况不宜使用内联：</p>
<ul>
<li>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</li>
<li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li>
</ul>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2024/07/16/1-%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>传统多任务操作系统中一个可以独立调度的任务（或称之为顺序执行流）是一个进程。每个程序加载到内存后只可以唯一地对应创建一个顺序执行流，即传统意义的进程。</p>
<p>每个进程的全部系统资源是私有的，如虚拟地址空间，文件描述符和信号处理等等。使用多进程实现多任务应用时存在如下问题：</p>
<ul>
<li>任务切换，即进程间上下文切换，系统开销比较大。（虚拟地址空间以及 task_struct 都需要切换）</li>
<li>多任务之间的协作比较麻烦，涉及进程间通讯。（因为不同的进程工作在不同的地址空间）</li>
</ul>
<p>所以，为了提高系统的性能，许多操作系统规范里引入了轻量级进程的概念，也被称为线程。</p>
<p>通常线程指的是<strong>共享相同地址空间的多个任务</strong>。线程最大的特点就是在同一个进程中创建的线程共享该进程的地址空间；但一个线程仍用 task_struct 来描述，线程和进程都参与统一的调度。所以，多线程的好处便体现出来：</p>
<ul>
<li>大大提高了任务切换的效率；因为各线程共享进程的地址空间，任务切换时只要切换 task_struct 即可；</li>
<li>线程间通信比较方便；因为在同一块地址空间，数据共享；</li>
</ul>
<p>当然，共享地址空间也会成为线程的缺点，因为共享地址空间，如果其中一个线程出现错误（比如段错误），整个线程组都会崩掉！</p>
<p>Linux 之所以称呼其线程为 LWP( Light Weight Process )，因为从内核实现的角度来说，它并没有为线程单独创建一个结构，而是继承了很多进程的设计：</p>
<ul>
<li>继承了进程的结构体定义 task_struct ；</li>
<li>没有专门定义线程 ID，复用了 PID；</li>
<li>更没有为线程定义特别的调度算法，而是沿用了原来对 task_struct 的调度算法。</li>
</ul>
<p>线程已经替代原来的进程称为调度的实际最小单位。</p>
<p>原来的进程概念可以看成是多个线程的容器，称之为线程组；即一个进程就是所有相关的线程构成的一个线程组。传统的进程等价于单线程进程。</p>
<p>每个线程组都有自己的标识符 tgid (数据类型为 pid_t )，其值等于该进程(线程组)中的第一个线程(group_leader)的 PID。</p>
<h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> *(* routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"># 函数参数</span></span><br><span class="line"><span class="function"><span class="meta"># thread ：创建的线程ID</span></span></span><br><span class="line"><span class="function"><span class="meta"># attr ：指定线程的属性，NULL表示使用缺省属性</span></span></span><br><span class="line"><span class="function"><span class="meta"># routine ：线程执行的函数</span></span></span><br><span class="line"><span class="function"><span class="meta"># arg ：传递给线程执行的函数的参数</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建成功返回 0，否则返回-1</li>
<li>routine 是回调函数（callback），函数类型由内核来决定，这里将地址传给内核；</li>
<li>函数并不是线程创建了就会执行，而是只有当其被调度到 cpu 上时才会被执行</li>
<li>arg 是线程执行函数的参数，，使用时需要先进行类型转换，才能使用；</li>
<li>如果 arg 参数不止一个，我们可以将其放入到结构体中，传入结构体指针；</li>
</ul>
<h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><p>和进程中的 exit() 、wait()一样，这里 pthread_join 与 pthread_exit 是工作在两个线程之中；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#以阻塞的方式等待thread指定的线程结束。</span><br><span class="line"><span class="built_in">pthread_join</span>(thread, [线程返回的参数]) </span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_exit</span>([线程返回的参数])</span><br></pre></td></tr></table></figure>

<h1 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h1><p>临界资源：某些资源来说，其在同一时间只能被一段机器指令序列所占用。这些一次只能被一段指令序列所占用的资源就是所谓的临界资源。</p>
<p>临界区：对于临界资源的访问，必须是互斥进行。也就是当临界资源被一个指令序列占用时，另一个需要访问相同临界资源的指令序列就不能被执行。指令序列不能执行的实际意思就是其所在的进程&#x2F;线程会被阻塞。所以我们定义程序内访问临界资源的代码序列被称为临界区。</p>
<p>互斥：是指同事只允许一个访问者对临界资源进行访问，具有唯一性和排它性。但互斥无法限制访问这个对资源的访问顺序，即访问时无序的。</p>
<p>同步：是指在互斥的基础上，通过其他机制实现访问者对资源的有序访问。</p>
<h2 id="线程间互斥"><a href="#线程间互斥" class="headerlink" title="线程间互斥"></a>线程间互斥</h2><p>引入互斥(mutual exlusion)锁的目的是用来保证共享数据的完整性。</p>
<p>互斥锁主要用来保护临界资源。每个临界资源都有一个互斥锁来保护，任何时刻最多只能有一个线程能访问该资源；线程必须先获得互斥锁才能访问临界资源，访问完资源后释放该锁。如果无法获得锁，线程会阻塞直到获得锁为止；</p>
<p>通常，我们在临界区前上锁，临界区后解锁；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化互斥锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">pthread_mutexattr_t</span> *attr )</span></span></span><br><span class="line"><span class="function"><span class="comment">//申请互斥锁</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span></span><br><span class="line"><span class="function"><span class="comment">//释放互斥锁</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步(synchronization) 指的是多个任务（线程）按照约定的顺序相互配合完成一件事情；线程间同步——P &#x2F; V 操作</p>
<p>信号量代表某一类资源，其值表示系统中该资源当前可用的数量。信号量是一个受保护的变量，只能通过三种操作来访问：</p>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化信号量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_int</span> <span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> pshared,<span class="type">unsigned</span> <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">函数参数</span></span><br><span class="line"><span class="function">sem：初始化的信号量</span></span><br><span class="line"><span class="function">pshared：信号量共享的范围（0：线程间使用 非0 ：进程间使用）</span></span><br><span class="line"><span class="function">value ：信号量初值</span></span><br><span class="line"><span class="function">函数返回值成功：0</span></span><br><span class="line"><span class="function">出错：-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>P 操作（申请资源）P（S）含义如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *sem)</span> <span class="comment">//P 操作</span></span></span><br><span class="line"><span class="function">函数参数 </span></span><br><span class="line"><span class="function">sem：信号量</span></span><br><span class="line"><span class="function">函数返回值成功：0</span></span><br><span class="line"><span class="function">出错：-1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(信号量的值大于 <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	请资源的任务继续运行；</span><br><span class="line">	信号量的值 减一；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	请资源的任务阻塞；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>V 操作（释放资源）V（S）含义如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span> <span class="comment">//V 操作</span></span></span><br><span class="line"><span class="function">函数参数</span></span><br><span class="line"><span class="function">sem：信号量</span></span><br><span class="line"><span class="function">函数返回值成功：0</span></span><br><span class="line"><span class="function">出错：-1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(没有任务在等待该资源)</span></span>&#123;</span><br><span class="line">	信号量的值 加一；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	唤醒第一个等待的任务，让其继续运行；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习笔记</title>
    <url>/2024/07/02/1-%E8%AF%AD%E8%A8%80-Python-Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Python 是一种面向对象的解释型计算机程序设计语言，可以处理系统运维、图形处理、数学处理、文本处理、数据库编程、网络编程、web 编程、多媒体应用、pymo 引擎、黑客编程、爬虫编写、机器学习、人工智能等等。</p>
<h1 id="基础入门（12-学时）"><a href="#基础入门（12-学时）" class="headerlink" title="基础入门（12 学时）"></a>基础入门（12 学时）</h1><h2 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h2><h3 id="Python-简介"><a href="#Python-简介" class="headerlink" title="Python 简介"></a>Python 简介</h3><h3 id="Python-安装"><a href="#Python-安装" class="headerlink" title="Python 安装"></a>Python 安装</h3><h3 id="语法格式与编码规范"><a href="#语法格式与编码规范" class="headerlink" title="语法格式与编码规范"></a>语法格式与编码规范</h3><h3 id="Python-包管理及其版本管理工具的使用"><a href="#Python-包管理及其版本管理工具的使用" class="headerlink" title="Python 包管理及其版本管理工具的使用"></a>Python 包管理及其版本管理工具的使用</h3><h2 id="类型与运算（包括容器以及容器的访问使用）"><a href="#类型与运算（包括容器以及容器的访问使用）" class="headerlink" title="类型与运算（包括容器以及容器的访问使用）"></a>类型与运算（包括容器以及容器的访问使用）</h2><h3 id="Python-的字符串"><a href="#Python-的字符串" class="headerlink" title="Python 的字符串"></a>Python 的字符串</h3><h3 id="List，set，Dict，tuple-等类型（包括访问、添加、删除等超作）"><a href="#List，set，Dict，tuple-等类型（包括访问、添加、删除等超作）" class="headerlink" title="List，set，Dict，tuple 等类型（包括访问、添加、删除等超作）"></a>List，set，Dict，tuple 等类型（包括访问、添加、删除等超作）</h3><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><h3 id="列表推倒"><a href="#列表推倒" class="headerlink" title="列表推倒"></a>列表推倒</h3><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h3 id="迭代器和解析"><a href="#迭代器和解析" class="headerlink" title="迭代器和解析"></a>迭代器和解析</h3><h2 id="语句与语法以及文件操作"><a href="#语句与语法以及文件操作" class="headerlink" title="语句与语法以及文件操作"></a>语句与语法以及文件操作</h2><h3 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h3><h3 id="运算符和基本运算（位运算）"><a href="#运算符和基本运算（位运算）" class="headerlink" title="运算符和基本运算（位运算）"></a>运算符和基本运算（位运算）</h3><h3 id="赋值、表达式以及输入输出"><a href="#赋值、表达式以及输入输出" class="headerlink" title="赋值、表达式以及输入输出"></a>赋值、表达式以及输入输出</h3><h3 id="If、for-以及-while"><a href="#If、for-以及-while" class="headerlink" title="If、for 以及 while"></a>If、for 以及 while</h3><h2 id="函数以及函数式编程入门"><a href="#函数以及函数式编程入门" class="headerlink" title="函数以及函数式编程入门"></a>函数以及函数式编程入门</h2><h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h3 id="参数与返回值（多返回值、默认参数等）"><a href="#参数与返回值（多返回值、默认参数等）" class="headerlink" title="参数与返回值（多返回值、默认参数等）"></a>参数与返回值（多返回值、默认参数等）</h3><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h3 id="匿名函数：lambda"><a href="#匿名函数：lambda" class="headerlink" title="匿名函数：lambda"></a>匿名函数：lambda</h3><h3 id="函数式编程工具：filter-和-reduce"><a href="#函数式编程工具：filter-和-reduce" class="headerlink" title="函数式编程工具：filter 和 reduce"></a>函数式编程工具：filter 和 reduce</h3><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文本文件、二进制文件读写"><a href="#文本文件、二进制文件读写" class="headerlink" title="文本文件、二进制文件读写"></a>文本文件、二进制文件读写</h3><h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><h2 id="模块与面向对象"><a href="#模块与面向对象" class="headerlink" title="模块与面向对象"></a>模块与面向对象</h2><h3 id="模块代码编写基础"><a href="#模块代码编写基础" class="headerlink" title="模块代码编写基础"></a>模块代码编写基础</h3><h3 id="类代码编写基础"><a href="#类代码编写基础" class="headerlink" title="类代码编写基础"></a>类代码编写基础</h3><h2 id="多线程、Re-正则表达式的使用"><a href="#多线程、Re-正则表达式的使用" class="headerlink" title="多线程、Re 正则表达式的使用"></a>多线程、Re 正则表达式的使用</h2><h3 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h3><h3 id="使用-Threading-模块创建线程"><a href="#使用-Threading-模块创建线程" class="headerlink" title="使用 Threading 模块创建线程"></a>使用 Threading 模块创建线程</h3><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h3 id="线程优先级队列（-Queue）"><a href="#线程优先级队列（-Queue）" class="headerlink" title="线程优先级队列（ Queue）"></a>线程优先级队列（ Queue）</h3><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="什么是-Socket"><a href="#什么是-Socket" class="headerlink" title="什么是 Socket?"></a>什么是 Socket?</h3><h3 id="requests-网络库的简介和使用"><a href="#requests-网络库的简介和使用" class="headerlink" title="requests 网络库的简介和使用"></a>requests 网络库的简介和使用</h3><h1 id="Python-实践（8-学时）"><a href="#Python-实践（8-学时）" class="headerlink" title="Python 实践（8 学时）"></a>Python 实践（8 学时）</h1><h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><h3 id="网络爬虫技术价值、简单的网络爬虫架构"><a href="#网络爬虫技术价值、简单的网络爬虫架构" class="headerlink" title="网络爬虫技术价值、简单的网络爬虫架构"></a>网络爬虫技术价值、简单的网络爬虫架构</h3><h3 id="URI-管理器及其实现方法"><a href="#URI-管理器及其实现方法" class="headerlink" title="URI 管理器及其实现方法"></a>URI 管理器及其实现方法</h3><h3 id="网页下载及其-urllib2、requests-的使用"><a href="#网页下载及其-urllib2、requests-的使用" class="headerlink" title="网页下载及其 urllib2、requests 的使用"></a>网页下载及其 urllib2、requests 的使用</h3><h3 id="网页解析器和-BeautifulSoup-模块"><a href="#网页解析器和-BeautifulSoup-模块" class="headerlink" title="网页解析器和 BeautifulSoup 模块"></a>网页解析器和 BeautifulSoup 模块</h3><h2 id="数据分析与机器学习库以及相关算法介绍"><a href="#数据分析与机器学习库以及相关算法介绍" class="headerlink" title="数据分析与机器学习库以及相关算法介绍"></a>数据分析与机器学习库以及相关算法介绍</h2><h3 id="数据分析库：Numpy-Scipy-Pandas"><a href="#数据分析库：Numpy-Scipy-Pandas" class="headerlink" title="数据分析库：Numpy&#x2F;Scipy&#x2F;Pandas"></a>数据分析库：Numpy&#x2F;Scipy&#x2F;Pandas</h3><h3 id="机器学习库：Scikit-Learn"><a href="#机器学习库：Scikit-Learn" class="headerlink" title="机器学习库：Scikit-Learn"></a>机器学习库：Scikit-Learn</h3><h3 id="数据可视化库：Matplotlib"><a href="#数据可视化库：Matplotlib" class="headerlink" title="数据可视化库：Matplotlib"></a>数据可视化库：Matplotlib</h3><h3 id="文本分析库：NLTK"><a href="#文本分析库：NLTK" class="headerlink" title="文本分析库：NLTK"></a>文本分析库：NLTK</h3><h3 id="网络分析库：igraph"><a href="#网络分析库：igraph" class="headerlink" title="网络分析库：igraph"></a>网络分析库：igraph</h3>]]></content>
      <categories>
        <category>1.语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python安装</title>
    <url>/2024/05/21/1-%E8%AF%AD%E8%A8%80-Python-Python%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><p>打开终端，使用以下命令更新软件包列表：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>安装编译 Python 3.10 所需的依赖项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev wget</span><br></pre></td></tr></table></figure>

<p>下载 Python 3.10 的源代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wget https:<span class="comment">//www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz</span></span><br></pre></td></tr></table></figure>

<p>解压源代码并进入解压后的目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xf Python-3.10.0.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.10.0</span><br></pre></td></tr></table></figure>

<p>配置 Python 3.10 的编译选项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --enable-optimizations</span><br></pre></td></tr></table></figure>

<p>编译并安装 Python 3.10：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make -j 8</span><br><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure>

<p>确认 Python 3.10 是否安装成功：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">python3<span class="number">.10</span> --version</span><br></pre></td></tr></table></figure>

<p>如果输出了 Python 3.10 的版本号，则说明安装成功。</p>
<p>安装时网络问题见 <a href="source/_posts/1.%E8%AF%AD%E8%A8%80/Python/pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.md">pip下载网络问题</a></p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python返回前端请求IP地址</title>
    <url>/2024/05/22/1-%E8%AF%AD%E8%A8%80-Python-Python%E8%BF%94%E5%9B%9E%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82IP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="前端-js-代码"><a href="#前端-js-代码" class="headerlink" title="前端 js 代码"></a>前端 js 代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="title function_">fetch</span>(<span class="string">&#x27;/get_ip&#x27;</span>,</span><br><span class="line">    &#123;<span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,<span class="attr">headers</span>: &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;,&#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;ip_addr&quot;</span>).<span class="property">innerHTML</span>=data&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>pip下载网络问题</title>
    <url>/2024/05/21/1-%E8%AF%AD%E8%A8%80-Python-pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在使用 Python 安装包工具 pip 时经常会出现下载很慢的情况，这其中有很大一部分原因和 pip 的源有关，在我们安装 python 后，通常 python 解释器自带 pip 这个工具，但是这里 pip 是设置的默认源，也就是官方源：<code>https://pypi.org/simple</code>，这个源在国内的下载速度是很慢的，所以我们为了提高包的下载速度我们可以通过换源来实现。</p>
<h1 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>可以在使用 pip 的时候加参数 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple markdown</span><br></pre></td></tr></table></figure>

<p>这样就会从清华这边的镜像去安装 markdown。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 清华源</span><br><span class="line">pip install markdown -i https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"># 阿里源</span><br><span class="line">pip install markdown -i https:<span class="comment">//mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"># 腾讯源</span><br><span class="line">pip install markdown -i http:<span class="comment">//mirrors.cloud.tencent.com/pypi/simple</span></span><br><span class="line"># 豆瓣源</span><br><span class="line">pip install markdown -i http:<span class="comment">//pypi.douban.com/simple/</span></span><br><span class="line"># 中国科学技术大学</span><br><span class="line">pip install markdown -i http:<span class="comment">//pypi.mirrors.ustc.edu.cn/simple/</span></span><br></pre></td></tr></table></figure>

<h2 id="报错未添加信任源"><a href="#报错未添加信任源" class="headerlink" title="报错未添加信任源"></a>报错未添加信任源</h2><p><code>pip install beautifulsoup4 --trusted-host mirrors.aliyun.com</code></p>
<h1 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 清华源</span><br><span class="line">pip config set global.index-url https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"># 阿里源</span><br><span class="line">pip config set global.index-url https:<span class="comment">//mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"># 腾讯源</span><br><span class="line">pip config set global.index-url http:<span class="comment">//mirrors.cloud.tencent.com/pypi/simple</span></span><br><span class="line"># 豆瓣源</span><br><span class="line">pip config set global.index-url http:<span class="comment">//pypi.douban.com/simple/</span></span><br><span class="line"># 换回默认源</span><br><span class="line">pip config unset global.index-url</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>Linux 下 <code>~/.pip/pip.conf</code></li>
<li>Windows 下 &#96;&#96;%HOMEPATH%\pip\pip.ini&#96;<br>内容如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br></pre></td></tr></table></figure>

<h2 id="报错未添加信任源-1"><a href="#报错未添加信任源-1" class="headerlink" title="报错未添加信任源"></a>报错未添加信任源</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[install]</span><br><span class="line">trusted-host=pypi.douban.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>pythonWeb部署方案</title>
    <url>/2024/05/22/1-%E8%AF%AD%E8%A8%80-Python-pythonWeb%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><p>首先，确认系统安装的 Python 版本是 3.7.x：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ python3 --version</span><br><span class="line">Python <span class="number">3.7</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>然后，用 <code>pip</code> 安装开发 Web App 需要的第三方库：</p>
<p>异步框架 aiohttp：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$pip3 install aiohttp</span><br></pre></td></tr></table></figure>

<p>前端模板引擎 jinja2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ pip3 install jinja2</span><br></pre></td></tr></table></figure>

<p>MySQL 5.x 数据库，从 <a href="http://dev.mysql.com/downloads/mysql/5.6.html">官方网站</a> 下载并安装，安装完毕后，请务必牢记 root 口令。为避免遗忘口令，建议直接把 root 口令设置为 <code>password</code>；</p>
<p>MySQL 的 Python 异步驱动程序 aiomysql：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ pip3 install aiomysql</span><br></pre></td></tr></table></figure>

<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>选择一个工作目录，然后，我们建立如下的目录结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">awesome-python3-webapp/  &lt;-- 根目录</span><br><span class="line">|</span><br><span class="line">+- backup/               &lt;-- 备份目录</span><br><span class="line">|</span><br><span class="line">+- conf/                 &lt;-- 配置文件</span><br><span class="line">|</span><br><span class="line">+- dist/                 &lt;-- 打包目录</span><br><span class="line">|</span><br><span class="line">+- www/                  &lt;-- Web目录，存放.py文件</span><br><span class="line">|  |</span><br><span class="line">|  +- <span class="type">static</span>/            &lt;-- 存放静态文件</span><br><span class="line">|  |</span><br><span class="line">|  +- templates/         &lt;-- 存放模板文件</span><br><span class="line">|</span><br><span class="line">+- ios/                  &lt;-- 存放iOS App工程</span><br><span class="line">|</span><br><span class="line">+- LICENSE               &lt;-- 代码LICENSE</span><br></pre></td></tr></table></figure>

<p>创建好项目的目录结构后，建议同时建立 git 仓库并同步至 GitHub，保证代码修改的安全。</p>
<h3 id="Web-骨架"><a href="#Web-骨架" class="headerlink" title="Web 骨架"></a>Web 骨架</h3><p>由于我们的 Web App 建立在 asyncio 的基础上，因此用 aiohttp 写一个基本的 <code>app.py</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging; logging.<span class="built_in">basicConfig</span>(level=logging.INFO)</span><br><span class="line"><span class="keyword">import</span> asyncio, os, json, <span class="function">time</span></span><br><span class="line"><span class="function">from datetime <span class="keyword">import</span> datetime</span></span><br><span class="line"><span class="function">from aiohttp <span class="keyword">import</span> web</span></span><br><span class="line"><span class="function">def <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="function">    return web.Response(body=</span>b<span class="number">&#x27;</span>&lt;h1&gt;Awesome&lt;/h1&gt;<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">@asyncio.coroutine</span></span><br><span class="line"><span class="string">def init(loop):</span></span><br><span class="line"><span class="string">    app = web.Application(loop=loop)</span></span><br><span class="line"><span class="string">    app.router.add_route(&#x27;</span>GET<span class="number">&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, index)</span><br><span class="line">    srv = yield from loop.<span class="built_in">create_server</span>(app.<span class="built_in">make_handler</span>(), <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9000</span>)</span><br><span class="line">    logging.<span class="built_in">info</span>(<span class="string">&#x27;server started at http://127.0.0.1:9000...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> srv</span><br><span class="line">loop = asyncio.<span class="built_in">get_event_loop</span>()</span><br><span class="line">loop.<span class="built_in">run_until_complete</span>(<span class="built_in">init</span>(loop))</span><br><span class="line">loop.<span class="built_in">run_forever</span>()</span><br></pre></td></tr></table></figure>

<p>运行 <code>python app.py</code>，Web App 将在 <code>9000</code> 端口监听 HTTP 请求，并且对首页 <code>/</code> 进行响应：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ python3 app.py</span><br><span class="line">INFO:root:server started at http:<span class="comment">//127.0.0.1:9000...</span></span><br></pre></td></tr></table></figure>

<p>这里我们简单地返回一个 <code>Awesome</code> 字符串，在浏览器中可以看到效果</p>
<p>这说明我们的 Web App 骨架已经搭好了，可以进一步往里面添加更多的东西。</p>
<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM 全称是：Object Relational Mapping(对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录。</p>
<p>在一个 Web App 中，所有数据，包括用户信息、发布的日志、评论等，都存储在数据库中。在 <code>awesome-python3-webapp</code> 中，我们选择 MySQL 作为数据库。</p>
<p>Web App 里面有很多地方都要访问数据库。访问数据库需要创建数据库连接、游标对象，然后执行 SQL 语句，最后处理异常，清理资源。这些访问数据库的代码如果分散到各个函数中，势必无法维护，也不利于代码复用。</p>
<p>所以，我们要首先把常用的 SELECT、INSERT、UPDATE 和 DELETE 操作用函数封装起来。</p>
<p>由于 Web 框架使用了基于 asyncio 的 aiohttp，这是基于协程的异步模型。在协程中，不能调用普通的同步 IO 操作，因为所有用户都是由一个线程服务的，协程的执行速度必须非常快，才能处理大量用户的请求。而耗时的 IO 操作不能在协程中以同步的方式调用，否则，等待一个 IO 操作时，系统无法响应任何其他用户。</p>
<p>这就是异步编程的一个原则：一旦决定使用异步，则系统每一层都必须是异步，“开弓没有回头箭”。</p>
<p>幸运的是 <code>aiomysql</code> 为 MySQL 数据库提供了异步 IO 的驱动。</p>
<h3 id="创建连接池"><a href="#创建连接池" class="headerlink" title="创建连接池"></a>创建连接池</h3><p>我们需要创建一个全局的连接池，每个 HTTP 请求都可以从连接池中直接获取数据库连接。使用连接池的好处是不必频繁地打开和关闭数据库连接，而是能复用就尽量复用。</p>
<p>连接池由全局变量 <code>__pool</code> 存储，缺省情况下将编码设置为 <code>utf8</code>，自动提交事务：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@asyncio.<span class="function">coroutine</span></span><br><span class="line"><span class="function">def <span class="title">create_pool</span><span class="params">(loop, **kw)</span>:</span></span><br><span class="line"><span class="function">    logging.info(<span class="string">&#x27;create database connection pool...&#x27;</span>)</span></span><br><span class="line"><span class="function">    global __pool</span></span><br><span class="line"><span class="function">    __pool =</span> yield from aiomysql.<span class="built_in">create_pool</span>(</span><br><span class="line">        host=kw.<span class="built_in">get</span>(<span class="string">&#x27;host&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>),</span><br><span class="line">        port=kw.<span class="built_in">get</span>(<span class="string">&#x27;port&#x27;</span>, <span class="number">3306</span>),</span><br><span class="line">        user=kw[<span class="string">&#x27;user&#x27;</span>],</span><br><span class="line">        password=kw[<span class="string">&#x27;password&#x27;</span>],</span><br><span class="line">        db=kw[<span class="string">&#x27;db&#x27;</span>],</span><br><span class="line">        charset=kw.<span class="built_in">get</span>(<span class="string">&#x27;charset&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>),</span><br><span class="line">        autocommit=kw.<span class="built_in">get</span>(<span class="string">&#x27;autocommit&#x27;</span>, True),</span><br><span class="line">        maxsize=kw.<span class="built_in">get</span>(<span class="string">&#x27;maxsize&#x27;</span>, <span class="number">10</span>),</span><br><span class="line">        minsize=kw.<span class="built_in">get</span>(<span class="string">&#x27;minsize&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">        loop=loop</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>要执行 SELECT 语句，我们用 <code>select</code> 函数执行，需要传入 SQL 语句和 SQL 参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@asyncio.<span class="function">coroutine</span></span><br><span class="line"><span class="function">def <span class="title">select</span><span class="params">(sql, args, size=None)</span>:</span></span><br><span class="line"><span class="function">    log(sql, args)</span></span><br><span class="line"><span class="function">    global __pool</span></span><br><span class="line"><span class="function">    with (yield from __pool) as conn:</span></span><br><span class="line"><span class="function">        cur =</span> yield from conn.<span class="built_in">cursor</span>(aiomysql.DictCursor)</span><br><span class="line">        yield from cur.<span class="built_in">execute</span>(sql.<span class="built_in">replace</span>(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;%s&#x27;</span>), args <span class="built_in">or</span> ())</span><br><span class="line">        <span class="keyword">if</span> size:</span><br><span class="line">            rs = yield from cur.<span class="built_in">fetchmany</span>(size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rs = yield from cur.<span class="built_in">fetchall</span>()</span><br><span class="line">        yield from cur.<span class="built_in">close</span>()</span><br><span class="line">        logging.<span class="built_in">info</span>(<span class="string">&#x27;rows returned: %s&#x27;</span> % <span class="built_in">len</span>(rs))</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>

<p>SQL 语句的占位符是 <code>?</code>，而 MySQL 的占位符是 <code>%s</code>，<code>select()</code> 函数在内部自动替换。注意要始终坚持使用带参数的 SQL，而不是自己拼接 SQL 字符串，这样可以防止 SQL 注入攻击。</p>
<p>注意到 <code>yield from</code> 将调用一个子协程（也就是在一个协程中调用另一个协程）并直接获得子协程的返回结果。</p>
<p>如果传入 <code>size</code> 参数，就通过 <code>fetchmany()</code> 获取最多指定数量的记录，否则，通过 <code>fetchall()</code> 获取所有记录。</p>
<h3 id="Insert-Update-Delete"><a href="#Insert-Update-Delete" class="headerlink" title="Insert, Update, Delete"></a>Insert, Update, Delete</h3><p>要执行 INSERT、UPDATE、DELETE 语句，可以定义一个通用的 <code>execute()</code> 函数，因为这 3 种 SQL 的执行都需要相同的参数，以及返回一个整数表示影响的行数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@asyncio.<span class="function">coroutine</span></span><br><span class="line"><span class="function">def <span class="title">execute</span><span class="params">(sql, args)</span>:</span></span><br><span class="line"><span class="function">    log(sql)</span></span><br><span class="line"><span class="function">    with (yield from __pool) as conn:</span></span><br><span class="line"><span class="function">        try:</span></span><br><span class="line"><span class="function">            cur =</span> yield from conn.<span class="built_in">cursor</span>()</span><br><span class="line">            yield from cur.<span class="built_in">execute</span>(sql.<span class="built_in">replace</span>(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;%s&#x27;</span>), args)</span><br><span class="line">            affected = cur.rowcount</span><br><span class="line">            yield from cur.<span class="built_in">close</span>()</span><br><span class="line">        except BaseException as e:</span><br><span class="line">            raise</span><br><span class="line">        <span class="keyword">return</span> affected</span><br></pre></td></tr></table></figure>

<p><code>execute()</code> 函数和 <code>select()</code> 函数所不同的是，cursor 对象不返回结果集，而是通过 <code>rowcount</code> 返回结果数。</p>
<h3 id="ORM-1"><a href="#ORM-1" class="headerlink" title="ORM"></a>ORM</h3><p>有了基本的 <code>select()</code> 和 <code>execute()</code> 函数，我们就可以开始编写一个简单的 ORM 了。</p>
<p>设计 ORM 需要从上层调用者角度来设计。</p>
<p>我们先考虑如何定义一个 <code>User</code> 对象，然后把数据库表 <code>users</code> 和它关联起来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">from orm <span class="keyword">import</span> Model, StringField, <span class="function">IntegerField</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line"><span class="function">    __table__ =</span> <span class="string">&#x27;users&#x27;</span></span><br><span class="line">    id = <span class="built_in">IntegerField</span>(primary_key=True)</span><br><span class="line">    name = <span class="built_in">StringField</span>()</span><br></pre></td></tr></table></figure>

<p>注意到定义在 <code>User</code> 类中的 <code>__table__</code>、<code>id</code> 和 <code>name</code> 是类的属性，不是实例的属性。所以，在类级别上定义的属性用来描述 <code>User</code> 对象和表的映射关系，而实例属性必须通过 <code>__init__()</code> 方法去初始化，所以两者互不干扰：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 创建实例:</span><br><span class="line">user = <span class="built_in">User</span>(id=<span class="number">123</span>, name=<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line"># 存入数据库:</span><br><span class="line">user.<span class="built_in">insert</span>()</span><br><span class="line"># 查询所有User对象:</span><br><span class="line">users = User.<span class="built_in">findAll</span>()</span><br></pre></td></tr></table></figure>

<h3 id="定义-Model"><a href="#定义-Model" class="headerlink" title="定义 Model"></a>定义 Model</h3><p>首先要定义的是所有 ORM 映射的基类 <code>Model</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict, metaclass=ModelMetaclass)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self, **kw):</span></span><br><span class="line"><span class="function">        super(Model, self).__init__(**kw)</span></span><br><span class="line"><span class="function">    def __getattr__(self, key):</span></span><br><span class="line"><span class="function">        try:</span></span><br><span class="line"><span class="function">            return self[key]</span></span><br><span class="line"><span class="function">        except KeyError:</span></span><br><span class="line"><span class="function">            raise AttributeError(r<span class="string">&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)</span></span><br><span class="line"><span class="function">    def __setattr__(self, key, value):</span></span><br><span class="line"><span class="function">        self[key] =</span> <span class="function">value</span></span><br><span class="line"><span class="function">    def <span class="title">getValue</span><span class="params">(self, key)</span>:</span></span><br><span class="line"><span class="function">        return getattr(self, key, None)</span></span><br><span class="line"><span class="function">    def getValueOrDefault(self, key):</span></span><br><span class="line"><span class="function">        value =</span> <span class="built_in">getattr</span>(self, key, None)</span><br><span class="line">        <span class="keyword">if</span> value is None:</span><br><span class="line">            field = self.__mappings__[key]</span><br><span class="line">            <span class="keyword">if</span> field.<span class="keyword">default</span> is <span class="keyword">not</span> None:</span><br><span class="line">                value = field.<span class="built_in">default</span>() <span class="keyword">if</span> <span class="built_in">callable</span>(field.<span class="keyword">default</span>) <span class="keyword">else</span> field.<span class="keyword">default</span></span><br><span class="line">                logging.<span class="built_in">debug</span>(<span class="string">&#x27;using default value for %s: %s&#x27;</span> % (key, <span class="built_in">str</span>(value)))</span><br><span class="line">                <span class="built_in">setattr</span>(self, key, value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<p><code>Model</code> 从 <code>dict</code> 继承，所以具备所有 <code>dict</code> 的功能，同时又实现了特殊方法 <code>__getattr__()</code> 和 <code>__setattr__()</code>，因此又可以像引用普通字段那样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; user[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line"><span class="number">123</span></span><br><span class="line">&gt;&gt;&gt; user.id</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>以及 <code>Field</code> 和各种 <code>Field</code> 子类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self, name, column_type, primary_key, default):</span></span><br><span class="line"><span class="function">        self.name =</span> name</span><br><span class="line">        self.column_type = column_type</span><br><span class="line">        self.primary_key = primary_key</span><br><span class="line">        self.<span class="keyword">default</span> = <span class="keyword">default</span></span><br><span class="line">    def __str__(self):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;%s, %s:%s&gt;&#x27;</span> % (self.__class__.__name__, self.column_type, self.name)</span><br></pre></td></tr></table></figure>

<p>映射 <code>varchar</code> 的 <code>StringField</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self, name=</span>None, primary_key=False, <span class="keyword">default</span>=None, ddl=<span class="string">&#x27;varchar(100)&#x27;</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, ddl, primary_key, <span class="keyword">default</span>)</span><br></pre></td></tr></table></figure>

<p>注意到 <code>Model</code> 只是一个基类，如何将具体的子类如 <code>User</code> 的映射信息读取出来呢？答案就是通过 metaclass：<code>ModelMetaclass</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">ModelMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="function">    def __new__(cls, name, bases, attrs):</span></span><br><span class="line"><span class="function">        # 排除Model类本身:</span></span><br><span class="line"><span class="function">        if name=</span>=<span class="string">&#x27;Model&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line">        # 获取table名称:</span><br><span class="line">        tableName = attrs.<span class="built_in">get</span>(<span class="string">&#x27;__table__&#x27;</span>, None) <span class="keyword">or</span> name</span><br><span class="line">        logging.<span class="built_in">info</span>(<span class="string">&#x27;found model: %s (table: %s)&#x27;</span> % (name, tableName))</span><br><span class="line">        # 获取所有的Field和主键名:</span><br><span class="line">        mappings = <span class="built_in">dict</span>()</span><br><span class="line">        fields = []</span><br><span class="line">        primaryKey = None</span><br><span class="line">        <span class="keyword">for</span> k, v in attrs.<span class="built_in">items</span>():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, Field):</span><br><span class="line">                logging.<span class="built_in">info</span>(<span class="string">&#x27;  found mapping: %s ==&gt; %s&#x27;</span> % (k, v))</span><br><span class="line">                mappings[k] = v</span><br><span class="line">                <span class="keyword">if</span> v.primary_key:</span><br><span class="line">                    # 找到主键:</span><br><span class="line">                    <span class="keyword">if</span> primaryKey:</span><br><span class="line">                        raise <span class="built_in">RuntimeError</span>(<span class="string">&#x27;Duplicate primary key for field: %s&#x27;</span> % k)</span><br><span class="line">                    primaryKey = k</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    fields.<span class="built_in">append</span>(k)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> primaryKey:</span><br><span class="line">            raise <span class="built_in">RuntimeError</span>(<span class="string">&#x27;Primary key not found.&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> k in mappings.<span class="built_in">keys</span>():</span><br><span class="line">            attrs.<span class="built_in">pop</span>(k)</span><br><span class="line">        escaped_fields = <span class="built_in">list</span>(<span class="built_in">map</span>(lambda f: <span class="string">&#x27;`%s`&#x27;</span> % f, fields))</span><br><span class="line">        attrs[<span class="string">&#x27;__mappings__&#x27;</span>] = mappings # 保存属性和列的映射关系</span><br><span class="line">        attrs[<span class="string">&#x27;__table__&#x27;</span>] = tableName</span><br><span class="line">        attrs[<span class="string">&#x27;__primary_key__&#x27;</span>] = primaryKey # 主键属性名</span><br><span class="line">        attrs[<span class="string">&#x27;__fields__&#x27;</span>] = fields # 除主键外的属性名</span><br><span class="line">        # 构造默认的SELECT, INSERT, UPDATE和DELETE语句:</span><br><span class="line">        attrs[<span class="string">&#x27;__select__&#x27;</span>] = <span class="string">&#x27;select `%s`, %s from `%s`&#x27;</span> % (primaryKey, <span class="string">&#x27;, &#x27;</span>.<span class="built_in">join</span>(escaped_fields), tableName)</span><br><span class="line">        attrs[<span class="string">&#x27;__insert__&#x27;</span>] = <span class="string">&#x27;insert into `%s` (%s, `%s`) values (%s)&#x27;</span> % (tableName, <span class="string">&#x27;, &#x27;</span>.<span class="built_in">join</span>(escaped_fields), primaryKey, <span class="built_in">create_args_string</span>(<span class="built_in">len</span>(escaped_fields) + <span class="number">1</span>))</span><br><span class="line">        attrs[<span class="string">&#x27;__update__&#x27;</span>] = <span class="string">&#x27;update `%s` set %s where `%s`=?&#x27;</span> % (tableName, <span class="string">&#x27;, &#x27;</span>.<span class="built_in">join</span>(<span class="built_in">map</span>(lambda f: <span class="string">&#x27;`%s`=?&#x27;</span> % (mappings.<span class="built_in">get</span>(f).name <span class="keyword">or</span> f), fields)), primaryKey)</span><br><span class="line">        attrs[<span class="string">&#x27;__delete__&#x27;</span>] = <span class="string">&#x27;delete from `%s` where `%s`=?&#x27;</span> % (tableName, primaryKey)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br></pre></td></tr></table></figure>

<p>这样，任何继承自 Model 的类（比如 User），会自动通过 ModelMetaclass 扫描映射关系，并存储到自身的类属性如 <code>__table__</code>、<code>__mappings__</code> 中。</p>
<p>然后，我们往 Model 类添加 class 方法，就可以让所有子类调用 class 方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">    @classmethod</span></span><br><span class="line"><span class="function">    @asyncio.coroutine</span></span><br><span class="line"><span class="function">    def find(cls, pk):</span></span><br><span class="line"><span class="function">        <span class="string">&#x27; find object by primary key. &#x27;</span></span></span><br><span class="line"><span class="function">        rs =</span> <span class="function">yield from <span class="title">select</span><span class="params">(<span class="string">&#x27;%s where `%s`=?&#x27;</span> % (cls.__select__, cls.__primary_key__), [pk], <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">len</span><span class="params">(rs)</span> </span>== <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cls</span>(**rs[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>User 类现在就可以通过类方法实现主键查找：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">user = yield from User.<span class="built_in">find</span>(<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>往 Model 类添加实例方法，就可以让所有子类调用实例方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">    @asyncio.coroutine</span></span><br><span class="line"><span class="function">    def save(self):</span></span><br><span class="line"><span class="function">        args =</span> <span class="built_in">list</span>(<span class="built_in">map</span>(self.getValueOrDefault, self.__fields__))</span><br><span class="line">        args.<span class="built_in">append</span>(self.<span class="built_in">getValueOrDefault</span>(self.__primary_key__))</span><br><span class="line">        rows = yield from <span class="built_in">execute</span>(self.__insert__, args)</span><br><span class="line">        <span class="keyword">if</span> rows != <span class="number">1</span>:</span><br><span class="line">            logging.<span class="built_in">warn</span>(<span class="string">&#x27;failed to insert record: affected rows: %s&#x27;</span> % rows)</span><br></pre></td></tr></table></figure>

<p>这样，就可以把一个 User 实例存入数据库：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">user = <span class="built_in">User</span>(id=<span class="number">123</span>, name=<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line">yield from user.<span class="built_in">save</span>()</span><br></pre></td></tr></table></figure>

<p>最后一步是完善 ORM，对于查找，我们可以实现以下方法：</p>
<ul>
<li>findAll() - 根据 WHERE 条件查找；</li>
<li>findNumber() - 根据 WHERE 条件查找，但返回的是整数，适用于 <code>select count(*)</code> 类型的 SQL。<br>以及 <code>update()</code> 和 <code>remove()</code> 方法。<br>所有这些方法都必须用 <code>@asyncio.coroutine</code> 装饰，变成一个协程。<br>调用时需要特别注意：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">user.<span class="built_in">save</span>()</span><br></pre></td></tr></table></figure>

<p>没有任何效果，因为调用 <code>save()</code> 仅仅是创建了一个协程，并没有执行它。一定要用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">yield from user.<span class="built_in">save</span>()</span><br></pre></td></tr></table></figure>

<p>才真正执行了 INSERT 操作。</p>
<h3 id="编写-Model"><a href="#编写-Model" class="headerlink" title="编写 Model"></a>编写 Model</h3><p>有了 ORM，我们就可以把 Web App 需要的 3 个表用 <code>Model</code> 表示出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, uuid</span><br><span class="line">from orm <span class="keyword">import</span> Model, StringField, BooleanField, FloatField, <span class="function">TextField</span></span><br><span class="line"><span class="function">def <span class="title">next_id</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    return <span class="string">&#x27;%015d%s000&#x27;</span> % (int(time.time() * <span class="number">1000</span>), uuid.uuid4().hex)</span></span><br><span class="line"><span class="function">class User(Model):</span></span><br><span class="line"><span class="function">    __table__ =</span> <span class="string">&#x27;users&#x27;</span></span><br><span class="line">    id = <span class="built_in">StringField</span>(primary_key=True, <span class="keyword">default</span>=next_id, ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    email = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    passwd = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    admin = <span class="built_in">BooleanField</span>()</span><br><span class="line">    name = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    image = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(500)&#x27;</span>)</span><br><span class="line">    created_at = <span class="built_in">FloatField</span>(<span class="keyword">default</span>=time.time)</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">Blog</span>(Model):</span><br><span class="line">    __table__ = <span class="string">&#x27;blogs&#x27;</span></span><br><span class="line">    id = <span class="built_in">StringField</span>(primary_key=True, <span class="keyword">default</span>=next_id, ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    user_id = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    user_name = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    user_image = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(500)&#x27;</span>)</span><br><span class="line">    name = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    summary = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(200)&#x27;</span>)</span><br><span class="line">    content = <span class="built_in">TextField</span>()</span><br><span class="line">    created_at = <span class="built_in">FloatField</span>(<span class="keyword">default</span>=time.time)</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">Comment</span>(Model):</span><br><span class="line">    __table__ = <span class="string">&#x27;comments&#x27;</span></span><br><span class="line">    id = <span class="built_in">StringField</span>(primary_key=True, <span class="keyword">default</span>=next_id, ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    blog_id = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    user_id = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    user_name = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(50)&#x27;</span>)</span><br><span class="line">    user_image = <span class="built_in">StringField</span>(ddl=<span class="string">&#x27;varchar(500)&#x27;</span>)</span><br><span class="line">    content = <span class="built_in">TextField</span>()</span><br><span class="line">    created_at = <span class="built_in">FloatField</span>(<span class="keyword">default</span>=time.time)</span><br></pre></td></tr></table></figure>

<p>在编写 ORM 时，给一个 Field 增加一个 <code>default</code> 参数可以让 ORM 自己填入缺省值，非常方便。并且，缺省值可以作为函数对象传入，在调用 <code>save()</code> 时自动计算。</p>
<p>例如，主键 <code>id</code> 的缺省值是函数 <code>next_id</code>，创建时间 <code>created_at</code> 的缺省值是函数 <code>time.time</code>，可以自动设置当前日期和时间。</p>
<p>日期和时间用 <code>float</code> 类型存储在数据库中，而不是 <code>datetime</code> 类型，这么做的好处是不必关心数据库的时区以及时区转换问题，排序非常简单，显示的时候，只需要做一个 <code>float</code> 到 <code>str</code> 的转换，也非常容易。</p>
<h3 id="初始化数据库表"><a href="#初始化数据库表" class="headerlink" title="初始化数据库表"></a>初始化数据库表</h3><p>如果表的数量很少，可以手写创建表的 SQL 脚本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-- schema.sql</span><br><span class="line">drop database <span class="keyword">if</span> exists awesome;</span><br><span class="line">create database awesome;</span><br><span class="line">use awesome;</span><br><span class="line">grant select, insert, update, <span class="keyword">delete</span> on awesome.* to <span class="string">&#x27;www-data&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;www-data&#x27;</span>;</span><br><span class="line"><span class="function">create table <span class="title">users</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    `id` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `email` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `passwd` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `admin` <span class="type">bool</span> <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `name` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `image` varchar(<span class="number">500</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `created_at` real <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    unique key `idx_email` (`email`),</span></span></span><br><span class="line"><span class="params"><span class="function">    key `idx_created_at` (`created_at`),</span></span></span><br><span class="line"><span class="params"><span class="function">    primary key (`id`)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> engine</span>=innodb <span class="keyword">default</span> charset=utf8;</span><br><span class="line"><span class="function">create table <span class="title">blogs</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    `id` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `user_id` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `user_name` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `user_image` varchar(<span class="number">500</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `name` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `summary` varchar(<span class="number">200</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `content` mediumtext <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `created_at` real <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    key `idx_created_at` (`created_at`),</span></span></span><br><span class="line"><span class="params"><span class="function">    primary key (`id`)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> engine</span>=innodb <span class="keyword">default</span> charset=utf8;</span><br><span class="line"><span class="function">create table <span class="title">comments</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    `id` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `blog_id` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `user_id` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `user_name` varchar(<span class="number">50</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `user_image` varchar(<span class="number">500</span>) <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `content` mediumtext <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    `created_at` real <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">    key `idx_created_at` (`created_at`),</span></span></span><br><span class="line"><span class="params"><span class="function">    primary key (`id`)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> engine</span>=innodb <span class="keyword">default</span> charset=utf8;</span><br></pre></td></tr></table></figure>

<p>如果表的数量很多，可以从 <code>Model</code> 对象直接通过脚本自动生成 SQL 脚本，使用更简单。</p>
<p>把 SQL 脚本放到 MySQL 命令行里执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p &lt; schema.sql</span><br></pre></td></tr></table></figure>

<p>我们就完成了数据库表的初始化。</p>
<h3 id="编写数据访问代码"><a href="#编写数据访问代码" class="headerlink" title="编写数据访问代码"></a>编写数据访问代码</h3><p>接下来，就可以真正开始编写代码操作对象了。比如，对于 <code>User</code> 对象，我们就可以做如下操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> orm</span><br><span class="line">from models <span class="keyword">import</span> User, Blog, <span class="function">Comment</span></span><br><span class="line"><span class="function">def <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    yield from orm.create_pool(user=</span><span class="string">&#x27;www-data&#x27;</span>, password=<span class="string">&#x27;www-data&#x27;</span>, database=<span class="string">&#x27;awesome&#x27;</span>)</span><br><span class="line">    u = <span class="built_in">User</span>(name=<span class="string">&#x27;Test&#x27;</span>, email=<span class="string">&#x27;test@example.com&#x27;</span>, passwd=<span class="string">&#x27;1234567890&#x27;</span>, image=<span class="string">&#x27;about:blank&#x27;</span>)</span><br><span class="line">    yield from u.<span class="built_in">save</span>()</span><br><span class="line"><span class="keyword">for</span> x in <span class="built_in">test</span>():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>可以在 MySQL 客户端命令行查询，看看数据是不是正常存储到 MySQL 里面了。</p>
<h3 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h3><p>在正式开始 Web 开发前，我们需要编写一个 Web 框架。</p>
<p><code>aiohttp</code> 已经是一个 Web 框架了，为什么我们还需要自己封装一个？</p>
<p>原因是从使用者的角度来说，<code>aiohttp</code> 相对比较底层，编写一个 URL 的处理函数需要这么几步：</p>
<p>第一步，编写一个用 <code>@asyncio.coroutine</code> 装饰的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@asyncio.<span class="function">coroutine</span></span><br><span class="line"><span class="function">def <span class="title">handle_url_xxx</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="function">    pass</span></span><br></pre></td></tr></table></figure>

<p>第二步，传入的参数需要自己从 <code>request</code> 中获取：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">url_param = request.match_info[<span class="string">&#x27;key&#x27;</span>]</span><br><span class="line">query_params = <span class="built_in">parse_qs</span>(request.query_string)</span><br></pre></td></tr></table></figure>

<p>最后，需要自己构造 <code>Response</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">text = <span class="built_in">render</span>(<span class="string">&#x27;template&#x27;</span>, data)</span><br><span class="line"><span class="keyword">return</span> web.<span class="built_in">Response</span>(text.<span class="built_in">encode</span>(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>这些重复的工作可以由框架完成。例如，处理带参数的 URL<code>/blog/&#123;id&#125;</code> 可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">get</span>(<span class="string">&#x27;/blog/&#123;id&#125;&#x27;</span>)</span><br><span class="line"><span class="function">def <span class="title">get_blog</span><span class="params">(id)</span>:</span></span><br><span class="line"><span class="function">    pass</span></span><br></pre></td></tr></table></figure>

<p>处理 <code>query_string</code> 参数可以通过关键字参数 <code>**kw</code> 或者命名关键字参数接收：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">get</span>(<span class="string">&#x27;/api/comments&#x27;</span>)</span><br><span class="line"><span class="function">def <span class="title">api_comments</span><span class="params">(*, page=<span class="string">&#x27;1&#x27;</span>)</span>:</span></span><br><span class="line"><span class="function">    pass</span></span><br></pre></td></tr></table></figure>

<p>对于函数的返回值，不一定是 <code>web.Response</code> 对象，可以是 <code>str</code>、<code>bytes</code> 或 <code>dict</code>。</p>
<p>如果希望渲染模板，我们可以这么返回一个 <code>dict</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="string">&#x27;__template__&#x27;</span>: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;...&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，Web 框架的设计是完全从使用者出发，目的是让使用者编写尽可能少的代码。</p>
<p>编写简单的函数而非引入 <code>request</code> 和 <code>web.Response</code> 还有一个额外的好处，就是可以单独测试，否则，需要模拟一个 <code>request</code> 才能测试。</p>
<h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="@get 和@post"></a>@get 和@post</h3><p>要把一个函数映射为一个 URL 处理函数，我们先定义 <code>@get()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">get</span><span class="params">(path)</span>:</span></span><br><span class="line"><span class="function">    <span class="string">&#x27;&#x27;&#x27;</span></span></span><br><span class="line"><span class="function">    Define decorator @get(<span class="string">&#x27;/path&#x27;</span>)</span></span><br><span class="line"><span class="function">    <span class="string">&#x27;&#x27;&#x27;</span></span></span><br><span class="line"><span class="function">    def decorator(func):</span></span><br><span class="line"><span class="function">        @functools.wraps(func)</span></span><br><span class="line"><span class="function">        def wrapper(*args, **kw):</span></span><br><span class="line"><span class="function">            return func(*args, **kw)</span></span><br><span class="line"><span class="function">        wrapper.__method__ =</span> <span class="string">&#x27;GET&#x27;</span></span><br><span class="line">        wrapper.__route__ = path</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>

<p>这样，一个函数通过 <code>@get()</code> 的装饰就附带了 URL 信息。</p>
<p><code>@post</code> 与 <code>@get</code> 定义类似。</p>
<h3 id="定义-RequestHandler"><a href="#定义-RequestHandler" class="headerlink" title="定义 RequestHandler"></a>定义 RequestHandler</h3><p>URL 处理函数不一定是一个 <code>coroutine</code>，因此我们用 <code>RequestHandler()</code> 来封装一个 URL 处理函数。</p>
<p><code>RequestHandler</code> 是一个类，由于定义了 <code>__call__()</code> 方法，因此可以将其实例视为函数。</p>
<p><code>RequestHandler</code> 目的就是从 URL 函数中分析其需要接收的参数，从 <code>request</code> 中获取必要的参数，调用 URL 函数，然后把结果转换为 <code>web.Response</code> 对象，这样，就完全符合 <code>aiohttp</code> 框架的要求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">RequestHandler</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self, app, fn):</span></span><br><span class="line"><span class="function">        self._app =</span> app</span><br><span class="line">        self._func = fn</span><br><span class="line">        ...</span><br><span class="line">    @asyncio.coroutine</span><br><span class="line">    def __call__(self, request):</span><br><span class="line">        kw = ... 获取参数</span><br><span class="line">        r = yield from self._func(**kw)</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<p>再编写一个 <code>add_route</code> 函数，用来注册一个 URL 处理函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">add_route</span><span class="params">(app, fn)</span>:</span></span><br><span class="line"><span class="function">    method =</span> <span class="built_in">getattr</span>(fn, <span class="string">&#x27;__method__&#x27;</span>, None)</span><br><span class="line">    path = <span class="built_in">getattr</span>(fn, <span class="string">&#x27;__route__&#x27;</span>, None)</span><br><span class="line">    <span class="keyword">if</span> path is None <span class="keyword">or</span> method is None:</span><br><span class="line">        raise <span class="built_in">ValueError</span>(<span class="string">&#x27;@get or @post not defined in %s.&#x27;</span> % <span class="built_in">str</span>(fn))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> asyncio.<span class="built_in">iscoroutinefunction</span>(fn) <span class="keyword">and</span> <span class="keyword">not</span> inspect.<span class="built_in">isgeneratorfunction</span>(fn):</span><br><span class="line">        fn = asyncio.<span class="built_in">coroutine</span>(fn)</span><br><span class="line">    logging.<span class="built_in">info</span>(<span class="string">&#x27;add route %s %s =&gt; %s(%s)&#x27;</span> % (method, path, fn.__name__, <span class="string">&#x27;, &#x27;</span>.<span class="built_in">join</span>(inspect.<span class="built_in">signature</span>(fn).parameters.<span class="built_in">keys</span>())))</span><br><span class="line">    app.router.<span class="built_in">add_route</span>(method, path, <span class="built_in">RequestHandler</span>(app, fn))</span><br></pre></td></tr></table></figure>

<p>最后一步，把很多次 <code>add_route()</code> 注册的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_route</span>(app, handles.index)</span><br><span class="line"><span class="built_in">add_route</span>(app, handles.blog)</span><br><span class="line"><span class="built_in">add_route</span>(app, handles.create_comment)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>变成自动扫描：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 自动把handler模块的所有符合条件的函数注册了:</span><br><span class="line"><span class="built_in">add_routes</span>(app, <span class="string">&#x27;handlers&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>add_routes()</code> 定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">add_routes</span><span class="params">(app, module_name)</span>:</span></span><br><span class="line"><span class="function">    n =</span> module_name.<span class="built_in">rfind</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> n == (<span class="number">-1</span>):</span><br><span class="line">        mod = __import__(module_name, <span class="built_in">globals</span>(), <span class="built_in">locals</span>())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        name = module_name[n+<span class="number">1</span>:]</span><br><span class="line">        mod = <span class="built_in">getattr</span>(__import__(module_name[:n], <span class="built_in">globals</span>(), <span class="built_in">locals</span>(), [name]), name)</span><br><span class="line">    <span class="keyword">for</span> attr in <span class="built_in">dir</span>(mod):</span><br><span class="line">        <span class="keyword">if</span> attr.<span class="built_in">startswith</span>(<span class="string">&#x27;_&#x27;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        fn = <span class="built_in">getattr</span>(mod, attr)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">callable</span>(fn):</span><br><span class="line">            method = <span class="built_in">getattr</span>(fn, <span class="string">&#x27;__method__&#x27;</span>, None)</span><br><span class="line">            path = <span class="built_in">getattr</span>(fn, <span class="string">&#x27;__route__&#x27;</span>, None)</span><br><span class="line">            <span class="keyword">if</span> method <span class="keyword">and</span> path:</span><br><span class="line">                <span class="built_in">add_route</span>(app, fn)</span><br></pre></td></tr></table></figure>

<p>最后，在 <code>app.py</code> 中加入 <code>middleware</code>、<code>jinja2</code> 模板和自注册的支持：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">app = web.<span class="built_in">Application</span>(loop=loop, middlewares=[</span><br><span class="line">    logger_factory, response_factory</span><br><span class="line">])</span><br><span class="line"><span class="built_in">init_jinja2</span>(app, filters=<span class="built_in">dict</span>(datetime=datetime_filter))</span><br><span class="line"><span class="built_in">add_routes</span>(app, <span class="string">&#x27;handlers&#x27;</span>)</span><br><span class="line"><span class="built_in">add_static</span>(app)</span><br></pre></td></tr></table></figure>

<h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p><code>middleware</code> 是一种拦截器，一个 URL 在被某个函数处理前，可以经过一系列的 <code>middleware</code> 的处理。</p>
<p>一个 <code>middleware</code> 可以改变 URL 的输入、输出，甚至可以决定不继续处理而直接返回。middleware 的用处就在于把通用的功能从每个 URL 处理函数中拿出来，集中放到一个地方。例如，一个记录 URL 日志的 <code>logger</code> 可以简单定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@asyncio.<span class="function">coroutine</span></span><br><span class="line"><span class="function">def <span class="title">logger_factory</span><span class="params">(app, handler)</span>:</span></span><br><span class="line"><span class="function">    @asyncio.coroutine</span></span><br><span class="line"><span class="function">    def logger(request):</span></span><br><span class="line"><span class="function">        # 记录日志:</span></span><br><span class="line"><span class="function">        logging.info(<span class="string">&#x27;Request: %s %s&#x27;</span> % (request.method, request.path))</span></span><br><span class="line"><span class="function">        # 继续处理请求:</span></span><br><span class="line"><span class="function">        return (yield from handler(request))</span></span><br><span class="line"><span class="function">    return logger</span></span><br></pre></td></tr></table></figure>

<p>而 <code>response</code> 这个 <code>middleware</code> 把返回值转换为 <code>web.Response</code> 对象再返回，以保证满足 <code>aiohttp</code> 的要求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@asyncio.<span class="function">coroutine</span></span><br><span class="line"><span class="function">def <span class="title">response_factory</span><span class="params">(app, handler)</span>:</span></span><br><span class="line"><span class="function">    @asyncio.coroutine</span></span><br><span class="line"><span class="function">    def response(request):</span></span><br><span class="line"><span class="function">        # 结果:</span></span><br><span class="line"><span class="function">        r =</span> <span class="function">yield from <span class="title">handler</span><span class="params">(request)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">isinstance</span><span class="params">(r, web.StreamResponse)</span>:</span></span><br><span class="line"><span class="function">            return r</span></span><br><span class="line"><span class="function">        if isinstance(r, bytes):</span></span><br><span class="line"><span class="function">            resp =</span> web.<span class="built_in">Response</span>(body=r)</span><br><span class="line">            resp.content_type = <span class="string">&#x27;application/octet-stream&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> resp</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(r, str):</span><br><span class="line">            resp = web.<span class="built_in">Response</span>(body=r.<span class="built_in">encode</span>(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            resp.content_type = <span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> resp</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(r, dict):</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>有了这些基础设施，我们就可以专注地往 <code>handlers</code> 模块不断添加 URL 处理函数了，可以极大地提高开发效率。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>有了 Web 框架和 ORM 框架，我们就可以开始装配 App 了。</p>
<p>通常，一个 Web App 在运行时都需要读取配置文件，比如数据库的用户名、口令等，在不同的环境中运行时，Web App 可以通过读取不同的配置文件来获得正确的配置。</p>
<p>由于 Python 本身语法简单，完全可以直接用 Python 源代码来实现配置，而不需要再解析一个单独的 <code>.properties</code> 或者 <code>.yaml</code> 等配置文件。</p>
<p>默认的配置文件应该完全符合本地开发环境，这样，无需任何设置，就可以立刻启动服务器。</p>
<p>我们把默认的配置文件命名为 <code>config_default.py</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># config_default.py</span><br><span class="line">configs = &#123;</span><br><span class="line">    <span class="string">&#x27;db&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;port&#x27;</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;www-data&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;www-data&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;database&#x27;</span>: <span class="string">&#x27;awesome&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;session&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;secret&#x27;</span>: <span class="string">&#x27;AwEsOmE&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述配置文件简单明了。但是，如果要部署到服务器时，通常需要修改数据库的 host 等信息，直接修改 <code>config_default.py</code> 不是一个好办法，更好的方法是编写一个 <code>config_override.py</code>，用来覆盖某些默认设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># config_override.py</span><br><span class="line">configs = &#123;</span><br><span class="line">    <span class="string">&#x27;db&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;192.168.0.100&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>config_default.py</code> 作为开发环境的标准配置，把 <code>config_override.py</code> 作为生产环境的标准配置，我们就可以既方便地在本地开发，又可以随时把应用部署到服务器上。</p>
<p>应用程序读取配置文件需要优先从 <code>config_override.py</code> 读取。为了简化读取配置文件，可以把所有配置读取到统一的 <code>config.py</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># config.py</span></span><br><span class="line">configs = config_default.configs</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> config_override</span><br><span class="line">    configs = <span class="built_in">merge</span>(configs, config_override.configs)</span><br><span class="line">except ImportError:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>这样，我们就完成了 App 的配置。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>现在，ORM 框架、Web 框架和配置都已就绪，我们可以开始编写一个最简单的 MVC，把它们全部启动起来。</p>
<p>通过 Web 框架的 <code>@get</code> 和 ORM 框架的 Model 支持，可以很容易地编写一个处理首页 URL 的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">get</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="function">def <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="function">    users =</span> yield from User.<span class="built_in">findAll</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;__template__&#x27;</span>: <span class="string">&#x27;test.html&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;users&#x27;</span>: users</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>&#39;__template__&#39;</code> 指定的模板文件是 <code>test.html</code>，其他参数是传递给模板的数据，所以我们在模板的根目录 <code>templates</code> 下创建 <code>test.html</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="line">    &lt;title&gt;Test users - Awesome Python Webapp&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;All users&lt;/h1&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> u in users %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; u.name &#125;&#125; / &#123;&#123; u.email &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，如果一切顺利，可以用命令行启动 Web 服务器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ python3 app.py</span><br></pre></td></tr></table></figure>

<p>然后，在浏览器中访问 <code>http://localhost:9000/</code>。</p>
<p>如果数据库的 <code>users</code> 表什么内容也没有，你就无法在浏览器中看到循环输出的内容。可以自己在 MySQL 的命令行里给 <code>users</code> 表添加几条记录，然后再访问</p>
<h3 id="构建前端"><a href="#构建前端" class="headerlink" title="构建前端"></a>构建前端</h3><p>对于复杂的 HTML 前端页面来说，我们需要一套基础的 CSS 框架来完成页面布局和基本样式。另外，jQuery 作为操作 DOM 的 JavaScript 库也必不可少。</p>
<p>从零开始写 CSS 不如直接从一个已有的功能完善的 CSS 框架开始。有很多 CSS 框架可供选择。我们这次选择 <a href="http://getuikit.com/">uikit</a> 这个强大的 CSS 框架。它具备完善的响应式布局，漂亮的 UI，以及丰富的 HTML 组件，让我们能轻松设计出美观而简洁的页面。</p>
<p>可以从 <a href="http://getuikit.com/">uikit首页</a> 下载打包的资源文件。</p>
<p>所有的静态资源文件我们统一放到 <code>www/static</code> 目录下，并按照类别归类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span>/</span><br><span class="line">+- css/</span><br><span class="line">|  +- addons/</span><br><span class="line">|  |  +- uikit.addons.min.css</span><br><span class="line">|  |  +- uikit.almost-flat.addons.min.css</span><br><span class="line">|  |  +- uikit.gradient.addons.min.css</span><br><span class="line">|  +- awesome.css</span><br><span class="line">|  +- uikit.almost-flat.addons.min.css</span><br><span class="line">|  +- uikit.gradient.addons.min.css</span><br><span class="line">|  +- uikit.min.css</span><br><span class="line">+- fonts/</span><br><span class="line">|  +- fontawesome-webfont.eot</span><br><span class="line">|  +- fontawesome-webfont.ttf</span><br><span class="line">|  +- fontawesome-webfont.woff</span><br><span class="line">|  +- FontAwesome.otf</span><br><span class="line">+- js/</span><br><span class="line">   +- awesome.js</span><br><span class="line">   +- html5.js</span><br><span class="line">   +- jquery.min.js</span><br><span class="line">   +- uikit.min.js</span><br></pre></td></tr></table></figure>

<p>由于前端页面肯定不止首页一个页面，每个页面都有相同的页眉和页脚。如果每个页面都是独立的 HTML 模板，那么我们在修改页眉和页脚的时候，就需要把每个模板都改一遍，这显然是没有效率的。</p>
<p>常见的模板引擎已经考虑到了页面上重复的 HTML 部分的复用问题。有的模板通过 include 把页面拆成三部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;% include file=<span class="string">&quot;inc_header.html&quot;</span> %&gt;</span><br><span class="line">    &lt;% include file=<span class="string">&quot;index_body.html&quot;</span> %&gt;</span><br><span class="line">    &lt;% include file=<span class="string">&quot;inc_footer.html&quot;</span> %&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这样，相同的部分 <code>inc_header.html</code> 和 <code>inc_footer.html</code> 就可以共享。</p>
<p>但是 include 方法不利于页面整体结构的维护。jinjia2 的模板还有另一种“继承”方式，实现模板的复用更简单。</p>
<p>“继承”模板的方式是通过编写一个“父模板”，在父模板中定义一些可替换的 block（块）。然后，编写多个“子模板”，每个子模板都可以只替换父模板定义的 block。比如，定义一个最简单的父模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!-- base.html --&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;&#123;% block title%&#125; 这里定义了一个名为title的block &#123;% endblock %&#125;&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &#123;% block content %&#125; 这里定义了一个名为content的block &#123;% endblock %&#125;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>对于子模板 <code>a.html</code>，只需要把父模板的 <code>title</code> 和 <code>content</code> 替换掉：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&#x27;base.html&#x27;</span> %&#125;</span><br><span class="line">&#123;% block title %&#125; A &#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;h1&gt;Chapter A&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;blablabla...&lt;/p&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>对于子模板 <code>b.html</code>，如法炮制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&#x27;base.html&#x27;</span> %&#125;</span><br><span class="line">&#123;% block title %&#125; B &#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;h1&gt;Chapter B&lt;/h1&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">       &lt;li&gt;list <span class="number">1</span>&lt;/li&gt;</span><br><span class="line">       &lt;li&gt;list <span class="number">2</span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一旦定义好父模板的整体布局和 CSS 样式，编写子模板就会非常容易。</p>
<p>让我们通过 uikit 这个 CSS 框架来完成父模板 <code>__base__.html</code> 的编写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="line">    &#123;% block meta %&#125;&lt;!-- block meta  --&gt;&#123;% endblock %&#125;</span><br><span class="line">    &lt;title&gt;&#123;% block title %&#125; ? &#123;% endblock %&#125; - Awesome Python Webapp&lt;/title&gt;</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/css/uikit.min.css&quot;</span>&gt;</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/css/uikit.gradient.min.css&quot;</span>&gt;</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/css/awesome.css&quot;</span> /&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;/static/js/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;/static/js/md5.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;/static/js/uikit.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;/static/js/awesome.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &#123;% block beforehead %&#125;&lt;!-- before head  --&gt;&#123;% endblock %&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;nav <span class="keyword">class</span>=<span class="string">&quot;uk-navbar uk-navbar-attached uk-margin-bottom&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-container uk-container-center&quot;</span>&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;/&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-navbar-brand&quot;</span>&gt;Awesome&lt;/a&gt;</span><br><span class="line">            &lt;ul <span class="keyword">class</span>=<span class="string">&quot;uk-navbar-nav&quot;</span>&gt;</span><br><span class="line">                &lt;li data-url=<span class="string">&quot;blogs&quot;</span>&gt;&lt;a href=<span class="string">&quot;/&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-home&quot;</span>&gt;&lt;/i&gt; 日志&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-book&quot;</span>&gt;&lt;/i&gt; 教程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-code&quot;</span>&gt;&lt;/i&gt; 源码&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-navbar-flip&quot;</span>&gt;</span><br><span class="line">                &lt;ul <span class="keyword">class</span>=<span class="string">&quot;uk-navbar-nav&quot;</span>&gt;</span><br><span class="line">                &#123;% <span class="keyword">if</span> user %&#125;</span><br><span class="line">                    &lt;li <span class="keyword">class</span>=<span class="string">&quot;uk-parent&quot;</span> data-uk-dropdown&gt;</span><br><span class="line">                        &lt;a href=<span class="string">&quot;#0&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-user&quot;</span>&gt;&lt;/i&gt; &#123;&#123; user.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">                        &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-dropdown uk-dropdown-navbar&quot;</span>&gt;</span><br><span class="line">                            &lt;ul <span class="keyword">class</span>=<span class="string">&quot;uk-nav uk-nav-navbar&quot;</span>&gt;</span><br><span class="line">                                &lt;li&gt;&lt;a href=<span class="string">&quot;/signout&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-sign-out&quot;</span>&gt;&lt;/i&gt; 登出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                            &lt;/ul&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/li&gt;</span><br><span class="line">                &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">                    &lt;li&gt;&lt;a href=<span class="string">&quot;/signin&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-sign-in&quot;</span>&gt;&lt;/i&gt; 登陆&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&lt;a href=<span class="string">&quot;/register&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-edit&quot;</span>&gt;&lt;/i&gt; 注册&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &#123;% endif %&#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-container uk-container-center&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-grid&quot;</span>&gt;</span><br><span class="line">            &lt;!-- content --&gt;</span><br><span class="line">            &#123;% block content %&#125;</span><br><span class="line">            &#123;% endblock %&#125;</span><br><span class="line">            &lt;!-- <span class="comment">// content --&gt;</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-margin-large-top&quot;</span> style=<span class="string">&quot;background-color:#eee; border-top:1px solid #ccc;&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-container uk-container-center uk-text-center&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-panel uk-margin-top uk-margin-bottom&quot;</span>&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-icon-button uk-icon-weibo&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">                    &lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-icon-button uk-icon-github&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">                    &lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-icon-button uk-icon-linkedin-square&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">                    &lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-icon-button uk-icon-twitter&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">                &lt;/p&gt;</span><br><span class="line">                &lt;p&gt;Powered by &lt;a href=<span class="string">&quot;#&quot;</span>&gt;Awesome Python Webapp&lt;/a&gt;. Copyright &amp;copy; <span class="number">2014.</span> [&lt;a href=<span class="string">&quot;/manage/&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&gt;Manage&lt;/a&gt;]&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;&lt;a href=<span class="string">&quot;http://www.liaoxuefeng.com/&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&gt;www.liaoxuefeng.com&lt;/a&gt;. All rights reserved.&lt;/p&gt;</span><br><span class="line">                &lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-html5&quot;</span> style=<span class="string">&quot;font-size:64px; color: #444;&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>__base__.html</code> 定义的几个 block 作用如下：</p>
<p>用于子页面定义一些 meta，例如 rss feed：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% block meta %&#125; ... &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖页面的标题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; ... &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>子页面可以在 <code>&lt;head&gt;</code> 标签关闭前插入 JavaScript 代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% block beforehead %&#125; ... &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>子页面的 content 布局和内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">    ...</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>我们把首页改造一下，从 <code>__base__.html</code> 继承一个 <code>blogs.html</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&#x27;__base__.html&#x27;</span> %&#125;</span><br><span class="line">&#123;% block title %&#125;日志&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-width-medium-3-4&quot;</span>&gt;</span><br><span class="line">        &#123;% <span class="keyword">for</span> blog in blogs %&#125;</span><br><span class="line">            &lt;article <span class="keyword">class</span>=<span class="string">&quot;uk-article&quot;</span>&gt;</span><br><span class="line">                &lt;h2&gt;&lt;a href=<span class="string">&quot;/blog/&#123;&#123; blog.id &#125;&#125;&quot;</span>&gt;&#123;&#123; blog.name &#125;&#125;&lt;/a&gt;&lt;/h2&gt;</span><br><span class="line">                &lt;p <span class="keyword">class</span>=<span class="string">&quot;uk-article-meta&quot;</span>&gt;发表于&#123;&#123; blog.created_at&#125;&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;&#123;&#123; blog.summary &#125;&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;&lt;a href=<span class="string">&quot;/blog/&#123;&#123; blog.id &#125;&#125;&quot;</span>&gt;继续阅读 &lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-angle-double-right&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">            &lt;/article&gt;</span><br><span class="line">            &lt;hr <span class="keyword">class</span>=<span class="string">&quot;uk-article-divider&quot;</span>&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-width-medium-1-4&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-panel uk-panel-header&quot;</span>&gt;</span><br><span class="line">            &lt;h3 <span class="keyword">class</span>=<span class="string">&quot;uk-panel-title&quot;</span>&gt;友情链接&lt;/h3&gt;</span><br><span class="line">            &lt;ul <span class="keyword">class</span>=<span class="string">&quot;uk-list uk-list-line&quot;</span>&gt;</span><br><span class="line">                &lt;li&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-thumbs-o-up&quot;</span>&gt;&lt;/i&gt; &lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span>&gt;编程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-thumbs-o-up&quot;</span>&gt;&lt;/i&gt; &lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span>&gt;读书&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-thumbs-o-up&quot;</span>&gt;&lt;/i&gt; &lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span>&gt;Python教程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-thumbs-o-up&quot;</span>&gt;&lt;/i&gt; &lt;a target=<span class="string">&quot;_blank&quot;</span> href=<span class="string">&quot;#&quot;</span>&gt;Git教程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>相应地，首页 URL 的处理函数更新如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">get</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="function">def <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="function">    summary =</span> <span class="string">&#x27;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&#x27;</span></span><br><span class="line">    blogs = [</span><br><span class="line">        <span class="built_in">Blog</span>(id=<span class="string">&#x27;1&#x27;</span>, name=<span class="string">&#x27;Test Blog&#x27;</span>, summary=summary, created_at=time.<span class="built_in">time</span>()<span class="number">-120</span>),</span><br><span class="line">        <span class="built_in">Blog</span>(id=<span class="string">&#x27;2&#x27;</span>, name=<span class="string">&#x27;Something New&#x27;</span>, summary=summary, created_at=time.<span class="built_in">time</span>()<span class="number">-3600</span>),</span><br><span class="line">        <span class="built_in">Blog</span>(id=<span class="string">&#x27;3&#x27;</span>, name=<span class="string">&#x27;Learn Swift&#x27;</span>, summary=summary, created_at=time.<span class="built_in">time</span>()<span class="number">-7200</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;__template__&#x27;</span>: <span class="string">&#x27;blogs.html&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;blogs&#x27;</span>: blogs</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Blog 的创建日期显示的是一个浮点数，因为它是由这段模板渲染出来的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="keyword">class</span>=<span class="string">&quot;uk-article-meta&quot;</span>&gt;发表于&#123;&#123; blog.created_at &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>解决方法是通过 jinja2 的 filter（过滤器），把一个浮点数转换成日期字符串。我们来编写一个 <code>datetime</code> 的 filter，在模板里用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="keyword">class</span>=<span class="string">&quot;uk-article-meta&quot;</span>&gt;发表于&#123;&#123; blog.created_at|datetime &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>filter 需要在初始化 jinja2 时设置。相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">datetime_filter</span><span class="params">(t)</span>:</span></span><br><span class="line"><span class="function">    delta =</span> <span class="built_in">int</span>(time.<span class="built_in">time</span>() - t)</span><br><span class="line">    <span class="keyword">if</span> delta &lt; <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;1分钟前&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> delta &lt; <span class="number">3600</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s分钟前&#x27;</span> % (delta <span class="comment">// 60)</span></span><br><span class="line">    <span class="keyword">if</span> delta &lt; <span class="number">86400</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s小时前&#x27;</span> % (delta <span class="comment">// 3600)</span></span><br><span class="line">    <span class="keyword">if</span> delta &lt; <span class="number">604800</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s天前&#x27;</span> % (delta <span class="comment">// 86400)</span></span><br><span class="line">    dt = datetime.<span class="built_in">fromtimestamp</span>(t)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s年%s月%s日&#x27;</span> % (dt.year, dt.month, dt.day)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">init_jinja2</span>(app, filters=<span class="built_in">dict</span>(datetime=datetime_filter))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在，完善的首页显示如下</p>
<h3 id="编写-API"><a href="#编写-API" class="headerlink" title="编写 API"></a>编写 API</h3><p>什么是 Web API 呢？</p>
<p>如果我们想要获取一篇 Blog，输入 <code>http://localhost:9000/blog/123</code>，就可以看到 id 为 <code>123</code> 的 Blog 页面，但这个结果是 HTML 页面，它同时混合包含了 Blog 的数据和 Blog 的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从 HTML 中解析出 Blog 的数据。</p>
<p>如果一个 URL 返回的不是 HTML，而是机器能直接解析的数据，这个 URL 就可以看成是一个 Web API。比如，读取 <code>http://localhost:9000/api/blogs/123</code>，如果能直接返回 Blog 的数据，那么机器就可以直接读取。</p>
<p>REST 就是一种设计 API 的模式。最常用的数据格式是 JSON。由于 JSON 能直接被 JavaScript 读取，所以，以 JSON 格式编写的 REST 风格的 API 具有简单、易读、易用的特点。</p>
<p>编写 API 有什么好处呢？由于 API 就是把 Web App 的功能全部封装了，所以，通过 API 操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。</p>
<p>一个 API 也是一个 URL 的处理函数，我们希望能直接通过一个 <code>@api</code> 来把函数变成 JSON 格式的 REST API，这样，获取注册用户可以用一个 API 实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">get</span>(<span class="string">&#x27;/api/users&#x27;</span>)</span><br><span class="line"><span class="function">def <span class="title">api_get_users</span><span class="params">(*, page=<span class="string">&#x27;1&#x27;</span>)</span>:</span></span><br><span class="line"><span class="function">    page_index =</span> <span class="built_in">get_page_index</span>(page)</span><br><span class="line">    num = yield from User.<span class="built_in">findNumber</span>(<span class="string">&#x27;count(id)&#x27;</span>)</span><br><span class="line">    p = <span class="built_in">Page</span>(num, page_index)</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dict</span>(page=p, users=())</span><br><span class="line">    users = yield from User.<span class="built_in">findAll</span>(orderBy=<span class="string">&#x27;created_at desc&#x27;</span>, limit=(p.offset, p.limit))</span><br><span class="line">    <span class="keyword">for</span> u in users:</span><br><span class="line">        u.passwd = <span class="string">&#x27;******&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(page=p, users=users)</span><br></pre></td></tr></table></figure>

<p>只要返回一个 <code>dict</code>，后续的 <code>response</code> 这个 <code>middleware</code> 就可以把结果序列化为 JSON 并返回。</p>
<p>我们需要对 Error 进行处理，因此定义一个 <code>APIError</code>，这种 Error 是指 API 调用时发生了逻辑错误（比如用户不存在），其他的 Error 视为 Bug，返回的错误代码为 <code>internalerror</code>。</p>
<p>客户端调用 API 时，必须通过错误代码来区分 API 调用是否成功。错误代码是用来告诉调用者出错的原因。很多 API 用一个整数表示错误码，这种方式很难维护错误码，客户端拿到错误码还需要查表得知错误信息。更好的方式是用字符串表示错误代码，不需要看文档也能猜到错误原因。</p>
<p>可以在浏览器直接测试 API，例如，输入 <code>http://localhost:9000/api/users</code>，就可以看到返回的 JSON：</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="注册和登录"><a href="#注册和登录" class="headerlink" title="注册和登录"></a>注册和登录</h2><p>用户管理是绝大部分 Web 网站都需要解决的问题。用户管理涉及到用户注册和登录。</p>
<p>用户注册相对简单，我们可以先通过 API 把用户注册这个功能实现了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_RE_EMAIL = re.<span class="built_in">compile</span>(r<span class="number">&#x27;</span>^[a-z0<span class="number">-9</span>\.\-\_]+\@[a-z0<span class="number">-9</span>\-\_]+(\.[a-z0<span class="number">-9</span>\-\_]+)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;$<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">_RE_SHA1 = re.compile(r&#x27;</span>^[<span class="number">0</span><span class="number">-9</span>a-f]&#123;<span class="number">40</span>&#125;$<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">@post(&#x27;</span>/api/users<span class="number">&#x27;</span>)</span><br><span class="line">def <span class="built_in">api_register_user</span>(*, email, name, passwd):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">or</span> <span class="keyword">not</span> name.<span class="built_in">strip</span>():</span><br><span class="line">        raise <span class="built_in">APIValueError</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> email <span class="keyword">or</span> <span class="keyword">not</span> _RE_EMAIL.<span class="built_in">match</span>(email):</span><br><span class="line">        raise <span class="built_in">APIValueError</span>(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> passwd <span class="keyword">or</span> <span class="keyword">not</span> _RE_SHA1.<span class="built_in">match</span>(passwd):</span><br><span class="line">        raise <span class="built_in">APIValueError</span>(<span class="string">&#x27;passwd&#x27;</span>)</span><br><span class="line">    users = yield from User.<span class="built_in">findAll</span>(<span class="string">&#x27;email=?&#x27;</span>, [email])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(users) &gt; <span class="number">0</span>:</span><br><span class="line">        raise <span class="built_in">APIError</span>(<span class="string">&#x27;register:failed&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;Email is already in use.&#x27;</span>)</span><br><span class="line">    uid = <span class="built_in">next_id</span>()</span><br><span class="line">    sha1_passwd = <span class="string">&#x27;%s:%s&#x27;</span> % (uid, passwd)</span><br><span class="line">    user = <span class="built_in">User</span>(id=uid, name=name.<span class="built_in">strip</span>(), email=email, passwd=hashlib.<span class="built_in">sha1</span>(sha1_passwd.<span class="built_in">encode</span>(<span class="string">&#x27;utf-8&#x27;</span>)).<span class="built_in">hexdigest</span>(), image=<span class="string">&#x27;http://www.gravatar.com/avatar/%s?d=mm&amp;s=120&#x27;</span> % hashlib.<span class="built_in">md5</span>(email.<span class="built_in">encode</span>(<span class="string">&#x27;utf-8&#x27;</span>)).<span class="built_in">hexdigest</span>())</span><br><span class="line">    yield from user.<span class="built_in">save</span>()</span><br><span class="line">    <span class="meta"># make session cookie:</span></span><br><span class="line">    r = web.<span class="built_in">Response</span>()</span><br><span class="line">    r.<span class="built_in">set_cookie</span>(COOKIE_NAME, <span class="built_in">user2cookie</span>(user, <span class="number">86400</span>), max_age=<span class="number">86400</span>, httponly=True)</span><br><span class="line">    user.passwd = <span class="string">&#x27;******&#x27;</span></span><br><span class="line">    r.content_type = <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    r.body = json.<span class="built_in">dumps</span>(user, ensure_ascii=False).<span class="built_in">encode</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<p>注意用户口令是客户端传递的经过 SHA1 计算后的 40 位 Hash 字符串，所以服务器端并不知道用户的原始口令。</p>
<p>接下来可以创建一个注册页面，让用户填写注册表单，然后，提交数据到注册用户的 API：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&#x27;__base__.html&#x27;</span> %&#125;</span><br><span class="line">&#123;% block title %&#125;注册&#123;% endblock %&#125;</span><br><span class="line">&#123;% block beforehead %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function">function <span class="title">validateEmail</span><span class="params">(email)</span> </span>&#123;</span><br><span class="line">    var re = /^[a-z0<span class="number">-9</span>\.\-\_]+\@[a-z0<span class="number">-9</span>\-\_]+(\.[a-z0<span class="number">-9</span>\-\_]+)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;$/;</span><br><span class="line">    <span class="keyword">return</span> re.<span class="built_in">test</span>(email.<span class="built_in">toLowerCase</span>());</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="built_in">function</span> () &#123;</span><br><span class="line">    var vm = <span class="keyword">new</span> <span class="built_in">Vue</span>(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#vm&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: <span class="string">&#x27;&#x27;,</span></span><br><span class="line"><span class="string">            email: &#x27;</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">            password1: &#x27;</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">            password2: &#x27;</span>&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            submit: <span class="built_in">function</span> (event) &#123;</span><br><span class="line">                event.<span class="built_in">preventDefault</span>();</span><br><span class="line">                var $form = $(<span class="string">&#x27;#vm&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (! <span class="keyword">this</span>.name.<span class="built_in">trim</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> $form.<span class="built_in">showFormError</span>(<span class="string">&#x27;请输入名字&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (! <span class="built_in">validateEmail</span>(<span class="keyword">this</span>.email.<span class="built_in">trim</span>().<span class="built_in">toLowerCase</span>())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> $form.<span class="built_in">showFormError</span>(<span class="string">&#x27;请输入正确的Email地址&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.password1.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> $form.<span class="built_in">showFormError</span>(<span class="string">&#x27;口令长度至少为6个字符&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.password1 !== <span class="keyword">this</span>.password2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> $form.<span class="built_in">showFormError</span>(<span class="string">&#x27;两次输入的口令不一致&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                var email = <span class="keyword">this</span>.email.<span class="built_in">trim</span>().<span class="built_in">toLowerCase</span>();</span><br><span class="line">                $form.<span class="built_in">postJSON</span>(<span class="string">&#x27;/api/users&#x27;</span>, &#123;</span><br><span class="line">                    name: <span class="keyword">this</span>.name.<span class="built_in">trim</span>(),</span><br><span class="line">                    email: email,</span><br><span class="line">                    passwd: CryptoJS.<span class="built_in">SHA1</span>(email + <span class="string">&#x27;:&#x27;</span> + <span class="keyword">this</span>.password1).<span class="built_in">toString</span>()</span><br><span class="line">                &#125;, <span class="built_in">function</span> (err, r) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        <span class="keyword">return</span> $form.<span class="built_in">showFormError</span>(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> location.<span class="built_in">assign</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">&#x27;#vm&#x27;</span>).<span class="built_in">show</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-width-2-3&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;欢迎注册！&lt;/h1&gt;</span><br><span class="line">        &lt;form id=<span class="string">&quot;vm&quot;</span> v-on=<span class="string">&quot;submit: submit&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-form uk-form-stacked&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-alert uk-alert-danger uk-hidden&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-row&quot;</span>&gt;</span><br><span class="line">                &lt;label <span class="keyword">class</span>=<span class="string">&quot;uk-form-label&quot;</span>&gt;名字:&lt;/label&gt;</span><br><span class="line">                &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-controls&quot;</span>&gt;</span><br><span class="line">                    &lt;input v-model=<span class="string">&quot;name&quot;</span> type=<span class="string">&quot;text&quot;</span> maxlength=<span class="string">&quot;50&quot;</span> placeholder=<span class="string">&quot;名字&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span>&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-row&quot;</span>&gt;</span><br><span class="line">                &lt;label <span class="keyword">class</span>=<span class="string">&quot;uk-form-label&quot;</span>&gt;电子邮件:&lt;/label&gt;</span><br><span class="line">                &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-controls&quot;</span>&gt;</span><br><span class="line">                    &lt;input v-model=<span class="string">&quot;email&quot;</span> type=<span class="string">&quot;text&quot;</span> maxlength=<span class="string">&quot;50&quot;</span> placeholder=<span class="string">&quot;your-name@example.com&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span>&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-row&quot;</span>&gt;</span><br><span class="line">                &lt;label <span class="keyword">class</span>=<span class="string">&quot;uk-form-label&quot;</span>&gt;输入口令:&lt;/label&gt;</span><br><span class="line">                &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-controls&quot;</span>&gt;</span><br><span class="line">                    &lt;input v-model=<span class="string">&quot;password1&quot;</span> type=<span class="string">&quot;password&quot;</span> maxlength=<span class="string">&quot;50&quot;</span> placeholder=<span class="string">&quot;输入口令&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span>&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-row&quot;</span>&gt;</span><br><span class="line">                &lt;label <span class="keyword">class</span>=<span class="string">&quot;uk-form-label&quot;</span>&gt;重复口令:&lt;/label&gt;</span><br><span class="line">                &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-controls&quot;</span>&gt;</span><br><span class="line">                    &lt;input v-model=<span class="string">&quot;password2&quot;</span> type=<span class="string">&quot;password&quot;</span> maxlength=<span class="string">&quot;50&quot;</span> placeholder=<span class="string">&quot;重复口令&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span>&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-row&quot;</span>&gt;</span><br><span class="line">                &lt;button type=<span class="string">&quot;submit&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-button uk-button-primary&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-user&quot;</span>&gt;&lt;/i&gt; 注册&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就把用户注册的功能完成了</p>
<p>用户登录比用户注册复杂。由于 HTTP 协议是一种无状态协议，而服务器要跟踪用户状态，就只能通过 cookie 实现。大多数 Web 框架提供了 Session 功能来封装保存用户状态的 cookie。</p>
<p>Session 的优点是简单易用，可以直接从 Session 中取出用户登录信息。</p>
<p>Session 的缺点是服务器需要在内存中维护一个映射表来存储用户登录信息，如果有两台以上服务器，就需要对 Session 做集群，因此，使用 Session 的 Web App 很难扩展。</p>
<p>我们采用直接读取 cookie 的方式来验证用户登录，每次用户访问任意 URL，都会对 cookie 进行验证，这种方式的好处是保证服务器处理任意的 URL 都是无状态的，可以扩展到多台服务器。</p>
<p>由于登录成功后是由服务器生成一个 cookie 发送给浏览器，所以，要保证这个 cookie 不会被客户端伪造出来。</p>
<p>实现防伪造 cookie 的关键是通过一个单向算法（例如 SHA1），举例如下：</p>
<p>当用户输入了正确的口令登录成功后，服务器可以从数据库取到用户的 id，并按照如下方式计算出一个字符串：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;用户id&quot;</span> + <span class="string">&quot;过期时间&quot;</span> + <span class="built_in">SHA1</span>(<span class="string">&quot;用户id&quot;</span> + <span class="string">&quot;用户口令&quot;</span> + <span class="string">&quot;过期时间&quot;</span> + <span class="string">&quot;SecretKey&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当浏览器发送 cookie 到服务器端后，服务器可以拿到的信息包括：</p>
<ul>
<li>用户 id</li>
<li>过期时间</li>
<li>SHA1 值<br>如果未到过期时间，服务器就根据用户 id 查找用户口令，并计算：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SHA1</span>(<span class="string">&quot;用户id&quot;</span> + <span class="string">&quot;用户口令&quot;</span> + <span class="string">&quot;过期时间&quot;</span> + <span class="string">&quot;SecretKey&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>并与浏览器 cookie 中的哈希进行比较，如果相等，则说明用户已登录，否则，cookie 就是伪造的。</p>
<p>这个算法的关键在于 SHA1 是一种单向算法，即可以通过原始字符串计算出 SHA1 结果，但无法通过 SHA1 结果反推出原始字符串。</p>
<p>所以登录 API 可以实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">post</span>(<span class="string">&#x27;/api/authenticate&#x27;</span>)</span><br><span class="line"><span class="function">def <span class="title">authenticate</span><span class="params">(*, email, passwd)</span>:</span></span><br><span class="line"><span class="function">    if not email:</span></span><br><span class="line"><span class="function">        raise APIValueError(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;Invalid email.&#x27;</span>)</span></span><br><span class="line"><span class="function">    if not passwd:</span></span><br><span class="line"><span class="function">        raise APIValueError(<span class="string">&#x27;passwd&#x27;</span>, <span class="string">&#x27;Invalid password.&#x27;</span>)</span></span><br><span class="line"><span class="function">    users =</span> yield from User.<span class="built_in">findAll</span>(<span class="string">&#x27;email=?&#x27;</span>, [email])</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(users)</span> </span>== <span class="number">0</span>:</span><br><span class="line">        raise <span class="built_in">APIValueError</span>(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;Email not exist.&#x27;</span>)</span><br><span class="line">    user = users[<span class="number">0</span>]</span><br><span class="line">    <span class="meta"># check passwd:</span></span><br><span class="line">    sha1 = hashlib.<span class="built_in">sha1</span>()</span><br><span class="line">    sha1.<span class="built_in">update</span>(user.id.<span class="built_in">encode</span>(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    sha1.<span class="built_in">update</span>(b<span class="number">&#x27;</span>:<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    sha1.update(passwd.encode(&#x27;</span>utf<span class="number">-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> user.passwd != sha1.<span class="built_in">hexdigest</span>():</span><br><span class="line">        raise <span class="built_in">APIValueError</span>(<span class="string">&#x27;passwd&#x27;</span>, <span class="string">&#x27;Invalid password.&#x27;</span>)</span><br><span class="line">    <span class="meta"># authenticate ok, set cookie:</span></span><br><span class="line">    r = web.<span class="built_in">Response</span>()</span><br><span class="line">    r.<span class="built_in">set_cookie</span>(COOKIE_NAME, <span class="built_in">user2cookie</span>(user, <span class="number">86400</span>), max_age=<span class="number">86400</span>, httponly=True)</span><br><span class="line">    user.passwd = <span class="string">&#x27;******&#x27;</span></span><br><span class="line">    r.content_type = <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    r.body = json.<span class="built_in">dumps</span>(user, ensure_ascii=False).<span class="built_in">encode</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">    </span><br><span class="line"># 计算加密cookie:</span><br><span class="line">def <span class="built_in">user2cookie</span>(user, max_age):</span><br><span class="line">    <span class="meta"># build cookie string by: id-expires-sha1</span></span><br><span class="line">    expires = <span class="built_in">str</span>(<span class="built_in">int</span>(time.<span class="built_in">time</span>() + max_age))</span><br><span class="line">    s = <span class="string">&#x27;%s-%s-%s-%s&#x27;</span> % (user.id, user.passwd, expires, _COOKIE_KEY)</span><br><span class="line">    L = [user.id, expires, hashlib.<span class="built_in">sha1</span>(s.<span class="built_in">encode</span>(<span class="string">&#x27;utf-8&#x27;</span>)).<span class="built_in">hexdigest</span>()]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span>.<span class="built_in">join</span>(L)</span><br></pre></td></tr></table></figure>

<p>对于每个 URL 处理函数，如果我们都去写解析 cookie 的代码，那会导致代码重复很多次。</p>
<p>利用 middle 在处理 URL 之前，把 cookie 解析出来，并将登录用户绑定到 <code>request</code> 对象上，这样，后续的 URL 处理函数就可以直接拿到登录用户：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@asyncio.<span class="function">coroutine</span></span><br><span class="line"><span class="function">def <span class="title">auth_factory</span><span class="params">(app, handler)</span>:</span></span><br><span class="line"><span class="function">    @asyncio.coroutine</span></span><br><span class="line"><span class="function">    def auth(request):</span></span><br><span class="line"><span class="function">        logging.info(<span class="string">&#x27;check user: %s %s&#x27;</span> % (request.method, request.path))</span></span><br><span class="line"><span class="function">        request.__user__ =</span> None</span><br><span class="line">        cookie_str = request.cookies.<span class="built_in">get</span>(COOKIE_NAME)</span><br><span class="line">        <span class="keyword">if</span> cookie_str:</span><br><span class="line">            user = yield from <span class="built_in">cookie2user</span>(cookie_str)</span><br><span class="line">            <span class="keyword">if</span> user:</span><br><span class="line">                logging.<span class="built_in">info</span>(<span class="string">&#x27;set current user: %s&#x27;</span> % user.email)</span><br><span class="line">                request.__user__ = user</span><br><span class="line">        <span class="built_in">return</span> (yield from <span class="built_in">handler</span>(request))</span><br><span class="line">    <span class="keyword">return</span> auth</span><br><span class="line">    </span><br><span class="line"># 解密cookie:</span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def <span class="built_in">cookie2user</span>(cookie_str):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    Parse cookie <span class="keyword">and</span> load user <span class="keyword">if</span> cookie is valid.</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cookie_str:</span><br><span class="line">        <span class="keyword">return</span> None</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        L = cookie_str.<span class="built_in">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(L) != <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        uid, expires, sha1 = L</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(expires) &lt; time.<span class="built_in">time</span>():</span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        user = yield from User.<span class="built_in">find</span>(uid)</span><br><span class="line">        <span class="keyword">if</span> user is None:</span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        s = <span class="string">&#x27;%s-%s-%s-%s&#x27;</span> % (uid, user.passwd, expires, _COOKIE_KEY)</span><br><span class="line">        <span class="keyword">if</span> sha1 != hashlib.<span class="built_in">sha1</span>(s.<span class="built_in">encode</span>(<span class="string">&#x27;utf-8&#x27;</span>)).<span class="built_in">hexdigest</span>():</span><br><span class="line">            logging.<span class="built_in">info</span>(<span class="string">&#x27;invalid sha1&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> None</span><br><span class="line">        user.passwd = <span class="string">&#x27;******&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.<span class="built_in">exception</span>(e)</span><br><span class="line">        <span class="keyword">return</span> None</span><br></pre></td></tr></table></figure>

<p>这样，我们就完成了用户注册和登录的功能。</p>
<h2 id="编写日志创建页"><a href="#编写日志创建页" class="headerlink" title="编写日志创建页"></a>编写日志创建页</h2><p>在 Web 开发中，后端代码写起来其实是相当容易的。</p>
<p>例如，我们编写一个 REST API，用于创建一个 Blog：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">post</span>(<span class="string">&#x27;/api/blogs&#x27;</span>)</span><br><span class="line"><span class="function">def <span class="title">api_create_blog</span><span class="params">(request, *, name, summary, content)</span>:</span></span><br><span class="line"><span class="function">    check_admin(request)</span></span><br><span class="line"><span class="function">    if not name or not name.strip():</span></span><br><span class="line"><span class="function">        raise APIValueError(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name cannot be empty.&#x27;</span>)</span></span><br><span class="line"><span class="function">    if not summary or not summary.strip():</span></span><br><span class="line"><span class="function">        raise APIValueError(<span class="string">&#x27;summary&#x27;</span>, <span class="string">&#x27;summary cannot be empty.&#x27;</span>)</span></span><br><span class="line"><span class="function">    if not content or not content.strip():</span></span><br><span class="line"><span class="function">        raise APIValueError(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;content cannot be empty.&#x27;</span>)</span></span><br><span class="line"><span class="function">    blog =</span> <span class="built_in">Blog</span>(user_id=request.__user__.id, user_name=request.__user__.name, user_image=request.__user__.image, name=name.<span class="built_in">strip</span>(), summary=summary.<span class="built_in">strip</span>(), content=content.<span class="built_in">strip</span>())</span><br><span class="line">    yield from blog.<span class="built_in">save</span>()</span><br><span class="line">    <span class="keyword">return</span> blog</span><br></pre></td></tr></table></figure>

<p>编写后端 Python 代码不但很简单，而且非常容易测试，上面的 API：<code>api_create_blog()</code> 本身只是一个普通函数。</p>
<p>Web 开发真正困难的地方在于编写前端页面。前端页面需要混合 HTML、CSS 和 JavaScript，如果对这三者没有深入地掌握，编写的前端页面将很快难以维护。</p>
<p>更大的问题在于，前端页面通常是动态页面，也就是说，前端页面往往是由后端代码生成的。</p>
<p>生成前端页面最早的方式是拼接字符串：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&#x27;</span></span><br><span class="line">    + title</span><br><span class="line">    + <span class="string">&#x27;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#x27;</span></span><br><span class="line">    + body</span><br><span class="line">    + <span class="string">&#x27;&lt;/body&gt;&lt;/html&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>显然这种方式完全不具备可维护性。所以有第二种模板方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;&#123; body &#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>ASP、JSP、PHP 等都是用这种模板方式生成前端页面。</p>
<p>如果在页面上大量使用 JavaScript（事实上大部分页面都会），模板方式仍然会导致 JavaScript 代码与后端代码绑得非常紧密，以至于难以维护。其根本原因在于负责显示的 HTML DOM 模型与负责数据和交互的 JavaScript 代码没有分割清楚。</p>
<p>要编写可维护的前端代码绝非易事。和后端结合的 MVC 模式已经无法满足复杂页面逻辑的需要了，所以，新的 <a href="http://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a>：Model View ViewModel 模式应运而生。</p>
<p>MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var blog = &#123;</span><br><span class="line">        name: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">        summary: <span class="string">&#x27;this is summary&#x27;</span>,</span><br><span class="line">        content: <span class="string">&#x27;this is content...&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>View 是纯 HTML：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/api/blogs&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input name=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">    &lt;input name=<span class="string">&quot;summary&quot;</span>&gt;</span><br><span class="line">    &lt;textarea name=<span class="string">&quot;content&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;OK&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>由于 Model 表示数据，View 负责显示，两者做到了最大限度的分离。</p>
<p>把 Model 和 View 关联起来的就是 ViewModel。ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model。</p>
<p>ViewModel 如何编写？需要用 JavaScript 编写一个通用的 ViewModel，这样，就可以复用整个 MVVM 模型了。</p>
<p>好消息是已有许多成熟的 MVVM 框架，例如 AngularJS，KnockoutJS 等。我们选择 <a href="http://vuejs.org/">Vue</a> 这个简单易用的 MVVM 框架来实现创建 Blog 的页面 <code>templates/manage_blog_edit.html</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&#x27;__base__.html&#x27;</span> %&#125;</span><br><span class="line">&#123;% block title %&#125;编辑日志&#123;% endblock %&#125;</span><br><span class="line">&#123;% block beforehead %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var</span><br><span class="line">    ID = <span class="string">&#x27;&#123;&#123; id &#125;&#125;&#x27;</span>,</span><br><span class="line">    action = <span class="string">&#x27;&#123;&#123; action &#125;&#125;&#x27;</span>;</span><br><span class="line"><span class="function">function <span class="title">initVM</span><span class="params">(blog)</span> </span>&#123;</span><br><span class="line">    var vm = <span class="keyword">new</span> <span class="built_in">Vue</span>(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#vm&#x27;</span>,</span><br><span class="line">        data: blog,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            submit: <span class="built_in">function</span> (event) &#123;</span><br><span class="line">                event.<span class="built_in">preventDefault</span>();</span><br><span class="line">                var $form = $(<span class="string">&#x27;#vm&#x27;</span>).<span class="built_in">find</span>(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line">                $form.<span class="built_in">postJSON</span>(action, <span class="keyword">this</span>.$data, <span class="built_in">function</span> (err, r) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        $form.<span class="built_in">showFormError</span>(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> location.<span class="built_in">assign</span>(<span class="string">&#x27;/api/blogs/&#x27;</span> + r.id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">&#x27;#vm&#x27;</span>).<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="built_in">function</span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (ID) &#123;</span><br><span class="line">        <span class="built_in">getJSON</span>(<span class="string">&#x27;/api/blogs/&#x27;</span> + ID, <span class="built_in">function</span> (err, blog) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">fatal</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">            $(<span class="string">&#x27;#loading&#x27;</span>).<span class="built_in">hide</span>();</span><br><span class="line">            <span class="built_in">initVM</span>(blog);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">&#x27;#loading&#x27;</span>).<span class="built_in">hide</span>();</span><br><span class="line">        <span class="built_in">initVM</span>(&#123;</span><br><span class="line">            name: <span class="string">&#x27;&#x27;,</span></span><br><span class="line"><span class="string">            summary: &#x27;</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">            content: &#x27;</span>&#x27;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1 uk-margin-bottom&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-panel uk-panel-box&quot;</span>&gt;</span><br><span class="line">            &lt;ul <span class="keyword">class</span>=<span class="string">&quot;uk-breadcrumb&quot;</span>&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=<span class="string">&quot;/manage/comments&quot;</span>&gt;评论&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=<span class="string">&quot;/manage/blogs&quot;</span>&gt;日志&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=<span class="string">&quot;/manage/users&quot;</span>&gt;用户&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;error&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;loading&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1 uk-text-center&quot;</span>&gt;</span><br><span class="line">        &lt;span&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-spinner uk-icon-medium uk-icon-spin&quot;</span>&gt;&lt;/i&gt; 正在加载...&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;vm&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-2-3&quot;</span>&gt;</span><br><span class="line">        &lt;form v-on=<span class="string">&quot;submit: submit&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-form uk-form-stacked&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-alert uk-alert-danger uk-hidden&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-row&quot;</span>&gt;</span><br><span class="line">                &lt;label <span class="keyword">class</span>=<span class="string">&quot;uk-form-label&quot;</span>&gt;标题:&lt;/label&gt;</span><br><span class="line">                &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-controls&quot;</span>&gt;</span><br><span class="line">                    &lt;input v-model=<span class="string">&quot;name&quot;</span> name=<span class="string">&quot;name&quot;</span> type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;标题&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span>&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-row&quot;</span>&gt;</span><br><span class="line">                &lt;label <span class="keyword">class</span>=<span class="string">&quot;uk-form-label&quot;</span>&gt;摘要:&lt;/label&gt;</span><br><span class="line">                &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-controls&quot;</span>&gt;</span><br><span class="line">                    &lt;textarea v-model=<span class="string">&quot;summary&quot;</span> rows=<span class="string">&quot;4&quot;</span> name=<span class="string">&quot;summary&quot;</span> placeholder=<span class="string">&quot;摘要&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span> style=<span class="string">&quot;resize:none;&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-row&quot;</span>&gt;</span><br><span class="line">                &lt;label <span class="keyword">class</span>=<span class="string">&quot;uk-form-label&quot;</span>&gt;内容:&lt;/label&gt;</span><br><span class="line">                &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-controls&quot;</span>&gt;</span><br><span class="line">                    &lt;textarea v-model=<span class="string">&quot;content&quot;</span> rows=<span class="string">&quot;16&quot;</span> name=<span class="string">&quot;content&quot;</span> placeholder=<span class="string">&quot;内容&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span> style=<span class="string">&quot;resize:none;&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="keyword">class</span>=<span class="string">&quot;uk-form-row&quot;</span>&gt;</span><br><span class="line">                &lt;button type=<span class="string">&quot;submit&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-button uk-button-primary&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-save&quot;</span>&gt;&lt;/i&gt; 保存&lt;/button&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;/manage/blogs&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-button&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-times&quot;</span>&gt;&lt;/i&gt; 取消&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>初始化 Vue 时，我们指定 3 个参数：</p>
<p>el：根据选择器查找绑定的 View，这里是 <code>#vm</code>，就是 id 为 <code>vm</code> 的 DOM，对应的是一个 <code>&lt;div&gt;</code> 标签；</p>
<p>data：JavaScript 对象表示的 Model，我们初始化为 <code>&#123; name: &#39;&#39;, summary: &#39;&#39;, content: &#39;&#39;&#125;</code>；</p>
<p>methods：View 可以触发的 JavaScript 函数，<code>submit</code> 就是提交表单时触发的函数。</p>
<p>接下来，我们在 <code>&lt;form&gt;</code> 标签中，用几个简单的 <code>v-model</code>，就可以让 Vue 把 Model 和 View 关联起来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!-- input的value和Model的name关联起来了 --&gt;</span><br><span class="line">&lt;input v-model=<span class="string">&quot;name&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>Form 表单通过 <code>&lt;form v-on=&quot;submit: submit&quot;&gt;</code> 把提交表单的事件关联到 <code>submit</code> 方法。</p>
<p>需要特别注意的是，在 MVVM 中，Model 和 View 是双向绑定的。如果我们在 Form 中修改了文本框的值，可以在 Model 中立刻拿到新的值。试试在表单中输入文本，然后在 Chrome 浏览器中打开 JavaScript 控制台，可以通过 <code>vm.name</code> 访问单个属性，或者通过 <code>vm.$data</code> 访问整个 Model</p>
<p>如果我们在 JavaScript 逻辑中修改了 Model，这个修改会立刻反映到 View 上。试试在 JavaScript 控制台输入 <code>vm.name = &#39;MVVM简介&#39;</code>，可以看到文本框的内容自动被同步了</p>
<p>双向绑定是 MVVM 框架最大的作用。借助于 MVVM，我们把复杂的显示逻辑交给框架完成。由于后端编写了独立的 REST API，所以，前端用 AJAX 提交表单非常容易，前后端分离得非常彻底。</p>
<h2 id="日志列表页"><a href="#日志列表页" class="headerlink" title="日志列表页"></a>日志列表页</h2><p>MVVM 模式不但可用于 Form 表单，在复杂的管理页面中也能大显身手。例如，分页显示 Blog 的功能，我们先把后端代码写出来：</p>
<p>在 <code>apis.py</code> 中定义一个 <code>Page</code> 类用于存储分页信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Page</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self, item_count, page_index=</span><span class="number">1</span>, page_size=<span class="number">10</span>):</span><br><span class="line">        self.item_count = item_count</span><br><span class="line">        self.page_size = page_size</span><br><span class="line">        self.page_count = item_count <span class="comment">// page_size + (1 if item_count % page_size &gt; 0 else 0)</span></span><br><span class="line">        <span class="keyword">if</span> (item_count == <span class="number">0</span>) <span class="built_in">or</span> (page_index &gt; self.page_count):</span><br><span class="line">            self.offset = <span class="number">0</span></span><br><span class="line">            self.limit = <span class="number">0</span></span><br><span class="line">            self.page_index = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.page_index = page_index</span><br><span class="line">            self.offset = self.page_size * (page_index - <span class="number">1</span>)</span><br><span class="line">            self.limit = self.page_size</span><br><span class="line">        self.has_next = self.page_index &lt; self.page_count</span><br><span class="line">        self.has_previous = self.page_index &gt; <span class="number">1</span></span><br><span class="line">    def __str__(self):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;item_count: %s, page_count: %s, page_index: %s, page_size: %s, offset: %s, limit: %s&#x27;</span> % (self.item_count, self.page_count, self.page_index, self.page_size, self.offset, self.limit)</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>

<p>在 <code>handlers.py</code> 中实现 API：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">get</span>(<span class="string">&#x27;/api/blogs&#x27;</span>)</span><br><span class="line"><span class="function">def <span class="title">api_blogs</span><span class="params">(*, page=<span class="string">&#x27;1&#x27;</span>)</span>:</span></span><br><span class="line"><span class="function">    page_index =</span> <span class="built_in">get_page_index</span>(page)</span><br><span class="line">    num = yield from Blog.<span class="built_in">findNumber</span>(<span class="string">&#x27;count(id)&#x27;</span>)</span><br><span class="line">    p = <span class="built_in">Page</span>(num, page_index)</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dict</span>(page=p, blogs=())</span><br><span class="line">    blogs = yield from Blog.<span class="built_in">findAll</span>(orderBy=<span class="string">&#x27;created_at desc&#x27;</span>, limit=(p.offset, p.limit))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(page=p, blogs=blogs)</span><br></pre></td></tr></table></figure>

<p>管理页面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">get</span>(<span class="string">&#x27;/manage/blogs&#x27;</span>)</span><br><span class="line"><span class="function">def <span class="title">manage_blogs</span><span class="params">(*, page=<span class="string">&#x27;1&#x27;</span>)</span>:</span></span><br><span class="line"><span class="function">    return &#123;</span></span><br><span class="line">        <span class="string">&#x27;__template__&#x27;</span>: <span class="string">&#x27;manage_blogs.html&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;page_index&#x27;</span>: <span class="built_in">get_page_index</span>(page)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>模板页面首先通过 API：<code>GET /api/blogs?page=?</code> 拿到 Model：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;page&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;has_next&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;page_index&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;page_count&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;has_previous&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;item_count&quot;</span>: <span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;blogs&quot;</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，通过 Vue 初始化 MVVM：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function">function <span class="title">initVM</span><span class="params">(data)</span> </span>&#123;</span><br><span class="line">    var vm = <span class="keyword">new</span> <span class="built_in">Vue</span>(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#vm&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            blogs: data.blogs,</span><br><span class="line">            page: data.page</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            edit_blog: <span class="built_in">function</span> (blog) &#123;</span><br><span class="line">                location.<span class="built_in">assign</span>(<span class="string">&#x27;/manage/blogs/edit?id=&#x27;</span> + blog.id);</span><br><span class="line">            &#125;,</span><br><span class="line">            delete_blog: <span class="built_in">function</span> (blog) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">confirm</span>(<span class="string">&#x27;确认要删除“&#x27;</span> + blog.name + <span class="string">&#x27;”？删除后不可恢复！&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="built_in">postJSON</span>(<span class="string">&#x27;/api/blogs/&#x27;</span> + blog.id + <span class="string">&#x27;/delete&#x27;</span>, <span class="built_in">function</span> (err, r) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">alert</span>(err.message || err.error || err);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">refresh</span>();</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">&#x27;#vm&#x27;</span>).<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="built_in">function</span>() &#123;</span><br><span class="line">    <span class="built_in">getJSON</span>(<span class="string">&#x27;/api/blogs&#x27;</span>, &#123;</span><br><span class="line">        page: &#123;&#123; page_index &#125;&#125;</span><br><span class="line">    &#125;, <span class="built_in">function</span> (err, results) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fatal</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">&#x27;#loading&#x27;</span>).<span class="built_in">hide</span>();</span><br><span class="line">        <span class="built_in">initVM</span>(results);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>View 的容器是 <code>#vm</code>，包含一个 table，我们用 <code>v-repeat</code> 可以把 Model 的数组 <code>blogs</code> 直接变成多行的 <code>&lt;tr&gt;</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;vm&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-1&quot;</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;/manage/blogs/create&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uk-button uk-button-primary&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-plus&quot;</span>&gt;&lt;/i&gt; 新日志&lt;/a&gt;</span><br><span class="line">    &lt;table <span class="keyword">class</span>=<span class="string">&quot;uk-table uk-table-hover&quot;</span>&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;th <span class="keyword">class</span>=<span class="string">&quot;uk-width-5-10&quot;</span>&gt;标题 / 摘要&lt;/th&gt;</span><br><span class="line">                &lt;th <span class="keyword">class</span>=<span class="string">&quot;uk-width-2-10&quot;</span>&gt;作者&lt;/th&gt;</span><br><span class="line">                &lt;th <span class="keyword">class</span>=<span class="string">&quot;uk-width-2-10&quot;</span>&gt;创建时间&lt;/th&gt;</span><br><span class="line">                &lt;th <span class="keyword">class</span>=<span class="string">&quot;uk-width-1-10&quot;</span>&gt;操作&lt;/th&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">            &lt;tr v-repeat=<span class="string">&quot;blog: blogs&quot;</span> &gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a target=<span class="string">&quot;_blank&quot;</span> v-attr=<span class="string">&quot;href: &#x27;/blog/&#x27;+blog.id&quot;</span> v-text=<span class="string">&quot;blog.name&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a target=<span class="string">&quot;_blank&quot;</span> v-attr=<span class="string">&quot;href: &#x27;/user/&#x27;+blog.user_id&quot;</span> v-text=<span class="string">&quot;blog.user_name&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;span v-text=<span class="string">&quot;blog.created_at.toDateTime()&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a href=<span class="string">&quot;#0&quot;</span> v-on=<span class="string">&quot;click: edit_blog(blog)&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-edit&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">                    &lt;a href=<span class="string">&quot;#0&quot;</span> v-on=<span class="string">&quot;click: delete_blog(blog)&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;uk-icon-trash-o&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/tbody&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;div v-component=<span class="string">&quot;pagination&quot;</span> v-with=<span class="string">&quot;page&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>往 Model 的 <code>blogs</code> 数组中增加一个 Blog 元素，table 就神奇地增加了一行；把 <code>blogs</code> 数组的某个元素删除，table 就神奇地减少了一行。所有复杂的 Model-View 的映射逻辑全部由 MVVM 框架完成，我们只需要在 HTML 中写上 <code>v-repeat</code> 指令，就什么都不用管了。</p>
<p>可以把 <code>v-repeat=&quot;blog: blogs&quot;</code> 看成循环代码，所以，可以在一个 <code>&lt;tr&gt;</code> 内部引用循环变量 <code>blog</code>。<code>v-text</code> 和 <code>v-attr</code> 指令分别用于生成文本和 DOM 节点属性。</p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>现在，我们已经把一个 Web App 的框架完全搭建好了，从后端的 API 到前端的 MVVM，流程已经跑通了。</p>
<p>在继续工作前，注意到每次修改 Python 代码，都必须在命令行先 Ctrl-C 停止服务器，再重启，改动才能生效。</p>
<p>在开发阶段，每天都要修改、保存几十次代码，每次保存都手动来这么一下非常麻烦，严重地降低了我们的开发效率。有没有办法让服务器检测到代码修改后自动重新加载呢？</p>
<p>Django 的开发环境在 Debug 模式下就可以做到自动重新加载，如果我们编写的服务器也能实现这个功能，就能大大提升开发效率。</p>
<p>可惜的是，Django 没把这个功能独立出来，不用 Django 就享受不到，怎么办？</p>
<p>其实 Python 本身提供了重新载入模块的功能，但不是所有模块都能被重新载入。另一种思路是检测 <code>www</code> 目录下的代码改动，一旦有改动，就自动重启服务器。</p>
<p>按照这个思路，我们可以编写一个辅助程序 <code>pymonitor.py</code>，让它启动 <code>wsgiapp.py</code>，并时刻监控 <code>www</code> 目录下的代码改动，有改动时，先把当前 <code>wsgiapp.py</code> 进程杀掉，再重启，就完成了服务器进程的自动重启。</p>
<p>要监控目录文件的变化，我们也无需自己手动定时扫描，Python 的第三方库 <code>watchdog</code> 可以利用操作系统的 API 来监控目录文件的变化，并发送通知。我们先用 <code>pip</code> 安装：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ pip3 install watchdog</span><br></pre></td></tr></table></figure>

<p>利用 <code>watchdog</code> 接收文件变化的通知，如果是 <code>.py</code> 文件，就自动重启 <code>wsgiapp.py</code> 进程。</p>
<p>利用 Python 自带的 <code>subprocess</code> 实现进程的启动和终止，并把输入输出重定向到当前进程的输入输出中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf<span class="number">-8</span> -*-</span><br><span class="line">__author__ = <span class="string">&#x27;Michael Liao&#x27;</span></span><br><span class="line"><span class="keyword">import</span> os, sys, time, subprocess</span><br><span class="line">from watchdog.observers <span class="keyword">import</span> Observer</span><br><span class="line">from watchdog.events <span class="keyword">import</span> FileSystemEventHandler</span><br><span class="line">def <span class="built_in">log</span>(s):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[Monitor] %s&#x27;</span> % s)</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">MyFileSystemEventHander</span>(FileSystemEventHandler):</span><br><span class="line">    def __init__(self, fn):</span><br><span class="line">        <span class="built_in">super</span>(MyFileSystemEventHander, self).__init__()</span><br><span class="line">        self.restart = fn</span><br><span class="line">    def <span class="built_in">on_any_event</span>(self, event):</span><br><span class="line">        <span class="keyword">if</span> event.src_path.<span class="built_in">endswith</span>(<span class="string">&#x27;.py&#x27;</span>):</span><br><span class="line">            <span class="built_in">log</span>(<span class="string">&#x27;Python source file changed: %s&#x27;</span> % event.src_path)</span><br><span class="line">            self.<span class="built_in">restart</span>()</span><br><span class="line">command = [<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;ok&#x27;</span>]</span><br><span class="line">process = None</span><br><span class="line">def <span class="built_in">kill_process</span>():</span><br><span class="line">    global process</span><br><span class="line">    <span class="keyword">if</span> process:</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&#x27;Kill process [%s]...&#x27;</span> % process.pid)</span><br><span class="line">        process.<span class="built_in">kill</span>()</span><br><span class="line">        process.<span class="built_in">wait</span>()</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&#x27;Process ended with code %s.&#x27;</span> % process.returncode)</span><br><span class="line">        process = None</span><br><span class="line">def <span class="built_in">start_process</span>():</span><br><span class="line">    global process, command</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&#x27;Start process %s...&#x27;</span> % <span class="string">&#x27; &#x27;</span>.<span class="built_in">join</span>(command))</span><br><span class="line">    process = subprocess.<span class="built_in">Popen</span>(command, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)</span><br><span class="line">def <span class="built_in">restart_process</span>():</span><br><span class="line">    <span class="built_in">kill_process</span>()</span><br><span class="line">    <span class="built_in">start_process</span>()</span><br><span class="line">def <span class="built_in">start_watch</span>(path, callback):</span><br><span class="line">    observer = <span class="built_in">Observer</span>()</span><br><span class="line">    observer.<span class="built_in">schedule</span>(<span class="built_in">MyFileSystemEventHander</span>(restart_process), path, recursive=True)</span><br><span class="line">    observer.<span class="built_in">start</span>()</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&#x27;Watching directory %s...&#x27;</span> % path)</span><br><span class="line">    <span class="built_in">start_process</span>()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            time.<span class="built_in">sleep</span>(<span class="number">0.5</span>)</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        observer.<span class="built_in">stop</span>()</span><br><span class="line">    observer.<span class="built_in">join</span>()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    argv = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> argv:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Usage: ./pymonitor your-script.py&#x27;</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> argv[<span class="number">0</span>] != <span class="string">&#x27;python3&#x27;</span>:</span><br><span class="line">        argv.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&#x27;python3&#x27;</span>)</span><br><span class="line">    command = argv</span><br><span class="line">    path = os.path.<span class="built_in">abspath</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="built_in">start_watch</span>(path, None)</span><br></pre></td></tr></table></figure>

<p>一共 70 行左右的代码，就实现了 Debug 模式的自动重新加载。用下面的命令启动服务器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ python3 pymonitor.py wsgiapp.py</span><br></pre></td></tr></table></figure>

<p>或者给 <code>pymonitor.py</code> 加上可执行权限，启动服务器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ./pymonitor.py app.py</span><br></pre></td></tr></table></figure>

<p>在编辑器中打开一个 <code>.py</code> 文件，修改后保存，看看命令行输出，是不是自动重启了服务器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ./pymonitor.py app.py </span><br><span class="line">[Monitor] Watching directory /Users/michael/Github/awesome-python3-webapp/www...</span><br><span class="line">[Monitor] Start process python app.py...</span><br><span class="line">...</span><br><span class="line">INFO:root:<span class="built_in">application</span> (/Users/michael/Github/awesome-python3-webapp/www) will start at <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9000.</span>..</span><br><span class="line">[Monitor] Python source file changed: /Users/michael/Github/awesome-python-webapp/www/handlers.py</span><br><span class="line">[Monitor] Kill process [<span class="number">2747</span>]...</span><br><span class="line">[Monitor] Process ended with code <span class="number">-9.</span></span><br><span class="line">[Monitor] Start process python app.py...</span><br><span class="line">...</span><br><span class="line">INFO:root:<span class="built_in">application</span> (/Users/michael/Github/awesome-python3-webapp/www) will start at <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9000.</span>..</span><br></pre></td></tr></table></figure>

<p>现在，只要一保存代码，就可以刷新浏览器看到效果，大大提升了开发效率。</p>
<h2 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h2><p>在 Web App 框架和基本流程跑通后，剩下的工作全部是体力活了：在 Debug 开发模式下完成后端所有 API、前端所有页面。我们需要做的事情包括：</p>
<p>把当前用户绑定到 <code>request</code> 上，并对 URL<code>/manage/</code> 进行拦截，检查当前用户是否是管理员身份：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@asyncio.<span class="function">coroutine</span></span><br><span class="line"><span class="function">def <span class="title">auth_factory</span><span class="params">(app, handler)</span>:</span></span><br><span class="line"><span class="function">    @asyncio.coroutine</span></span><br><span class="line"><span class="function">    def auth(request):</span></span><br><span class="line"><span class="function">        logging.info(<span class="string">&#x27;check user: %s %s&#x27;</span> % (request.method, request.path))</span></span><br><span class="line"><span class="function">        request.__user__ =</span> None</span><br><span class="line">        cookie_str = request.cookies.<span class="built_in">get</span>(COOKIE_NAME)</span><br><span class="line">        <span class="keyword">if</span> cookie_str:</span><br><span class="line">            user = yield from <span class="built_in">cookie2user</span>(cookie_str)</span><br><span class="line">            <span class="keyword">if</span> user:</span><br><span class="line">                logging.<span class="built_in">info</span>(<span class="string">&#x27;set current user: %s&#x27;</span> % user.email)</span><br><span class="line">                request.__user__ = user</span><br><span class="line">        <span class="keyword">if</span> request.path.<span class="built_in">startswith</span>(<span class="string">&#x27;/manage/&#x27;</span>) <span class="built_in">and</span> (request.__user__ is None <span class="keyword">or</span> <span class="keyword">not</span> request.__user__.admin):</span><br><span class="line">            <span class="keyword">return</span> web.<span class="built_in">HTTPFound</span>(<span class="string">&#x27;/signin&#x27;</span>)</span><br><span class="line">        <span class="built_in">return</span> (yield from <span class="built_in">handler</span>(request))</span><br><span class="line">    <span class="keyword">return</span> auth</span><br></pre></td></tr></table></figure>

<p>后端 API 包括：</p>
<ul>
<li>获取日志：GET &#x2F;api&#x2F;blogs</li>
<li>创建日志：POST &#x2F;api&#x2F;blogs</li>
<li>修改日志：POST &#x2F;api&#x2F;blogs&#x2F;:blog_id</li>
<li>删除日志：POST &#x2F;api&#x2F;blogs&#x2F;:blog_id&#x2F;delete</li>
<li>获取评论：GET &#x2F;api&#x2F;comments</li>
<li>创建评论：POST &#x2F;api&#x2F;blogs&#x2F;:blog_id&#x2F;comments</li>
<li>删除评论：POST &#x2F;api&#x2F;comments&#x2F;:comment_id&#x2F;delete</li>
<li>创建新用户：POST &#x2F;api&#x2F;users</li>
<li>获取用户：GET &#x2F;api&#x2F;users<br>管理页面包括：</li>
<li>评论列表页：GET &#x2F;manage&#x2F;comments</li>
<li>日志列表页：GET &#x2F;manage&#x2F;blogs</li>
<li>创建日志页：GET &#x2F;manage&#x2F;blogs&#x2F;create</li>
<li>修改日志页：GET &#x2F;manage&#x2F;blogs&#x2F;</li>
<li>用户列表页：GET &#x2F;manage&#x2F;users<br>用户浏览页面包括：</li>
<li>注册页：GET &#x2F;register</li>
<li>登录页：GET &#x2F;signin</li>
<li>注销页：GET &#x2F;signout</li>
<li>首页：GET &#x2F;</li>
<li>日志详情页：GET &#x2F;blog&#x2F;:blog_id<br>把所有的功能实现，我们第一个 Web App 就宣告完成！</li>
</ul>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>很多做开发的同学把部署这件事情看成是运维同学的工作，这种看法是完全错误的。首先，最近流行 <a href="http://zh.wikipedia.org/wiki/DevOps">DevOps</a> 理念，就是说，开发和运维要变成一个整体。其次，运维的难度，其实跟开发质量有很大的关系。代码写得垃圾，运维再好也架不住天天挂掉。最后，DevOps 理念需要把运维、监控等功能融入到开发中。你想服务器升级时不中断用户服务？那就得在开发时考虑到这一点。</p>
<p>下面，我们就来把 awesome-python3-webapp 部署到 Linux 服务器。</p>
<h3 id="搭建-Linux-服务器"><a href="#搭建-Linux-服务器" class="headerlink" title="搭建 Linux 服务器"></a>搭建 Linux 服务器</h3><p>要部署到 Linux，首先得有一台 Linux 服务器。要在公网上体验的同学，可以在 Amazon 的 <a href="http://aws.amazon.com/">AWS</a> 申请一台 EC2 虚拟机（免费使用 1 年），或者使用国内的一些云服务器，一般都提供 Ubuntu Server 的镜像。想在本地部署的同学，请安装虚拟机，推荐使用 <a href="https://www.virtualbox.org/">VirtualBox</a>。</p>
<p>我们选择的 Linux 服务器版本是 <a href="http://www.ubuntu.com/download/server">Ubuntu Server 14.04 LTS</a>，原因是 apt 太简单了。如果你准备使用其他 Linux 版本，也没有问题。</p>
<p>Linux 安装完成后，请确保 ssh 服务正在运行，否则，需要通过 apt 安装：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>有了 ssh 服务，就可以从本地连接到服务器上。建议把公钥复制到服务器端用户的 <code>.ssh/authorized_keys</code> 中，这样，就可以通过证书实现无密码连接。</p>
<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>利用 Python 自带的 asyncio，我们已经编写了一个异步高性能服务器。但是，我们还需要一个高性能的 Web 服务器，这里选择 Nginx，它可以处理静态资源，同时作为反向代理把动态请求交给 Python 代码处理。这个模型如下</p>
<p>Nginx 负责分发请求</p>
<p>在服务器端，我们需要定义好部署的目录结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">+- srv/</span><br><span class="line">   +- awesome/       &lt;-- Web App根目录</span><br><span class="line">      +- www/        &lt;-- 存放Python源码</span><br><span class="line">      |  +- <span class="type">static</span>/  &lt;-- 存放静态资源文件</span><br><span class="line">      +- log/        &lt;-- 存放log</span><br></pre></td></tr></table></figure>

<p>在服务器上部署，要考虑到新版本如果运行不正常，需要回退到旧版本时怎么办。每次用新的代码覆盖掉旧的文件是不行的，需要一个类似版本控制的机制。由于 Linux 系统提供了软链接功能，所以，我们把 <code>www</code> 作为一个软链接，它指向哪个目录，哪个目录就是当前运行的版本</p>
<p>而 Nginx 和 python 代码的配置文件只需要指向 <code>www</code> 目录即可。</p>
<p>Nginx 可以作为服务进程直接启动，但 <code>app.py</code> 还不行，所以，<a href="http://supervisord.org/">Supervisor</a> 登场！Supervisor 是一个管理进程的工具，可以随系统启动而启动服务，它还时刻监控服务进程，如果服务进程意外退出，Supervisor 可以自动重启服务。</p>
<p>总结一下我们需要用到的服务有：</p>
<ul>
<li>Nginx：高性能 Web 服务器 + 负责反向代理；</li>
<li>Supervisor：监控服务进程的工具；</li>
<li>MySQL：数据库服务。<br>在 Linux 服务器上用 apt 可以直接安装上述服务：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install nginx supervisor python3 mysql-server</span><br></pre></td></tr></table></figure>

<p>然后，再把我们自己的 Web App 用到的 Python 库安装了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ sudo pip3 install jinja2 aiomysql aiohttp</span><br></pre></td></tr></table></figure>

<p>在服务器上创建目录 <code>/srv/awesome/</code> 以及相应的子目录。</p>
<p>在服务器上初始化 MySQL 数据库，把数据库初始化脚本 <code>schema.sql</code> 复制到服务器上执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p &lt; schema.sql</span><br></pre></td></tr></table></figure>

<p>服务器端准备就绪。</p>
<h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><p>用 FTP 还是 SCP 还是 rsync 复制文件？如果你需要手动复制，用一次两次还行，一天如果部署 50 次不但慢、效率低，而且容易出错。</p>
<p>正确的部署方式是使用工具配合脚本完成自动化部署。<a href="http://www.fabfile.org/">Fabric</a> 就是一个自动化部署工具。由于 Fabric 是用 Python 2.x 开发的，所以，部署脚本要用 Python 2.7 来编写，本机还必须安装 Python 2.7 版本。</p>
<p>要用 Fabric 部署，需要在本机（是开发机器，不是 Linux 服务器）安装 Fabric：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ easy_install fabric</span><br></pre></td></tr></table></figure>

<p>Linux 服务器上不需要安装 Fabric，Fabric 使用 SSH 直接登录服务器并执行部署命令。</p>
<p>下一步是编写部署脚本。Fabric 的部署脚本叫 <code>fabfile.py</code>，我们把它放到 <code>awesome-python-webapp</code> 的目录下，与 <code>www</code> 目录平级：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">awesome-python-webapp/</span><br><span class="line">+- fabfile.py</span><br><span class="line">+- www/</span><br><span class="line">+- ...</span><br></pre></td></tr></table></figure>

<p>Fabric 的脚本编写很简单，首先导入 Fabric 的 API，设置部署时的变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># fabfile.py</span></span><br><span class="line"><span class="keyword">import</span> os, re</span><br><span class="line">from datetime <span class="keyword">import</span> datetime</span><br><span class="line"># 导入Fabric API:</span><br><span class="line">from fabric.api <span class="keyword">import</span> *</span><br><span class="line"># 服务器登录用户名:</span><br><span class="line">env.user = <span class="string">&#x27;michael&#x27;</span></span><br><span class="line"><span class="meta"># sudo用户为root:</span></span><br><span class="line">env.sudo_user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line"># 服务器地址，可以有多个，依次部署:</span><br><span class="line">env.hosts = [<span class="string">&#x27;192.168.0.3&#x27;</span>]</span><br><span class="line"># 服务器MySQL用户名和口令:</span><br><span class="line">db_user = <span class="string">&#x27;www-data&#x27;</span></span><br><span class="line">db_password = <span class="string">&#x27;www-data&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，每个 Python 函数都是一个任务。我们先编写一个打包的任务：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_TAR_FILE = <span class="string">&#x27;dist-awesome.tar.gz&#x27;</span></span><br><span class="line">def <span class="built_in">build</span>():</span><br><span class="line">    includes = [<span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;templates&#x27;</span>, <span class="string">&#x27;transwarp&#x27;</span>, <span class="string">&#x27;favicon.ico&#x27;</span>, <span class="string">&#x27;*.py&#x27;</span>]</span><br><span class="line">    excludes = [<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;.*&#x27;</span>, <span class="string">&#x27;*.pyc&#x27;</span>, <span class="string">&#x27;*.pyo&#x27;</span>]</span><br><span class="line">    <span class="built_in">local</span>(<span class="string">&#x27;rm -f dist/%s&#x27;</span> % _TAR_FILE)</span><br><span class="line">    with <span class="built_in">lcd</span>(os.path.<span class="built_in">join</span>(os.path.<span class="built_in">abspath</span>(<span class="string">&#x27;.&#x27;</span>), <span class="string">&#x27;www&#x27;</span>)):</span><br><span class="line">        cmd = [<span class="string">&#x27;tar&#x27;</span>, <span class="string">&#x27;--dereference&#x27;</span>, <span class="string">&#x27;-czvf&#x27;</span>, <span class="string">&#x27;../dist/%s&#x27;</span> % _TAR_FILE]</span><br><span class="line">        cmd.<span class="built_in">extend</span>([<span class="string">&#x27;--exclude=\&#x27;</span>%s\<span class="string">&#x27;&#x27; % ex for ex in excludes])</span></span><br><span class="line"><span class="string">        cmd.extend(includes)</span></span><br><span class="line"><span class="string">        local(&#x27;</span> <span class="string">&#x27;.join(cmd))</span></span><br></pre></td></tr></table></figure>

<p>Fabric 提供 <code>local(&#39;...&#39;)</code> 来运行本地命令，<code>with lcd(path)</code> 可以把当前命令的目录设定为 <code>lcd()</code> 指定的目录，注意 Fabric 只能运行命令行命令，Windows 下可能需要 <a href="http://cygwin.com/">Cgywin</a> 环境。</p>
<p>在 <code>awesome-python-webapp</code> 目录下运行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ fab build</span><br></pre></td></tr></table></figure>

<p>看看是否在 <code>dist</code> 目录下创建了 <code>dist-awesome.tar.gz</code> 的文件。</p>
<p>打包后，我们就可以继续编写 <code>deploy</code> 任务，把打包文件上传至服务器，解压，重置 <code>www</code> 软链接，重启相关服务：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_REMOTE_TMP_TAR = <span class="string">&#x27;/tmp/%s&#x27;</span> % _TAR_FILE</span><br><span class="line">_REMOTE_BASE_DIR = <span class="string">&#x27;/srv/awesome&#x27;</span></span><br><span class="line">def <span class="built_in">deploy</span>():</span><br><span class="line">    newdir = <span class="string">&#x27;www-%s&#x27;</span> % datetime.<span class="built_in">now</span>().<span class="built_in">strftime</span>(<span class="string">&#x27;%y-%m-%d_%H.%M.%S&#x27;</span>)</span><br><span class="line">    # 删除已有的tar文件:</span><br><span class="line">    <span class="built_in">run</span>(<span class="string">&#x27;rm -f %s&#x27;</span> % _REMOTE_TMP_TAR)</span><br><span class="line">    # 上传新的tar文件:</span><br><span class="line">    <span class="built_in">put</span>(<span class="string">&#x27;dist/%s&#x27;</span> % _TAR_FILE, _REMOTE_TMP_TAR)</span><br><span class="line">    # 创建新目录:</span><br><span class="line">    with <span class="built_in">cd</span>(_REMOTE_BASE_DIR):</span><br><span class="line">        <span class="built_in">sudo</span>(<span class="string">&#x27;mkdir %s&#x27;</span> % newdir)</span><br><span class="line">    # 解压到新目录:</span><br><span class="line">    with <span class="built_in">cd</span>(<span class="string">&#x27;%s/%s&#x27;</span> % (_REMOTE_BASE_DIR, newdir)):</span><br><span class="line">        <span class="built_in">sudo</span>(<span class="string">&#x27;tar -xzvf %s&#x27;</span> % _REMOTE_TMP_TAR)</span><br><span class="line">    # 重置软链接:</span><br><span class="line">    with <span class="built_in">cd</span>(_REMOTE_BASE_DIR):</span><br><span class="line">        <span class="built_in">sudo</span>(<span class="string">&#x27;rm -f www&#x27;</span>)</span><br><span class="line">        <span class="built_in">sudo</span>(<span class="string">&#x27;ln -s %s www&#x27;</span> % newdir)</span><br><span class="line">        <span class="built_in">sudo</span>(<span class="string">&#x27;chown www-data:www-data www&#x27;</span>)</span><br><span class="line">        <span class="built_in">sudo</span>(<span class="string">&#x27;chown -R www-data:www-data %s&#x27;</span> % newdir)</span><br><span class="line">    # 重启Python服务和nginx服务器:</span><br><span class="line">    with <span class="built_in">settings</span>(warn_only=True):</span><br><span class="line">        <span class="built_in">sudo</span>(<span class="string">&#x27;supervisorctl stop awesome&#x27;</span>)</span><br><span class="line">        <span class="built_in">sudo</span>(<span class="string">&#x27;supervisorctl start awesome&#x27;</span>)</span><br><span class="line">        <span class="built_in">sudo</span>(<span class="string">&#x27;/etc/init.d/nginx reload&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意 <code>run()</code> 函数执行的命令是在服务器上运行，<code>with cd(path)</code> 和 <code>with lcd(path)</code> 类似，把当前目录在服务器端设置为 <code>cd()</code> 指定的目录。如果一个命令需要 sudo 权限，就不能用 <code>run()</code>，而是用 <code>sudo()</code> 来执行。</p>
<h3 id="配置-Supervisor"><a href="#配置-Supervisor" class="headerlink" title="配置 Supervisor"></a>配置 Supervisor</h3><p>上面让 Supervisor 重启 awesome 的命令会失败，因为我们还没有配置 Supervisor 呢。</p>
<p>编写一个 Supervisor 的配置文件 <code>awesome.conf</code>，存放到 <code>/etc/supervisor/conf.d/</code> 目录下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[program:awesome]</span><br><span class="line">command     = /srv/awesome/www/app.py</span><br><span class="line">directory   = /srv/awesome/www</span><br><span class="line">user        = www-data</span><br><span class="line">startsecs   = <span class="number">3</span></span><br><span class="line">redirect_stderr         = <span class="literal">true</span></span><br><span class="line">stdout_logfile_maxbytes = <span class="number">50</span>MB</span><br><span class="line">stdout_logfile_backups  = <span class="number">10</span></span><br><span class="line">stdout_logfile          = /srv/awesome/log/app.log</span><br></pre></td></tr></table></figure>

<p>配置文件通过 <code>[program:awesome]</code> 指定服务名为 <code>awesome</code>，<code>command</code> 指定启动 <code>app.py</code>。</p>
<p>然后重启 Supervisor 后，就可以随时启动和停止 Supervisor 管理的服务了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ sudo supervisorctl reload</span><br><span class="line">$ sudo supervisorctl start awesome</span><br><span class="line">$ sudo supervisorctl status</span><br><span class="line">awesome                RUNNING    pid <span class="number">1401</span>, uptime <span class="number">5</span>:<span class="number">01</span>:<span class="number">34</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3><p>Supervisor 只负责运行 <code>app.py</code>，我们还需要配置 Nginx。把配置文件 <code>awesome</code> 放到 <code>/etc/nginx/sites-available/</code> 目录下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      <span class="number">80</span>; # 监听<span class="number">80</span>端口</span><br><span class="line">    root       /srv/awesome/www;</span><br><span class="line">    access_log /srv/awesome/log/access_log;</span><br><span class="line">    error_log  /srv/awesome/log/error_log;</span><br><span class="line">    # server_name awesome.liaoxuefeng.com; # 配置域名</span><br><span class="line">    # 处理静态文件/favicon.ico:</span><br><span class="line">    location /favicon.ico &#123;</span><br><span class="line">        root /srv/awesome/www;</span><br><span class="line">    &#125;</span><br><span class="line">    # 处理静态资源:</span><br><span class="line">    location ~ ^\/<span class="type">static</span>\/.*$ &#123;</span><br><span class="line">        root /srv/awesome/www;</span><br><span class="line">    &#125;</span><br><span class="line">    # 动态请求转发到<span class="number">9000</span>端口:</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass       http:<span class="comment">//127.0.0.1:9000;</span></span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>/etc/nginx/sites-enabled/</code> 目录下创建软链接：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/etc/nginx/sites-enabled</span><br><span class="line">$ sudo ln -s /etc/nginx/sites-available/awesome .</span><br></pre></td></tr></table></figure>

<p>让 Nginx 重新加载配置文件，不出意外，我们的 <code>awesome-python3-webapp</code> 应该正常运行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ sudo /etc/init.d/nginx reload</span><br></pre></td></tr></table></figure>

<p>如果有任何错误，都可以在 <code>/srv/awesome/log</code> 下查找 Nginx 和 App 本身的 log。如果 Supervisor 启动时报错，可以在 <code>/var/log/supervisor</code> 下查看 Supervisor 的 log。</p>
<p>如果一切顺利，你可以在浏览器中访问 Linux 服务器上的 <code>awesome-python3-webapp</code> 了</p>
<p>如果在开发环境更新了代码，只需要在命令行执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ fab build</span><br><span class="line">$ fab deploy</span><br></pre></td></tr></table></figure>

<p>自动部署完成！刷新浏览器就可以看到服务器代码更新后的效果。</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>利用chardet识别文件编码</title>
    <url>/2024/09/23/1-%E8%AF%AD%E8%A8%80-Python-%E5%88%A9%E7%94%A8chardet%E8%AF%86%E5%88%AB%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>常见编码格式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ASCII, UTF<span class="number">-8</span>, UTF<span class="number">-16</span> (<span class="number">2</span> variants), UTF<span class="number">-32</span> (<span class="number">4</span> variants)</span><br><span class="line"></span><br><span class="line">Big5, GB2312, EUC-TW, HZ-GB<span class="number">-2312</span>, ISO<span class="number">-2022</span>-<span class="built_in">CN</span> (Traditional <span class="keyword">and</span> Simplified Chinese)</span><br><span class="line"></span><br><span class="line">EUC-JP, SHIFT_JIS, CP932, ISO<span class="number">-2022</span>-<span class="built_in">JP</span> (Japanese)</span><br><span class="line"></span><br><span class="line">EUC-KR, ISO<span class="number">-2022</span>-<span class="built_in">KR</span> (Korean)</span><br><span class="line"></span><br><span class="line">KOI8-R, MacCyrillic, IBM855, IBM866, ISO<span class="number">-8859</span><span class="number">-5</span>, windows<span class="number">-1251</span> (Cyrillic)</span><br><span class="line"></span><br><span class="line">ISO<span class="number">-8859</span><span class="number">-5</span>, windows<span class="number">-1251</span> (Bulgarian)</span><br><span class="line"></span><br><span class="line">ISO<span class="number">-8859</span><span class="number">-1</span>, windows<span class="number">-1252</span> (Western European languages)</span><br><span class="line"></span><br><span class="line">ISO<span class="number">-8859</span><span class="number">-7</span>, windows<span class="number">-1253</span> (Greek)</span><br><span class="line"></span><br><span class="line">ISO<span class="number">-8859</span><span class="number">-8</span>, windows<span class="number">-1255</span> (Visual <span class="keyword">and</span> Logical Hebrew)</span><br><span class="line"></span><br><span class="line">TIS<span class="number">-620</span> (Thai)</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"></span><br><span class="line">open_file = <span class="built_in">open</span>(file=<span class="string">&quot;miui.cpp&quot;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) # 以二进制模式读取文件</span><br><span class="line">data = open_file.<span class="built_in">read</span>() # 获取文件内容</span><br><span class="line"><span class="built_in">print</span>(data) </span><br><span class="line">open_file.<span class="built_in">close</span>() # 关闭文件</span><br><span class="line"></span><br><span class="line">result = chardet.<span class="built_in">detect</span>(data) # 检测文件内容</span><br><span class="line"><span class="built_in">print</span>(result)  #&#123;<span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;confidence&#x27;</span>: <span class="number">0.99</span>, <span class="string">&#x27;language&#x27;</span>: <span class="string">&#x27;&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span>     表示检测到文件的编码格式为utf<span class="number">-8</span></span><br><span class="line"><span class="string">&#x27;confidence&#x27;</span>: <span class="number">0.99</span>       表示可信度为百分之九十九</span><br><span class="line"><span class="string">&#x27;language&#x27;</span>: <span class="string">&#x27;&#x27;          表示文件内容的语言</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>设置flask后端CORS跨域访问</title>
    <url>/2024/05/22/1-%E8%AF%AD%E8%A8%80-Python-%E8%AE%BE%E7%BD%AEflask%E5%90%8E%E7%AB%AFCORS%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>设置前后端分离</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>flask 项目地址 <a href="https://tutorial.helloflask.com/">https://tutorial.helloflask.com/</a></p>
<p>安装 flask 和 flask-cors</p>
<p>cors 用于允许服务器进行跨域访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pip install flask</span><br><span class="line">pip install flask-cors</span><br></pre></td></tr></table></figure>

<h1 id="浏览器-js-前端代码"><a href="#浏览器-js-前端代码" class="headerlink" title="浏览器 js 前端代码"></a>浏览器 js 前端代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SendUrlToServer</span>(<span class="params">url, method</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> requestUrl = <span class="string">&#x27;http://124.222.246.202:8081/fetch-sub-url?url=&#x27;</span>+url;</span><br><span class="line">	<span class="comment">/*let requestUrl = ?url=&#x27;http://127.0.0.1:8081/fetch-sub-url*/</span></span><br><span class="line">	<span class="title function_">fetch</span>(requestUrl, &#123;</span><br><span class="line">	<span class="attr">method</span>: method,</span><br><span class="line">	<span class="attr">headers</span>: &#123;</span><br><span class="line">	<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">/*body: JSON.stringify(&#123; url: url &#125;)*/</span></span><br><span class="line">	&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Response from server:&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error sending data:&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">RSS</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title class_">SendUrlToServer</span>(<span class="string">&quot;https://rsshub.app/bilibili/ranking/0/3/1&quot;</span>, <span class="string">&#x27;GET&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="服务器端-python-代码"><a href="#服务器端-python-代码" class="headerlink" title="服务器端 python 代码"></a>服务器端 python 代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="comment">##get python path</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">python_path = os.environ.get(<span class="string">&quot;PYTHONPATH&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PYTHONPATH:&quot;</span>, python_path)</span><br><span class="line"><span class="comment">##get end</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment">#CORS(app, resources=&#123;r&quot;/*&quot;: &#123;&quot;origins&quot;: &quot;http://127.0.0.1:80&quot;&#125;&#125;)  # 允许指定的来源访问</span></span><br><span class="line">CORS(app)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/fetch-sub-url&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_sub_url</span>():</span><br><span class="line">    <span class="comment">#data = request.get_json()</span></span><br><span class="line">    <span class="comment">#url = data.get(&#x27;url&#x27;)</span></span><br><span class="line">    <span class="comment">#url = &#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    url = request.args.get(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;current url is ===&gt;&quot;</span>+url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        response_text = response.text</span><br><span class="line">        <span class="keyword">return</span> response_text</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;error&#x27;</span>: <span class="built_in">str</span>(e)&#125;)</span><br><span class="line">    <span class="comment"># 解析RSS feed</span></span><br><span class="line">    <span class="comment">#feed = feedparser.parse(url)</span></span><br><span class="line">    <span class="comment"># 打印feed的标题</span></span><br><span class="line">    <span class="comment">#print(&quot;Feed Title:&quot;, feed.feed.title)</span></span><br><span class="line">    <span class="comment"># 打印feed中的条目</span></span><br><span class="line">    <span class="comment">#for entry in feed.entries:</span></span><br><span class="line">    <span class="comment">#    print(&quot;\nTitle:&quot;, entry.title)</span></span><br><span class="line">    <span class="comment">#    print(&quot;Link:&quot;, entry.link)</span></span><br><span class="line">    <span class="comment">#    print(&quot;description:&quot;, entry.description)</span></span><br><span class="line">    <span class="comment">#return feed</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8081</span>)</span><br></pre></td></tr></table></figure>

<h1 id="后端服务开机自启-systemd"><a href="#后端服务开机自启-systemd" class="headerlink" title="后端服务开机自启 systemd"></a>后端服务开机自启 systemd</h1><p>&#x2F;etc&#x2F;systemd&#x2F;system 启动</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Start Python BackEnd With Html</span><br><span class="line">After=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/home/ubuntu</span><br><span class="line">Type=idle</span><br><span class="line">#ExecStart=/home/ubuntu/html/BackEnd/start_backend.sh</span><br><span class="line">ExecStart=/usr/bin/python3 /home/ubuntu/html/BackEnd/main.py</span><br><span class="line">User=ubuntu</span><br><span class="line">Group=ubuntu</span><br><span class="line">Environment=<span class="string">&quot;PYTHONPATH=/home/ubuntu/.local/lib/python3.10/site-packages&quot;</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>将服务单元文件复制到 systemd 目录： 将您的服务单元文件复制到&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;目录下。您可以使用 sudo 命令进行拷贝，确保文件的权限设置正确。</p>
<p><code>sudo cp your-service-name.service /etc/systemd/system/</code></p>
<p>重新加载 systemd 配置： 您需要重新加载 systemd 配置以使更改生效。</p>
<p><code>sudo systemctl daemon-reload</code></p>
<p>启用服务： 要启用服务，使其在系统启动时自动启动，可以运行以下命令：</p>
<p><code>sudo systemctl enable your-service-name.service</code></p>
<p>这将会在适当的运行级别下创建符号链接，以便服务在系统启动时自动启动。</p>
<p>启动服务： 如果您想立即启动服务，可以运行以下命令：</p>
<p><code>sudo systemctl start your-service-name.service</code></p>
<p>这将启动您的服务。</p>
<p>完整后端处理代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, make_response, jsonify</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"><span class="keyword">from</span> werkzeug.middleware.proxy_fix <span class="keyword">import</span> ProxyFix</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> xmltodict</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"><span class="comment"># root_dir = &#x27;/home/ubuntu/html/&#x27;</span></span><br><span class="line"><span class="comment"># pic_dir = &#x27;0.res/Picture/&#x27;</span></span><br><span class="line"><span class="comment"># name = &#x27;1&#x27;#request.args.get(&#x27;id&#x27;)</span></span><br><span class="line"><span class="comment"># act_addr = os.path.join(root_dir,pic_dir,name);</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fileNameList = &#x27;&#x27;</span></span><br><span class="line"><span class="comment"># for file_name in os.listdir(act_addr):</span></span><br><span class="line"><span class="comment">#     fileNameList += pic_dir+name+&quot;/&quot;+file_name</span></span><br><span class="line"><span class="comment"># print(fileNameList)</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.wsgi_app = ProxyFix(app.wsgi_app)</span><br><span class="line"><span class="comment"># 只允许特定路由支持跨域请求</span></span><br><span class="line">CORS(app, origins=[<span class="string">&quot;http://124.222.246.202&quot;</span>,<span class="string">&quot;http://127.0.0.1&quot;</span>])</span><br><span class="line">HOME_PATH = <span class="string">&quot;/home/ubuntu/BlogData/&quot;</span></span><br><span class="line"><span class="comment">#@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class="line"><span class="comment">#def home_index():</span></span><br><span class="line"><span class="comment">#    index_html = open(&quot;/home/ubuntu/liuluhua.github.io/index.html&quot;, &quot;r&quot;)</span></span><br><span class="line"><span class="comment">#    print (&quot;文件名: &quot;, index_html.name)</span></span><br><span class="line"><span class="comment">#    print (&quot;是否已关闭 : &quot;, index_html.closed)</span></span><br><span class="line"><span class="comment">#    print (&quot;访问模式 : &quot;, index_html.mode)</span></span><br><span class="line"><span class="comment">#    return index_html.read()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/get_ip&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ip_addr</span>():</span><br><span class="line">    ip_addr = request.remote_addr</span><br><span class="line">    api_url = <span class="string">f&#x27;https://ipinfo.io/<span class="subst">&#123;ip_addr&#125;</span>/json&#x27;</span></span><br><span class="line">    response = requests.get(api_url)</span><br><span class="line">    data = response.json()</span><br><span class="line">    ret_data = <span class="string">&quot;来自&quot;</span>+data.get(<span class="string">&#x27;country&#x27;</span>)+<span class="string">&quot; &quot;</span>+data.get(<span class="string">&#x27;region&#x27;</span>)+<span class="string">&quot;的&quot;</span>+data.get(<span class="string">&#x27;ip&#x27;</span>)+<span class="string">&quot;朋友&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret_data</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/get_picture&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">picture_show</span>():</span><br><span class="line">    pic_dir = <span class="string">&#x27;0.res/Picture/&#x27;</span></span><br><span class="line">    name = request.args.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    act_addr = os.path.join(HOME_PATH,pic_dir,name);</span><br><span class="line">    fileNameList = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> os.listdir(act_addr):</span><br><span class="line">        fileNameList += <span class="string">f&#x27;&lt;img src=&quot;<span class="subst">&#123;pic_dir&#125;</span><span class="subst">&#123;name&#125;</span>/<span class="subst">&#123;file_name&#125;</span>&quot; alt=&quot;<span class="subst">&#123;file_name&#125;</span>&quot;&gt;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(file_name)</span><br><span class="line">    <span class="built_in">print</span> (fileNameList)</span><br><span class="line">    <span class="keyword">return</span> (fileNameList)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/getFileContent&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFileContent</span>():</span><br><span class="line">    filePath = request.get_json().get(<span class="string">&#x27;filePos&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(filePath)</span><br><span class="line">    f = <span class="built_in">open</span>(filePath)</span><br><span class="line">    lines = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/getFileList&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFileList</span>():</span><br><span class="line">    <span class="comment">#return  json.dumps(request.get_json()) + getDirList(HOME_PATH+&quot;Python&quot;);</span></span><br><span class="line">    <span class="keyword">return</span>  getDirList(HOME_PATH+<span class="string">&quot;Python&quot;</span>);</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getDirList</span>(<span class="params">dir_path,ret_list=<span class="literal">None</span>,depth=<span class="number">0</span></span>):</span><br><span class="line">    base_list = <span class="built_in">sorted</span>(os.scandir(dir_path),key=<span class="keyword">lambda</span> entry: (<span class="keyword">not</span> entry.is_dir(), entry.name))</span><br><span class="line">    <span class="keyword">if</span> ret_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ret_list = []</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> base_list:</span><br><span class="line">        <span class="keyword">if</span> entry.is_dir():</span><br><span class="line">            ret_list.append(<span class="string">&#x27;&lt;details&gt;&lt;summary&gt;&lt;span class=&quot;tree-item&quot;&gt;&#x27;</span>)</span><br><span class="line">            ret_list.append(entry.name+<span class="string">&#x27;&lt;/span&gt;&lt;/summary&gt;&#x27;</span>)</span><br><span class="line">            getDirList(entry.path, ret_list, depth+<span class="number">1</span>)</span><br><span class="line">            ret_list.append(<span class="string">&#x27;&lt;/details&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            file_pos = dir_path.replace(<span class="string">&quot;/home/ubuntu/html&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">            ret_list.append(<span class="string">f&#x27;&lt;details&gt;&lt;summary&gt; \</span></span><br><span class="line"><span class="string">            &lt;span class=&quot;tree-item&quot; onclick=&quot;openFile(\&#x27;<span class="subst">&#123;file_pos&#125;</span>/<span class="subst">&#123;entry.name&#125;</span>\&#x27;)&quot;&gt;&#x27;</span> + entry.name+<span class="string">&#x27;&lt;/summary&gt;&lt;/details&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(ret_list)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/signin&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signin</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;post signin&quot;</span>)</span><br><span class="line">    username = request.form.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    password = request.form.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    button_clicked = request.form.get(<span class="string">&#x27;signin&#x27;</span>)  <span class="comment"># 或者使用 &#x27;signup&#x27;</span></span><br><span class="line">    <span class="comment">#jsonify(&#123;&quot;response&quot;: &quot;test&quot;&#125;)</span></span><br><span class="line">    <span class="comment"># 确定哪个按钮被点击了</span></span><br><span class="line">    <span class="keyword">if</span> button_clicked == <span class="string">&#x27;signin&#x27;</span>:</span><br><span class="line">        <span class="comment"># 处理登录操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Login: Username=<span class="subst">&#123;username&#125;</span>, Password=<span class="subst">&#123;password&#125;</span>&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> button_clicked == <span class="string">&#x27;signup&#x27;</span>:</span><br><span class="line">        <span class="comment"># 处理注册操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Signup: Username=<span class="subst">&#123;username&#125;</span>, Password=<span class="subst">&#123;password&#125;</span>&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 没有按钮被点击或者未知按钮名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Unknown button pressed&#x27;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/wechat&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wechat_signature</span>():</span><br><span class="line">    data = request.args</span><br><span class="line">    echostr = data.get(<span class="string">&#x27;echostr&#x27;</span>)</span><br><span class="line">    signature = data.get(<span class="string">&#x27;signature&#x27;</span>)</span><br><span class="line">    timestamp = data.get(<span class="string">&#x27;timestamp&#x27;</span>)</span><br><span class="line">    nonce = data.get(<span class="string">&quot;nonce&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> signature <span class="keyword">or</span> <span class="keyword">not</span> timestamp <span class="keyword">or</span> <span class="keyword">not</span> nonce:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    tmp_str = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>([<span class="string">&#x27;******&#x27;</span>, timestamp, nonce]))</span><br><span class="line">    tmp_str = hashlib.sha1(tmp_str.encode(<span class="string">&#x27;UTF-8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> tmp_str == signature:</span><br><span class="line">        <span class="keyword">return</span> echostr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Failed&quot;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/wechat&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wechat_communication</span>():</span><br><span class="line">    <span class="comment">#获取微信服务器post过来的xml数据</span></span><br><span class="line">    xml = request.data</span><br><span class="line">    <span class="comment"># 把xml格式的数据进行处理，转换成字典进行取值</span></span><br><span class="line">    req = xmltodict.parse(xml)[<span class="string">&#x27;xml&#x27;</span>]</span><br><span class="line">    <span class="comment"># 判断post过来的数据中数据类型是不是文本</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;text&#x27;</span> == req.get(<span class="string">&#x27;MsgType&#x27;</span>):</span><br><span class="line">    <span class="comment"># 获取用户的信息，开始构造返回数据，把用户发送的信息原封不动的返回过去，字典格式</span></span><br><span class="line">        resp = &#123;</span><br><span class="line">            <span class="string">&#x27;ToUserName&#x27;</span>:req.get(<span class="string">&#x27;FromUserName&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;FromUserName&#x27;</span>:req.get(<span class="string">&#x27;ToUserName&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;CreateTime&#x27;</span>:<span class="built_in">int</span>(time.time()),</span><br><span class="line">            <span class="string">&#x27;MsgType&#x27;</span>:<span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content&#x27;</span>:req.get(<span class="string">&#x27;Content&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 把构造的字典转换成xml格式</span></span><br><span class="line">        xml = xmltodict.unparse(&#123;<span class="string">&#x27;xml&#x27;</span>:resp&#125;)</span><br><span class="line">        <span class="comment"># print(req.get(&#x27;Content&#x27;))</span></span><br><span class="line">        <span class="comment"># 返回数据</span></span><br><span class="line">        <span class="keyword">return</span> xml</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        resp = &#123;</span><br><span class="line">            <span class="string">&#x27;ToUserName&#x27;</span>: req.get(<span class="string">&#x27;FromUserName&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;FromUserName&#x27;</span>: req.get(<span class="string">&#x27;ToUserName&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;CreateTime&#x27;</span>: <span class="built_in">int</span>(time.time()),</span><br><span class="line">            <span class="string">&#x27;MsgType&#x27;</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content&#x27;</span>: <span class="string">&#x27;I LOVE ITCAST&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        xml = xmltodict.unparse(&#123;<span class="string">&#x27;xml&#x27;</span>:resp&#125;)</span><br><span class="line">        <span class="keyword">return</span> xml</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">9080</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>QProcess类来执行系统命令并获取输出</title>
    <url>/2024/07/23/1-%E8%AF%AD%E8%A8%80-Qt-QProcess%E7%B1%BB%E6%9D%A5%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E5%B9%B6%E8%8E%B7%E5%8F%96%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>使用 QProcess 的 start 方法启动命令。通过 waitForStarted 等待命令启动完成，使用 connect 连接 readyReadStandardOutput 信号到一个槽函数，当有新的标准输出时，会触发该槽函数读取并输出结果。最后使用 waitForFinished(-1)等待命令执行完毕，-1 表示无限等待，直到命令完成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProcess&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QProcess process;</span><br><span class="line">    <span class="comment">// 以异步方式启动命令，这里以执行&quot;dir&quot;命令为例（Windows 系统）</span></span><br><span class="line">    process.<span class="built_in">start</span>(<span class="string">&quot;cmd&quot;</span>, <span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;/c&quot;</span> &lt;&lt; <span class="string">&quot;dir&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待命令启动完成</span></span><br><span class="line">    <span class="keyword">if</span> (!process.<span class="built_in">waitForStarted</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Command failed to start!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接信号与槽，以便在有新的标准输出时进行处理</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;process, &amp;QProcess::readyReadStandardOutput, [&amp;]() &#123;</span><br><span class="line">        QString output = process.<span class="built_in">readAllStandardOutput</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; output; </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待命令执行完成</span></span><br><span class="line">    <span class="keyword">if</span> (!process.<span class="built_in">waitForFinished</span>(<span class="number">-1</span>)) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Command execution timed out!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是在 Windows 系统下执行 dir 命令的示例。如果你在 Linux 系统下，需要将启动命令修改为相应的终端命令，例如 process.start(“bash”, QStringList() &lt;&lt; “-c” &lt;&lt; “ls”); 来执行 ls 命令列出目录内容。</p>
<p>QProcess 中 start 和 write 中写的命令，末尾要加上 <code>\n</code>（Linux 直接加 <code>\n</code>，Windows 加 <code>\r\n</code>），否则命令可能无法执行。并且，write 方法不可与 waitForFinished 一起使用，否则会阻塞 30 秒，waitForFinished 只能用 start 一起使用。</p>
<p>如果要执行带有管道“|”等特殊字符的命令，可能需要一些额外的处理。例如，在 Linux 系统下执行 ps -ef | grep’mem’这样的命令，需要按照如下方式启动进程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString cmd = <span class="string">&quot;ps -ef | grep&#x27;mem&#x27;&quot;</span>;</span><br><span class="line">process.<span class="built_in">start</span>(<span class="string">&quot;bash&quot;</span>, <span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;-c&quot;</span> &lt;&lt; cmd);</span><br></pre></td></tr></table></figure>

<p>这样就可以通过 QProcess 获取执行系统命令的输出结果了。Qt 无法直接识别管道“|”和重定向“&gt;&gt;”命令，需要在启动程序或终端时作为参数传入这些命令，而不是启动后再输入。</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt多项目管理</title>
    <url>/2024/03/03/1-%E8%AF%AD%E8%A8%80-Qt-Qt%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Qt 工程过大或需要将工程分模块编译成库的形式加载时,需要将整体的 Qt 项目拆分各个小模块进行编译。</p>
<h1 id="1-条件编译文件"><a href="#1-条件编译文件" class="headerlink" title="1.条件编译文件"></a>1.条件编译文件</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unix&#123;</span><br><span class="line">    <span class="comment">//执行unix环境下的配置选项</span></span><br><span class="line">&#125;</span><br><span class="line">win32&#123;</span><br><span class="line">    <span class="comment">//执行Windows环境下的配置选项</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">contains</span>(QT_ARCH, arm64)&#123;</span><br><span class="line">    <span class="comment">//执行在架构为arm64的环境下的配置选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-子项目-lib"><a href="#2-子项目-lib" class="headerlink" title="2. 子项目 lib"></a>2. 子项目 lib</h1><p>子项目工程文件为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QT -= gui</span><br><span class="line">TARGET = printHello</span><br><span class="line">CONFIG   += staticlib</span><br><span class="line">TEMPLATE = lib</span><br><span class="line">DEFINES += printHello_LIBRARY</span><br><span class="line">CONFIG -= debug_and_release</span><br><span class="line">SOURCES += printHello. cpp</span><br><span class="line">HEADERS += printHello. h</span><br></pre></td></tr></table></figure>

<h1 id="3-子项目-dll"><a href="#3-子项目-dll" class="headerlink" title="3. 子项目 dll"></a>3. 子项目 dll</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QT -= gui</span><br><span class="line">TARGET = printNice</span><br><span class="line">TEMPLATE = lib</span><br><span class="line">DEFINES += printNice_LIBRARY</span><br><span class="line">CONFIG -= debug_and_release</span><br><span class="line">SOURCES += printNice. cpp</span><br><span class="line">HEADERS += printNice. h</span><br></pre></td></tr></table></figure>

<h1 id="4-可执行程序项目-exe"><a href="#4-可执行程序项目-exe" class="headerlink" title="4.可执行程序项目 exe"></a>4.可执行程序项目 exe</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QT += core gui widgets</span><br><span class="line">TARGET = print</span><br><span class="line">TEMPLATE = app</span><br><span class="line">SOURCES += main. cpp printwindow. cpp</span><br><span class="line">LIBS += -LprintHello -lprintHello -LprintNice -lprintNice</span><br><span class="line">FORMS += printwindow. ui</span><br><span class="line">HEADERS += printwindow. h</span><br></pre></td></tr></table></figure>

<h1 id="5-管理项-Dirs"><a href="#5-管理项-Dirs" class="headerlink" title="5.管理项 Dirs"></a>5.管理项 Dirs</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TEMPLATE = subdirs</span><br><span class="line">SUBDIRS += printHello/printHello.pro printNice/printNice.pro print.pro</span><br><span class="line">CONFIG += ordered</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt操作Sqlite3</title>
    <url>/2024/05/22/1-%E8%AF%AD%E8%A8%80-Qt-Qt%E6%93%8D%E4%BD%9CSqlite3/</url>
    <content><![CDATA[<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqliteOperator::CreatDb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QSqlDatabase::<span class="built_in">contains</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        db = QSqlDatabase::<span class="built_in">database</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line">        db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;test.db&quot;</span>);</span><br><span class="line">        db.<span class="built_in">setUserName</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        db.<span class="built_in">setPassword</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打开及关闭数据库"><a href="#打开及关闭数据库" class="headerlink" title="打开及关闭数据库"></a>打开及关闭数据库</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SqliteOperator::OpenDb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!db.<span class="built_in">open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error: Failed to connect database.&quot;</span> &lt;&lt; db.<span class="built_in">lastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqliteOperator::CloseDb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    db.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqliteOperator::CreateTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    QString creat_sql = <span class="string">&quot;create table student (id int primary key, name varchar(30), age int)&quot;</span>;</span><br><span class="line">    sql_query.<span class="built_in">prepare</span>(creat_sql);</span><br><span class="line">    <span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error: Fail to create table.&quot;</span> &lt;&lt; sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Table created!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqliteOperator::InsertData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString insert_sql = <span class="string">&quot;insert into student values (?, ?, ?)&quot;</span>;</span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    sql_query.<span class="built_in">prepare</span>(insert_sql);</span><br><span class="line">sql_query.<span class="built_in">addBindValue</span>(<span class="built_in">GetMaxId</span>() +<span class="number">1</span>);</span><br><span class="line">    sql_query.<span class="built_in">addBindValue</span>(<span class="string">&quot;Wang&quot;</span>);</span><br><span class="line">    sql_query.<span class="built_in">addBindValue</span>(<span class="number">25</span>);</span><br><span class="line">    <span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;inserted Wang!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqliteOperator::QueryAllData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString select_all_sql = <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    sql_query.<span class="built_in">prepare</span>(select_all_sql);</span><br><span class="line">    <span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(sql_query.<span class="built_in">next</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> id = sql_query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">            QString name = sql_query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">            <span class="type">int</span> age = sql_query.<span class="built_in">value</span>(<span class="number">2</span>).<span class="built_in">toInt</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">QString</span>(<span class="string">&quot;id:%1    name:%2    age:%3&quot;</span>).<span class="built_in">arg</span>(id).<span class="built_in">arg</span>(name).<span class="built_in">arg</span>(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqliteOperator::QueryData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString select_sql = <span class="built_in">QString</span>(<span class="string">&quot;select * from student where name = &#x27;%1&#x27; and (age = &#x27;%2&#x27; or age = &#x27;%3&#x27;)&quot;</span>)</span><br><span class="line">            .<span class="built_in">arg</span>(<span class="string">&quot;Wang&quot;</span>)</span><br><span class="line">            .<span class="built_in">arg</span>(<span class="number">30</span>)</span><br><span class="line">            .<span class="built_in">arg</span>(<span class="number">25</span>);</span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    <span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>(select_sql))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(sql_query.<span class="built_in">next</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> id = sql_query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">            QString name = sql_query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">QString</span>(<span class="string">&quot;id:%1    name:%2&quot;</span>).<span class="built_in">arg</span>(id).<span class="built_in">arg</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt的条件编译</title>
    <url>/2024/06/12/1-%E8%AF%AD%E8%A8%80-Qt-Qt%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="通过-DEFINES-定义宏"><a href="#通过-DEFINES-定义宏" class="headerlink" title="通过 DEFINES 定义宏"></a>通过 DEFINES 定义宏</h1><p>可以在 pro 文件中使用 <code>DEFINES +=</code> 宏名来定义宏。然后在 pro 文件或源码中使用 <code>contains(DEFINES,宏名)</code> 来判断该宏是否被定义,从而实现条件编译。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DEFINES += MY_MACRO  # 定义宏 MY_MACRO</span><br><span class="line"><span class="built_in">contains</span>(DEFINES, MY_MACRO) &#123;</span><br><span class="line">    <span class="built_in">message</span>(<span class="string">&quot;MY_MACRO defined&quot;</span>)</span><br><span class="line">	# 做一些操作</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">message</span>(<span class="string">&quot;MY_MACRO not defined&quot;</span>) </span><br><span class="line">	# 做其他操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">contains</span>(QMAKE_HOST.os, Unix) &#123;</span><br><span class="line">    # 针对unix平台做一些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在源码中也可以使用 <code>#ifdef MY_MACRO...#endif</code> 来根据宏定义进行条件编译。</p>
<h1 id="通过-CONFIG-配置"><a href="#通过-CONFIG-配置" class="headerlink" title="通过 CONFIG 配置"></a>通过 CONFIG 配置</h1><p><code>CONFIG</code> 变量用于指定工程配置和编译器选项,每个选项值都可用于条件判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CONFIG += MY_CONFIG</span><br><span class="line"></span><br><span class="line">MY_CONFIG &#123;</span><br><span class="line">    LIBS += -lmydll  # 链接某库</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LIBS += -lxxxdll # 链接其他库</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通过平台判断"><a href="#通过平台判断" class="headerlink" title="通过平台判断"></a>通过平台判断</h1><p>QMake 提供了一些内置变量来判断当前平台,如 win32、macx、android 等,可以根据这些变量进行条件编译。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">win32 &#123;</span><br><span class="line">    LIBS += -lwindowslib</span><br><span class="line">&#125;</span><br><span class="line">macx &#123;</span><br><span class="line">    LIBS += -lmaclib </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!macx:!win32 &#123;</span><br><span class="line">    # 针对unix平台做一些操作 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt的线程池</title>
    <url>/2024/08/16/1-%E8%AF%AD%E8%A8%80-Qt-Qt%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池是一种常见的并发编程模型，用于管理和复用多个线程来执行任务。它的基本思想是在应用程序启动时创建一组线程，这些线程可以重复使用，以执行一系列的任务，而不需要为每个任务都创建和销毁线程。</p>
<p>线程池通常由线程池管理器、工作队列和一组工作线程组成。</p>
<ul>
<li>线程池管理器：负责管理线程池的创建、销毁和线程数量的控制。</li>
<li>工作队列：用于存储待执行的任务。当任务提交至线程池时，会被添加到工作队列中，等待线程池中的线程来执行。</li>
<li>工作线程：线程池中的线程会从工作队列中取出任务，并执行任务的操作。</li>
</ul>
<p>线程池的优点包括：</p>
<ul>
<li>提高性能：通过重用线程，避免了频繁创建和销毁线程的开销，可以减少系统资源的占用和提高任务的响应速度。</li>
<li>控制并发度：通过限制线程池中的线程数量，可以有效控制并发任务的数量，避免资源过度消耗和系统负载过重。</li>
<li>提供任务队列：线程池可以维护一个任务队列，任务的提交和执行是解耦的，可以灵活地调整任务的处理顺序和优先级。</li>
<li>简化线程管理：由线程池管理器负责线程的创建、销毁和管理，开发者无需手动管理线程的生命周期。</li>
</ul>
<h1 id="Qt-的线程池"><a href="#Qt-的线程池" class="headerlink" title="Qt 的线程池"></a>Qt 的线程池</h1><p>QThreadPool 管理并回收单个 QThread 对象，以帮助降低使用线程的程序中的线程创建成本。每个 Qt 应用程序都有一个全局的 QThreadPool 对象，可以通过调用 globalInstance() 来访问。</p>
<p>要使用 QThreadPool 中的一个线程，子类化 QRunnable 并实现 run() 虚函数。然后创建该类的一个对象，并将其传递给 QThreadPool::start()。QThreadPool 默认会自动删除 QRunnable。使用 QRunnable::setAutoDelete() 来更改自动删除标志。</p>
<p>QThreadPool 支持通过在 QRunnable::run() 内部调用 tryStart(this) 多次执行同一个 QRunnable。如果启用了自动删除，当最后一个线程退出 run 函数时，QRunnable 将被删除。在启用自动删除时，使用相同的 QRunnable 多次调用 start() 会造成竞争条件，不建议这样做。</p>
<p>一段时间未使用的线程将会过期。默认的过期超时时间是 30000 毫秒（30 秒）。可以使用 setExpiryTimeout() 更改此设置。设置负的过期超时时间将禁用过期机制。</p>
<p>调用 maxThreadCount() 来查询要使用的最大线程数。如果需要，可以使用 setMaxThreadCount() 更改限制。默认的 maxThreadCount() 是 QThread::idealThreadCount()。activeThreadCount() 函数返回当前正在工作的线程数量。</p>
<p>reserveThread() 函数为外部使用保留一个线程。使用完线程后使用 releaseThread()，以便它可以被重新使用。本质上，这些函数暂时增加或减少活动线程数，在实现对 QThreadPool 不可见的耗时操作时非常有用。</p>
<p>QThreadPool 是用于管理线程的低级类，有关更高级的替代方案，请参阅 Qt Concurrent 模块。</p>
<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取和设置线程中的最大线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaxThreadCount</span><span class="params">(<span class="type">int</span> maxThreadCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务, 任务是一个 QRunnable 类型的对象</span></span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 任务会放到任务队列中, 等待线程处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::start</span><span class="params">(QRunnable * runnable, <span class="type">int</span> priority = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 直接返回值, 任务添加失败, 任务不会添加到任务队列中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryStart</span><span class="params">(QRunnable * runnable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池中被激活的线程的个数(正在工作的线程个数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QThreadPool::activeThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试性的将某一个任务从线程池的任务队列中删除, 如果任务已经开始执行就无法删除了</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryTake</span><span class="params">(QRunnable *runnable)</span></span>;</span><br><span class="line"><span class="comment">// 将线程池中的任务队列里边没有开始处理的所有任务删除, 如果已经开始处理了就无法通过该函数删除了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个Qt应用程序中都有一个全局的线程池对象, 通过这个函数直接访问这个对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> QThreadPool * <span class="title">QThreadPool::globalInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="一个扫描-IP-地址的线程池实例"><a href="#一个扫描-IP-地址的线程池实例" class="headerlink" title="一个扫描 IP 地址的线程池实例"></a>一个扫描 IP 地址的线程池实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThreadPool&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScanIpThread</span> : <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QString ipAddr;</span><br><span class="line">    <span class="built_in">ScanIpThread</span>(QString ip_addr)&#123;</span><br><span class="line">        ipAddr = ip_addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Hello world from thread&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">        QStringList parameters;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WIN32)</span></span><br><span class="line">        parameters &lt;&lt; <span class="string">&quot;-n&quot;</span> &lt;&lt; <span class="string">&quot;5&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        parameters &lt;&lt; <span class="string">&quot;-c 5&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        parameters &lt;&lt; ipAddr;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> exitCode = QProcess::<span class="built_in">execute</span>(<span class="string">&quot;ping&quot;</span>, parameters);</span><br><span class="line">        <span class="keyword">if</span> (exitCode==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;ipAddr&lt;&lt;<span class="string">&quot; it&#x27;s alive&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;ipAddr&lt;&lt;<span class="string">&quot; it&#x27;s dead&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QThreadPool *threadPool = <span class="keyword">new</span> QThreadPool;</span><br><span class="line">    threadPool-&gt;<span class="built_in">setMaxThreadCount</span>(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">255</span>; i++)&#123;</span><br><span class="line">        ScanIpThread *scanNode = <span class="keyword">new</span> <span class="built_in">ScanIpThread</span>(<span class="built_in">QString</span>(<span class="string">&quot;192.168.0.%1&quot;</span>).<span class="built_in">arg</span>(i));</span><br><span class="line">        <span class="comment">// QThreadPool takes ownership and deletes node automatically</span></span><br><span class="line">        threadPool-&gt;<span class="built_in">start</span>(scanNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt线程管理QThread</title>
    <url>/2024/07/16/1-%E8%AF%AD%E8%A8%80-Qt-Qt%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86QThread/</url>
    <content><![CDATA[<p>QThread 会通知你触发了一个信号当线程 started()和 finished()时，或者使用 isFinished()和 isRunning()来查询线程的状态。</p>
<p>可以通过调用 exit()或 quit()来停止线程。在极端情况下，你可能要强行 terminate()一个执行线程。但是，这样做是危险的。请阅读文档查看 terminate()和 setTerminationEnabled()的详细信息。</p>
<p>可以通过连接 finished()信号到 QObject::deleteLater()释放运行刚刚结束的线程对象。</p>
<p>使用 wait()来阻塞调用的线程，直到其他线程执行完毕（或者直到指定的时间过去）。</p>
<p>QThread 中还提供了静态的、平台独立的休眠功能：sleep()、msleep()、usleep()允许秒，毫秒和微秒来区分。</p>
<p>注意：一般情况下，wait()和 sleep()函数应该不需要，因为 Qt 是一个事件驱动型框架。而不是 wait()，关心监听信号 finished()。取代 sleep()，可以考虑使用 QTimer。</p>
<p>静态函数 currentThreadId()和 currentThread()返回标识当前正在执行的线程。前者返回该线程的平台特定的 ID，后者返回一个线程指针。</p>
<p>要设置线程的名称，可以在启动线程之前调用 setObjectName()。如果不调用 setObjectName()，线程的名称将是线程对象的运行时类型（上例中“WorkerThread”，因为这是 QThread 子类的类名）。</p>
<p>和界面有关的函数不能通过 QThread 的方式执行</p>
<h1 id="movetothread"><a href="#movetothread" class="headerlink" title="movetothread"></a>movetothread</h1><p>Worker 槽中的代码将在一个单独的线程中执行，然而，可以将（来自任何对象、在任何线程中）任何信号与该槽自由地连接，在不同的线程里连接信号和槽也是安全的，这要归功于一个叫排队的连接机制（queued connections）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line">	<span class="keyword">public</span> slots:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">const</span> QString &amp;parameter)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			<span class="function">emit <span class="title">resultReady</span><span class="params">(result)</span></span>;</span><br><span class="line">		&#125;</span><br><span class="line">	signals:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">resultReady</span><span class="params">(<span class="type">const</span> QString &amp;result)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line">	QThread workerThread;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Controller</span>() &#123;</span><br><span class="line">			Worker *worker = <span class="keyword">new</span> Worker;</span><br><span class="line">			worker-&gt;<span class="built_in">moveToThread</span>(&amp;workerThread);</span><br><span class="line">			<span class="built_in">connect</span>(workerThread, &amp;QThread::finished, worker, &amp;QObject::deleteLater);</span><br><span class="line">			<span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;Controller::operate, worker, &amp;Worker::doWork);</span><br><span class="line">			<span class="built_in">connect</span>(worker, &amp;Worker::resultReady, <span class="keyword">this</span>, &amp;Controller::handleResults);</span><br><span class="line">			workerThread.<span class="built_in">start</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Controller</span>() &#123;</span><br><span class="line">			workerThread.<span class="built_in">quit</span>();</span><br><span class="line">			workerThread.<span class="built_in">wait</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span> slots:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">handleResults</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line">	signals:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">operate</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="实例化-QThread"><a href="#实例化-QThread" class="headerlink" title="实例化 QThread"></a>实例化 QThread</h1><p>是子类化 QThread 中并重新实现 run 函数，在 run()返回后线程就会退出，在线程中将不会有任何的事件循环运行除非调用 exec()。</p>
<p>当子类化 QThread 时，构造函数在旧线程中执行，然而 run()在新线程中执行。</p>
<p>一个<strong>线程实例位于实例化它的旧线程</strong>中，而非调用 run()的新线程中，这意味着<strong>所有线程的排队槽将在旧线程中执行</strong>。因此，开发人员希望在<strong>新线程调用槽必须</strong> 通过 movetothread 实现，新槽不应直接在子类化 QThread 中来实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">run</span><span class="params">()</span> Q_DECL_OVERRIDE </span>&#123;</span><br><span class="line">		QString result;</span><br><span class="line">		<span class="function">emit <span class="title">resultReady</span><span class="params">(result)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	signals:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">resultReady</span><span class="params">(<span class="type">const</span> QString &amp;s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyObject::startWorkInAThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WorkerThread *workerThread = <span class="keyword">new</span> <span class="built_in">WorkerThread</span>(<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">connect</span>(workerThread, &amp;WorkerThread::resultReady, <span class="keyword">this</span>, &amp;MyObject::handleResults);</span><br><span class="line">	<span class="built_in">connect</span>(workerThread, &amp;WorkerThread::finished, workerThread, &amp;QObject::deleteLater);</span><br><span class="line">	workerThread-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Shell脚本</title>
    <url>/2024/06/07/1-%E8%AF%AD%E8%A8%80-Shell-Shell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>Shell 脚本的本质:</p>
<pre><code>shell命令的有序集合
</code></pre>
<p>#!&#x2F;bin&#x2F;bash</p>
<ol>
<li><p>chmod u+x  test.sh<br>.&#x2F;test.sh 				 &#x3D;&#x3D; &#x2F;home&#x2F;fs&#x2F;Temp&#x2F;test.sh</p>
</li>
<li><p>&#x2F;bin&#x2F;bash  test.sh </p>
</li>
<li><p>chmod u+x test.sh<br>PATH+&#x3D;:&#x2F;home&#x2F;fs&#x2F;Temp<br>test.sh 任意目录运行</p>
</li>
<li><pre><code>chmod u+x test.sh
</code></pre>
<p> sudo mv  test.sh  &#x2F;bin&#x2F;</p>
</li>
</ol>
<p>Shell 变量</p>
<p>自定义变量:</p>
<pre><code>1.不区分数据类型,全部识别为字符串 

2.命名符合标识符规定,

3.引用 

    $Var

    $&#123;&#125; 边界识别

4. 只读变量

    readonly 变量名

5. 删除变量

    unset 变量名

    set 显示本地的所有变量
</code></pre>
<p>位置变量:</p>
<pre><code>$# 参数的个数

$? 命令执行结果,函数返回结果,

$$ 进程id

$1,$2..$9,$&#123;10&#125;, $&#123;11&#125;


$@ &quot;&quot;
$* &quot;$*&quot;  当做整体处理
</code></pre>
<p>环境变量 (全局可以访问的变量)</p>
<pre><code>env	

export 变量名 	 将局部变量变为全局变量
</code></pre>
<p>PS:</p>
<pre><code>脚本中定义的变量只在本脚本有效
</code></pre>
<p>功能语句</p>
<pre><code>read

  -p &quot;提示内容&quot;

  -t 等待用户输入时间

  -n 读的字符个数

  -s 隐藏输入

  
read -n 5 AA BB CC
read AA BB CC 
hello xiaoming, mingtian you kong 

expr
 expr $AA + $BB
    sum=`expr $AA +　$BB`
    sum=$(expr $AA + $BB)	
 sum=$(($AA + $BB))   
 sum=$[$AA + $BB]
 let &quot;sum=$AA + $BB&quot;
 let sum=$AA+$BB 
 
 test
    字符串 test str1 = str2  !=  
    整数	-eq -ne  -gt -ge  -lt -le 
    文件属性 -d -f -r -w 
</code></pre>
<p>结构语句</p>
<pre><code> switch case  if   for  while  untill

if [ ] then	fi

if [ ]then else fi


case 
case var in
1)
    ...
    ;;
2|3|4)
    ...
    ;;	
esac

for 变量 in 单词表
do
    ..
done
for ((i=0; i&lt;N; i++))
do 
done

for var in `ls`
for var in $(ls)
for var	#单词表的内容是位置参数变量时，可以省略in ...

while 表达式
do 
    。。
done
while (($i &lt; $loop))
do
    ...
done 
</code></pre>
<p>函数</p>
<p> 定义：</p>
<p> 函数返回值用$?</p>
<p> 输出给了变量 var&#x3D;$(add_fun)</p>
<p> 返回值范围 0-255 </p>
<p> 传参:</p>
<pre><code>add_fun str1 str2 str3 
</code></pre>
<p>gcc 编译流程</p>
<pre><code>    step1:预处理

        头文件加载,宏定义替换,条件编译,注释  生成预处理文件.i &lt;有效文件&gt;

        gcc  -E name.c  -o name.i 	gcc -o name.i  -E name.c

    step2:编译

        检查代码的语法错误,如果有错误，报错，结束编译。否则，生成汇编代码.s 

        gcc -S name.i  -o name.s	gcc -o name.s  -S  name.i

    step3:汇编

        将汇编源码编译生成机器码(目标文件).o

        gcc -c name.s  -o name.o    gcc -o name.o  -c  name.s

    step4:链接

        将目标文件(&gt;=个)链接生成可执行文件

        gcc  name.o  -o   name      gcc -o name  name.o
</code></pre>
<p>gdb</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2024/05/17/1-%E8%AF%AD%E8%A8%80-Shell-shell/</url>
    <content><![CDATA[<h1 id="什么是-shell"><a href="#什么是-shell" class="headerlink" title="什么是 shell"></a>什么是 shell</h1><p>shell 是一个编程语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支；</p>
<p>也是一个命令行解释器，交互式地解释和执行用户输入的命令；</p>
<p>还是内核的保护工具，它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。</p>
<p><strong>Shell 有两种执行命令的方式：</strong><br><strong>交互式</strong>（Interactive）：解释执行用户的命令，用户输入一条命令，Shell 就解释执行一条。<br><strong>批处理</strong>（Batch）：用户事先写一个 Shell 脚本 (Script)，shell 脚本是 shell 命令的有限序列，将各类命令预先放入其中，方便一次性执行的一个程序文件，主要用于方便管理员进行设置或者管理，而不必一条一条地敲命令。</p>
<p>*Shell 脚本是解释执行的，不需要编译，Shell 程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到 Shell 提示符下执行</p>
<p>Linux 的 Shell 种类众多，常见的有：<code>Bourne Shell</code>（&#x2F;usr&#x2F;bin&#x2F;sh 或&#x2F;bin&#x2F;sh）、<code>Bourne Again Shell</code>（&#x2F;bin&#x2F;bash）、<code>C Shell</code>（&#x2F;usr&#x2F;bin&#x2F;csh）、<code>K Shell</code>（&#x2F;usr&#x2F;bin&#x2F;ksh）、<code>Shell for Root</code>（&#x2F;sbin&#x2F;sh）等等。</p>
<p>不同的 Shell 语言的语法有所不同，所以不能交换使用。我们关注的重点是 Bash，Bash 也是大多数 Linux 系统默认的 Shell。在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，在下面的文字中，我们可以看到#!&#x2F;bin&#x2F;sh，它同样也可以改为#!&#x2F;bin&#x2F;bash。</p>
<p>编写 Shell 脚本的格式是固定的，一个简单的 shell 脚本如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"><span class="meta">#print hello world in the console window</span></span><br><span class="line">a = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>

<p>首行中的符号**#!告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序**。 如果首行没有这句话，在执行脚本文件的时候，将会出现错误。</p>
<p>后续的部分就是主程序，Shell 脚本像高级语言一样，也有变量赋值，也有控制语句。 除第一行外，以#开头的行就是注释行，直到此行的结束。 如果一行未完成，可以在行尾加上 “，这个符号表明下一行与此行会合并为同一行。</p>
<p>编辑完毕，将脚本存盘为 filename.sh，文件名后缀 sh 表明这是一个 Bash 脚本文件。</p>
<p>执行方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>加可执行权限</span><br><span class="line">    chmod u+x  filename.sh</span><br><span class="line">    ./filename.sh</span><br><span class="line"><span class="number">2.</span>执行通过bash运行</span><br><span class="line">    /bin/bash  filename.sh</span><br><span class="line"><span class="number">3.</span>将路径添加到环境变量</span><br><span class="line">    chmod u+x filename.sh</span><br><span class="line">    PATH+=:/home/fs/Temp</span><br><span class="line">    filename.sh  <span class="comment">//任意目录运行</span></span><br><span class="line"><span class="number">4.</span>添加到bin文件夹</span><br><span class="line">    chmod u+x filename.sh</span><br><span class="line">    sudo mv  filename.sh  /bin/</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，一定要写成.&#x2F;filename.sh，而不是 filename.sh。运行其它二进制的程序也一样，直接写 filename.sh，linux 系统会去 PATH 里寻找有没有叫 filename.sh 的，而只有&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 filename.sh 是会找不到命令的，要用.&#x2F;filename.sh 告诉系统说，就在当前目录找。</li>
</ul>
<p><strong>速查表</strong></p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%!xxd</td>
<td align="left">将二进制文件转换为 16 进制和 ASCII 表形式查看</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">代表通配符，可代表任意长度的任意字符；</td>
</tr>
<tr>
<td align="left">？</td>
<td align="left">可代表单个长度的任意字符</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">通配括号中的元素</td>
</tr>
<tr>
<td align="left">[^……]</td>
<td align="left">除去括号中的元素，其他通配</td>
</tr>
<tr>
<td align="left">&gt;file</td>
<td align="left">将输出重定向到 file 中去（新建）</td>
</tr>
<tr>
<td align="left">&gt;&gt;file</td>
<td align="left">将输出重定向到 file 中去（追加模式）</td>
</tr>
<tr>
<td align="left">&lt;file</td>
<td align="left">将 file 作为标准输入</td>
</tr>
<tr>
<td align="left">2&gt; 或 &amp;&gt;</td>
<td align="left">–&gt;标准错误</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">pipe 管道,将第一个命令的输出作为第二个命令的输入</td>
</tr>
</tbody></table>
<h1 id="shell-命令使用"><a href="#shell-命令使用" class="headerlink" title="shell 命令使用"></a>shell 命令使用</h1><ol>
<li>tab 补齐：命令 文件名 路径</li>
<li>history ：查看命令历史</li>
<li>通配符 *：匹配任意长度任意字符串</li>
<li>管道 |：第一个指令的输出作为第二个指令的输入：<code>ls /usr/bin | wc -l</code></li>
<li>重定向 :</li>
<li>命令置换：反撇号<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   ls `pwd`</span><br></pre></td></tr></table></figure></li>
<li>常用命令</li>
<li>用户管理命令</li>
<li>进程管理命令</li>
</ol>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">?</span><br><span class="line">[...]</span><br><span class="line">[-]</span><br><span class="line">[^...]</span><br><span class="line">[a-z, ABC] <span class="comment">// 表示匹配a到z和A,B,C中任意一个字符</span></span><br><span class="line">ls file[<span class="number">3</span><span class="number">-4</span>][<span class="number">5</span><span class="number">-9</span>].c <span class="comment">/*表示名匹配文件名含[3-4]中的一个字符和[5-9]中的一个字符，两个字符的共两个字符的文件名都符合规则。*/</span></span><br></pre></td></tr></table></figure>

<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>|</p>
<p>将第一个命令的正确输出内容 通过管道输出给 第二个命令作为输入.</p>
<p>要求第一个命令有输出，第二个命令有输入功能。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><code>echo &quot;hello world&quot; &gt; test</code> &#x2F;&#x2F;将内容输出到文件 test 中。</p>
<p><code>echo &quot;hello Eric&quot; &gt;&gt; test</code> &#x2F;&#x2F;将字符串内容追加到 test 中,在 test 原有的内容上添加</p>
<p><code>2&gt; 2&gt;&gt;</code> &#x2F;&#x2F;将报错信息重定向或追加到指定文件.</p>
<p><code>&amp;&gt; &amp;&gt;&gt;</code> &#x2F;&#x2F;将正确信息和错误信息一起重定向或追加到指定文件。</p>
<p>0 标准输入 stdin</p>
<p>1 标准输出 stdout ‘\n’ main() return ; fflush(stdout);</p>
<p>2 标准出错 stderr</p>
<p><code>/dev/null</code> 是一个被称作 Linux 黑洞的文件，把输出信息重定向到这个文件等同于删除数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; ~/.bash_history <span class="comment">// 利用/dev/null清空指定文件。</span></span><br><span class="line">/dev/zero</span><br></pre></td></tr></table></figure>

<p><code>command &gt; file</code> 将输出重定向到 file。</p>
<p><code>command &lt; file</code> 将输入重定向到 file。</p>
<p><code>command &gt;&gt; file</code> 将输出以追加的方式重定向到 file。</p>
<p><code>n &gt; file</code> 将文件描述符为 n 的文件重定向到 file。</p>
<p><code>n &gt;&gt; file</code> 将文件描述符为 n 的文件以追加的方式重定向到 file。</p>
<p><code>n &gt;&amp; m</code> 将输出文件 m 和 n 合并。</p>
<p><code>n &lt;&amp; m</code> 将输入文件 m 和 n 合并。</p>
<p><code>&lt;&lt; tag</code> 将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
<h2 id="管道和重定向的比较"><a href="#管道和重定向的比较" class="headerlink" title="管道和重定向的比较"></a>管道和重定向的比较</h2><p><code>command1 | command2</code></p>
<p>左输出 | 右输入</p>
<p><code>command &gt; file</code></p>
<p>左输出 &gt; 右文件</p>
<p><code>command &lt; file</code></p>
<p>左输入 &lt; 右文件</p>
<p>管道的命令同时执行,command2 等待 command1 的输出 (阻塞)</p>
<p>重定向是有优先级的,由进程优先级决定.</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>less/more</code></p>
<p><code>alias</code> 定义别名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alias md=<span class="string">&#x27;mkdir&#x27;</span></span><br><span class="line">md dir1 dir2 <span class="comment">//md就是mkdir了,这里创建了两个目录(文件夹)dir1和dir2.</span></span><br></pre></td></tr></table></figure>

<p><code>head/tail</code></p>
<p><code>sort</code> 排序命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | sort -t:   -k <span class="number">4</span>  -n <span class="comment">//-t指定分隔符  -k 4 指定分隔后的段, -n 完整比较。</span></span><br><span class="line">man</span><br><span class="line">man <span class="number">1</span>  可执行程序或Shell命令</span><br><span class="line">man <span class="number">2</span>  ?</span><br><span class="line">man <span class="number">3</span>  ?</span><br></pre></td></tr></table></figure>

<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">adduser</span><br><span class="line">deluser  --remove-home <span class="comment">//删除用户的同时，删除其工作目录</span></span><br><span class="line">chown</span><br><span class="line">chown  xiaomeng  jielun <span class="comment">//将文件jielun的所有者改为xiaomeng.</span></span><br><span class="line">su  切换用户</span><br><span class="line">passwd 修改密码</span><br><span class="line">sudo <span class="comment">//用超级用户权限执行一次命令；</span></span><br><span class="line">sudo passwd <span class="comment">//普通用户修改root用户密码;</span></span><br><span class="line">usermod</span><br><span class="line">usermod  -l Ez   xiaoming <span class="comment">//更改用户名xiaoming为Ez,要保证用户不在登陆状态;</span></span><br></pre></td></tr></table></figure>

<p>相关文件:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/skel/</span><br><span class="line">/etc/group</span><br><span class="line">/etc/gshadow</span><br><span class="line">chmod 改变文件读写执行权限</span><br><span class="line">rw-     r-- r--</span><br><span class="line"><span class="number">110</span>     <span class="number">100</span> <span class="number">100</span></span><br><span class="line"><span class="number">6</span>        <span class="number">4</span>    <span class="number">4</span></span><br><span class="line">|       |   |其他用户</span><br><span class="line">|       |组用户权限</span><br><span class="line">|所属者的权限Xm</span><br></pre></td></tr></table></figure>

<h2 id="进程管理信息"><a href="#进程管理信息" class="headerlink" title="进程管理信息"></a>进程管理信息</h2><p><strong>进程的概念:</strong><br>程是指正在执行的程序的实例。每个运行的程序都在系统中作为一个进程存在。进程是操作系统进行任务调度和资源管理的基本单位，它拥有自己的内存空间、执行代码、数据和资源。进程之间相互独立，彼此隔离，这样可以确保一个进程的异常不会影响其他进程的正常运行。<br><strong>进程与程序的区别:</strong><br>程序是一组静态的指令和数据的集合，它们存储在磁盘上；而进程是程序的实例，是程序在内存中的执行过程。程序只是静态的代码和数据的集合，而进程是具有动态特性、在系统中运行的实体。</p>
<table>
<thead>
<tr>
<th align="center">&#x2F;</th>
<th align="center">进程</th>
<th align="center">程序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义</td>
<td align="center">进程是正在运行的程序的实例。在操作系统中，进程代表了一个独立的执行单元，拥有自己的内存空间、程序代码、数据和资源。每个运行的程序都以进程的形式存在。</td>
<td align="center">程序是一组指令和数据的集合，它是静态的、存储在磁盘上的文件，描述了如何执行特定任务。程序本身并不占用系统资源，只有在被加载到内存并运行时，才成为一个进程。</td>
</tr>
<tr>
<td align="center">特性</td>
<td align="center">进程是一个动态的实体，具有生命周期，可以处于运行、就绪、阻塞、挂起等不同状态，而且进程之间相互独立，彼此隔离。</td>
<td align="center">程序是一个静态的实体，只是存储在磁盘上的文件，并不具有自己的执行状态和资源。</td>
</tr>
<tr>
<td align="center">生命周期</td>
<td align="center">进程从创建、运行到终止，进程有一个明确的生命周期。当进程终止时，它占用的资源会被操作系统回收。</td>
<td align="center">程序本身没有生命周期，只有在被加载到内存并执行为进程后，才会有生命周期。</td>
</tr>
</tbody></table>
<ul>
<li>进程和程序之间是一种从程序到进程的实例化关系。当运行一个程序时，操作系统会为该程序创建一个对应的进程，使得程序在内存中得以执行。</li>
</ul>
<p><strong>进程的查看:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br><span class="line">ps -elf</span><br></pre></td></tr></table></figure>

<p><strong>进程的几种状态:</strong></p>
<ul>
<li>运行（Running）：表示进程正在运行或正在执行。</li>
<li>就绪（Ready）：表示进程已经准备好运行，但由于系统资源限制或其他进程的运行，它暂时还没有得到处理器的分配。</li>
<li>阻塞（Blocked）：也称为等待（Waiting），表示进程由于等待某个事件的发生（如 I&#x2F;O 操作完成、信号等）而暂停执行，直到事件发生才能继续运行。</li>
<li>挂起（Suspended）：表示进程被暂时挂起，不占用 CPU 资源，并且可能被放置在磁盘上。这种状态通常用于系统中的一些特殊情况，如进程被调试或由于内存不足而被置换出来。</li>
</ul>
<h1 id="shell-命令行下查找"><a href="#shell-命令行下查找" class="headerlink" title="shell 命令行下查找"></a>shell 命令行下查找</h1><p>在当前目录下所有文件中查找内容包含 string 的文件并列出字符所在的文件,所在行及所在行的内容:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">find ./ -name <span class="string">&quot;*&quot;</span> -exec grep -n <span class="string">&quot;string&quot;</span> ./ &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>使用 find 查找时希望忽略某个目录 (-prune):</p>
<p>如果希望在&#x2F;app 目录下查找文件，但不希望在&#x2F;app&#x2F;bin 目录下查找:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">find /app -name <span class="string">&quot;/app/bin&quot;</span> -prune -o -print</span><br></pre></td></tr></table></figure>

<p>使用 type 选项:</p>
<p>如果要在&#x2F;etc 目录下查找所有的目录:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">find /etc -type d -print</span><br></pre></td></tr></table></figure>

<p>如果要在&#x2F;etc 目录下查找.svn 的目录:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">find /etc -name .svn -type d -print</span><br></pre></td></tr></table></figure>

<p>为了在当前目录下查找除目录以外的所有类型的文件:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">find . ! -type d -print</span><br></pre></td></tr></table></figure>

<p>为了在当前目录下查找所有的符号链接文件，可以用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">find . -type | -print</span><br></pre></td></tr></table></figure>

<p>为了用 ls -l 命令列出所匹配到的文件，可以把 ls -l 命令放在 find 命令的 -exec 选项中:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">find . -type f -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>注：f 表示普通文件</p>
<h1 id="shell-脚本各种执行方式"><a href="#shell-脚本各种执行方式" class="headerlink" title="shell 脚本各种执行方式"></a>shell 脚本各种执行方式</h1><p><code>source ./*.sh</code> <code>. ./*.sh</code> <code>./*.sh</code> 的区别</p>
<ul>
<li><code>./*.sh</code> 的执行方式等价于 <code>sh ./*.sh</code> 或者 <code>bash ./*.sh</code>，<br>  此三种执行脚本的方式都是重新启动一个子 shell,在子 shell 中执行此脚本。</li>
<li><code>.source ./*.sh</code> 和 <code>. ./*.sh</code> 的执行方式是等价的，即两种执行方式都是在当前 shell 进程中执行此脚本，而不是重新启动一个 shell 而在子 shell 进程中执行此脚本。<br>验证依据：没有被 export 导出的变量（即非环境变量）是不能被子 shell 继承的<br>验证结果：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="meta">#name=dangxu <span class="comment">//定义一般变量</span></span></span><br><span class="line">[root@localhost ~]<span class="meta"># echo $&#123;name&#125;</span></span><br><span class="line">dangxu</span><br><span class="line">[root@localhost ~]<span class="meta"># cat test.sh <span class="comment">//验证脚本，实例化标题中的./*.sh</span></span></span><br><span class="line">#!/bin/sh</span><br><span class="line">echo $&#123;name&#125;</span><br><span class="line">[root@localhost ~]<span class="meta"># ls -l test.sh <span class="comment">//验证脚本可执行</span></span></span><br><span class="line">-rwxr-xr-x <span class="number">1</span> root root <span class="number">23</span> Feb <span class="number">611</span>:<span class="number">09</span> test.sh</span><br><span class="line">[root@localhost ~]# ./test.sh <span class="comment">//以下三个命令证明了结论一</span></span><br><span class="line">[root@localhost ~]<span class="meta"># sh ./test.sh</span></span><br><span class="line">[root@localhost ~]<span class="meta"># bash ./test.sh</span></span><br><span class="line">[root@localhost ~]# . ./test.sh <span class="comment">//以下两个命令证明了结论二</span></span><br><span class="line">dangxu</span><br><span class="line">[root@localhost ~]<span class="meta"># source ./test.sh</span></span><br><span class="line">dangxu</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Shell 支持自定义变量，不区分数据类型,全部识别为字符串</p>
<p>定义变量时，命名符合标识符规定，变量名不加 $ 符号</p>
<p><code>varName=&quot;value&quot;</code></p>
<p>注意变量名和等号之间不能有空格，同时变量名的命令遵循以下规则</p>
<ul>
<li>首个字符必须为字母</li>
<li>中间不能有空格，支持下划线</li>
<li>不能使用标点符号，不能使用 bash 里的关键字</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用一个定义过的变量，只要在变量名前面加 $ 符号即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">echo $varName</span><br><span class="line">echo $&#123;varName&#125; <span class="comment">//&#123;&#125;帮助进行边界识别</span></span><br></pre></td></tr></table></figure>

<p>变量名外的花括号时可选的，可以用于帮助解释器识别变量，比如下面这种情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> skill in Ada</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	echo <span class="string">&quot;i am good at $&#123;skill&#125;Script&quot;</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>如果不给 skill 变量加{}，解释器会把 $skillScript 当成一个变量</p>
<h2 id="重新定义"><a href="#重新定义" class="headerlink" title="重新定义"></a>重新定义</h2><p>已定义的变量可以被重新定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myUrl=<span class="string">&quot;http://see.xidian.edu.cn/cpp/linux/&quot;</span></span><br><span class="line">echo $&#123;myUrl&#125;</span><br><span class="line">myUrl=<span class="string">&quot;http://see.xidian.edu.cn/cpp/shell/&quot;</span></span><br><span class="line">echo $&#123;myUrl&#125;</span><br></pre></td></tr></table></figure>

<p>第二次赋值的时候不能写 <code>$myUrl=&quot;http://see.xidian.edu.cn/cpp/shell/&quot;</code>，只有使用变量时才加 $ 符号</p>
<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用 readonly 可以将变量定义为只读变变量，只读变量的值不能被改变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">myUrl=<span class="string">&quot;http://see.xidian.edu.cn/cpp/shell/&quot;</span></span><br><span class="line">readonly myUrl</span><br><span class="line">myUrl=<span class="string">&quot;http://see.xidian.edu.cn/cpp/danpianji/&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行脚本，会报如下错误：</p>
<p><code>/bin/sh: NAME: This variable is read only.</code></p>
<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用 unset 可以删除变量，unset 不能删除只读变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unset 变量名</span><br><span class="line">set 显示本地的所有变量</span><br></pre></td></tr></table></figure>

<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h3><p><strong>接收用户参数</strong></p>
<ul>
<li>$0 表示当前脚本名称</li>
<li>$1 表示接收的第一个命令行参数</li>
<li>$2 表示第二个命令行参数，以此类推</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$# 参数的个数</span><br><span class="line">$? 命令执行结果,函数返回结果,</span><br><span class="line">$$ 进程id</span><br><span class="line">$<span class="number">1</span>,$<span class="number">2.</span>.$<span class="number">9</span>,$&#123;<span class="number">10</span>&#125;, $&#123;<span class="number">11</span>&#125;</span><br><span class="line">$@ <span class="string">&quot;&quot;</span></span><br><span class="line">$* <span class="string">&quot;$*&quot;</span>  当做整体处理</span><br></pre></td></tr></table></figure>

<h3 id="环境变量-全局可以访问的变量"><a href="#环境变量-全局可以访问的变量" class="headerlink" title="环境变量 (全局可以访问的变量)"></a>环境变量 (全局可以访问的变量)</h3><p>脚本中定义的变量只在本脚本有效</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">env</span><br><span class="line"><span class="keyword">export</span> 变量名  <span class="comment">//将局部变量变为全局变量</span></span><br></pre></td></tr></table></figure>

<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><table>
<thead>
<tr>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td align="center">$n</td>
<td>传递给脚本或函数的参数，$1,$2</td>
</tr>
<tr>
<td align="center">$#</td>
<td>传递给脚本或函数的参数个数</td>
</tr>
<tr>
<td align="center">$*</td>
<td>传递给脚本或函数的所有参数</td>
</tr>
<tr>
<td align="center">$@</td>
<td></td>
</tr>
<tr>
<td align="center">$?</td>
<td>上个命令的退出状态或函数的返回值</td>
</tr>
<tr>
<td align="center">$$</td>
<td>当前 shell 进程 ID</td>
</tr>
</tbody></table>
<p><strong><code>$*</code> 和 <code>$@</code> 的区别</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;\$*=&quot;</span> $*</span><br><span class="line">echo <span class="string">&quot;\&quot;\$*\&quot;=&quot;</span><span class="string">&quot;$*&quot;</span></span><br><span class="line">echo <span class="string">&quot;\$@=&quot;</span> $@</span><br><span class="line">echo <span class="string">&quot;\&quot;\$@\&quot;=&quot;</span><span class="string">&quot;$@&quot;</span></span><br><span class="line">echo <span class="string">&quot;print each param from \$*&quot;</span></span><br><span class="line"><span class="keyword">for</span> var in $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	echo <span class="string">&quot;$var&quot;</span></span><br><span class="line">done</span><br><span class="line">echo <span class="string">&quot;print each param from \$@&quot;</span></span><br><span class="line"><span class="keyword">for</span> var in $@</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	echo <span class="string">&quot;$var&quot;</span></span><br><span class="line">done</span><br><span class="line">echo <span class="string">&quot;print each param from \&quot;\$*\&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> var in <span class="string">&quot;$*&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	echo <span class="string">&quot;$var&quot;</span></span><br><span class="line">done</span><br><span class="line">echo <span class="string">&quot;print each param from \&quot;\$@\&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> var in <span class="string">&quot;$@&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	echo <span class="string">&quot;$var&quot;</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>运行 .&#x2F;test.sh “a” “b” “c” “d”，看到下面的结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$*= a b c d<span class="string">&quot;</span></span><br><span class="line"><span class="string">$*&quot;</span>= a b c d</span><br><span class="line">$@= a b c d<span class="string">&quot;</span></span><br><span class="line"><span class="string">$@&quot;</span>= a b c d</span><br><span class="line">print each param from $*abcd</span><br><span class="line">print each param from $@abcd</span><br><span class="line">print each param from <span class="string">&quot;$*&quot;</span>a b c d</span><br><span class="line">print each param from <span class="string">&quot;$@&quot;</span>abcd</span><br></pre></td></tr></table></figure>

<h1 id="替换，运算符，字符串，数组"><a href="#替换，运算符，字符串，数组" class="headerlink" title="替换，运算符，字符串，数组"></a>替换，运算符，字符串，数组</h1><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">echo -e <span class="string">&quot;Value of a is $a \n&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里 -e 表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Value of a is <span class="number">10</span>\n</span><br></pre></td></tr></table></figure>

<p><strong>命令替换</strong><br>命令替换是将一个命令的输出作为另一个命令的参数。命令格式如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">command1  `command2`</span><br></pre></td></tr></table></figure>

<p>其中，命令 command2 的输出将作为命令 command1 的参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ls `pwd`  <span class="comment">//这里是反引号,和~是同一个按键</span></span><br></pre></td></tr></table></figure>

<p>pwd 命令用于显示当前目录的绝对路径。在上面的命令行中，使用命令置换符，将 pwd 的运行结果作为 ls 命令的参数。最终，命令执行结果是显示当前目录的文件内容。</p>
<ul>
<li>需要注意命令置换和管道 pipe 的区别</li>
</ul>
<p><strong>变量替换</strong><br>变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值可以使用的变量替换形式</p>
<table>
<thead>
<tr>
<th align="center">形式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">${var}</td>
<td align="center">变量本来的值</td>
</tr>
<tr>
<td align="center">${var:-word}</td>
<td align="center">如果变量 var 为空或已被删除 (unset)，那么返回 word，但不改变 var 的值。</td>
</tr>
<tr>
<td align="center">${var:&#x3D;word}</td>
<td align="center">如果变量 var 为空或已被删除(unset)，那么返回word，并将 var 的值设置为 word。</td>
</tr>
<tr>
<td align="center">${var:?message}</td>
<td align="center">如果变量 var 为空或已被删除 (unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在 Shell 脚本中，那么脚本将停止运行。</td>
</tr>
<tr>
<td align="center">${var:+word}</td>
<td align="center">如果变量 var 被定义，那么返回 word，但不改变 var 的值。</td>
</tr>
</tbody></table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Bash 支持很多运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符<br><strong>算数运算符</strong><br>awk 和 expr，expr</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">val=`expr <span class="number">2</span> + <span class="number">2</span>`</span><br><span class="line">echo <span class="string">&quot;value : $val&quot;</span></span><br><span class="line">val=`expr <span class="number">2</span> \* <span class="number">2</span>`</span><br><span class="line">echo <span class="string">&quot;value : $val&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出 <code>value : 4 value : 4</code></p>
<ul>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2</li>
<li>完整的表达式要被 &#96;&#96; 包含，注意这个字符不是常用的单引号，在 Esc 键下边</li>
<li>乘号 <code>*</code> 前边必须加反斜杠 <code>\</code> 才能实现乘法运算</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">`+`</span><br><span class="line">`-`</span><br><span class="line">`*`</span><br><span class="line">`/`</span><br><span class="line">`%`取余</span><br><span class="line">`=`赋值</span><br><span class="line">`==`相等</span><br><span class="line">`!=`不等</span><br></pre></td></tr></table></figure>

<p><strong>关系运算符</strong><br>关系运算符只支持数字，不支持字符串，除非字符串的值是数字<br><code>-eq</code> 相等<br><code>-ne</code> 不等<br><code>-gt</code> 左侧大于右侧，返回 true<br><code>-lt</code> 小于<br><code>-ge</code> 大于等于<br><code>-le</code> 小于等于<br><strong>布尔运算符</strong><br><code>!</code> 非<br><code>-a</code> 与<br><code>-o</code> 或<br><strong>字符串运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[ -z $String ] echo $?</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">`=` 检测两个字符串是否相等，相等返回 <span class="literal">true</span>。</span><br><span class="line">`!=` 不等</span><br><span class="line">`-z` 检测字符串长度是否为<span class="number">0</span>，为<span class="number">0</span>返回 <span class="literal">true</span></span><br><span class="line">`-n` 检测字符串长度是否为<span class="number">0</span>，不为<span class="number">0</span>返回 <span class="literal">true</span></span><br><span class="line">`str` 检测字符串是否为空，不为空返回 <span class="literal">true</span>。</span><br></pre></td></tr></table></figure>

<p><strong>文件测试运算符</strong><br>文件测试运算符用于检测 Unix 文件的各种属性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[ -d /etc/fstab ] echo $?</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-b file</td>
<td align="center">检测文件是否是块设备文件</td>
</tr>
<tr>
<td align="center">-c file</td>
<td align="center">检测文件是否是字符设备文件</td>
</tr>
<tr>
<td align="center">-d file</td>
<td align="center">检测文件是否是目录</td>
</tr>
<tr>
<td align="center">-f file</td>
<td align="center">检测文件是否是普通文件（既不是目录，也不是设备文件）</td>
</tr>
<tr>
<td align="center">-g file</td>
<td align="center">检测文件是否设置了 SGID 位</td>
</tr>
<tr>
<td align="center">-k file</td>
<td align="center">检测文件是否设置了粘着位 (Sticky Bit)</td>
</tr>
<tr>
<td align="center">-p file</td>
<td align="center">检测文件是否是具名管道</td>
</tr>
<tr>
<td align="center">-u file</td>
<td align="center">检测文件是否设置了 SUID 位</td>
</tr>
<tr>
<td align="center">-r file</td>
<td align="center">检测文件是否可读</td>
</tr>
<tr>
<td align="center">-w file</td>
<td align="center">检测文件是否可写</td>
</tr>
<tr>
<td align="center">-x file</td>
<td align="center">检测文件是否可执行</td>
</tr>
<tr>
<td align="center">-s file</td>
<td align="center">检测文件是否为空（文件大小是否大于 0）</td>
</tr>
<tr>
<td align="center">-e file</td>
<td align="center">检测文件（包括目录）是否存在</td>
</tr>
</tbody></table>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串可以用单引号，也可以用双引号，也可以不用引号</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li>
<li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>bash 支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p>
<p><strong>定义数组</strong></p>
<p>在 Shell 中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure>

<p>还可以单独定义数组的各个分量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array_name[<span class="number">0</span>]=value0</span><br><span class="line">array_name[<span class="number">1</span>]=value1</span><br><span class="line">array_name[<span class="number">2</span>]=value2</span><br></pre></td></tr></table></figure>

<p><strong>读取数组</strong><br>读取数组元素值的一般格式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$&#123;array_name[index]&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@</code> 或 <code>*</code> 可以获取数组中的所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$&#123;array_name[*]&#125;</span><br><span class="line">$&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取数组长度</strong><br>或取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]</span><br></pre></td></tr></table></figure>

<h1 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h1><h2 id="功能语句"><a href="#功能语句" class="headerlink" title="功能语句"></a>功能语句</h2><p>read 是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p 参数用于向用户显示一定的提示信息。</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-p</td>
<td align="center">“ 提示内容 “</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">等待用户输入时间</td>
</tr>
<tr>
<td align="center">-n</td>
<td align="center">读的字符个数</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="center">隐藏输入</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">read -n <span class="number">5</span> AA BB CC</span><br><span class="line">read AA BB CC</span><br><span class="line">hello xiaoming, mingtian you kong</span><br><span class="line">read -p <span class="string">&quot;Enter your score（0-100）：&quot;</span> GRADE</span><br></pre></td></tr></table></figure>

<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p><strong>判断语句格式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[ 条件表达式 ]</span><br></pre></td></tr></table></figure>

<p>对应两边应均有一个空格</p>
<p><strong>逻辑测试语句：</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="center">与 (当前面的命令执行成功后才会执行它后面的命令)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">或（当前面的命令执行失败后才会执行它后面的命令）</td>
</tr>
<tr>
<td align="center">！</td>
<td align="center">非（把条件测试中的判断结果取相反值）</td>
</tr>
</tbody></table>
<p>得到当前内存剩余量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FreeMem=`free -m | grep Mem: | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>`</span><br><span class="line">[ $FreeMem -lt <span class="number">1024</span> ] &amp;&amp; echo <span class="string">&quot;Insufficient Memory&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>break 语句</strong><br>break 命令允许跳出所有循环（终止执行后面的所有循环）。在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> n    <span class="comment">//表示跳出第 n 层循环。</span></span><br></pre></td></tr></table></figure>

<p><strong>continue 语句</strong><br>continue 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。<br>同样，continue 后面也可以跟一个数字，表示跳出第几层循环。</p>
<h2 id="结构语句"><a href="#结构语句" class="headerlink" title="结构语句"></a>结构语句</h2><p><strong>case</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">case</span> var in</span><br><span class="line"><span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line">;;</span><br><span class="line"><span class="number">2</span>|<span class="number">3</span>|<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>case 工作方式如上所示。取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。</p>
<p>demo:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p <span class="string">&quot;请输入一个字符，并按Enter键确认：&quot;</span> KEY</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;$KEY&quot;</span> in</span><br><span class="line">[a-z]|[A-Z])</span><br><span class="line">    echo <span class="string">&quot;您输入的是 字母。&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>])</span><br><span class="line">    echo <span class="string">&quot;您输入的是 数字。&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    echo <span class="string">&quot;您输入的是 空格、功能键或其他控制字符。&quot;</span></span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<p><strong>if</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ] then</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fi</span><br><span class="line"><span class="keyword">if</span> [ ] then</span><br><span class="line">elif [ ] then</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>demo:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p <span class="string">&quot;Enter The Users Password : &quot;</span> PASSWD</span><br><span class="line"><span class="keyword">for</span> UNAME in `cat users.txt`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">id $UNAME &amp;&gt; /dev/null （&amp;&gt;就是<span class="string">&quot;&gt;&quot;</span>和<span class="string">&quot;2&gt;&quot;</span>这两个的结合体）</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ] then</span><br><span class="line">    echo <span class="string">&quot;Already exists&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    useradd $UNAME &amp;&gt; /dev/null echo <span class="string">&quot;$PASSWD&quot;</span> | passwd --stdin $UNAME &amp;&gt; /dev/null</span><br><span class="line">    <span class="keyword">if</span> [ $? -eq <span class="number">0</span> ] then</span><br><span class="line">    echo <span class="string">&quot;$UNAME , Create success&quot;</span> <span class="keyword">else</span> echo <span class="string">&quot;$UNAME , Create failure&quot;</span></span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p><strong>for</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 in 列表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">..</span><br><span class="line"><span class="function">done</span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="params">((i=<span class="number">0</span>; i&lt;N; i++))</span></span></span><br><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">done</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> var in `ls`</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> var in $<span class="params">(ls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">for</span> var    #列表的内容是位置参数变量时，可以省略in ...</span></span><br></pre></td></tr></table></figure>

<p>列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。</p>
<p>demo:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HLIST=`echo www.baidu.com`</span><br><span class="line"><span class="keyword">for</span> IP in $HLIST</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ping -c <span class="number">3</span> -i <span class="number">0.2</span> -W <span class="number">3</span> $IP &amp;&gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -eq <span class="number">0</span> ] then</span><br><span class="line">    echo <span class="string">&quot;baidu is online&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo <span class="string">&quot;baidu is offline&quot;</span></span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>while</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">..</span><br><span class="line"><span class="function">done</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">(($i &lt; $loop))</span></span></span><br><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">done</span></span><br></pre></td></tr></table></figure>

<p>while 循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。</p>
<p>demo:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PRICE=$(expr $RANDOM % <span class="number">1000</span>)</span><br><span class="line">TIMES=<span class="number">0</span></span><br><span class="line">echo <span class="string">&quot;商品实际价格为0-999之间，猜猜看是多少？&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    read -p <span class="string">&quot;请输入您猜测的价格数目：&quot;</span> INT</span><br><span class="line">    let TIMES++</span><br><span class="line">    <span class="keyword">if</span> [ $INT -eq $PRICE ] ; then</span><br><span class="line">        echo <span class="string">&quot;恭喜您答对了，实际价格是 $PRICE&quot;</span> echo <span class="string">&quot;您总共猜测了 $TIMES 次&quot;</span></span><br><span class="line">        exit <span class="number">0</span></span><br><span class="line">    elif [ $INT -gt $PRICE] ; then</span><br><span class="line">        echo <span class="string">&quot;太高了！&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        echo <span class="string">&quot;太低了！&quot;</span></span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>untill</strong><br>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般 while 循环优于 until 循环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a=<span class="number">0</span></span><br><span class="line">until [ ! $a -lt <span class="number">10</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">echo $a</span><br><span class="line">a=`expr $a + <span class="number">1</span>`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><p><strong>定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">function_name</span> () &#123;</span><br><span class="line">    list of commands</span><br><span class="line">    [ <span class="keyword">return</span> value ]</span><br><span class="line">&#125;</span><br><span class="line">function <span class="built_in">function_name</span> () &#123;</span><br><span class="line">    list of commands</span><br><span class="line">    [ <span class="keyword">return</span> value ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。<br><strong>返回值</strong><br>函数返回值，可以显式增加 return 语句；如果不加，会将最后一条命令运行结果作为返回值。接收函数返回值用 <code>$?</code>。<br>Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0 表示成功，其他值表示失败。（返回值范围 0-255）<br>如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。<br>如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。<br><strong>调用</strong><br>调用函数只需要给出函数名，不需要加括号。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Hello</span>() &#123;</span><br><span class="line">echo <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Hello</span></span><br><span class="line"><span class="function"><span class="title">Hello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">echo <span class="string">&quot;hello2, world&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">Hello2</span><br><span class="line">ret=$?</span><br></pre></td></tr></table></figure>

<p>输出给了变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var=$(Hello2)</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong><br>像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 .f 选项，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unset .f function_name</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>在 Shell 中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1 表示第一个参数，$2 表示第二个参数</p>
<p>获取第十个参数需要 <code>$&#123;10&#125;</code>。当 n&gt;&#x3D;10 时，需要使用 <code>$&#123;n&#125;</code> 来获取参数。</p>
<p><code>$#</code> 传递给函数的参数个数。</p>
<p><code>$*</code> 显示所有传递给函数的参数。</p>
<p><code>$@</code> 与 <code>$*</code> 相同，但是略有区别</p>
<p><code>$?</code> 函数的返回值。</p>
<p>传参:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">add_fun</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">add_fun str1 str2 str3</span><br></pre></td></tr></table></figure>

<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">. filename</span><br><span class="line">source filename</span><br></pre></td></tr></table></figure>

<p>两种方式的效果相同，简单起见，一般使用点号 (.)，但是注意点号 (.) 和文件名中间有一空格</p>
<ul>
<li>被包含脚本不需要有执行权限</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等等。</p>
<p><strong>变量种类</strong></p>
<p>按变量的生存周期来划分，Linux 变量可分为两类：</p>
<ul>
<li>永久的：需要修改配置文件，变量永久生效。</li>
<li>临时的：使用 export 命令声明即可，变量在关闭 shell 时失效。<br><strong>设置环境变量</strong></li>
<li>在&#x2F;etc&#x2F;profile 文件中添加变量【对所有用户生效（永久的）】<br>  用 VI 在文件&#x2F;etc&#x2F;profile 文件中增加变量，该变量将会对 Linux 下所有用户有效，并且是“永久的”。例如：编辑&#x2F;etc&#x2F;profile 文件，添加 PATH 变量<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  export PATH=/home/fs : $PATH</span><br></pre></td></tr></table></figure><br>  &gt; 注：修改文件后要想马上生效还要运行# source &#x2F;etc&#x2F;profile 不然只能在下次重进此用户时生效。</li>
<li>在用户目录下的.bash_profile 文件中增加变量【对单一用户生效（永久的）】<br>  用 VI 在用户目录下的.bash_profile 文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 例如：编辑 guok 用户目录（&#x2F;home&#x2F;guok）下的.bash_profile，添加如下内容：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure><br>  &gt; 注：修改文件后要想马上生效还要运行 $ source &#x2F;home&#x2F;guok&#x2F;.bash_profile 不然只能在下次重进此用户时生效。</li>
<li>直接运行 export 命令定义变量【只对当前 shell（BASH）有效（临时的）】<br>  在 shell 的命令行下直接使用 [export 变量名&#x3D;变量值] 定义变量，该变量只在当前的 shell（BASH）或其子 shell（BASH）下是有效的，shell 关闭了，变量也就失效了，再打开新 shell 时就没有这个变量，需要使用的话还需要重新定义。<br><strong>PATH 声明</strong><br>其格式为：<code>PATH=$PATH:</code> 你可以自己加上指定的路径，中间用冒号隔开。<br>环境变量更改后，在用户下次登陆时生效。<br>如果想立刻生效，则可执行下面的语句：<code>$source .bash_profile</code><br>需要注意的是，最好不要把当前路径 <code>./</code> 放到 PATH 里，这样可能会受到意想不到的攻击。<br>完成后，可以通过 <code>$ echo $PATH</code> 查看当前的搜索路径。这样定制后，就可以避免频繁的启动位于 shell 搜索的路径之外的程序了。<br><strong>常用的环境变量</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PATH</td>
<td align="center">决定了 shell 将到哪些目录中寻找命令或程序</td>
</tr>
<tr>
<td align="center">HOME</td>
<td align="center">当前用户主目录</td>
</tr>
<tr>
<td align="center">HISTSIZE</td>
<td align="center">历史记录数</td>
</tr>
<tr>
<td align="center">LOGNAME</td>
<td align="center">当前用户的登录名</td>
</tr>
<tr>
<td align="center">HOSTNAME</td>
<td align="center">指主机的名称</td>
</tr>
<tr>
<td align="center">SHELL</td>
<td align="center">当前用户 Shell 类型</td>
</tr>
<tr>
<td align="center">LANGUGE</td>
<td align="center">语言相关的环境变量，多语言可以修改此环境变量</td>
</tr>
<tr>
<td align="center">MAIL</td>
<td align="center">当前用户的邮件存放目录</td>
</tr>
<tr>
<td align="center">PS1</td>
<td align="center">基本提示符，对于 root 用户是#，对于普通用户是 $</td>
</tr>
</tbody></table>
<p><strong>常用的环境变量相关命令</strong></p>
<ul>
<li>设置一个新的环境变量 hello<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ export HELLO=&quot;Hello&quot;</span><br><span class="line">  fs@ubuntu:~$ echo $HELLO</span><br><span class="line">  Hello</span><br><span class="line">  fs@ubuntu:~$</span><br></pre></td></tr></table></figure></li>
<li>使用 env 命令显示所有的环境变量<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ env</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure></li>
<li>使用 set 命令显示所有本地定义的 Shell 变量，set 可以设置某个环境变量的值。<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ set</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>使用 unset 命令来清除环境变量，清除环境变量的值用 unset 命令。如果未指定值，则该变量值将被设为 NULL。示例如下：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ export TEST=&quot;Test&quot; \\增加一个环境变量TEST</span><br><span class="line">  fs@ubuntu:~$ env | grep TEST \\此命令有输出，证明环境变量TEST已存在</span><br><span class="line">  TEST=Test</span><br><span class="line">  fs@ubuntu:~$ unset $TEST \\删除环境变量TEST</span><br><span class="line">  fs@ubuntu:~$ env | grep TEST \\此命令没输出，证明环境变量TEST已经存在</span><br></pre></td></tr></table></figure></li>
<li>使用 readonly 命令设置只读变量，如果使用了 readonly 命令的话，变量就不可以被修改或清除了。示例如下：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  fs@ubuntu:~$ export TEST=&quot;Test&quot; \\增加一个环境变量TEST</span><br><span class="line">  fs@ubuntu:~$ readonly TEST \\将环境变量TEST设为只读</span><br><span class="line">  fs@ubuntu:~$ unset TEST \\此变量无法删除</span><br><span class="line">  bash: unset: TEST: cannot unset: readonly variable</span><br><span class="line">  fs@ubuntu:~$ TEST=&quot;NEW&quot; \\此变量不可更改</span><br><span class="line">  bash: TEST: readonly variable</span><br><span class="line">  fs@ubuntu:~$</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="计划任务服务程序"><a href="#计划任务服务程序" class="headerlink" title="计划任务服务程序"></a>计划任务服务程序</h2><p><strong>一次性计划任务</strong><br>“at 时间 “ 是一个命令行工具，用于在指定的时间执行一次性任务。<br>通过使用该命令，您可以安排计划在将来的某个时间运行的命令或脚本。<br>时间参数可以采用多种格式，如 HH:MM，HH:MM AM&#x2F;PM 或者明天的日期。<br>例如，以下命令将在下午 2 点运行一个脚本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">at <span class="number">2</span>pm &lt;脚本路径&gt;</span><br></pre></td></tr></table></figure>

<p><strong>查看计划任务</strong><br>“at -l” 命令用于列出当前计划的 at 任务列表，显示已经被安排的任务及其相关信息，如任务序号、执行时间等。<br>例如，以下命令将列出当前计划的 at 任务列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">at -l</span><br></pre></td></tr></table></figure>

<p><strong>取消计划任务</strong><br>“atrm 任务序号 “ 命令用于取消一个已经计划的 at 任务，其中任务序号是通过 “at -l” 命令列出的任务的序号。<br>例如，以下命令将取消任务序号为 1 的 at 任务：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">atrm <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>长期性计划任务</strong><br><code>crontab -e</code> 创建、编辑计划任务<br><code>crontab -l</code> 查看当前计划任务<br><code>crontab -r</code> 删除某条计划任务<br><code>crontab -u</code> 编辑他人的计划任务<br>demo:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">crontab -l</span><br><span class="line">&gt;<span class="number">25</span> <span class="number">3</span> * * <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span> /usr/bin/tar -czvf backup.tar /home/wwwroot</span><br><span class="line">whereis rm</span><br></pre></td></tr></table></figure>

<p><strong>时间周期设置：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">25</span> <span class="number">3</span> * * <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>依次对应 分钟，小时，日期，月份，星期</p>
<p><strong>任务内容:</strong></p>
<p>要运行的命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/usr/bin/tar -czvf backup.tar /home/wwwroot</span><br></pre></td></tr></table></figure>

<h2 id="终端和控制台"><a href="#终端和控制台" class="headerlink" title="终端和控制台"></a>终端和控制台</h2><p><strong>终端 (terminal，或者叫物理终端）：</strong><br>是一种设备，不是一个程序，一般说的就是能提供命令行用户界面的设备，典型的是屏幕和键盘，或其他的一些物理终端。</p>
<blockquote>
<p>虚拟终端：<br>屏幕和键盘只是一个终端，可能不够用，又不想增加设备投入，就产生了虚拟终端。<br>gnome-terminal,urxvt，mlterm，xterm 等等是一个程序，职责是模拟终端设备，和虚拟终端的区别表面上在于它以 GUI 形式的窗口出现，内部则是程序结构和系统控制结构有所不同，但本质上差不多。<br><strong>控制台（console):</strong><br>显示系统消息的终端就叫控制台，Linux 默认所有虚拟终端都是控制台，都能显示系统消息。<br>有时专指 CLI 下的模拟终端设备的一个程序，和 gnome-terminal,urxvt，mlterm，xterm 等相同，只是 CLI 和 GUI 界面的区别。<br>一般 console 有 6 个，tty1-6，CTRL+ALT+f1-6 切换。<br><strong>shell：</strong><br>shell 是一个抽象概念，shell 的一切操作都在计算机内部，负责处理人机交互，执行脚本等，是操作系统能正常运行的重要组成部分,bash，ash，zsh，tcsh 等是 shell 这个抽象概念的一种具体的实现，都是一个程序，都能生成一个进程对象<br>如果想换 shell 的程序，可以修改&#x2F;etc&#x2F;passwd，把里面的&#x2F;bin&#x2F;bash 换成你想要的 shell，或者用 chsh 命令来切换<br><strong>shell 与终端的关系：</strong><br>shell 把一些信息适当的输送到终端设备，同时还接收来自终端设备的输入。一般每个 shell 进程都会有一个终端关联，也可以没有。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">字符程序 &lt;---&gt; 虚拟终端 &lt;---&gt; 图像显示</span><br><span class="line">shell &lt;---&gt; xterm &lt;---&gt; X11</span><br></pre></td></tr></table></figure>

<p><strong>控制台和终端的历史遗留区别</strong><br>计算机最初由于价格昂贵，因此，一台计算机一般是由多个人同时使用的。在这种情况下一台计算机需要连接上许多套键盘和显示器来供多个人使用。</p>
<p>在以前专门有这种可以连上一台电脑的设备，只有显示器和键盘，还有简单的处理电路，本身不具有处理计算机信息的能力，他是负责连接到一台正常的计算机上（通常是通过串口） ，然后登陆计算机，并对该计算机进行操作。</p>
<p>当然，那时候的计算机操作系统都是多任务多用户的操作系统。</p>
<p>这样一台只有显示器和键盘能够通过串口连接到计算机 的设备就叫做终端。</p>
<p>而控制台又是什么回事呢？ 学机电的人应该知道，一台机床，或者数控设备的控制箱，通常会被称为控制台，顾名思义，控制台就是一个直接控制设备的台面（一个面板，上面有很多控制按钮）。</p>
<p>在计算机里，把那套直接连接在电脑上的键盘和显示器就叫做控制台。</p>
<p>请注意它和终端的区别，终端是通过串口连接上的，不是计算机本身就有的设备，而控制台是计算机本身就有的设备，一个计算机只有一个控制台。</p>
<p>计算机启动的时候，所有的信息都会显示到控制台上，而不会显示到终端上。</p>
<p>也就是说，控制台是计算机的基 本设备，而终端是附加设备。</p>
<p>当然，由于控制台也有终端一样的功能，控制台有时候也被模糊的统称为终端。</p>
<p>计算机操作系统中，与终端不相关的信息，比如内核消息，后台服务消息，都可以显示到控制台上，但不会显示到终端上。</p>
<p><strong>现在</strong><br>普通用户可以简单的把终端和控制台理解为：可以输入命令行并显示程序运行过程中的信息以及程序运行结果的窗口。 不必要严格区分这两者的差别。</p>
<p>现在由于计算机硬件越来越便宜，通常都是一个人独占一台计算机超做，不再连接以前那种真正意义上的“终端设备了”，因此，终端和控制台的概念也慢慢演化了。</p>
<p>终端和控制台由硬件的概念，演化成了软件的概念。</p>
<p>现在说的终端，比如 linux 中的虚拟终端，都是软件的概念，他用计算机的软件来模拟以前硬件的方式。</p>
<p>比如在 linux 中，你用 alt+f1 ~ f6 可以切换六个虚拟终端，就好比是以前多人公用的计算机中的六个终端设备，这就是为什么这个叫“虚拟终端”的原因。</p>
<p>当然，现在的 linux 也可以通过串口 线，连接一个真正的终端，现在这种终端设备已经非常罕见了，但是还存在，只是一般人很难见到。</p>
<p>也有人利用以前的老电脑（386，486）装上一个串口通信软件，连上一台计算机，来模拟一个终端来用。这样可以达到一台电脑多人使用的目的。</p>
<p>简单的说，能直接显示系统消息的那个终端称为控制台，其他的则称为终端。</p>
<p>但是在 linux 系统中，这个概念也已经模糊化了。</p>
<p>比如下面这条命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;hello,world&quot;</span> &gt; /dev/console</span><br></pre></td></tr></table></figure>

<p>这条命令的目的是将 “hello,world” 显示到控制台上&#x2F;dev&#x2F;console 是控制台设备的设备名。</p>
<p>在 linux 中，在字符模式下，你无论在哪个虚拟终端下执行这条命令，字符 hello,world 都会显示在当前的虚拟终端下。也就是说，linux 把当前的终端当作控制台来看待。可见，linux 中已经完全淡化了控制台和终端的区别。</p>
<p>但是在其他的 UNIX 类系统中，却很明显的有虚拟终端和控制台的区别。比如 freeBSD 系统。在 freebsd 中，只有第一个“终端”才是真正的控制台。（就是说按 alt+f1 得到的那个虚拟终端），你无论在哪个虚拟终端上执行上面的那条命令（哪怕是通过网络连接的伪终端上执行这条命令）。hello,world 字符总会显示到第一个“终端”也就是 真正的控制台上。</p>
<p>另外，其他的一些系统内部信息，比如哪个用户在哪个终端登陆，系统有何严重错误警告等信息，全都显示在这个真正的控制台上。在这里，就明显的区分了终端和控制台的概念。其他 UNIX 中也是这样的。</p>
<p>比如 Tru64 unix 在 X 下有一个控制台模拟软件，你无论在哪里输入 <code>echo &quot;hello,world&quot; &gt; /dev/console</code> 命令，hello,world 总会显示在这个控制台模拟器中。</p>
<p>我们在 X 界面下用的那些输入命令的软件，比如 xterm ,rxvt, gnome-terminal 等等，都应该被称为终端模拟软件。</p>
<p>请注意它和控制台模拟软件的区别。</p>
<p>linux 中好象没有控制台模拟软件。</p>
<p>在 X 中的终端模拟 软件中输入的 <code>echo &quot;hello,world&quot;&gt;/dev/console</code> 命令的输出信息，都会输出到启动该 X 服务器的虚拟终端上。</p>
<p>比如，你用字符方式登陆系统。进入第一个虚拟终端，然后 startx 启动 X 服务器。</p>
<p>再打开 xterm 来输入 <code>echo &quot;hello,world&quot;&gt;/dev/console</code> 命令，那么字符串 hello,world 就显示在第一个虚拟终端上。</p>
<p>你按 ctrl+alt+f1，回到那个启动 X 服务器的终端，就可以看到 hello, world 字符串。</p>
<p>现在该明白终端和控制台的区别了吧。</p>
<p>再简单的说，控制台是直接和计算机相连接的原生设备，终端是通过电缆、网络等等和主机连接的设备。在以前的硬件终端设备中，由于生产厂家不同，所遵循的标准不同，因此有不同的型号标准。</p>
<p>比如 vt100 等。这里的 vt100 就是一个标准，那么现在我 们所说的终端，往往不是真正的硬件终端了，而是终端模拟软件了，因此不同的终端模拟软件可能符合不同的标准，还有一些终端模拟软件符合很多种不同终端的标准。</p>
<p>比如 gnome 的终端模拟软件 gnome-terminal，他提供好几中标准可供用户选择。</p>
<p>用户只要设置一下就可以了。现在，由于原先的这些设备在我们的视线中渐渐淡出，控制台和终端的概念也慢慢谈化。</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2024/05/22/1-%E8%AF%AD%E8%A8%80-%E5%89%8D%E7%AB%AF-JavaScript/</url>
    <content><![CDATA[<h1 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在当前页面重新载入页面</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reloadPageContent</span>(<span class="params">reloadPage</span>)&#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(reloadPage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按钮点击展开或隐藏</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="variable language_">document</span>).<span class="title function_">ready</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;	<span class="comment">//ready函数来确保文档加载完毕后再执行代码(jquery库代码)</span></span><br><span class="line">	$(<span class="string">&quot;a&quot;</span>).<span class="title function_">click</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;	<span class="comment">//为文档中的所有&lt;a&gt;标签绑定点击事件</span></span><br><span class="line">	    $(<span class="variable language_">this</span>).<span class="title function_">next</span>(<span class="string">&quot;.menu&quot;</span>).<span class="title function_">toggle</span>()<span class="comment">//找到当前被点击的&lt;a&gt;标签的下一个.menu类的元素，切换它的可见性</span></span><br><span class="line">	&#125;))</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取并更新innerHTML中的内容</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInnerHTML</span>(<span class="params">filePos</span>)&#123;	</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, filePos, <span class="literal">true</span>);</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        	<span class="keyword">var</span> htmlContent = xhr.<span class="property">responseText</span>;</span><br><span class="line">        	<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainmenu&quot;</span>).<span class="property">innerHTML</span> = htmlContent;</span><br><span class="line">		<span class="title function_">updateClick</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showPicture</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://124.222.246.202/get_picture?id=1&#x27;</span>,</span><br><span class="line">    &#123;<span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,<span class="attr">headers</span>: &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;,&#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainmenu&quot;</span>).<span class="property">innerHTML</span>=data&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">openFile</span>(<span class="params">filePos</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">            xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://124.222.246.202/getFileContent&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> message = &#123;</span><br><span class="line">                filePos</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">var</span> jsonMessage = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(message);</span><br><span class="line">            xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> responseContainer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainmenu&quot;</span>);</span><br><span class="line">                    responseContainer.<span class="property">innerHTML</span> = </span><br><span class="line">			<span class="string">&#x27;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;2.css/github-markdown-css/github-markdown.css&quot;&gt;&lt;style&gt;.markdown-body &#123;box-sizing: border-box;min-width: 200px;max-width: 980px;margin: 0 auto;padding: 45px;&#125;@media (max-width: 767px) &#123;.markdown-body &#123;padding: 15px;&#125;&#125;&lt;/style&gt;&lt;article class=&quot;markdown-body&quot;&gt;&#x27;</span>+marked.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>)+<span class="string">&#x27;&lt;/article&gt;&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            xhr.<span class="title function_">send</span>(jsonMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">blogList</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// 创建XMLHttpRequest对象</span></span><br><span class="line">		<span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 配置请求，将消息发送到后端Python服务器</span></span><br><span class="line">		xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://124.222.246.202/getFileList&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置请求头，告诉服务器发送的是JSON数据</span></span><br><span class="line">		xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建要发送的消息对象</span></span><br><span class="line">		<span class="keyword">var</span> message = &#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello, backend!&quot;</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将消息对象转换为JSON格式</span></span><br><span class="line">		<span class="keyword">var</span> jsonMessage = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(message);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理响应</span></span><br><span class="line">		xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">				<span class="comment">// 在页面上显示后端返回的消息</span></span><br><span class="line">				<span class="keyword">var</span> responseContainer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainmenu&quot;</span>);</span><br><span class="line">				responseContainer.<span class="property">innerHTML</span> = <span class="string">&quot;后端返回的消息: &quot;</span> + xhr.<span class="property">responseText</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送请求</span></span><br><span class="line">		xhr.<span class="title function_">send</span>(jsonMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript学习笔记</title>
    <url>/2024/05/22/1-%E8%AF%AD%E8%A8%80-%E5%89%8D%E7%AB%AF-JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JavaScript-用法"><a href="#JavaScript-用法" class="headerlink" title="JavaScript 用法"></a>JavaScript 用法</h1><p>HTML 中的 Javascript 脚本代码必须位于 <code>&lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 标签之间。</p>
<p>通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。</p>
<p>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。</p>
<p>Javascript 脚本代码可被放置在 HTML 页面的 <code>&lt;body&gt;</code> 和 <code>&lt;head&gt;</code> 部分中。</p>
<blockquote>
<p>通常的做法是把函数放入 <code>&lt;head&gt; </code> 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p>
</blockquote>
<h1 id="外部的-JavaScript"><a href="#外部的-JavaScript" class="headerlink" title="外部的 JavaScript"></a>外部的 JavaScript</h1><p>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p>
<p>外部 JavaScript 文件的文件扩展名是 .js。</p>
<p>如需使用外部文件，请在 <code>&lt;script&gt;</code> 标签的 “src” 属性中设置该 .js 文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;myFunction()&quot;</span>&gt;点击这里&lt;/button&gt;</span><br><span class="line">&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;myFunction 保存在名为 <span class="string">&quot;myScript.js&quot;</span> 的外部文件中。&lt;/p&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;myScript.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>js 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    document.<span class="built_in">getElementById</span>(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;我的第一个 JavaScript 函数&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>外部脚本不能包含 <code>&lt;script&gt;</code> 标签。<br>在标签中填写 onclick 事件调用函数时，不是 onclick&#x3D;函数名， 而是 onclick&#x3D;函数名 +()</p>
</blockquote>
<h1 id="JavaScript-JSON"><a href="#JavaScript-JSON" class="headerlink" title="JavaScript JSON"></a>JavaScript JSON</h1><p>JSON 英文全称 JavaScript Object Notation</p>
<p>JSON 是用于存储和传输数据的格式。</p>
<p>JSON 通常用于服务端向网页传递数据 。</p>
<ul>
<li>数据为 键&#x2F;值 对。</li>
<li>数据由逗号分隔。</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<blockquote>
<p>JSON 是 JS 对象的字符串表示法。它使用文本表示一个 JS 对象的信息，（JSON）本质是一个字符串。<br> JSON 字符串转换为 JavaScript 对象</p>
</blockquote>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> var text = <span class="string">&#x27;&#123; &quot;sites&quot; : [&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">obj = JSON.<span class="built_in">parse</span>(text);</span><br><span class="line">document.<span class="built_in">getElementById</span>(<span class="string">&quot;demo&quot;</span>).innerHTML = obj.sites[<span class="number">1</span>].name + <span class="string">&quot; &quot;</span> + obj.sites[<span class="number">1</span>].url;</span><br></pre></td></tr></table></figure>

<p>JSON.parse()	用于将一个 JSON 字符串转换为 JavaScript 对象。</p>
<p>JSON.stringify()	用于将 JavaScript 值转换为 JSON 字符串。</p>
<h1 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a>运行与调试</h1><p>在 Chrome 浏览器中可以通过按下 F12 按钮或者右击页面，选择 “ 检查 “ 来开启开发者工具</p>
<p>或者在右上角菜单栏选择 “ 更多工具 “&#x3D;》” 开发者工具 “ 来开启</p>
<ul>
<li>Console 窗口调试 JavaScript 代码<br>我们在 &gt; 符号后输入我们要执行的代码 console.log(“runoob”)，按回车后执行</li>
</ul>
<blockquote>
<p>清空 Console 窗口到内容</p>
</blockquote>
<ul>
<li>Chrome snippets 小脚本<br>我们也可以在 Chrome 浏览器中创建一个脚本来执行，在开发者工具中点击 Sources 面板，选择 Snippets 选项卡，在导航器中右击鼠标，然后选择 Create new snippet 来新建一个脚本文件</li>
</ul>
<p>点击 Create new snippet 后，会自动创建一个文件，你只需在右侧窗口输入以下代码，然后按 Ctrl+S 保存更改即可。</p>
<p>保存后，右击文件名，选择 “Run” 执行代码</p>
<h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p>debugger 关键字</p>
<h2 id="JavaScript-输出"><a href="#JavaScript-输出" class="headerlink" title="JavaScript 输出"></a>JavaScript 输出</h2><ul>
<li>使用 window.alert() 弹出警告框。</li>
<li>使用 document.write() 方法将内容写到 HTML 文档中。</li>
<li>使用 innerHTML 写入到 HTML 元素。</li>
<li>使用 console.log() 写入到浏览器的控制台。</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="JavaScript-字面量"><a href="#JavaScript-字面量" class="headerlink" title="JavaScript 字面量"></a>JavaScript 字面量</h2><ul>
<li>数字（Number）字面量 可以是整数或者是小数，或者是科学计数 (e)。</li>
<li>字符串（String）字面量 可以使用单引号或双引号:</li>
<li>表达式字面量 用于计算： 5 + 6</li>
<li>数组（Array）字面量 定义一个数组：[40, 100, 1, 5, 25, 10]</li>
<li>对象（Object）字面量 定义一个对象：{firstName:”John”, lastName:”Doe”, age:50, eyeColor:”blue”}</li>
<li>函数（Function）字面量 定义一个函数：function myFunction(a, b) { return a * b;}</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p> var 关键词来声明变量</p>
<p>当您声明新变量时，可以使用关键词 “new” 来声明其类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var carname=<span class="keyword">new</span> String;</span><br><span class="line">var x=      <span class="keyword">new</span> Number;</span><br><span class="line">var y=      <span class="keyword">new</span> Boolean;</span><br><span class="line">var cars=   <span class="keyword">new</span> Array;</span><br><span class="line">var person= <span class="keyword">new</span> Object;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量的数据类型可以使用 typeof 操作符来查看：</p>
</blockquote>
<h2 id="值类型-基本类型-："><a href="#值类型-基本类型-：" class="headerlink" title="值类型 (基本类型)："></a>值类型 (基本类型)：</h2><ul>
<li>字符串（String）		var x &#x3D; “John”;	</li>
<li>数字 (Number)			var x &#x3D; 5; </li>
<li>布尔 (Boolean)			var x&#x3D;true;</li>
<li>空（Null）</li>
<li>未定义（Undefined）	var x;</li>
<li>Symbol。</li>
</ul>
<h2 id="引用数据类型（对象类型）："><a href="#引用数据类型（对象类型）：" class="headerlink" title="引用数据类型（对象类型）："></a>引用数据类型（对象类型）：</h2><ul>
<li>对象 (Object)</li>
</ul>
<p>			</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> var person = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    id : <span class="number">5566</span>,</span><br><span class="line">    fullName : <span class="built_in">function</span>() </span><br><span class="line">	&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象属性有两种寻址方式：<br>name&#x3D;person.lastname;<br>name&#x3D;person[“lastname”];</p>
</blockquote>
<ul>
<li>数组 (Array)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var cars=[<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>var cars&#x3D;new Array();<br>cars[0]&#x3D;”Saab”;<br>cars[1]&#x3D;”Volvo”;<br>cars[2]&#x3D;”BMW”;<br>或者 (condensed array):<br>var cars&#x3D;new Array(“Saab”,”Volvo”,”BMW”);<br>或者 (literal array):<br>var cars&#x3D;[“Saab”,”Volvo”,”BMW”];</p>
</blockquote>
<ul>
<li>函数 (Function)</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> &lt;button onclick=<span class="string">&quot;myFunction(&#x27;Harry Potter&#x27;,&#x27;Wizard&#x27;)&quot;</span>&gt;点击这里&lt;/button&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;myFunction(&#x27;Bob&#x27;,&#x27;Builder&#x27;)&quot;</span>&gt;点击这里&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function <span class="built_in">myFunction</span>(name,job)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">alert</span>(<span class="string">&quot;Welcome &quot;</span> + name + <span class="string">&quot;, the &quot;</span> + job);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>带有返回值的函数</p>
</blockquote>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">function <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    var x=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">var myVar=<span class="built_in">myFunction</span>();</span><br></pre></td></tr></table></figure>

<p>函数表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var x = <span class="built_in">function</span> (a, b) &#123;<span class="keyword">return</span> a * b&#125;;</span><br></pre></td></tr></table></figure>

<p>还有两个特殊的对象：</p>
<ul>
<li>正则（RegExp）<br> &#x2F;正则表达式主体&#x2F;修饰符 (可选)</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> var patt = /runoob/i 			<span class="comment">//字符串</span></span><br><span class="line"> var n = str.<span class="built_in">search</span>(/Runoob/i);</span><br><span class="line"> var patt = /e/;				<span class="comment">//正则</span></span><br><span class="line">patt.<span class="built_in">test</span>(<span class="string">&quot;The best things in life are free!&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;runoob&#x2F;i 是一个正则表达式。<br>runoob 是一个正则表达式主体 (用于检索)。<br>i 是一个修饰符 (搜索不区分大小写)。</p>
</blockquote>
<p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
<p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p>
<p>replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。</p>
<p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>
<ul>
<li>日期（Date）</li>
</ul>
<h2 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h2><ul>
<li><p>局部变量<br> 在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。</p>
</li>
<li><p>全局变量<br>函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。</p>
</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>HTML 事件可以是浏览器行为，也可以是用户行为。</p>
<ul>
<li>HTML 页面完成加载</li>
<li>HTML input 字段改变时</li>
<li>HTML 按钮被点击</li>
</ul>
<p>|事件 			|描述								|</p>
<p>|:–:			|:–:								|</p>
<p>|onchange		|HTML 元素改变						|</p>
<p>|onclick		|用户点击 HTML 元素 					|</p>
<p>|onmouseover	|鼠标指针移动到指定的元素上时发生		|</p>
<p>|onmouseout		|用户从一个 HTML 元素上移开鼠标时发生	|</p>
<p>|onkeydown		|用户按下键盘按键						|</p>
<p>|onload			|浏览器已完成页面的加载				|</p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><strong>if-else</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)&#123;</span><br><span class="line">    当条件 <span class="number">1</span> 为 <span class="literal">true</span> 时执行的代码</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (condition2)&#123;</span><br><span class="line">    当条件 <span class="number">2</span> 为 <span class="literal">true</span> 时执行的代码</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  当条件 <span class="number">1</span> 和 条件 <span class="number">2</span> 都不为 <span class="literal">true</span> 时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        执行代码块 <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        执行代码块 <span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        与 <span class="keyword">case</span> <span class="number">1</span> 和 <span class="keyword">case</span> <span class="number">2</span> 不同时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p><strong>for</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i=<span class="number">0</span>,len=cars.length; i&lt;len; i++)</span><br><span class="line">&#123; </span><br><span class="line">    document.<span class="built_in">write</span>(cars[i] + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var person=&#123;fname:<span class="string">&quot;Bill&quot;</span>,lname:<span class="string">&quot;Gates&quot;</span>,age:<span class="number">56</span>&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (x in person)  <span class="comment">// x 为属性名</span></span><br><span class="line">&#123;</span><br><span class="line">    txt=txt + person[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>while</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件)</span><br><span class="line">&#123;</span><br><span class="line">    需要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    需要执行的代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>break</strong><br><strong>continue</strong><br><strong>typeof</strong><br>检测变量的数据类型<br><strong>null</strong><br>null 是一个只有一个值的特殊类型。表示一个空对象引用。<br><strong>undefined</strong><br>undefined 是一个没有设置值的变量</p>
<blockquote>
<p>null 和 undefined 的值相等，但类型不等</p>
</blockquote>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><ul>
<li>try 语句测试代码块的错误。</li>
<li>catch 语句处理错误。</li>
<li>throw 语句创建自定义错误。</li>
<li>finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</li>
</ul>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>这段程序中的 setTimeout 就是一个消耗时间较长（3 秒）的过程，它的第一个参数是个回调函数，第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 3 秒，然后执行回调函数 “print”，在命令行输出 “RUNOOB!”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    document.<span class="built_in">getElementById</span>(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;RUNOOB!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(print, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">function</span> () &#123;</span><br><span class="line">    document.<span class="built_in">getElementById</span>(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;RUNOOB!&quot;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-Promise"><a href="#JavaScript-Promise" class="headerlink" title="JavaScript Promise"></a>JavaScript Promise</h2><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h1 id="JavaScript-HTML-DOM"><a href="#JavaScript-HTML-DOM" class="headerlink" title="JavaScript HTML DOM"></a>JavaScript HTML DOM</h1><p>HTML DOM (文档对象模型)（Document Object Model）</p>
<ul>
<li>通过 id 找到 HTML 元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var x=document.<span class="built_in">getElementById</span>(<span class="string">&quot;intro&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过标签名找到 HTML 元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var x=document.<span class="built_in">getElementById</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">var y=x.<span class="built_in">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过类名找到 HTML 元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var x=document.<span class="built_in">getElementsByClassName</span>(<span class="string">&quot;intro&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-HTML-DOM-改变-HTML"><a href="#JavaScript-HTML-DOM-改变-HTML" class="headerlink" title="JavaScript HTML DOM - 改变 HTML"></a>JavaScript HTML DOM - 改变 HTML</h2><p><strong>内容</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;p1&quot;</span>&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.<span class="built_in">getElementById</span>(<span class="string">&quot;p1&quot;</span>).innerHTML=<span class="string">&quot;新文本!&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>属性</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img id=<span class="string">&quot;image&quot;</span> src=<span class="string">&quot;smiley.gif&quot;</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.<span class="built_in">getElementById</span>(<span class="string">&quot;image&quot;</span>).src=<span class="string">&quot;landscape.jpg&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-HTML-DOM-改变-CSS"><a href="#JavaScript-HTML-DOM-改变-CSS" class="headerlink" title="JavaScript HTML DOM - 改变 CSS"></a>JavaScript HTML DOM - 改变 CSS</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;p id=<span class="string">&quot;p1&quot;</span>&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;p2&quot;</span>&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.<span class="built_in">getElementById</span>(<span class="string">&quot;p2&quot;</span>).style.color=<span class="string">&quot;blue&quot;</span>;</span><br><span class="line">document.<span class="built_in">getElementById</span>(<span class="string">&quot;p2&quot;</span>).style.fontFamily=<span class="string">&quot;Arial&quot;</span>;</span><br><span class="line">document.<span class="built_in">getElementById</span>(<span class="string">&quot;p2&quot;</span>).style.fontSize=<span class="string">&quot;larger&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p&gt;以上段落通过脚本修改。&lt;/p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-HTML-DOM-事件"><a href="#JavaScript-HTML-DOM-事件" class="headerlink" title="JavaScript HTML DOM 事件"></a>JavaScript HTML DOM 事件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.<span class="built_in">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>).onclick=<span class="built_in">function</span>()&#123;<span class="built_in">displayDate</span>()&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>onload 和 onunload 事件会在用户进入或离开页面时被触发。</p>
<p>onchange 事件常结合对输入字段的验证来使用。</p>
<p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。</p>
<p>onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="JavaScript：直接写入-HTML-输出流"><a href="#JavaScript：直接写入-HTML-输出流" class="headerlink" title="JavaScript：直接写入 HTML 输出流"></a>JavaScript：直接写入 HTML 输出流</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">document.<span class="built_in">write</span>(<span class="string">&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;</span>);</span><br><span class="line">document.<span class="built_in">write</span>(<span class="string">&quot;&lt;p&gt;这是一个段落。&lt;/p&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您只能在 HTML 输出流中使用 document.write。 如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。</p>
</blockquote>
<h2 id="JavaScript：对事件的反应"><a href="#JavaScript：对事件的反应" class="headerlink" title="JavaScript：对事件的反应"></a>JavaScript：对事件的反应</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;alert(&#x27;欢迎!&#x27;)&quot;</span>&gt;点我!&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript：改变-HTML-内容"><a href="#JavaScript：改变-HTML-内容" class="headerlink" title="JavaScript：改变 HTML 内容"></a>JavaScript：改变 HTML 内容</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x=document.<span class="built_in">getElementById</span>(<span class="string">&quot;demo&quot;</span>);  <span class="comment">//查找元素</span></span><br><span class="line">x.innerHTML=<span class="string">&quot;Hello JavaScript&quot;</span>;    <span class="comment">//改变内容</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DOM (Document Object Model)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。</p>
</blockquote>
<h2 id="JavaScript：改变-HTML-图像"><a href="#JavaScript：改变-HTML-图像" class="headerlink" title="JavaScript：改变 HTML 图像"></a>JavaScript：改变 HTML 图像</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function">function <span class="title">changeImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    element=document.<span class="built_in">getElementById</span>(<span class="string">&#x27;myimage&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (element.src.<span class="built_in">match</span>(<span class="string">&quot;bulbon&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        element.src=<span class="string">&quot;/images/pic_bulboff.gif&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        element.src=<span class="string">&quot;/images/pic_bulbon.gif&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;img decoding=<span class="string">&quot;async&quot;</span> loading=<span class="string">&quot;lazy&quot;</span> id=<span class="string">&quot;myimage&quot;</span> onclick=<span class="string">&quot;changeImage()&quot;</span> src=<span class="string">&quot;/images/pic_bulboff.gif&quot;</span> width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;180&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript：改变-HTML-样式"><a href="#JavaScript：改变-HTML-样式" class="headerlink" title="JavaScript：改变 HTML 样式"></a>JavaScript：改变 HTML 样式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x=document.<span class="built_in">getElementById</span>(<span class="string">&quot;demo&quot;</span>)  <span class="comment">//找到元素 </span></span><br><span class="line">x.style.color=<span class="string">&quot;#ff0000&quot;</span>;           <span class="comment">//改变样式</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript：验证输入"><a href="#JavaScript：验证输入" class="headerlink" title="JavaScript：验证输入"></a>JavaScript：验证输入</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;demo&quot;</span> type=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function <span class="built_in">myFunction</span>()</span><br><span class="line">&#123;</span><br><span class="line">	var x=document.<span class="built_in">getElementById</span>(<span class="string">&quot;demo&quot;</span>).value;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">isNaN</span>(x)||x.<span class="built_in">replace</span>(/(^\s*)|(\s*$)/g,<span class="string">&quot;&quot;</span>)==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">		<span class="built_in">alert</span>(<span class="string">&quot;不是数字&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;myFunction()&quot;</span>&gt;点击这里&lt;/button&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown笔记</title>
    <url>/2024/05/16/1-%E8%AF%AD%E8%A8%80-%E5%89%8D%E7%AB%AF-Markdown%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Markdown-笔记语法"><a href="#Markdown-笔记语法" class="headerlink" title="Markdown 笔记语法"></a>Markdown 笔记语法</h1><h2 id="表格-文本样式"><a href="#表格-文本样式" class="headerlink" title="表格 &amp; 文本样式"></a>表格 &amp; 文本样式</h2><table>
<thead>
<tr>
<th align="center">样式</th>
<th>语法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">加粗</td>
<td>前后 <code>**</code> 或 <code>__</code></td>
<td><strong>加粗 1</strong> <strong>加粗 2</strong></td>
</tr>
<tr>
<td align="center">斜体</td>
<td>前后 <code>*</code> 或 <code>_</code></td>
<td><em>斜体 1</em> <em>斜体 2</em></td>
</tr>
<tr>
<td align="center">删除线</td>
<td>前后 <code>~~</code></td>
<td><del>删除线</del></td>
</tr>
<tr>
<td align="center">内联代码</td>
<td>前后 &#96;</td>
<td><code>code</code></td>
</tr>
<tr>
<td align="center">下划线</td>
<td>前<code>&lt;u&gt;</code>  后 <code>&lt;/u&gt;</code></td>
<td><u>下划线</u></td>
</tr>
<tr>
<td align="center">高亮</td>
<td>前后<code>==</code></td>
<td>&#x3D;&#x3D;高亮文本&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>此内容为引用内容</p>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><em>鼠标右击</em> 或 <em>Ctrl 键 + 点击</em> 系统默认浏览器打开链接</p>
<p><a href="https://liuluhua.github.io/">Blog网址</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>拖放图片文件、粘贴截图可直接将图片源数据存储到笔记中</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/GitHubImageBed/main/Qexo/24/3/title-icon_7de1fad10dc19f682355e8b3bbfb87c3.jpg" alt="LOGO"></p>
<p><em>图片可拖动为文件到任意窗口使用</em></p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li>项目<ul>
<li>项目 1<ul>
<li>项目 A</li>
<li>项目 B</li>
</ul>
</li>
<li>项目 2</li>
</ul>
</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol>
<li>项目 1<ol>
<li>项目 A</li>
<li>项目 B</li>
</ol>
</li>
<li>项目 2</li>
</ol>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><ul>
<li><input checked="" disabled="" type="checkbox"> A 计划<ul>
<li><input checked="" disabled="" type="checkbox"> A1 计划</li>
<li><input disabled="" type="checkbox"> A2 计划</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> B 计划</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块支持 168 种编程语言</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript 冒泡排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> swapped = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    swapped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; array.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = array[j];</span><br><span class="line">        array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">        array[j + <span class="number">1</span>] = temp;</span><br><span class="line">        swapped = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (swapped);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KaTeX-数学公式"><a href="#KaTeX-数学公式" class="headerlink" title="KaTeX 数学公式"></a><a href="https://katex.org/">KaTeX</a> 数学公式</h2><h3 id="内联公式"><a href="#内联公式" class="headerlink" title="内联公式"></a>内联公式</h3><p>质能方程 $E&#x3D;mc^2$</p>
<h3 id="公式块"><a href="#公式块" class="headerlink" title="公式块"></a>公式块</h3><p>$$<br>\displaystyle \left( \sum_{k&#x3D;1}^n a_k b_k \right)^2 \leq \left( \sum_{k&#x3D;1}^n a_k^2 \right) \left( \sum_{k&#x3D;1}^n b_k^2 \right)<br>$$</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2024/05/22/1-%E8%AF%AD%E8%A8%80-%E5%89%8D%E7%AB%AF-Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown-基础"><a href="#Markdown-基础" class="headerlink" title="Markdown 基础"></a>Markdown 基础</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <code>.md</code>, <code>.markdown</code>。</p>
<p>Markdown 能被使用来撰写电子书，如：Gitbook。</p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>Markdown 标题有两种格式。</p>
<p>使用 &#x3D; 和 - 标记一级和二级标题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">=================</span><br><span class="line">二级标题</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>Markdown 段落的换行有两种格式。</p>
<ul>
<li>使用两个以上空格加上回车</li>
<li>在段落后面使用一个空行</li>
</ul>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>

<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~~这是要删除的文本~~</span><br></pre></td></tr></table></figure>

<h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><p>利用 html 的 <code>&lt;u&gt;</code> 标签</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>

<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>脚注是对文本的补充说明。</p>
<p>Markdown 脚注的格式如下:</p>
<p>[^要注明的文本]</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>Markdown 支持有序列表和无序列表。</p>
<blockquote>
<p>无序列表使用星号 (*)、加号 (+) 或是减号 (-) 作为列表标记，这些标记后面要添加一个空格，然后再填写内容</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure>

<p>有序列表使用数字并加上 . 号来表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项</span><br><span class="line"><span class="number">2.</span> 第二项</span><br><span class="line"><span class="number">3.</span> 第三项</span><br></pre></td></tr></table></figure>

<blockquote>
<p>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项：</span><br><span class="line">- 第一项嵌套的第一个元素</span><br><span class="line">- 第一项嵌套的第二个元素</span><br><span class="line"><span class="number">2.</span> 第二项：</span><br><span class="line">- 第二项嵌套的第一个元素</span><br><span class="line">- 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><ul>
<li><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p>
</li>
<li><p>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套</p>
</li>
<li><p>区块中也可以使用列表</p>
</li>
<li><p>列表中也可以使用区块，需要在 &gt; 前添加四个空格的缩进</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; 区块</span><br><span class="line">&gt;&gt; 区块嵌套</span><br><span class="line">&gt;&gt;&gt; 区块嵌套</span><br><span class="line">&gt; <span class="number">1.</span> 区块列表<span class="number">1</span></span><br><span class="line">&gt; <span class="number">2.</span> 区块列表<span class="number">2</span></span><br><span class="line">&gt; + 区块列表<span class="number">1</span></span><br><span class="line">&gt; + 区块列表<span class="number">2</span></span><br><span class="line">* 列表<span class="number">1</span></span><br><span class="line">&gt; 列表区块<span class="number">1</span></span><br><span class="line">&gt; 列表区块<span class="number">2</span></span><br><span class="line">* 列表<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>段落上的一个函数或片段的代码可以用反引号把它包起来（&#96;）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">`<span class="built_in">printf</span>()`</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong></p>
<ol>
<li>四个空格</li>
<li>tab 制表符</li>
<li>用 ``&#96; 包裹一段代码，并指定一种语言</li>
</ol>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[链接名称](baidu.com)</span><br><span class="line">&lt;baidu.com&gt;</span><br></pre></td></tr></table></figure>

<p><strong>高级链接</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">这个链接用 <span class="number">1</span> 作为网址变量 [Google][<span class="number">1</span>]</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line">  [<span class="number">1</span>]: http:<span class="comment">//www.google.com/</span></span><br></pre></td></tr></table></figure>

<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line">![alt 属性文本](图片地址 <span class="string">&quot;可选标题&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以按照高级链接的方式，将图片地址放在文档结尾<br><strong>图片大小</strong><br>如果要修改图片大小，采用 html 的 <code>&lt;img&gt;</code> 标签</p>
</blockquote>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>

<p><strong>对齐</strong></p>
<ul>
<li><code>-:</code> 设置内容和标题栏居右对齐。</li>
<li><code>:-</code> 设置内容和标题栏居左对齐。</li>
<li><code>:-:</code> 设置内容和标题栏居中对齐。</li>
</ul>
<h1 id="Markdown-技巧"><a href="#Markdown-技巧" class="headerlink" title="Markdown 技巧"></a>Markdown 技巧</h1><blockquote>
<p>不同的 markdown 编辑器支持的语法略有不同，下方介绍的相关技巧不一定支持</p>
</blockquote>
<h1 id="Github-Flavored-Markdown-GFM-的工作清单"><a href="#Github-Flavored-Markdown-GFM-的工作清单" class="headerlink" title="Github Flavored Markdown (GFM) 的工作清单"></a>Github Flavored Markdown (GFM) 的工作清单</h1><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522155927.png" alt="image-1689835023112.png"></p>
<h3 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522155942.png" alt="image-1689835036131.png"></p>
<h1 id="KaTeX-数学公式排版语法"><a href="#KaTeX-数学公式排版语法" class="headerlink" title="KaTeX 数学公式排版语法"></a>KaTeX 数学公式排版语法</h1><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522155955.png" alt="image-1689834802409.png"></p>
<h3 id="显示效果-1"><a href="#显示效果-1" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160005.png" alt="image-1689834753660.png"></p>
<h1 id="SVG-向量流程图"><a href="#SVG-向量流程图" class="headerlink" title="SVG 向量流程图"></a>SVG 向量流程图</h1><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160016.png" alt="image-1689834876711.png"></p>
<h3 id="显示效果-2"><a href="#显示效果-2" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160027.png" alt="image-1689834889569.png"></p>
<h1 id="向量-UML-顺序图表"><a href="#向量-UML-顺序图表" class="headerlink" title="向量 UML 顺序图表"></a>向量 UML 顺序图表</h1><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160037.png" alt="image-1689834917934.png"></p>
<h3 id="显示效果-3"><a href="#显示效果-3" class="headerlink" title="显示效果"></a>显示效果</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522160043.png" alt="image-1689834929696.png"></p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>RSS</title>
    <url>/2024/05/22/1-%E8%AF%AD%E8%A8%80-%E5%89%8D%E7%AB%AF-RSS/</url>
    <content><![CDATA[<h1 id="Rsshub-的-docker-部署"><a href="#Rsshub-的-docker-部署" class="headerlink" title="Rsshub 的 docker 部署"></a>Rsshub 的 docker 部署</h1><p>下载 docker-compose.yml</p>
<p><code>wget https://raw.githubusercontent.com/DIYgod/RSSHub/master/docker-compose.yml</code></p>
<p>检查是否有需要修改的配置</p>
<p><code>vi docker-compose.yml  # or your favorite editor</code></p>
<p>创建 redis 卷 Create a docker volume to persist Redis caches</p>
<p><code>docker volume create redis-data</code></p>
<p>启动</p>
<p><code>docker-compose up -d</code></p>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">channel</span>&gt;</span> 参考手册 元素 描述</span><br><span class="line"><span class="tag">&lt;<span class="name">category</span>&gt;</span> 可选的。为 feed 定义所属的一个或多个种类。</span><br><span class="line"><span class="tag">&lt;<span class="name">cloud</span>&gt;</span> 可选的。注册进程，以获得 feed 更新的立即通知。</span><br><span class="line"><span class="tag">&lt;<span class="name">copyright</span>&gt;</span> 可选。告知版权资料。</span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span> 必需的。描述频道。</span><br><span class="line"><span class="tag">&lt;<span class="name">docs</span>&gt;</span> 可选的。规定指向当前 RSS 文件所用格式说明的 URL。</span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span>&gt;</span> 可选的。规定用于生成 feed 的程序。</span><br><span class="line"><span class="tag">&lt;<span class="name">image</span>&gt;</span> 可选的。在聚合器呈现某个 feed 时，显示一个图像。</span><br><span class="line"><span class="tag">&lt;<span class="name">language</span>&gt;</span> 可选的。规定编写 feed 所用的语言。</span><br><span class="line"><span class="tag">&lt;<span class="name">lastBuildDate</span>&gt;</span> 可选的。定义 feed 内容的最后修改日期。</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span> 必需的。定义指向频道的超链接。</span><br><span class="line"><span class="tag">&lt;<span class="name">managingEditor</span>&gt;</span> 可选的。定义 feed 内容编辑的电子邮件地址。</span><br><span class="line"><span class="tag">&lt;<span class="name">pubDate</span>&gt;</span> 可选的。为 feed 的内容定义最后发布日期。</span><br><span class="line"><span class="tag">&lt;<span class="name">rating</span>&gt;</span> 可选的。feed 的 PICS 级别。</span><br><span class="line"><span class="tag">&lt;<span class="name">skipDays</span>&gt;</span> 可选的。规定忽略 feed 更新的天。</span><br><span class="line"><span class="tag">&lt;<span class="name">skipHours</span>&gt;</span> 可选的。规定忽略 feed 更新的小时。</span><br><span class="line"><span class="tag">&lt;<span class="name">textInput</span>&gt;</span> 可选的。规定应当与 feed 一同显示的文本输入域。</span><br></pre></td></tr></table></figure>

<h1 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span> 参考手册 元素 描述</span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span> 可选的。规定项目作者的电子邮件地址。</span><br><span class="line"><span class="tag">&lt;<span class="name">category</span>&gt;</span> 可选的。定义项目所属的一个或多个类别。</span><br><span class="line"><span class="tag">&lt;<span class="name">comments</span>&gt;</span> 可选的。允许项目连接到有关此项目的注释（文件）。</span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span> 必需的。描述此项目。</span><br><span class="line"><span class="tag">&lt;<span class="name">enclosure</span>&gt;</span> 可选的。允许将一个媒体文件导入一个项中。</span><br><span class="line"><span class="tag">&lt;<span class="name">guid</span>&gt;</span> 可选的。为项目定义一个唯一的标识符。</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span> 必需的。定义指向此项目的超链接。</span><br><span class="line"><span class="tag">&lt;<span class="name">pubDate</span>&gt;</span> 可选的。定义此项目的最后发布日期。</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span> 可选的。为此项目指定一个第三方来源。</span><br></pre></td></tr></table></figure>

<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>可以在 <a href="http://www.feedvalidator.org/">http://www.feedvalidator.org</a> 找到很好的验证器。</p>
<h1 id="RSS-阅读器功能"><a href="#RSS-阅读器功能" class="headerlink" title="RSS 阅读器功能"></a>RSS 阅读器功能</h1><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>    <strong>字体</strong></p>
<p>    <strong>字号</strong></p>
<p>    <strong>背景</strong></p>
<p>    <strong>翻页</strong></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>    <strong>缩放</strong></p>
<p>    <strong>移动</strong></p>
<p>    <strong>下载</strong></p>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>    <strong>播放&#x2F;暂停</strong></p>
<p>    <strong>快进</strong></p>
<p>    <strong>进度条</strong></p>
<p>    <strong>音量</strong></p>
<p>    <strong>下载</strong></p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>    <strong>订阅</strong></p>
<p>    <strong>自动&#x2F;手动同步</strong></p>
<h1 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h1><h2 id="多线程处理等待消息返回"><a href="#多线程处理等待消息返回" class="headerlink" title="多线程处理等待消息返回"></a>多线程处理等待消息返回</h2><h2 id="xml-文件本地缓存的命名方式"><a href="#xml-文件本地缓存的命名方式" class="headerlink" title="xml 文件本地缓存的命名方式"></a>xml 文件本地缓存的命名方式</h2><h2 id="页面元素布局"><a href="#页面元素布局" class="headerlink" title="页面元素布局"></a>页面元素布局</h2><p>根据实际返回的页面元素，分别显示不同的页面</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式笔记</title>
    <url>/2024/05/17/1-%E8%AF%AD%E8%A8%80-%E5%89%8D%E7%AB%AF-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h1 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h1><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。</p>
<p><strong>正则表达式就是记录文本规则的代码</strong>，用于模式匹配和搜索文本的工具。</p>
<h1 id="正则表达式的模式"><a href="#正则表达式的模式" class="headerlink" title="正则表达式的模式"></a>正则表达式的模式</h1><ul>
<li><strong>字面值字符</strong>：普通字符按照字面意义进行匹配,例如字母、数字、空格等，可以直接匹配它们自身。</li>
<li><strong>特殊字符</strong>：例如点号 <code>.</code>、星号 <code>*</code>、加号 <code>+</code>、问号 <code>?</code> 等，它们具有特殊的含义和功能。</li>
<li><strong>字符类</strong>：用方括号 <code>[ ]</code> 包围的字符集合，用于匹配方括号内的任意一个字符。<code>[^ ]</code> 匹配除了括号内的字符以外的任意一个字符</li>
<li><strong>元字符</strong>：例如 <code>\d</code>、<code>\w</code>、<code>\s</code> 等，用于匹配特定类型的字符，如数字、字母、空白字符等。</li>
<li><strong>量词</strong>：例如 <code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code> 等，用于指定匹配的次数或范围。</li>
<li><strong>边界符号</strong>：例如 <code>^</code>、<code>$</code>、<code>\b</code>、<code>\B</code> 等，用于匹配字符串的开头、结尾或单词边界与非边界位置。</li>
<li><strong>分组和捕获</strong>：<code>( )</code>：用于分组和捕获子表达式。<code>(?: )</code>：用于分组但不捕获子表达式。</li>
</ul>
<h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><p>字符匹配直接在方括号里列出：</p>
<ul>
<li>[aeiou] 就匹配任何一个英文元音字母</li>
<li>[.?!] 匹配标点符号 (.或?或!)</li>
</ul>
<p>也可以指定一个字符范围：</p>
<ul>
<li>[0-9] 代表的含意与\d 就是完全一致的：一位数字</li>
<li>[a-z0-9A-Z_] 也完全等同于\w。</li>
</ul>
<p><strong>普通字符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[ABC]</td>
<td align="left">匹配 […] 中的所有字符</td>
</tr>
<tr>
<td align="center">[^ABC]</td>
<td align="left">匹配除了 […] 中字符的所有字符</td>
</tr>
<tr>
<td align="center">[A-Z]</td>
<td align="left">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。</td>
</tr>
<tr>
<td align="center">[\s\S]</td>
<td align="left">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配字母、数字、下划线。等价于 <code>[A-Za-z0-9_]</code></td>
</tr>
</tbody></table>
<p><strong>非打印字符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\cx</td>
<td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<p><strong>特殊字符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$</td>
<td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则$ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td>
</tr>
<tr>
<td align="center">( )</td>
<td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次。要匹配 * 字符，请使用*。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td align="center">[</td>
<td align="left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用?。</td>
</tr>
<tr>
<td align="center"><code>\</code></td>
<td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘&#39; 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用^。</td>
</tr>
<tr>
<td align="center">{</td>
<td align="left">标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">指明两项之间的一个选择。要匹配|，请使用 |。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>分支条件</strong><br><code>|</code> 元字符，用于在两种或多种模式之间进行选择</p>
<p>匹配分枝条件时，将会从左到右地测试每个条件，如果满足某个分枝，就不会再去向右测试。</p>
<p><strong>分组</strong><br>() 元字符，标记一个子表达式的开始和结束位置。例如 IP 地址表达式:<br><code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code></p>
</blockquote>
<p><strong>限定符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配 “z” 以及 “zoo”。</em> 等价于 {0,}。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，zo+ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 “do” 、 “does”、 “doxy” 中的 “do” 和 “does”。? 等价于 {0,1}。</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 “Bob” 中的 o，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配 n 次。例如，o{2,} 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 <code>o*</code>。</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 “fooooood” 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<p><strong>定位符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">非单词边界匹配。</td>
</tr>
</tbody></table>
<blockquote>
<p>不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <code>^*</code> 之类的表达式</p>
</blockquote>
<p><strong>转义字符与反义字符</strong></p>
<p>在正则表达式中，还有一些常用的转义字符,转义字符可以方便地匹配一些常见的字符类型:</p>
<table>
<thead>
<tr>
<th align="center">—</th>
<th align="center">—</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\d</td>
<td align="center">表示匹配任意一个数字字符</td>
<td></td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">表示匹配任意一个字母、数字或下划线字符</td>
<td></td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">表示匹配任意一个空白字符（包括空格、制表符、换行符等）</td>
<td></td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">表示匹配单词的边界等。</td>
<td></td>
</tr>
</tbody></table>
<p>在正则表达式中，反义字符是指用于匹配除了某些字符之外的任意字符的特殊字符。</p>
<p>反义字符以 \ 开头，后面跟着一个大写字母，表示匹配除了这个字符类别中的任意一个字符之外的所有字符。</p>
<table>
<thead>
<tr>
<th align="center">—</th>
<th align="center">—</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\D</td>
<td align="center">匹配任意一个非数字字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">匹配任意一个非字母、数字或下划线字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">匹配任意一个非空白字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">匹配不在单词边界上的任意一个字符。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>小括号的另一种用途是通过语法 (?#comment) 来包含注释</p>
<blockquote>
<p>IP 地址 2[0-4]\d(?#200-249)|25<a href="http://124.222.246.202:8080/2023/06/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#250-255">0-5</a>|[01]?\d\d?(?#0-199)。</p>
</blockquote>
<h1 id="贪婪和懒惰"><a href="#贪婪和懒惰" class="headerlink" title="贪婪和懒惰"></a>贪婪和懒惰</h1><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。</p>
<p>以这个表达式为例：a.*b，它将会匹配最长的以 a 开始，以 b 结束的字符串。</p>
<p>如果用它来搜索 aabab 的话，它会匹配整个字符串 aabab。这被称为<strong>贪婪匹配</strong>。</p>
<p>有时，我们更需要<strong>懒惰匹配</strong>，也就是匹配尽可能少的字符。</p>
<p>前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。</p>
<p>这样 <code>.*?</code> 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>
<p>现在看看懒惰版的例子吧： <code>a.*?b</code> 匹配最短的，以 a 开始，以 b 结束的字符串。如果把它应用于 aabab 的话，它会匹配 aab（第一到第三个字符）和 ab（第四到第五个字符）。</p>
<h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>
<p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">转义符</td>
</tr>
<tr>
<td align="center">(), (?:), (?&#x3D;), []</td>
<td align="center">圆括号和方括号</td>
</tr>
<tr>
<td align="center">*, +, ?, {n}, {n,}, {n,m}</td>
<td align="center">限定符</td>
</tr>
<tr>
<td align="center">^, $, \任何元字符、任何字符</td>
<td align="center">定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">替换，” 或 “ 操作,字符具有高于替换运算符的优先级，使得&#96;m</td>
</tr>
</tbody></table>
<h1 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h1><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本 (也就是此分组捕获的内容) 可以在表达式或其它程序中作进一步的处理。</p>
<p><strong>反向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code> 代表分组 1 匹配的文本。</strong></p>
<blockquote>
<p>分组 0 对应整个正则表达式 <code>\b(\w+)\b\s+\1\b</code> 可以用来匹配重复的单词，像 go go, 或者 kitty kitty。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>确定需要匹配的基本字符或字符类别&#x2F;集合等</li>
<li>确定匹配的字符或字符集合的数量</li>
<li>特殊字符和转义字符的处理</li>
<li>边界和位置的匹配</li>
<li>使用捕获组 <code>()</code> 进行多组匹配</li>
<li>使用反向引用</li>
<li>使用逻辑操作符进行判定</li>
</ol>
<h1 id="正则表达式字符含义表"><a href="#正则表达式字符含义表" class="headerlink" title="正则表达式字符含义表"></a>正则表达式字符含义表</h1><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，<code>n</code> 匹配字符 “n”。<code>\\n</code> 匹配一个换行符。序列 <code>\\</code> 匹配 “\ 而 “(“ 则匹配 “(“。</td>
<td></td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 <code>\\n</code> 或 <code>\\r</code> 之后的位置。</td>
<td></td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 <code>\\n</code> 或 <code>\\r</code> 之前的位置。</td>
<td></td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
<td></td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，<code>zo+</code> 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
<td></td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td>
<td></td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，<code>o&#123;2&#125;</code> 不能匹配 “Bob” 中的 <code>o</code>，但是能匹配 “food” 中的两个 o。</td>
<td></td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配 n 次。例如，<code>o&#123;2,&#125;</code> 不能匹配 “Bob” 中的 <code>o</code>，但能匹配 “foooood” 中的所有 o。<code>o&#123;1,&#125;</code> 等价于 <code>o+</code>。<code>o&#123;0,&#125;</code> 则等价于 <code>o*</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。<code>o&#123;0,1&#125;</code> 等价于 <code>o?</code>。请注意在逗号和两个数之间不能有空格。</td>
<td></td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，<code>o+?</code> 将匹配单个 “o”，而 <code>o+</code> 将匹配所有 <code>o</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 <code>\\n</code> 在内的任何字符，请使用像 &#96;(.</td>
<td>\n)&#96; 的模式。</td>
</tr>
<tr>
<td align="center">(pattern)</td>
<td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在 VBScript 中使用 SubMatches 集合，在 JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 <code>(</code> 或 <code>)</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">(?:pattern)</td>
<td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “ 或 “ 字符 (&#96;</td>
<td><code>) 来组合一个模式的各个部分是很有用。例如， </code>industr(?:y</td>
</tr>
<tr>
<td align="center">(?&#x3D;pattern)</td>
<td align="left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，&#96;Windows(?&#x3D;95</td>
<td>98</td>
</tr>
<tr>
<td align="center">(?!pattern)</td>
<td align="left">正向否定预查 (negative assert)，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如 &#96;Windows(?!95</td>
<td>98</td>
</tr>
<tr>
<td align="center">(?&lt;&#x3D;pattern)</td>
<td align="left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，&#96;(?&lt;&#x3D;95</td>
<td>98</td>
</tr>
<tr>
<td align="center">(?</td>
<td align="left">反向否定预查，与正向否定预查类似，只是方向相反。例如 “(?” 能匹配 “3.1Windows” 中的 “Windows”，但不能匹配 “2000Windows” 中的 “Windows”。</td>
<td></td>
</tr>
<tr>
<td align="center">&#96;x</td>
<td align="left">y&#96;</td>
<td>匹配 x 或 y。例如，&#96;z</td>
</tr>
<tr>
<td align="center">[xyz]</td>
<td align="left">字符集合。匹配所包含的任意一个字符。例如，<code>[abc]</code> 可以匹配 “plain” 中的 <code>a</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">[^xyz]</td>
<td align="left">负值字符集合。匹配未包含的任意字符。例如，<code>[^abc]</code> 可以匹配 “plain” 中的p、l、i、n。</td>
<td></td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="left">字符范围。匹配指定范围内的任意字符。例如，<code>[a-z]</code> 可以匹配 <code>a</code> 到 <code>z</code> 范围内的任意小写字母字符。</td>
<td></td>
</tr>
<tr>
<td align="center">[^a-z]</td>
<td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，<code>[^a-z]</code> 可以匹配任何不在 <code>a</code> 到 <code>z</code> 范围内的任意字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如，<code>er\\b</code> 可以匹配”never” 中的 <code>er</code>，但不能匹配 “verb” 中的 <code>er</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">匹配非单词边界。<code>er\\B</code> 能匹配 “verb” 中的 <code>er</code>，但不能匹配 “never” 中的 <code>er</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\cx</td>
<td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的<code>c</code> 字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">匹配一个数字字符。等价于 [0-9]。</td>
<td></td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">匹配一个非数字字符。等价于 [^0-9]。</td>
<td></td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
<td></td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
<td></td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
<td></td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
<td></td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
<td></td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
<td></td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
<td></td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配字母、数字、下划线。等价于<code>[A-Za-z0-9_]</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">匹配非字母、数字、下划线。等价于<code>[^A-Za-z0-9_]</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\xn</td>
<td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，<code>\\x41</code> 匹配 “A”。<code>\\x041</code> 则等价于 <code>\\x04</code> &amp; “1”。正则表达式中可以使用 ASCII 编码。</td>
<td></td>
</tr>
<tr>
<td align="center">\num</td>
<td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，<code>(.)\\1</code> 匹配两个连续的相同字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td>
<td></td>
</tr>
<tr>
<td align="center">\nm</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td>
<td></td>
</tr>
<tr>
<td align="center">\nml</td>
<td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td>
<td></td>
</tr>
<tr>
<td align="center">\un</td>
<td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td>
<td>&#96;</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>ARINC825</title>
    <url>/2024/09/10/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-ARINC825/</url>
    <content><![CDATA[<h1 id="ARINC825-协议栈"><a href="#ARINC825-协议栈" class="headerlink" title="ARINC825 协议栈"></a>ARINC825 协议栈</h1><p>ARINC825 规范全称为机载 CAN 网络通用标准（The General Standardization of CAN for Airborne Use）。顾名思义，ARINC825 规范是建立在 CAN 物理网络基础上的高层规范。ARINC825 协议物理层和数据链路层与 CAN 总线基本一致，而在网络层则增加了特殊的路由寻址、数据包封装和流速控制等功能；并在传输层引入了逻辑信道划分与数据包重发等功能。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725947686000u8cdr1.png" alt="gh"></p>
<h1 id="物理层接口"><a href="#物理层接口" class="headerlink" title="物理层接口"></a>物理层接口</h1><p>为了确保可靠的通信，ARINC825 的电气特性、总线收发条件、数据率等规定均符合 ISO 11898 标准。规范中还特别强调了每一位的时序计算及电磁兼容性。ARINC825 支持以下数据率：1Mb&#x2F;s、500Kb&#x2F;s、250Kb&#x2F;s、125Kb&#x2F;s 及 83.333Kb&#x2F;s。</p>
<h1 id="报文传输模式和-ID-结构"><a href="#报文传输模式和-ID-结构" class="headerlink" title="报文传输模式和 ID 结构"></a>报文传输模式和 ID 结构</h1><p>ARINC825 规范对 CAN 2.0B 扩展帧的 29 位标识进行了划分。其中高 3 位被用于逻辑通信通道（Logical Communication Channels, LCC）标识，按优先级从高到低依次为异常事件通道（EEC）、正常工作通道（NOC）、节点服务通道（NSC）、用户自定义通道（UDC）、测试与维护通道（TMC）及 CAN 基本帧兼容通道（FMC）。其中 EEC 和 NOC 通道用于多播（Any-to-Many）通信，NSC 和 TMC 通道用于端到端（Peer-to-Peer）通信。</p>
<p>ARINC825 协议支持 ATM（Anyone to Many）和 PTP（Peer to Peer）两种传输模式，报文一般采用 29 位扩展 ID，并实现了逻辑信道（LLC）的定义与划分，具体如表 4-1 所示。而且，ARINC825 协议的报文结构又按照传输模式不同而有所区别。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725948077000lvs0wo.png" alt="gh"></p>
<h2 id="ATM-模式"><a href="#ATM-模式" class="headerlink" title="ATM 模式"></a>ATM 模式</h2><p>ATM 模式是传统的 CAN 总线收发模式，通信节点间为对等关系，采用广播方式发送数据，并按照报文 ID 进行逐位仲裁和屏蔽接收，其报文 ID 域结构如图所示，包括功能标识（Function ID, FID）、区域标识（Local, LCL）、加密标识（Private, PVT）、数据对象代码（Data Object Code, DOC）和冗余标识（Redundancy Channel Identifier, RCI）。</p>
<p>ATM 通信的优势在于能够与网络中所有的节点建立持续的数据链接，但是 ATM 需要处理非自身的数据包，增加了接收节点的工作量。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/172594812900032816d.png" alt="gh"></p>
<h2 id="PTP-模式"><a href="#PTP-模式" class="headerlink" title="PTP 模式"></a>PTP 模式</h2><p>PTP 模式则扩展了是传统的 CAN 总线收发模式，允许网络中任意两个节点间采用基于客户端&#x2F;服务器（ Client&#x2F;Server ）的面向连接或无连接两种通信方式，其报文 ID 域结构如图所示，可支持 512 个不同的服务器节点和 128 种不同的服务类型。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725948148000f917s4.png" alt="gh"></p>
<blockquote>
<p>Server FID(Function ID) + SID(Server ID) +RCI 部分统称为 NID（Node ID）</p>
</blockquote>
<h1 id="高度完整性协议"><a href="#高度完整性协议" class="headerlink" title="高度完整性协议"></a>高度完整性协议</h1><p>ARINC825 协议针对系统控制器受到干扰时可能产生的错误，在 CAN2.0B 故障检测机制的基础上，加入了高度完整性协议（High Integrity Protocol）。如图 4-4 所示，该协议以减少数据载荷为代价，引入 MIC 校验码与 SN 号，对报文正确性及完整性进行验证。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725949553000ocyqpf.png" alt="gh"></p>
<ol>
<li>数据域消息格式，共包含 8bytes，前 5bytes 为有效数据载荷，第 6byte 为 SN 码，即消息序列号，第 7-8bytes 为 MIC，及数据完整性校验结果</li>
<li>高完整性校验范围，共包含 12bytes，即 29bits 的帧 ID，3bits 的补充位，8bytes 的数据域</li>
<li>处理时，先设置每个节点独立的消息序列号</li>
<li>按照高完整性校验范围，依次逐字节进行高完整性校验运算，得到 16bits 的 CRC 码作为数据完整性校验结果</li>
</ol>
<h1 id="带宽管理"><a href="#带宽管理" class="headerlink" title="带宽管理"></a>带宽管理</h1><p>传统的 CAN 总线协议是基于多主竞争下的位仲裁机制来管理总线的访问权和带宽，优先级较高的数据帧可以连续不受制约地访问总线，在总线载荷繁重时会造成低优先级数据帧较大的不确定延时。</p>
<p>ARINC825 引入时间触发总线调度技术，时间触发总线调度控制基于两个概念，Major Frame（主时间帧）和 Minor Frame（基本时间帧）。整个网络的数据传输周期（在一个周期内，每个数据包至少能得到一次传输机会）称为一个 主时间帧，它包含若干个基本时间帧 。Minor Frame 是总线中传输频率最</p>
<p>大的帧的周期，是 ARINC825 规范中进行带宽管理的最小时间单位。</p>
<p>同一时间帧内的数据帧采用多主竞争发送，只要控制总线中各个节点在基本时间帧内的发送，就可以保证总线节点间通信的确定性。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725957569000quevlt.png" alt="gh"></p>
<p>计算总线负载时，需要选取一个时间片段进行分析，使用时间间隔最小的基本时间帧作为发送间隔（Transmission Interval），可以计算出最大的总线负载。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1727234489000go8dl3.png" alt="gh"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1727234468000hhi6jl.png" alt="gh"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/172723445300093ixzh.png" alt="gh"></p>
<h1 id="ARINC-825-网络"><a href="#ARINC-825-网络" class="headerlink" title="ARINC 825 网络"></a>ARINC 825 网络</h1><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>设计分为处理端，控制端和收发端</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/17272346430003csrep.png" alt="gh"></p>
<h3 id="处理端"><a href="#处理端" class="headerlink" title="处理端"></a>处理端</h3><p>接收由传感器等设备采集到并发送过来的消息，并将接收到的消息进行处理，处理后的消息满足 CAN 和 ARINC825 网络的确定性和完整性要求</p>
<ul>
<li>时间片管理模块<br>  规划时间片通信调度机制：所有节点具有相同的主时间片和次时间片，主时间片包括若干次时间片和空闲时间窗(也称为仲裁窗)，每个次时间片的时间长度不小于系统内所有的节点依次进行总线竞争的时间，主时间片是当前系统周期消息的最大周期发送时间，即周期消息刷新时间，且次时间片是主时间片的偶分数。</li>
<li>消息接收和处理模块<br>  通过给定的时间片，接收传感器等设备的消息并进行格式化处理<br>  通过给定的时间片，接收控制端返回的消息并进行格式化处理</li>
<li>消息完整性校验模块<br>  进行高度完整性校验，步骤见 <a href="#%E9%AB%98%E5%BA%A6%E5%AE%8C%E6%95%B4%E6%80%A7%E5%8D%8F%E8%AE%AE">高度完整性协议</a></li>
<li>片外 SDRAM 控制模块<br>  存储格式化处理后的消息和完整性校验的校验结果，按照格式化的消息，独立的帧 ID，完整性校验的校验结果进行分别存储</li>
<li>串口通信模块<br>  将处理完成的消息发送给控制端</li>
</ul>
<h3 id="控制端"><a href="#控制端" class="headerlink" title="控制端"></a>控制端</h3><p>控制端通过热冗余进行数据的收发，以满足 ARINC825 的可用性要求</p>
<ul>
<li>双链路冗余模式，每个节点第一主节点的消息均发送到同一个 ARINC825_A 总线中，第二主节点的消息均发送到同一个 ARINC825_B 总线中<br>  系统中存在两条独立的通信链路，用于传输相同的数据或执行相同的任务。这两条链路同时工作，当其中一条链路出现故障时，另一条链路可以继续传输数据或执行任务，从而保证系统的正常运行。</li>
<li>双链路节点混合冗余模式，每个节点第一主节点的消息混合发送到两路 ARINC825 总线中 ，若干节点的第一主节点的消息交替发送至 ARINC825_A 和 ARINC825_B 总线中，同时节点中的第二主节点的消息发送至另一路 ARINC825 总线中。<br>  系统中不仅存在两条独立的通信链路，而且每个链路中的节点也可能存在冗余配置</li>
</ul>
<blockquote>
<p>冗余是指重复配置系统的一些部件，当系统发生故障时，冗余配置的部件介入并承担故障部件的工作，由此减少系统的故障时间。<br>热备是一种备份方式，即系统中存在一个主设备处于运行状态，同时有一个备份设备也处于通电运行状态（但可能未承担主要工作任务），随时准备在主设备出现故障时立即接管工作。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1727232970000ifohof.png" alt="gh"></p>
<h3 id="收发端"><a href="#收发端" class="headerlink" title="收发端"></a>收发端</h3><p>直接和总线进行交互</p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><h3 id="处理同步"><a href="#处理同步" class="headerlink" title="处理同步"></a>处理同步</h3><p>网关发送参考消息，总线上各节点接收到参考消息后，时间基准归零。保证总线上所有节点具有相同的主时间片和基本时间片，主时间片包含若干基本时间片和空闲时间窗口。基本时间片的时间长度不小于系统内所有节点同时进行总线竞争所需的总时间。基本事件片分为同步相和异步相，同步相用于传输周期性消息，异步相用于传输非周期性消息竞争，空闲时间窗口用于传输非周期性消息。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1727248636000d77eqm.png" alt="gh"></p>
<p>在 ARINC 825 规范中，主次时间帧的同步通常由 CAN 网络中的网关或中央控制节点发出同步信号，以确保所有节点的时间帧保持一致。然而，除了由网关发起的同步信号外，还有其他几种方式可以实现主次时间帧的同步或协调，具体如下：</p>
<h3 id="分布式时钟同步"><a href="#分布式时钟同步" class="headerlink" title="分布式时钟同步"></a><strong>分布式时钟同步</strong></h3><p>   一种方式是通过<strong>分布式时钟同步机制</strong>，让各个节点根据共同的参考时钟（如 GPS、PTP）来协调其本地时钟。每个节点可以定期接收时钟校准信号，从而调整其主次时间帧，使其与网络中的其他节点保持一致。这个方法适用于大规模系统，特别是在需要精准同步的应用中。</p>
<h3 id="事件驱动同步"><a href="#事件驱动同步" class="headerlink" title="事件驱动同步"></a><strong>事件驱动同步</strong></h3><p>   另一种方法是通过特定事件或消息的触发来实现同步。比如，当某一特定节点发送一个关键消息时，其他节点可以根据这个事件作为触发信号来调整自身的主次时间帧。这种方式可以适应系统中具有异步特性的操作场景。</p>
<h3 id="静态调度表"><a href="#静态调度表" class="headerlink" title="静态调度表"></a><strong>静态调度表</strong></h3><p>   在某些系统中，可以使用<strong>静态调度表</strong>来提前规划好所有节点的时间帧。每个节点在设计时就被赋予了固定的时间周期，用于发送或接收数据。这种方法通常用于具有固定通信模式的实时系统。所有节点根据预定义的调度表来操作，而不依赖动态的同步信号。</p>
<h3 id="分层架构同步"><a href="#分层架构同步" class="headerlink" title="分层架构同步"></a><strong>分层架构同步</strong></h3><p>   在复杂的系统中，可能会使用<strong>分层架构</strong>来实现时间同步。一个高级别的控制节点可以管理主时间帧的同步，而次时间帧可以由各个子网络或次节点自己管理。这种架构可以减少中央节点的同步负担，提供一定的灵活性。</p>
<h3 id="自主同步的节点"><a href="#自主同步的节点" class="headerlink" title="自主同步的节点"></a><strong>自主同步的节点</strong></h3><p>   在某些情况下，系统中的每个节点可以<strong>自主管理</strong>自己的主次时间帧，而无需依赖中央同步。每个节点可以根据自己内部的调度机制来划分主次时间帧，只要确保与其他节点的通信在规定的窗口内进行即可。这种方式适合一些分布式系统，节点间的时间不需要严格同步，而只需要在某些时刻进行协调。</p>
<h3 id="多网关同步"><a href="#多网关同步" class="headerlink" title="多网关同步"></a><strong>多网关同步</strong></h3><p>   当网络规模较大或具有不同功能区块时，可能会使用多个网关或中央控制单元。这些网关分别负责自己区域的同步任务，而通过跨网关的通信来确保整个网络的主次时间帧协调。这种方式可以增加系统的可靠性和扩展性。</p>
<h3 id="自主主次时间帧的实现"><a href="#自主主次时间帧的实现" class="headerlink" title="自主主次时间帧的实现"></a>自主主次时间帧的实现</h3><p>理论上，可以让<strong>各个节点自主使用自己的主次时间帧</strong>，但这取决于应用场景的具体需求。在一些情况下，这种分布式时间管理可以简化系统设计，但会增加节点之间的协调难度，尤其是在高实时性要求的系统中。如果各个节点的主次时间帧不严格同步，可能会导致数据传输延迟、不一致或数据丢失的问题。因此，节点自主时间帧的应用需要谨慎考虑网络拓扑结构、消息优先级和通信窗口的合理分配。</p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CANOpen 笔记</title>
    <url>/2024/05/20/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CANOpen-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>项目地址</strong> </p>
<ul>
<li>CANopenNode <a href="https://github.com/CANopenNode/CANopenNode">https://github.com/CANopenNode/CANopenNode</a></li>
<li>CANopenLinux <a href="https://github.com/CANopenNode/CANopenLinux">https://github.com/CANopenNode/CANopenLinux</a></li>
<li>CANopenDemo <a href="https://github.com/CANopenNode/CANopenDemo">https://github.com/CANopenNode/CANopenDemo</a></li>
<li>CANopenEditor <a href="https://github.com/CANopenNode/CANopenEditor">https://github.com/CANopenNode/CANopenEditor</a></li>
</ul>
<p><strong>帮助文档</strong></p>
<ul>
<li>CANopenLinux <a href="https://canopennode.github.io/CANopenLinux">https://canopennode.github.io/CANopenLinux</a></li>
<li>CANopenDemo <a href="https://canopennode.github.io/index.html">https://canopennode.github.io/index.html</a></li>
</ul>
<h1 id="CANopen"><a href="#CANopen" class="headerlink" title="CANopen"></a>CANopen</h1><p><code>CANopen</code> 是一种基于 <code>CAN（Controller Area Network）</code> 通信协议的高层协议和设备协议，定义了网络管理、设备配置、通信对象和应用对象等方面的标准，以确保不同设备之间的互操作性和通信的一致性。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>CiA 通过一系列文件维护保持 CANopen 设备和通讯协议规定。基本配置由 CiA 301 CANopen 应用层和通信配置规范定义。规范包括：</p>
<ul>
<li>CANopen 对象字典中的数据类型、编码规则和对象  </li>
<li>CANopen 通信服务和协议  </li>
<li>CANopen 网络管理服务和协议  </li>
<li>CANopen 通讯配置 – 物理层  </li>
<li>预定义的通信对象标识符连接数集、与紧急事件相关的对象、时间标识和同步通信对象</li>
</ul>
<p>此基本 CiA 301 配置规定由其他 CiA 文件进行了补充和扩展，为一些具体领域的设备和功能规定了设备、应用程序和接口配置。具体有以下几个部分，按照自身应用程序的实际情况引入。</p>
<ul>
<li>CiA 302 – CANopen 附加应用层功能  </li>
<li>CiA 303-1 – 布线和接头管脚分配  </li>
<li>CiA 303-3 – 指示器规范  </li>
<li>CiA 306 – CANopen 电子数据表规范  </li>
<li>CiA 309 – 从其他网络接入 CANopen  </li>
<li>CiA 315 – CANopen 通用框架  </li>
<li>CiA 401 – 通用 I&#x2F;O 模块的 CANopen 设备配置  </li>
<li>CiA 402 – 驱动和运动控制的 CANopen 设备配置</li>
</ul>
<h2 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h2><p>CANopen 的 OSI 模型，Data link 和 Physical 是由 CAN 进行实现的，Presentation 和 Session 是由 CANopen 进行实现的。</p>
<ul>
<li>物理层（Physical Layer）定义了物理介质、电气特性、传输速率和编码规范等。</li>
<li>数据链路层（Data Link Layer）划分数据帧、错误检测与纠正、流量控制。</li>
<li>网络层（Network Layer）提供路径选择、逻辑寻址、路由选择等功能。</li>
<li>传输层（Transport Layer）提供端到端的传输控制和错误恢复。</li>
<li>会话层（Session Layer）建立、维护、同步和恢复会话。</li>
<li>表示层（Presentation Layer）数据的加密、压缩、格式转换等。</li>
<li>应用层（Application Layer）用户数据交互和应用支持。</li>
</ul>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520145302.png" alt="image.png"></p>
<h2 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h2><p>每个 CANopen 设备都遵循一个通用的设备模型，因此不同的设备能依据同样的 CANopen 标准。CANopen 设备模型的三个组成部分是：      </p>
<ul>
<li>通讯接口</li>
<li>对象字典</li>
<li>应用程序<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523161558.png" alt="image.png"><br>一个 CANopen 设备必须支持一定数量的网络管理服务 NMT，需要至少一个 SDO。每个生产或消费过程数据的设备需要至少一个 PDO。所有其它的通讯对象是可选的。</li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><strong>通讯模式</strong></p>
<ul>
<li>设备&#x2F;节点通信有 3 种模型：主设备&#x2F;从设备、客户端&#x2F;服务器和生产者&#x2F;消费者</li>
</ul>
<p><strong>通讯协议</strong></p>
<ul>
<li>协议用于通信，例如配置节点（SDO）或传输实时数据（PDO）</li>
<li>定义了设备之间通信的机制和方式，包括对象字典、服务数据对象（SDO）、过程数据对象（PDO）、网络管理（NMT）等。</li>
</ul>
<p><strong>设备状态</strong></p>
<ul>
<li>设备支持不同的状态。“主”节点可以更改“从”节点的状态，例如将其重置。</li>
</ul>
<p><strong>对象字典（Object Dictionary，OD）</strong></p>
<ul>
<li>每个 CANopen 设备都有一个对象字典，OD 带有指定设备配置的条目，类似于一个查找表，列出了设备中的所有参数和数据。对象字典包括通信对象和应用对象，使用 16 位索引和 8 位子索引进行标识。可以通过 SDO 访问。</li>
</ul>
<p><strong>EDS（Electronic Data Sheet）</strong></p>
<ul>
<li>EDS 是用于 OD 的标准文件格式，允许更新设备的服务</li>
</ul>
<h1 id="通讯模式"><a href="#通讯模式" class="headerlink" title="通讯模式"></a>通讯模式</h1><p>CANopen 通过不同的通讯模式在节点之间传输报文:</p>
<p><strong>生产&#x2F;消费模式:</strong> 它是一个广播连接，以推送模式工作（信号生产节点向消费节点发送无任何特定要求的信息）和引入模式（消费节点向信号生产节点要求特定信息）。</p>
<p><strong>用户机&#x2F;服务器模式:</strong> 通过 SDO 协议，用户节点向服务器节点要求数据（对象字典索引），然后服务器节点通过发送在指定索引处的对象内容来响应。</p>
<p><strong>主机&#x2F;从机模式:</strong> 主机节点可在任何时候向从机节点发送或要求数据。例如：NMT 协议通信。</p>
<h1 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h1><p>数据帧由帧头 + 数据区组成，帧头由功能 ID+NodeID+RTR(远程传输请求)构成。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523134834.png" alt="image.png"></p>
<p>11 位的 CAN ID 称为通信对象标识符（COB-ID），分为两个部分：</p>
<ul>
<li>前 4 位等于功能代码 <code>Function Code</code>（代表一个 CANopen 通信对象）</li>
<li>后 7 位包含节点 ID<code>Node ID</code></li>
</ul>
<p>CANopen 网络中使用的 COB-ID 标识符的预定义分配</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520150656.png" alt="image.png"></p>
<p>数据区部分的定义就要通过 CANopen 中的重要概念，对象字典 OD 来实现。</p>
<h1 id="对象字典-OD"><a href="#对象字典-OD" class="headerlink" title="对象字典 OD"></a>对象字典 OD</h1><p>对象字典（OD）是 CANopen 协议的核心概念。它是一组预定义的 CANopen 对象，使用索引和子索引访问对象。对象字典提供了应用程序和设备之间的沟通方式，提供了配置该设备的途径，和与设备通信的方法。</p>
<p>所有 CANopen 节点必须具有对象字典（OD），对象字典是指含有描述的 CANopen 节点的 <code>行为</code> 的所有 <code>参数</code> 的 <code>标准化结构</code>。</p>
<p><strong>设备（例如从设备）的 OD 条目可以由其他设备（例如主机）使用 SDO 通过 CAN 进行访问</strong>。例如，通过 SDO 可以使应用程序主机更改从属发送心跳的频率。</p>
<p>作为对象索引存储在对象字典中的信息包括：</p>
<ul>
<li>通信和应用程序配置参数</li>
<li>标准化设备配置参数</li>
<li>制造商特定设备配置文件参数</li>
<li>设备配置静态数据类型</li>
<li>设备配置复杂数据类型</li>
<li>复杂和静态数据类型</li>
<li>制造商特定数据类型</li>
<li>其他</li>
</ul>
<p>可以按照 CANopen 标准的指导，以预定义的方式添加自己特定的制造商配置和数据类型。制造商还可以通过扩展由标准设备配置和数据类型规范要求的标准设备功能，来增强其设备的功能。</p>
<h3 id="主索引"><a href="#主索引" class="headerlink" title="主索引"></a>主索引</h3><p>索引值低于 0x0FFF 的是一些数据类型定义。一个节点的对象字典的有关范围在 0x1000 到 0x9FFF 之间，该范围内定义了一系列称为子协议的文档，用于定义节点的通讯行为。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523161012.png" alt="image.png"></p>
<p><strong>通讯子协议区域详细划分</strong><br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524131554.png" alt="image.png"></p>
<p><strong>通用通讯对象</strong><br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524131828.png" alt="image.png"></p>
<h2 id="OD-示例配置"><a href="#OD-示例配置" class="headerlink" title="OD 示例配置"></a>OD 示例配置</h2><p>下图是一个 TPDO 的定义示例，该 TPDO 在主索引 0x1800 的子索引中定义该 TPDO 相关的通信参数，主要是 TPDO 的发送类型和触发事件等设置，同时在和 0x1800 地址对应的 0x1A00 中定义了映射参数，在该参数的子索引中，定义了具体的映射地址和对象。并给出了该 TPDO 消息在发送时数据区内容。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524135154.png" alt="image.png"></p>
<h2 id="电子数据表（EDS）"><a href="#电子数据表（EDS）" class="headerlink" title="电子数据表（EDS）"></a>电子数据表（EDS）</h2><p>一个节点的对象字典是在电子数据文档（EDS：Electronic Data Sheet）中描述。</p>
<p>实际上，将使用适当的软件工具来配置&#x2F;管理复杂的 CANopen 网络。</p>
<p>一个电子数据表（EDS）是一个标准化的电子文件，描述为 CANopen 设备定义的通信功能和对象。此供应方生成的文件有 3 个区域：</p>
<ul>
<li>关于 EDS 文件的信息</li>
<li>一般设备信息</li>
<li>具有默认变量的对象字典</li>
</ul>
<p>EDS 文件可用作 CANopen 设备的配置和网络设置工具。</p>
<h1 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h1><h2 id="通信对象"><a href="#通信对象" class="headerlink" title="通信对象"></a>通信对象</h2><p>CANopen 通信单元由必要的通信接口和协议软件组成，通过总线在节点之间进行通信对象的发送和接收。各种 CANopen 通信对象用于实现各种类型的通信，CANopen 协议定义了几种不同类型的通信对象，每种对象都用于特定的通信目的：</p>
<ol>
<li><strong>过程数据对象（PDO）</strong>：用于实时数据传输，具有高优先级和低延迟。PDO 传输的数据量小，但传输速度快，适用于传感器数据和控制命令等实时性要求高的场景。</li>
<li><strong>服务数据对象（SDO）</strong>：用于非实时数据传输，如配置参数和大数据块的传输。SDO 传输的灵活性更大，但优先级较低，适用于设备配置和诊断等场景。</li>
<li><strong>网络管理对象（NMT）</strong>：用于控制设备状态和网络操作模式，如启动、停止和复位设备。</li>
<li><strong>同步对象（SYNC）</strong>：用于网络同步，确保所有节点在同一时间点进行操作。</li>
<li><strong>时间戳对象（TIME）</strong>：提供时间参考，用于时间相关的操作。</li>
<li><strong>紧急情况对象 (EMCY)</strong> ：</li>
</ol>
<p>指定状态下可用的通讯对象及状态转换说明：</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523165217.png" alt="image.png"></p>
<p>中括号内的字母表示处于不同状态那些通讯对象可以使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a. NMT</span><br><span class="line">b. Node Guard </span><br><span class="line">c. SDO </span><br><span class="line">d. Emergency</span><br><span class="line">e. PDO </span><br><span class="line">f. Boot-up</span><br></pre></td></tr></table></figure>

<h2 id="网络管理（NMT）"><a href="#网络管理（NMT）" class="headerlink" title="网络管理（NMT）"></a>网络管理（NMT）</h2><p>所有的 CANopen 节点都有自己专属的 NMT 状态，而主站可以通过 NMT 去控制从站的状态。CANopen 的网络管理采取主机&#x2F;从机通信模式。整个网络被设置为一个“状态机”，其中一个设备被指定为 NMT 主机，其余设备被指定为 NMT 从机。NMT 主机控制和监控 NMT 从机的状态。通过 NMT 主机触发，NMT 从机进行状态转换，实现 CANopen 网络的各个阶段。</p>
<p>NMT 服务用于通过 NMT 命令来控制 CANopen 设备的状态。只有 NMT-Master 节点能够传送 NMT Module Control 报文。所有从设备必须支持 NMT 模块控制服务。NMT Module Control 消息不需要应答。为了更改状态，NMT 主设备发送 COBID+2 字节的消息。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520151626.png" alt="image.png"></p>
<ol>
<li>COB-ID 为 0（function code&#x3D;0 和 node ID&#x3D;0），优先级为最高。</li>
<li>第一个 CAN 数据字节 Requested State 包含请求的状态</li>
<li>第二个 CAN 数据字节包含目标节点的节点 ID。节点 ID 0 表示广播命令。所有从节点都处理此消息。</li>
</ol>
<p>通过具体的 NMT 协议，如启动协议、模块控制协议、心跳协议（Heartbeat Protocol）和节点监测，<strong>主机向从机发出状态更改命令，进行这些状态转换</strong>。NMT 主机向特定节点或所有节点发送 NMT 命令代码以改变状态。</p>
<p>在<strong>预运行状态</strong>下，应用程序配置工具可以使用<strong>SDO 通信</strong>，配置 NMT 从机和设置参数。由于设备尚未开始运行，因此在此状态下<strong>不能使用 PDO 通信</strong>。</p>
<p>一旦状态从<strong>预运行</strong>变为<strong>运行</strong>状态，节点中的<strong>所有通信对象</strong>都将变为活跃状态，并且运行节点之间均可进行 PDO 和 SDO 通信。在此阶段，<strong>也可以通过 SDO 访问对象字典</strong>。当节点状态更改为停止时，PDO 和 SDO 通信都将停止。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524132402.png" alt="image.png"></p>
<p><strong>实际状态取值</strong></p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">Byte 0 取值（命令）</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">（2）</td>
<td align="center">01</td>
<td>operation</td>
</tr>
<tr>
<td align="center">（3）</td>
<td align="center">02</td>
<td>stop</td>
</tr>
<tr>
<td align="center">（4）</td>
<td align="center">80</td>
<td>pre-operation</td>
</tr>
<tr>
<td align="center">（5）</td>
<td align="center">81</td>
<td>reset app</td>
</tr>
<tr>
<td align="center">（6）</td>
<td align="center">82</td>
<td>reset communication</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># node 0x6 进入 `operational` 模式</span></span><br><span class="line">000 01 06</span><br><span class="line"><span class="comment"># 所有节点进入 `pre-operational` 模式</span></span><br><span class="line">000 80 00</span><br></pre></td></tr></table></figure>

<h2 id="服务数据对象（SDO）"><a href="#服务数据对象（SDO）" class="headerlink" title="服务数据对象（SDO）"></a>服务数据对象（SDO）</h2><p>SDO 提供了直接访问 CANopen 设备对象字典的入口，入口条件包括数据类型及大小。</p>
<p>访问者被称作客户端(client)，对象字典被访问且提供所请求服务的 CANopen 设备别称作服务器(server)。任何类型的 SDO 传输都由客户端发起，数据字典 OD 持有者是服务端，客户端和服务端都可以主动中止传输。通常情况下 CAN 总线网络中只有一个客户端。</p>
<p>客户的 CAN 报文和服务器的应答 CAN 报文总是包含 8 字节数据（尽管不是所有的数据字节都一定有意义）。一个客户的请求一定有来自服务器的应答。如果超时没有确认，则客户端节点将会重新发送原报文。</p>
<p>SDO 服务用于访问&#x2F;更改 CANopen 设备的对象字典中的值。允许 CANopen 节点通过 CAN 网络读取另一个节点的对象字典&#x2F;编辑值。下载（Download）是指对对象字典进行写操作，上传（Upload）指对对象字典进行读操作。</p>
<p>客户端节点可以通过以下 CAN 帧广播来启动 SDO 下载到节点 5，这将触发节点 5（并被其他节点忽略）。SDO 客户端的“接收”（即请求）CAN 帧如下所示：</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520153535.png" alt="image.png"></p>
<p>SDO 消息变量数据区 Byte 说明：</p>
<ul>
<li>Byte0 命令字节，主要定义了以下内容：<ul>
<li>CCS（客户端命令说明符，Client Command Specifier）描述<strong>传输类型</strong>（下载 download&#x2F;上载 upload）</li>
<li>n 是数据字节 4-7 中<strong>不包含数据的 bytes</strong> （如果设置了 e＆s 则有效）</li>
<li>如果设置，e 表示 <code>快速传输</code>(所有数据在单个 CAN 帧中)&#x2F;<code>分段传输</code></li>
<li>如果设置，s 表示<strong>数据大小</strong>显示在 n 中</li>
</ul>
</li>
<li>Byte1+Byte2 主索引字节（16 位）确认 OD 主索引</li>
<li>Byte3 子索引字节（8 位）确认 OD 子索引</li>
<li>Byte4-7 包含实际的数据内容</li>
</ul>
<p><em>一旦节点（客户端）发送了 CAN 帧，从节点 5（服务端）便会通过 RSDO 进行响应，并带有 COB-ID585。该响应包含索引&#x2F;子索引和 4 个空数据字节。<br>自然地，如果客户端节点请求上传（即从节点 5 OD 读取数据），则节点 5 将以字节 4-7 中包含的相关数据进行响应。</em></p>
<p>SDO 灵活，但会带来大量输出，使其不适用于实时操作数据。同时数据只能包含在后续 4 个字节中，对于较大的数据方案，无法一次传输完毕。因此 SDO 中实现了 2 种传送机制，两种传送机制实际包含 4 个请求&#x2F;应答协议，共有 5 个协议如下：</p>
<ul>
<li>快速传送（Expedited transfer） ： 最多传输 4 字节数据<ul>
<li>启动域下载 （Initiate Domain Download）</li>
<li>启动域上传 （Initiate Domain Upload）</li>
</ul>
</li>
<li>分段传送（Segmented transfer） ： 传输数据长度大于 4 字节<ul>
<li>域分段下载（Download Domain Segment）</li>
<li>域分段上传 （Upload Domain Segment）</li>
</ul>
</li>
<li>域传送中止（Abort Domain Transfer）。</li>
</ul>
<h3 id="快速-SDO"><a href="#快速-SDO" class="headerlink" title="快速 SDO"></a>快速 SDO</h3><p>Command specifier(CS)命令符:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="left"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">0x40</td>
<td align="left">读取命令</td>
<td></td>
</tr>
<tr>
<td align="center">0x2F</td>
<td align="center">写一个字节</td>
<td align="center">0x4F</td>
<td align="left">返回值响应一个字节</td>
<td></td>
</tr>
<tr>
<td align="center">0x2B</td>
<td align="center">写两个字节</td>
<td align="center">0x4B</td>
<td align="left">返回值响应两个字节</td>
<td></td>
</tr>
<tr>
<td align="center">0x27</td>
<td align="center">写三个字节</td>
<td align="center">0x47</td>
<td align="left">返回值响应三个字节</td>
<td></td>
</tr>
<tr>
<td align="center">0x23</td>
<td align="center">写四个字节</td>
<td align="center">0x43</td>
<td align="left">返回值响应四个字节</td>
<td></td>
</tr>
<tr>
<td align="center">0x60</td>
<td align="center">写成功应答</td>
<td align="center"></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">0x80</td>
<td align="center">异常响应</td>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h4 id="启动域下载（Initiate-Domain-Download）"><a href="#启动域下载（Initiate-Domain-Download）" class="headerlink" title="启动域下载（Initiate Domain Download）"></a>启动域下载（Initiate Domain Download）</h4><table>
<thead>
<tr>
<th>Bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>-</td>
<td>n</td>
<td>n</td>
<td>e</td>
<td>s</td>
</tr>
<tr>
<td>服务器</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>n</strong> ： 如果 <code>e=1</code> 且 <code>s=1</code>，则有效，否则为 0；表示数据部分中无意义数据的字节数（字节 8－n 到 7 数据无意义）。</li>
<li><strong>e</strong> ： 0 &#x3D; 正常传送，1 &#x3D; 加速传送（数据在一个帧中）。</li>
<li><strong>s</strong> ： 是否指明数据长度，0 &#x3D; 数据长度未指明，1 &#x3D; 数据长度指明。</li>
<li><strong>e &#x3D; 0， s &#x3D; 0</strong>： 由 CiA 保留。</li>
<li><strong>e &#x3D; 0， s &#x3D; 1</strong> ： 数据字节为字节计数器，byte 4 是数据低位部分（LSB），byte 7 是数据高位部分（MSB）。</li>
<li><strong>e &#x3D; 1</strong> ： 数据字节为将要下载（download）的数据。</li>
</ul>
<h4 id="启动域上传（Initiate-Domain-Upload）"><a href="#启动域上传（Initiate-Domain-Upload）" class="headerlink" title="启动域上传（Initiate Domain Upload）"></a>启动域上传（Initiate Domain Upload）</h4><table>
<thead>
<tr>
<th>Bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>服务器</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-</td>
<td>n</td>
<td>n</td>
<td>e</td>
<td>s</td>
</tr>
</tbody></table>
<p><strong>n</strong>，<strong>e</strong>，<strong>s</strong>： 与启动域下载相同。</p>
<h3 id="分段-SDO"><a href="#分段-SDO" class="headerlink" title="分段 SDO"></a>分段 SDO</h3><h4 id="域分段下载（Download-Domain-Segment）"><a href="#域分段下载（Download-Domain-Segment）" class="headerlink" title="域分段下载（Download Domain Segment）"></a>域分段下载（Download Domain Segment）</h4><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524142515.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>t</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>c</td>
</tr>
<tr>
<td>服务器</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>t</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<ul>
<li><strong>n</strong> ：无意义的数据字节数。如果没有指明段长度，则为 0。</li>
<li><strong>c</strong> ： 0 &#x3D; 有后续分段需要 download，1 &#x3D; 最后一个段。</li>
<li><strong>t</strong> ： 触发位，后续每个分段交替清零和置位（第一次传送为 0，等效于 request&#x2F;response）。</li>
</ul>
<h4 id="域分段上传（Upload-Domain-Segment）"><a href="#域分段上传（Upload-Domain-Segment）" class="headerlink" title="域分段上传（Upload Domain Segment）"></a>域分段上传（Upload Domain Segment）</h4><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524142553.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>客户端</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>t</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>服务器</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>t</td>
<td>n</td>
<td>n</td>
<td>n</td>
<td>c</td>
</tr>
</tbody></table>
<p><strong>n</strong>，<strong>c</strong>，<strong>t</strong> ： 与域分段下载相同。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>通讯示例 -upload</strong><br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152443.png" alt="image.png"><br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152452.png" alt="image.png"><br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152500.png" alt="image.png"></p>
<p>数据 0xFE ，对象字典节点 5 ,  索引 index 0x1400, 子索引 subindex 2 </p>
<p>客户端请求   ： <code>605 40 00 14 02 00 00 00 00</code> </p>
<p>若成功，应答： <code>585 4F 00 14 02 FE 00 00 00</code></p>
<p>数据 0x60120208 ，对象字典节点 5 ,  索引 index 0x1802, 子索引 subindex 1</p>
<p>客户端请求   ：<code>605 40 02 18 01 00 00 00 00</code></p>
<p>若成功，应答：<code>585 60 02 18 01 08 02 12 60</code></p>
<p><strong>通讯示例 -download</strong><br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152715.png" alt="image.png"><br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523152725.png" alt="image.png"><br>数据 0xFE ，对象字典节点 5 ,  索引 index 0x1400, 子索引 subindex 2 </p>
<p>客户端请求   ： <code>605 2F 00 14 02 FE 00 00 00</code></p>
<p>若成功，应答： <code>585 60 00 14 02 00 00 00 00</code></p>
<p>数据 0x60120208 ，对象字典节点 5 ,  索引 index 0x1802, 子索引 subindex 1</p>
<p>客户端请求   ：<code>605 23 02 18 01 08 02 12 60</code></p>
<p>若成功，应答：<code>585 60 02 18 01 00 00 00 00</code></p>
<h2 id="过程数据对象（PDO）"><a href="#过程数据对象（PDO）" class="headerlink" title="过程数据对象（PDO）"></a>过程数据对象（PDO）</h2><p>PDO 属于过程数据，即单向传输，无需接收节点回应 CAN 报文来确认，从通讯术语上来说是属于“生产消费”模型。、生产者“生产数据”，并使用 Transmit PDO（TPDO）将其传输到“消费者”（主用户）。相反，它可以通过 Receive PDO（RPDO）从使用者接收数据。</p>
<p>PDO 服务用于在设备之间传输实时数据，例如来自温度传感器的温度数据。PDO 承载大量信息，被视为最重要的 CANopen 协议。PDO 消息可以包含 8 个完整字节的数据，并且它可以在单个帧中包含多个对象参数值。因此在 PDO 服务中用 1 帧完成 SDO 至少需要 4 帧的操作。</p>
<p>带有特定 11 位 CAN 标识符的 TPDO 由一个设备发送，并作为 RPDO 由零个或多个设备接收。每个 PDO 在对象字典中用 2 个对象描述：</p>
<ul>
<li>PDO 通讯参数：包含哪个 COB-ID 将被 PDO 使用，传输类型，禁止时间和定时器周期。在索引 0x1400+ 和 0x1800+ 的对象字典中。</li>
<li>PDO 映射参数：包含一个对象字典中对象的列表，这些对象映射到 PDO 里，包括它们的数据长度（in bits）。生产者和消费者必须知道这个映射，以解释 PDO 内容。在索引 0x1600+ 和 0x1A00+ 的对象字典中。</li>
</ul>
<p>生产者节点可以被配置为每 100ms 响应消费者所广播的 SYNC 触发。然后，节点 5 可以例如在下面广播，以 COB-ID 185 的 TPDO：</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520153344.png" alt="image.png"></p>
<p>注意数据区部分 3 个参数值的打包方式，这些值是由数据字典中对应的映射结构决定了一个 PDO 的数据类型和映射关系。</p>
<h3 id="通信参数"><a href="#通信参数" class="headerlink" title="通信参数"></a>通信参数</h3><p>定义了该设备所使用的 COB-ID、传输类型、定时周期等。RPDO 通讯参数位于对象字典索引的 0x1400 to 0x15FF，TPDO 通讯参数位于对象字典索引的 0x1800 to 0x19FF。每条索引代表一个 PDO 的通信参数集，其中的子索引分别指向具体的各种参数。PDO 消息的内容是预定义的（或者在网络启动时配置的）。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524134811.png" alt="image.png"></p>
<ul>
<li>Number of entries 参数条目数量：即本索引中有几条参数；</li>
<li>COB-ID：即这个 PDO 发出或者接收的对应 CAN 帧 ID；</li>
<li>发送类型：即这个 PDO 发送或者接收的传输形式，通常使用循环同步和异步制造商特定事件较多；</li>
<li>Inhibit time 生产禁止约束时间(1&#x2F;10ms)：约束 PDO 发送的最小间隔，避免导致总线负载剧烈增加，比如数字量输入过快，导致状态改变发送的 TPDO 频繁发送，总线负载加大，所以需要一个约束时间来进行“滤波”，这个时间单位为 0.1ms；</li>
<li>Event timer 事件定时器触发的时间(单位 ms)：定时发送的 PDO，它的定时时间，如果这个时间为 0，则这个 PDO 为事件改变发送。</li>
<li>SYNC start value 同步起始值：同步传输的 PDO，收到诺干个同步包后，才进行发送，这个同步起始值就是同步包数量。比如设置为 2，即收到 2 个同步包后才进行发送。</li>
</ul>
<h4 id="发送类型"><a href="#发送类型" class="headerlink" title="发送类型"></a>发送类型</h4><p>PDO 可以有多种发送类型：</p>
<ul>
<li>同步（通过接收 SYNC 对象实现同步）<ul>
<li>非周期：远程帧预触发传送或设备子协议中规定的对象特定事件预触发传送。</li>
<li>周期：传送在每 1 到 240 个 SYNC 消息后触发。</li>
</ul>
</li>
<li>异步<ul>
<li>远程帧触发传送。通过发送与 PDO 的 COB-ID 相同的远程帧来触发 PDO 发送</li>
<li>由设备子协议中规定的对象特定事件触发传送。（基本采用这种，例如定时传输，数据变化传输等）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/24/20240524133832.png" alt="image.png"></p>
<p>由传输类型定义的不同 PDO 传输模式，传输类型为 PDO 通讯参数对象的一部分，由 8 位无符号整数定义。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523162157.png" alt="image.png"></p>
<h4 id="间隔时间"><a href="#间隔时间" class="headerlink" title="间隔时间"></a>间隔时间</h4><p>一个 PDO 可以指定一个禁止时间，即定义两个连续 PDO 传输的最小间隔时间，避免由于高优先级信息的数据量太大，始终占据总线，而使其它优先级较低的数据无力竞争总线的问题。禁止时间由 16 位无符号整数定义，单位 100us。</p>
<h4 id="定时周期"><a href="#定时周期" class="headerlink" title="定时周期"></a>定时周期</h4><p>一个 PDO 可以指定一个事件定时周期，当超过定时时间后，一个 PDO 传输可以被触发（不需要触发位）。事件定时周期由 16 位无符号整数定义，单位 1ms。</p>
<h3 id="映射参数"><a href="#映射参数" class="headerlink" title="映射参数"></a>映射参数</h3><p>RPDO 通讯参数 1400h to 15FFh，映射参数 1600h to 17FFh，数据存放为 2000h 之后厂商自定义区域；</p>
<p>TPDO 通讯参数 1800h to 19FFh，映射参数 1A00h to 1BFFh，数据存放为 2000h 之后厂商自定义区域。</p>
<p>包含了一个对象字典中的对象列表，这些对象映射到相应的 PDO，其中包括数据的长度（单位，位），对于生产者和消费者都必须要知道这个映射参数，才能够正确的解释 PDO 内容。就是将通信参数、应用数据和具体 CAN 报文中数据联系起来。</p>
<p>子索引 0：PDO 中映射应用程序对象的数量：</p>
<ul>
<li>值 0：映射被禁用。</li>
<li>值 1：子索引 0x01 有效。</li>
<li>值 2-8: 子索引 0x01 至 (0x02 至 0x08) 有效。</li>
</ul>
<p>子索引 1-8： 应用对象 1-8：</p>
<ul>
<li>位 16-31：索引</li>
<li>位 8-15：子索引</li>
<li>位 0-7：数据长度（位）</li>
</ul>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/29/20240529152926.png" alt="image.png"></p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><h4 id="示例设备配置"><a href="#示例设备配置" class="headerlink" title="示例设备配置"></a>示例设备配置</h4><ul>
<li><strong>节点 ID</strong>: 0x01</li>
<li><strong>第二个 Transmit PDO (TPDO2)</strong>:<ul>
<li>TPDO2 的 COB-ID: 0x280 + Node_ID &#x3D; 0x281</li>
</ul>
</li>
</ul>
<p> 对象字典（Object Dictionary）定义：</p>
<ol>
<li>0x1801: TPDO2 通信参数 <ul>
<li>子索引 0x00: 0x02 (表示有 2 个子索引) </li>
<li>子索引 0x01: 0x00000281 (TPDO2 的 COB-ID, 使能) </li>
<li>子索引 0x02: 0x00 (传输类型，假设为 0x00 表示同步传输)</li>
</ul>
</li>
<li>0x1A01: TPDO2 映射参数 <ul>
<li>子索引 0x00: 0x02 (映射对象数量，表示有两个对象映射到这个 TPDO) </li>
<li>子索引 0x01: 0x60000208 (映射对象 0x6000，子索引 0x02，8 位) </li>
<li>子索引 0x02: 0x64010110 (映射对象 0x6401，子索引 0x01，16 位)</li>
</ul>
</li>
</ol>
<p>假设当前设备中的数据如下：</p>
<ul>
<li><strong>对象 0x6000，子索引 0x02</strong>: 0xAB </li>
<li><strong>对象 0x6401，子索引 0x01</strong>: 0x1234</li>
</ul>
<p>TPDO2 实际发送的 CANopen 数据帧报文由以下 3 个字节组成：</p>
<ul>
<li>Byte 0: 0xAB</li>
<li>Byte 1: 0x34 (低 8 位)</li>
<li>Byte 2: 0x12 (高 8 位)</li>
</ul>
<p>实际的 CANopen 数据帧：<code>CAN ID: 0x281 Data: [0xAB, 0x34, 0x12]</code></p>
<h4 id="设置一个-TPDO"><a href="#设置一个-TPDO" class="headerlink" title="设置一个 TPDO"></a>设置一个 TPDO</h4><ul>
<li>Index 1800 + n，subindex <code>01</code> ，<strong>COB_ID</strong>（通讯对象的标识符）：包含 CAN-ID 和附加控制位的标识符</li>
<li>Index 1800 + n，subindex <code>02</code>， 写<strong>传输类型 t</strong>，<br>  t &#x3D; 1 – 0xF0：同步，时间触发模式 ，每 t 一周期<br>  t &#x3D; FD  　　：收到 PDO 请求后<br>  t &#x3D; FE　　  ：事件驱动（制造商指定）<br>  t &#x3D; FF  　　：事件传输，节点自发传输 PDO</li>
<li>Index 1800 + n， subindex <code>03</code>，<strong>抑制时间</strong>。<br>  如果传输类型设置为 FE 和 FF，它是最小的 PDO 传输间隔，单位 100us，值为 0 禁用抑制时间。PDO 报文需要延时 t × 100us 的时间才发出，以此避免在多 PDO 报文同时发出时，引起的时间冲突 。</li>
<li>Index 1800 + n， subindex <code>05</code>，<strong>时间定时器</strong>。<br>  如果传输类型设置为 FE 和 FF，它是 PDO 传输间隔，单位 ms，值为 0 禁用。t &#x3D;0xC8，200ms。</li>
<li>Index 1A00 + n，<strong>定义映射</strong><ul>
<li>subindex <code>0</code> ：定义映射数量（1 byte）。<br>  值 0，映射禁用；值 01，子索引 01 有效；值 02，子索引 01–02 有效……</li>
<li>subindex <code>1</code> ：映射第一个参数。<br>  格式，index (2 bytes) – subindex (1 byte) – size (1 byte)</li>
<li>subindex <code>2</code> ：映射第二个参数。<br>  格式，index (2 bytes) – subindex (1 byte) – size (1 byte)</li>
</ul>
</li>
</ul>
<p><code>605 2F 00 18 02 FF 00 00 00</code> 设置索引 Index 1800，事件传输</p>
<p><code>605 2F 00 18 05 C8 00 00 00</code> 设置索引 Index 1800，时间间隔 200ms</p>
<p><code>605 2F 00 1A 00 00 00 00 00</code> 设置子索引禁用</p>
<p><code>605 23 00 1A 01 10 00 30 40</code>0x40300010，设置映射索引 0x4030，子索引 00，大小 0x10（16 位）</p>
<p><code>605 23 00 1A 02 20 00 10 20</code>0x20100020，设置映射索引 0x2010，子索引 00，大小 0x20（32 位）</p>
<p><code>605 2F 00 1A 00 02 00 00 00</code> 设置映射数量，用多少设多少，这里用了 2 个</p>
<h4 id="设置一个-RPDO"><a href="#设置一个-RPDO" class="headerlink" title="设置一个 RPDO"></a>设置一个 RPDO</h4><ul>
<li>Index 1400 + n, subindex <code>01</code> ，<strong>COB_ID</strong>（通讯对象的标识符）</li>
<li>Index 1400 + n, subindex <code>02</code>，写<strong>传输类型</strong> t，　　　　　　　　　　　　　　<br>  t &#x3D; 1 – 0xF0：同步，时间触发模式 ，每 t 一周期<br>  t &#x3D; FD  　　：收到 PDO 请求后<br>  t &#x3D; FE　　  ：事件驱动（制造商指定）<br>  t &#x3D; FF  　　：事件传输，节点自发传输 PDO</li>
<li>Index 1600 + n，<strong>定义映射</strong><ul>
<li>subindex 0 ：定义映射数量（1 byte）。<br>  值 0，映射禁用；值 01，子索引 01 有效；值 02，子索引 01–02 有效……</li>
<li>subindex 1 ：映射第一个参数。<br>  格式，index (2 bytes) – subindex (1 byte) – size (1 byte)</li>
<li>subindex 2 ：映射第二个参数。<br>  格式，index (2 bytes) – subindex (1 byte) – size (1 byte)</li>
</ul>
</li>
</ul>
<p><code>605 2F 00 14 02 FF 00 00 00</code> 设置索引 Index 1400，事件传输</p>
<p><code>605 2F 00 16 00 00 00 00 00</code> 设置子索引禁用</p>
<p><code>605 23 00 16 01 10 00 30 40</code> 设置映射索引 0x4030，子索引 00，大小 0x10（16 位）</p>
<p><code>605 2F 00 16 00 01 00 00 00</code> 设置映射数量，用多少设多少，这里用了 01</p>
<p><em>定义映射时，先设置子索引禁用；再设置相应映射；然后设置映射数量</em><br><em>对于 TPDO 来说，其通信参数中的 COB-ID 是<strong>自身</strong>的 COB-ID，当发送 TPDO 时用来表明这个 TPDO 是谁发出的。</em><br><em>对于 RPDO 来说，其通信参数的 COB-ID 是<strong>发送方</strong>的 COB-ID，用来表示自己只接受某个 CAN 节点发过来的 TPDO。</em></p>
<h2 id="同步（SYNC）"><a href="#同步（SYNC）" class="headerlink" title="同步（SYNC）"></a>同步（SYNC）</h2><p>SYNC 消息通常由应用程序主机触发。每个节点都以该同步报文作为 PDO 触发参数，因此该同步报文的 COB-ID 具有比较高的优先级以及最短的传输时间。一般选用 0x80 作为同步报文的 CAN-ID，将 SYNC 消息（COB-ID 080）发送到 CANopen 网络。</p>
<ul>
<li>在网络范围内同步（尤其在驱动应用中）：在整个网络范围内当前输入值准同时保存，随后传送（如果需要），根据前一个 SYNC 后接收到的报文更新输出值。</li>
<li>主从模式：SYNC 主节点定时发送 SYNC 对象，SYNC 从节点收到后同步执行任务。</li>
<li>在 SYNC 报文传送后，在给定的时间窗口内传送一个同步 PDO。</li>
<li>用 CAL 中基本变量类型的 CMS 对象实现。</li>
<li>CANopen 建议用一个最高优先级的 COB-ID 以保证同步信号正常传送。SYNC 报文可以不传送数据以使报文尽可能短。</li>
</ul>
<p>一般同步报文由 NMT 主机发出，CAN 报文的数据为 0 字节。但如果一个网络内有 2 个同步机制，就需要设置不同的同步节拍，比如某些节点按 1 个同步帧发送 1 次 PDO，其他的节点收到 2 个同步帧才发送 1 次 PDO，所以这里 PDO 参数中的同步起始值就起了作用。</p>
<p>在同步协议中，有 3 个约束条件：</p>
<ul>
<li>同步命令：0x1005 中规定了同步帧的命令为 0x80；</li>
<li>通讯循环周期：索引 0x1006 规定了同步帧的循环周期；</li>
<li>同步窗口时间：索引 0x1007 约束了同步帧发送后，从节点发送 PDO 的时效，即在这个时间内发送的 PDO 才有效，超过时间的 PDO 将被丢弃。</li>
</ul>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>配置 1005 信息，设 SYNC 的 COB-ID 为 0x80（默认值）</p>
<p><code>23 05 10 00 80 00 00 00</code></p>
<p>读取 1006 信息</p>
<p><code>40 06 10 00 00 00 00 00</code></p>
<p>写入 1006 信息，将 SYNC 的通信周期设置为 100ms，那么需要写入到 <code>0x1006</code> 的值为 100000（100ms &#x3D; 100000us）</p>
<p><code>23 06 10 00 A0 86 01 00</code></p>
<h2 id="时间戳（TIME-stamp）"><a href="#时间戳（TIME-stamp）" class="headerlink" title="时间戳（TIME-stamp）"></a>时间戳（TIME-stamp）</h2><p>时间标记对象（Time Stamp），NMT 主机发送自身的时钟，为网络各个节点提供公共的时间参考，即网络对时，这在故障诊断中非常需要。</p>
<p>时间戳协议采用广播方式，无需节点应答，CAN-ID 为 0x100，数据长度为 6，数据为当前时刻与 1984 年 1 月 1 日 0 时的时间差。节点将此时间存储在对象字典 1012h 的索引中。</p>
<p>主机发出带有 CAN ID 100 的 TIME 消息，TIME 服务包含一个 6 字节的日期和时间信息。其中最初的 4 个数据字节包含午夜之后的毫秒数，随后的 2 个字节包含自 1984 年 1 月 1 日以来的天数。</p>
<h2 id="紧急情况（EMCY）"><a href="#紧急情况（EMCY）" class="headerlink" title="紧急情况（EMCY）"></a>紧急情况（EMCY）</h2><p>紧急报文协议（Emergency protocol）用于设备发生致命错误（例如传感器故障）的情况，从而使其可以向网络的其余部分指示此错误。</p>
<p>受影响的节点以高优先级向网络发送发送设备内部错误代码，提示 NMT 主站。紧急报文属于诊断性报文，一般不会影响 CANopen 通讯，其 CAN-ID 存储在 0x1014 的索引中，一般会定义为 0x080 + node-ID，数据包含 8 个字节，例如，节点 5 具有 COB-ID 085 + 数据字节，数据字节包含有关错误的信息，可以查找厂商定义的错误代码。</p>
<p>紧急信息的内容如下</p>
<ul>
<li>Bytes 0…1： CO_EM_errorCode_t，在本例中为 0x5000（设备硬件）</li>
<li>Bytes 2：CO_errorRegister_t，本例中为 0x01（通用错误）</li>
<li>Bytes 3：CO_EM_errorStatusBits_t 中的错误条件索引，本例中为 0x2F（CO_EM_NON_VOLATILE_MEMORY - 访问非易失性设备内存时出错）</li>
<li>Bytes 4…7：附加信息参数，本例中为 0x00000014 或 0x00000074</li>
</ul>
<p>紧急信息由 CO_errorReport() 函数内部触发。您可以在 CO_EM_NON_VOLATILE_MEMORY 的源代码中查找紧急信息的来源。</p>
<p>CO_EM_NON_VOLATILE_MEMORY 是一般的严重错误，默认情况下会设置 CANopen 错误寄存器。如果<strong>错误寄存器的值不等于零，则禁止节点进入 NMT 运行状态，并且不能与其交换 PDO</strong>。</p>
<h2 id="节点监测"><a href="#节点监测" class="headerlink" title="节点监测"></a>节点监测</h2><p>NMT 主机定期使用远程帧询问从机的当前状态，并将其与网络数据库中记录的早期状态相比较。任何不匹配和缺少 PDO 传输的状态都会以适当的错误代码表示，然后应用程序将采取适当的操作，如设备重置或错误标识。这称为节点监测，是通过使用节点监测协议得以实现。</p>
<p>NMT 从机使用一种称为生命监测的技术，通过在预定义的时间间隔里，内部检查节点监测帧的接收，来检测 NMT 主机的缺失。</p>
<p>现代设备设计使用 Heartbeat 协议进行节点监视，其中 NMT 从设备（Heartbeat Producer 心跳发出者）将周期性地向 NMT 主设备（Heartbeat Consumer 心跳使用者）发送 Heartbeat 报文。</p>
<p>这些报文之间的间隔是可配置的，并在主、从两个设备的对象字典中 Heartbeat producer time（心跳产生时间）对象上都进行设置。如果心跳报文在此时间限制内未到达，则发出者将被视为关机，使用者将采取补救措施，如设备重置或错误显示。</p>
<p>当一个 Heartbeat 节点启动后它的 Boot-up 报文是其第一个 Heartbeat 报文。Heartbeat 消费者通常是 NMT-Master 节点，它为每个 Heartbeat 节点设定一个超时值，当超时发生时采取相应动作。</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p>读取心跳时间设置</p>
<p><code>40 17 10 00 00 00 00 00</code></p>
<p>通过配置 0x1017 的 heartbeat 时间，自动上报设备状态。</p>
<p><code>2B 17 10 00 E8 03 00 00</code></p>
<p><del>Master 节点发送远程帧（无数据）NMT-Master -&gt; NMT-Slave</del></p>
<p><code>COB-ID</code> &#x3D; <code>0x700</code> + <code>Node_ID</code></p>
<p><del>NMT-Slave 节点发送如下报文应答 NMT-Master &lt;- NMT-Slave</del></p>
<p><code>COB-ID</code> &#x3D; <code>0x700</code> + <code>Node_ID</code></p>
<p><code>Byte0</code> &#x3D; <code>Bit 7-0 : 状态</code></p>
<h2 id="LSS"><a href="#LSS" class="headerlink" title="LSS"></a>LSS</h2><p>LSS（Layer Setting Services）是一个用于配置和管理 CANopen 设备的一种服务。它提供了一些特定的功能，主要用于设备的初始化和配置，例如设置节点 ID 和波特率。LSS 对于在生产、调试和运行过程中配置 CANopen 设备非常有用。</p>
<h3 id="LSS-的主要功能"><a href="#LSS-的主要功能" class="headerlink" title="LSS 的主要功能"></a>LSS 的主要功能</h3><ol>
<li><p><strong>设置节点 ID</strong>：</p>
<ul>
<li>在 CANopen 网络中，每个节点都有一个唯一的节点 ID，范围为 1 到 127。LSS 允许动态设置或修改节点 ID，而不需要物理访问设备。这在设备初始安装和替换时特别有用。</li>
</ul>
</li>
<li><p><strong>设置波特率</strong>：</p>
<ul>
<li>CANopen 网络中的所有节点必须使用相同的波特率进行通信。LSS 允许动态修改设备的波特率，以便在不同的网络条件下进行适应和优化。</li>
</ul>
</li>
<li><p><strong>设备识别</strong>：</p>
<ul>
<li>LSS 可以用于识别网络中的设备。通过 LSS 服务，可以查询设备的唯一标识符（例如制造商代码、产品代码、序列号等），从而实现设备的识别和管理。</li>
</ul>
</li>
</ol>
<h3 id="LSS-服务的主要操作"><a href="#LSS-服务的主要操作" class="headerlink" title="LSS 服务的主要操作"></a>LSS 服务的主要操作</h3><ol>
<li><p><strong>Switch Mode Global</strong>：</p>
<ul>
<li>切换所有节点到配置模式或操作模式。</li>
</ul>
</li>
<li><p><strong>Switch Mode Selective</strong>：</p>
<ul>
<li>选择性地切换特定节点到配置模式或操作模式。</li>
</ul>
</li>
<li><p><strong>Configure Node-ID</strong>：</p>
<ul>
<li>设置节点 ID。</li>
</ul>
</li>
<li><p><strong>Configure Bit Timing Parameters</strong>：</p>
<ul>
<li>设置 CAN 总线的波特率参数。</li>
</ul>
</li>
<li><p><strong>Identify Remote Slave</strong>：</p>
<ul>
<li>识别网络中的设备，读取其唯一标识符。</li>
</ul>
</li>
</ol>
<h3 id="LSS-协议的示例"><a href="#LSS-协议的示例" class="headerlink" title="LSS 协议的示例"></a>LSS 协议的示例</h3><p>假设我们需要将一个设备的节点 ID 设置为 0x02，并将波特率设置为 250 kbps。以下是使用 LSS 的步骤：</p>
<ol>
<li><p><strong>切换到配置模式</strong>： 发送 LSS Switch Mode Selective 命令，将目标设备切换到配置模式。</p>
</li>
<li><p><strong>设置节点 ID</strong>： 使用 LSS Configure Node-ID 命令，设置设备的节点 ID。</p>
</li>
<li><p><strong>设置波特率</strong>： 使用 LSS Configure Bit Timing Parameters 命令，设置设备的波特率。</p>
</li>
<li><p><strong>切换到操作模式</strong>： 发送 LSS Switch Mode Global 命令，将所有设备切换到操作模式。</p>
</li>
</ol>
<h3 id="LSS-消息格式"><a href="#LSS-消息格式" class="headerlink" title="LSS 消息格式"></a>LSS 消息格式</h3><p>LSS 消息使用特定的 CAN 标识符和数据格式。以下是 LSS Switch Mode Selective 命令的示例：</p>
<ul>
<li><strong>CAN ID</strong>：0x7E5（LSS 主站到从站）</li>
<li><strong>数据</strong>：0x04 0x00 0x00 0x00 0x00 0x00 0x00 0x00（切换到配置模式）</li>
</ul>
<p><strong>设置节点 ID 的命令</strong>：</p>
<ul>
<li><strong>CAN ID</strong>：0x7E5</li>
<li><strong>数据</strong>：0x11 0x02 0x00 0x00 0x00 0x00 0x00 0x00（设置节点 ID 为 0x02）</li>
</ul>
<p><strong>设置波特率的命令</strong>：</p>
<ul>
<li><strong>CAN ID</strong>：0x7E5</li>
<li><strong>数据</strong>：0x13 0x03 0x00 0x00 0x00 0x00 0x00 0x00（设置波特率为 250 kbps，假设 0x03 表示 250 kbps）</li>
</ul>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CANOpen 调试</title>
    <url>/2024/05/24/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CANOpen-%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>作为 CAN Open 总线上的数据抓取设备，要求程序具有以下功能</p>
<ul>
<li>能够作为总线上的从机设备，要求具有以下功能：<ul>
<li>HeartBeat</li>
<li>本设备 SDO 配置项</li>
<li>PDO 数据配置</li>
<li>如何通过主机 ASK 某一设备的数据</li>
</ul>
</li>
<li>能够作为总线上的主机设备，要求具有以下功能：<ul>
<li>从机设备的状态管理</li>
<li>PDO 数据采集</li>
</ul>
</li>
</ul>
<p>例如，预配置的过程数据对象 (PDO) 由生产者传输。每个 PDO 可能由多个节点使用。每个 CANopen 设备的其他有用的 CANopen 功能还包括：心跳生产者和消费者、紧急生产者、同步生产者或消费者、时间生产者或消费者、SDO 服务器（服务数据对象 - 从对象字典中提供变量）、NMT 从属（网络管理 - 启动或停止通信部分）、LSS 从属（节点 ID 和比特率的配置）。</p>
<p>CANopen 网络通常有一个具有命令功能的设备用于网络配置，例如：NMT 主站、LSS 主站、SDO 客户端、紧急消费者。CANopenNode 中的命令功能根据标准 CiA309-3 使用 Ascii 命令行接口实现。</p>
<h1 id="使能-CAN-接口"><a href="#使能-CAN-接口" class="headerlink" title="使能 CAN 接口"></a>使能 CAN 接口</h1><h2 id="Linux-下-虚拟-CAN-设备"><a href="#Linux-下-虚拟-CAN-设备" class="headerlink" title="Linux 下 虚拟 CAN 设备"></a><code>Linux</code> 下 虚拟 <code>CAN</code> 设备</h2><p><em><code>modprobe</code> 是 Linux 系统中的一个命令行工具，用于管理内核模块。内核模块是可以动态加载或卸载的可扩展组件，允许 Linux 内核在运行时添加或删除功能而不需要重启系统。常见的内核模块包括设备驱动程序、文件系统支持以及网络协议等。</em></p>
<p>创建一个虚拟 CAN 设备，并启用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo modprobe vcan</span><br><span class="line">sudo ip <span class="built_in">link</span> add dev can0 <span class="built_in">type</span> vcan</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> up can0</span><br></pre></td></tr></table></figure>

<p>安装 CAN 监测调试工具，<code>can-utils</code> 项目地址 <a href="https://github.com/linux-can/can-utils">https://github.com/linux-can/can-utils</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install can-utils</span><br><span class="line">candump -td can0 <span class="comment">#显示can消息</span></span><br></pre></td></tr></table></figure>

<p><code>rk3568</code> 的 <code>can</code> 使用时 <code>ip link set can0 up </code> 启用失败报错：</p>
<p><code>can0: incorrect missing data bit-timing</code></p>
<p>驱动问题，设备树中的节点配置，需要将 <code>kernel/arch/arm64/boot/dts/rockchip/rk3568.dtsi</code> 中的 <code>can0</code> 节点中的 <code>compatible = &quot;rockchip,canfd-1.0&quot;</code> 修改为 <code>compatible = &quot;rockchip,can-1.0&quot;</code>，重新编译后下载</p>
<h2 id="开发板-3568-的-CAN"><a href="#开发板-3568-的-CAN" class="headerlink" title="开发板 3568 的 CAN"></a>开发板 3568 的 CAN</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig can0 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 500000</span><br><span class="line">ifconfig can0 up</span><br><span class="line"></span><br><span class="line">ifconfig can1 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 up <span class="built_in">type</span> can bitrate 500000</span><br><span class="line">ifconfig can1 up</span><br><span class="line"></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 1000000 sample-point 0.75 dbitrate 4000000 dsample-point 0.8 fd on</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 up <span class="built_in">type</span> can bitrate 1000000 sample-point 0.75 dbitrate 4000000 dsample-point 0.8 fd on</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询当前网络设备:</span></span><br><span class="line">ifconfig -a</span><br><span class="line"><span class="comment">#关闭CAN:</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 down</span><br><span class="line"><span class="comment">#设置比特率500KHz:</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> can bitrate 500000</span><br><span class="line"><span class="comment">#打印can0信息:</span></span><br><span class="line">ip -details -statistics <span class="built_in">link</span> show can0</span><br><span class="line"><span class="comment">#启动CAN:</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up</span><br><span class="line"><span class="comment">#发送（标准帧,数据帧,ID:123,date:DEADBEEF）:</span></span><br><span class="line">cansend can0 123<span class="comment">#DEADBEEF</span></span><br><span class="line"><span class="comment">#发送（标准帧,远程帧,ID:123）:</span></span><br><span class="line">cansend can0 123<span class="comment">#R</span></span><br><span class="line"><span class="comment">#发送（扩展帧,数据帧,ID:00000123,date:DEADBEEF）:</span></span><br><span class="line">cansend can0 00000123<span class="comment">#12345678</span></span><br><span class="line"><span class="comment">#发送（扩展帧,远程帧,ID:00000123）:</span></span><br><span class="line">cansend can0 00000123<span class="comment">#R</span></span><br><span class="line"><span class="comment">#开启打印，等待接收:</span></span><br><span class="line">candump can0</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"><span class="comment">#设置can fd</span></span><br><span class="line"><span class="comment">#设置仲裁段1M波特率，数据段3M波特率:</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> can bitrate 1000000 dbitrate 3000000 fd on</span><br><span class="line"><span class="comment">#发送（标准帧,数据帧,ID:123,date:DEADBEEF）:</span></span><br><span class="line">cansend can0 123<span class="comment">##1DEADBEEF</span></span><br><span class="line"><span class="comment">#发送（扩展帧,数据帧,ID:00000123,date:DEADBEEF）:</span></span><br><span class="line">cansend can0 00000123<span class="comment">##1DEADBEEF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ifconfig -a</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> can bitrate 500000</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 <span class="built_in">type</span> can bitrate 500000</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 up</span><br><span class="line">candump can0 &amp;</span><br><span class="line">cansend can1 123<span class="comment">#DEADBEEF</span></span><br><span class="line">cansend can1 123<span class="comment">#DEADBEEF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个命令是用于配置 CAN（Controller Area Network，控制器局域网络）接口的 Linux 命令行指令。CAN 是一种用于实时应用的车辆、工业控制及自动化领域的串行通信协议。下面是对该命令各部分含义的详细解析：</p>
<p><code>ip link set can0 up</code></p>
<p>这部分命令是用来设置指定的网络接口（%s 是一个占位符，通常在脚本中使用，运行时会被实际的接口名称替换）为活动状态（up）。这意味着它将启动指定的 CAN 接口，使其准备好进行数据传输。</p>
<p><code>type can</code></p>
<p>指定接口类型为 CAN 总线。这是告诉系统该接口应该被配置和处理为 CAN 总线接口，而不是以太网或其他类型的网络接口。</p>
<p><code>bitrate 500000</code></p>
<p>设置 CAN 总线的比特率（通信速度）。500000 代表具体的比特率值，例如 125000 表示 125Kbps。比特率是指每秒钟传输的位数，是 CAN 总线配置中的一个关键参数，需要所有连接到同一总线上的设备匹配。</p>
<p><code>sample-point 0.75</code></p>
<p>配置 CAN 位采样点的位置。采样点是在每个 CAN 位的哪个时间点进行信号采样以确定位的逻辑电平（0 或 1）。值范围从 0 到 1，其中 1 代表位时间周期的结束。这里设置为 0.75 意味着在每位的 75%时间点进行采样。</p>
<p><code>dbitrate 4000000</code></p>
<p>分布式比特率（Data Bit Rate）设置。这通常用于 FlexCAN（Flexible Data-Rate CAN）等高级 CAN 协议变体中，允许数据段的比特率与仲裁段不同。这里设置为 4000000 表示数据段的比特率为 4Mbps。但需要注意的是，标准 CAN 协议并不支持不同的数据和仲裁比特率，这一选项可能特定于某些高级 CAN 控制器或实现。</p>
<p><code>dsample-point 0.8</code></p>
<p>数据段的采样点位置，类似于上述的 sample-point，但特指数据段（如果适用）。在这个例子中，数据段的采样点被设置在每位的 80%时间点。</p>
<p><code>fd on</code></p>
<p>启用 CAN FD（Flexible Data-rate CAN）模式。CAN FD 是 CAN 总线协议的一个扩展，允许更灵活的数据长度和更高的数据传输速率，旨在提高 CAN 网络的数据吞吐量。</p>
<h1 id="CAN-通信测试工具"><a href="#CAN-通信测试工具" class="headerlink" title="CAN 通信测试工具"></a>CAN 通信测试工具</h1><p><code>canutils</code> 是常用的 CAN 通信测试工具包，内含 5 个独立的程序：<code>canconfig</code>、<code>candump</code>、<code>canecho</code>、<code>cansend</code>、<code>cansequence</code>。</p>
<p>这几个程序的功能简述如下：</p>
<ul>
<li><code>canconfig</code> 用于配置 CAN 总线接口的参数，主要是波特率和模式。</li>
<li><code>candump</code> 从 CAN 总线接口接收数据并以十六进制形式打印到标准输出，也可以输出到指定文件。</li>
<li><code>canecho</code> 把从 CAN 总线接口接收到的所有数据重新发送到 CAN 总线接口。</li>
<li><code>cansend</code> 往指定的 CAN 总线接口发送指定的数据。</li>
<li><code>cansequence</code> 往指定的 CAN 总线接口自动重复递增数字，也可以指定接收模式并校验检查接收的递增数字。</li>
</ul>
<p><code>ip</code> CAN 波特率、功能等配置。</p>
<p>注意：<code>busybox</code> 里也有集成了 ip 工具，但 <code>busybox</code> 里的是阉割版本。不支持 <code>CAN</code> 的操作。故使用前请先确定 ip 命令的版本（<code>iproute2</code>）。上面工具包，网络上都有详细的编译说明。如果是自己编译 <code>buildroot</code>，直接开启宏就可以支持上述工具包。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BR2_PACKAGE_CAN_UTILS=y</span><br><span class="line">BR2_PACKAGE_IPROUTE2=y</span><br></pre></td></tr></table></figure>

<h1 id="CAN-比特率和采样点计算"><a href="#CAN-比特率和采样点计算" class="headerlink" title="CAN 比特率和采样点计算"></a>CAN 比特率和采样点计算</h1><p>目前 CAN 架构根据输入频率和比特率自动计算。采样点的规则按照 CIA 标准协议：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Use CiA recommended sample points */</span></span><br><span class="line"><span class="keyword">if</span> (bt-&gt;sample_point) &#123;</span><br><span class="line">	sample_point_nominal = bt-&gt;sample_point;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (bt-&gt;bitrate &gt; <span class="number">800000</span>)</span><br><span class="line">		sample_point_nominal = <span class="number">750</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;bitrate &gt; <span class="number">500000</span>)</span><br><span class="line">		sample_point_nominal = <span class="number">800</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sample_point_nominal = <span class="number">875</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比特率计算公式（详细原理可以百度，这里只介绍芯片配置相关）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BitRate = clk_can / (<span class="number">2</span> *(brq + <span class="number">1</span>) / ((tseg2 + <span class="number">1</span>) + (tseg1 + <span class="number">1</span>) + <span class="number">1</span>)</span><br><span class="line">Sample = (<span class="number">1</span> + (tseg1 + <span class="number">1</span>)) / (<span class="number">1</span> + (tseg1 + <span class="number">1</span>) + (tseg2 + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p><code>brq</code>、<code>tseg1</code>、<code>tseg2</code> 见 <code>CAN</code> 的 <code>TRM</code> 中 <code>BITTIMING</code> 寄存器。</p>
<h1 id="CAN-Open-用例分析"><a href="#CAN-Open-用例分析" class="headerlink" title="CAN Open 用例分析"></a><code>CAN Open</code> 用例分析</h1><h2 id="SDO-命令-状态恢复和存储"><a href="#SDO-命令-状态恢复和存储" class="headerlink" title="SDO 命令-状态恢复和存储"></a>SDO 命令-状态恢复和存储</h2><p>紧急信息、错误寄存器和 NMT 运行前状态在未初始化的非易失性存储器中都有数据源。对象 0x1010 和 0x1011 用于存储和恢复数据，通常来自 CANopen 对象字典。</p>
<p><em><code>CO_EM_NON_VOLATILE_MEMORY</code> 是一般的严重错误，默认情况下会设置 CANopen 错误寄存器。如果错误寄存器的值不为零，则可能禁止节点进入 NMT 操作状态，并且无法与其交换 PDO。</em></p>
<p>恢复所有非易失性存储器：</p>
<ul>
<li><p>CAN ID：0x600 + 节点 ID（表示从主机到从节点的 SDO 请求）。0x600 + 4 &#x3D; 0x604。</p>
</li>
<li><p>命令字节：表示写入命令和数据长度。0x23 表示写入 4 字节数据（visible string）。</p>
</li>
<li><p>索引：对象字典索引。0x1011（字节顺序为低字节在前）。</p>
</li>
<li><p>子索引：对象字典子索引。0x01</p>
</li>
<li><p>数据：load：ASCII 码 l、o、a、d 分别为 0x6C、0x6F、0x61、0x64。</p>
</li>
<li><p>构建数据恢复 CAN 帧 </p>
<ul>
<li>CAN ID：0x604。</li>
<li>数据：命令字节（0x23），索引（0x11 0x10），子索引（0x01），数据（0x6C 0x6F 0x61 0x64）。</li>
<li><code>can0 604 [8] 23 11 10 01 6C 6F 61 64</code></li>
</ul>
</li>
<li><p><code>save</code>：ASCII 码 <code>s</code>、<code>a</code>、<code>v</code>、<code>e</code> 分别为 <code>0x73</code>、<code>0x61</code>、<code>0x76</code>、<code>0x65</code>。</p>
</li>
<li><p>构建数据存储 CAN 帧</p>
<ul>
<li><strong>CAN ID</strong>：0x604。</li>
<li><strong>数据</strong>：命令字节（0x23），索引（0x10 0x10），子索引（0x01），数据（0x73 0x61 0x76 0x65）。</li>
<li><code>can0  604   [8]  23 10 10 01 73 61 76 65</code></li>
</ul>
</li>
</ul>
<h2 id="NMT-命令-设置-NMT-状态"><a href="#NMT-命令-设置-NMT-状态" class="headerlink" title="NMT 命令-设置 NMT 状态"></a>NMT 命令-设置 NMT 状态</h2><p>报文可以发送给特定节点或所有节点。它们可以重置设备、通信或将远程设备的内部状态设置为运行、预运行（禁用 PDO）或停止（仅启用心跳生产者和 NMT 消费者）。</p>
<p>当出现了设置错误寄存器的紧急状况时，start 不起作用。</p>
<p>设置 Node ID 为 4 的设备状态为 reset。</p>
<p><code>000 82 04</code></p>
<table>
<thead>
<tr>
<th align="center">Byte 0 取值（命令）</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td>start_remote_node</td>
</tr>
<tr>
<td align="center">02</td>
<td>stop_remote_node</td>
</tr>
<tr>
<td align="center">80</td>
<td>enter_pre-operational</td>
</tr>
<tr>
<td align="center">81</td>
<td>reset_node</td>
</tr>
<tr>
<td align="center">82</td>
<td>reset_communication</td>
</tr>
</tbody></table>
<h2 id="SDO-命令-设置心跳包"><a href="#SDO-命令-设置心跳包" class="headerlink" title="SDO 命令-设置心跳包"></a>SDO 命令-设置心跳包</h2><h3 id="读取心跳时间设置"><a href="#读取心跳时间设置" class="headerlink" title="读取心跳时间设置"></a>读取心跳时间设置</h3><p><code>CAN0 604 [8] 40 17 10 00 00 00 00 00</code></p>
<h3 id="写入心跳时间设置"><a href="#写入心跳时间设置" class="headerlink" title="写入心跳时间设置"></a>写入心跳时间设置</h3><ul>
<li><strong>CAN ID</strong>：0x600 + 节点 ID（4）&#x3D; 0x604。</li>
<li><strong>命令字节</strong>：<code>0x2B</code> 表示写入 2 字节（u16）。</li>
<li><strong>索引</strong>：0x1017（字节顺序为 <code>17 10</code>）。</li>
<li><strong>子索引</strong>：0x00。</li>
<li><strong>数据</strong>：1000ms&#x3D;<code>0x03E8</code>，字节顺序为 <code>E8 03</code>。10000ms&#x3D;<code>0x2710</code></li>
<li><code>can0 604 [8] 2B 17 10 00 E8 03 00 00</code></li>
</ul>
<h2 id="PDO-配置"><a href="#PDO-配置" class="headerlink" title="PDO 配置"></a>PDO 配置</h2><p>按以下步骤通过写入 OD 变量配置 PDO：</p>
<ul>
<li>将 PDO 通信参数 COB-ID 中的第 31 位设置为 1，禁用 PDO。</li>
<li>只有禁用 PDO 时才能配置 Node-Id。</li>
<li>将 PDO 映射参数，子索引 0 设置为 0，禁用映射。</li>
<li>配置映射</li>
<li>通过设置 PDO 映射参数，子索引 0 至映射对象数启用映射</li>
<li>通过将 PDO 通信参数 COB-ID 中的第 31 位设置为 0 来启用 PDO</li>
</ul>
<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="同步传输信号配置"><a href="#同步传输信号配置" class="headerlink" title="同步传输信号配置"></a>同步传输信号配置</h2><p>全局同步周期 SYNC 设置值保存在对象 1006h 中。</p>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>CANopen 主站的对象 1016h 的值(接收器心跳时间)变为自动优化后的值。 对象 1017h 的值(发生器心跳时间)被此处设置的值重写。适用于所有从站对象的对象 1017h(发生器心跳时间)的值被此处设置的值重写，对象 1016h 的值(接收器心跳时间)变为自动优化后的值。</p>
<h1 id="CAN-Open-总线建设"><a href="#CAN-Open-总线建设" class="headerlink" title="CAN Open 总线建设"></a>CAN Open 总线建设</h1><p>假定在一个 can open 网络中，node1 为主节点，node2 和 node3 为从节点，需要配置 node2，让 node2 接收 node3 的 TPDO 消息。</p>
<h2 id="设备配置"><a href="#设备配置" class="headerlink" title="设备配置"></a>设备配置</h2><table>
<thead>
<tr>
<th align="center">设备名</th>
<th>节点地址</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Node 1</td>
<td>0x01</td>
<td>主节点（NMT Master）</td>
</tr>
<tr>
<td align="center">Node 2</td>
<td>0x02</td>
<td>从节点（NMT Slave）</td>
</tr>
<tr>
<td align="center">Node 3</td>
<td>0x03</td>
<td>从节点（NMT Slave）</td>
</tr>
</tbody></table>
<p>其中 Node3 作为 TPDO 消息发出（生产者），期望 Node2 接收 Node3 消息。</p>
<h2 id="PDO-参数配置"><a href="#PDO-参数配置" class="headerlink" title="PDO 参数配置"></a>PDO 参数配置</h2><h3 id="配置所需信息"><a href="#配置所需信息" class="headerlink" title="配置所需信息"></a>配置所需信息</h3><p>配置 Node 3 的 TPDO：</p>
<ul>
<li>确定 Node 3 的 TPDO 消息的 COB-ID 和映射对象。</li>
<li>在 Node 3 的对象字典中设置 TPDO 通信参数和映射参数。</li>
</ul>
<p>配置 Node 2 的 RPDO：</p>
<ul>
<li>设置 Node 2 的 RPDO 通信参数，使其接收 Node 3 的 TPDO 消息。</li>
<li>配置 Node 2 的 RPDO 映射参数，以处理从 Node 3 接收到的数据。</li>
</ul>
<h3 id="通讯参数和映射参数（OD）"><a href="#通讯参数和映射参数（OD）" class="headerlink" title="通讯参数和映射参数（OD）"></a>通讯参数和映射参数（OD）</h3><p>Node 3 的配置：</p>
<ul>
<li>TPDO 通信参数（0x1802）：<ul>
<li>子索引 0x01: COB-ID &#x3D; 0x183</li>
<li>子索引 0x02: 传输类型（例如 0xFF，事件触发）</li>
</ul>
</li>
<li>TPDO 映射参数（0x1A02）：<ul>
<li>子索引 0x00: 映射对象数量 &#x3D; 2</li>
<li>子索引 0x01: 0x60000208（对象 0x6000，子索引 0x02，8 位）</li>
<li>子索引 0x02: 0x64010110（对象 0x6401，子索引 0x01，16 位）</li>
</ul>
</li>
</ul>
<p>Node 2 的配置：</p>
<ul>
<li>RPDO 通信参数（0x1400）：<ul>
<li>子索引 0x01: COB-ID &#x3D; 0x183（与 Node 3 的 TPDO COB-ID 一致）</li>
<li>子索引 0x02: 传输类型（例如 0xFF，事件触发）</li>
</ul>
</li>
<li>RPDO 映射参数（0x1600）：<ul>
<li>子索引 0x00: 映射对象数量 &#x3D; 2</li>
<li>子索引 0x01: 0x60000208（与 Node 3 的 TPDO 映射一致）</li>
<li>子索引 0x02: 0x64010110（与 Node 3 的 TPDO 映射一致）</li>
</ul>
</li>
</ul>
<h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>设置 Node 3 的 TPDO 通信参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CAN ID: <span class="number">0x601</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">2B</span> <span class="number">00</span> <span class="number">18</span> <span class="number">02</span> <span class="number">83</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>]  # 设置 COB-ID 为 <span class="number">0x183</span>（启用）</span><br><span class="line">CAN ID: <span class="number">0x601</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">2B</span> <span class="number">00</span> <span class="number">18</span> <span class="number">02</span> FF <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>]  # 设置传输类型为 <span class="number">0xFF</span>（事件触发）</span><br></pre></td></tr></table></figure>

<p>设置 Node 3 的 TPDO 映射参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CAN ID: <span class="number">0x601</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">2F</span> <span class="number">00</span> <span class="number">1</span>A <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>]  # 禁用 TPDO 映射</span><br><span class="line">CAN ID: <span class="number">0x601</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">23</span> <span class="number">00</span> <span class="number">1</span>A <span class="number">02</span> <span class="number">01</span> <span class="number">08</span> <span class="number">02</span> <span class="number">60</span>]  # 映射对象 <span class="number">0x6000</span>，子索引 <span class="number">0x02</span>，<span class="number">8</span> 位</span><br><span class="line">CAN ID: <span class="number">0x601</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">23</span> <span class="number">00</span> <span class="number">1</span>A <span class="number">02</span> <span class="number">02</span> <span class="number">10</span> <span class="number">01</span> <span class="number">64</span>]  # 映射对象 <span class="number">0x6401</span>，子索引 <span class="number">0x01</span>，<span class="number">16</span> 位</span><br><span class="line">CAN ID: <span class="number">0x601</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">2F</span> <span class="number">00</span> <span class="number">1</span>A <span class="number">02</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>]  # 启用 TPDO 映射</span><br></pre></td></tr></table></figure>

<p>设置 Node 2 的 RPDO 通信参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CAN ID: <span class="number">0x602</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">2B</span> <span class="number">00</span> <span class="number">14</span> <span class="number">00</span> <span class="number">83</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>]  # 设置 COB-ID 为 <span class="number">0x183</span></span><br><span class="line">CAN ID: <span class="number">0x602</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">2B</span> <span class="number">00</span> <span class="number">14</span> <span class="number">02</span> FF <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>]  # 设置传输类型为 <span class="number">0xFF</span>（事件触发）</span><br></pre></td></tr></table></figure>

<p>设置 Node 2 的 RPDO 映射参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CAN ID: <span class="number">0x602</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">2F</span> <span class="number">00</span> <span class="number">16</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>]  # 禁用 RPDO 映射</span><br><span class="line">CAN ID: <span class="number">0x602</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">23</span> <span class="number">00</span> <span class="number">16</span> <span class="number">01</span> <span class="number">08</span> <span class="number">02</span> <span class="number">60</span>]  # 映射对象 <span class="number">0x6000</span>，子索引 <span class="number">0x02</span>，<span class="number">8</span> 位</span><br><span class="line">CAN ID: <span class="number">0x602</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">23</span> <span class="number">00</span> <span class="number">16</span> <span class="number">02</span> <span class="number">10</span> <span class="number">01</span> <span class="number">64</span>]  # 映射对象 <span class="number">0x6401</span>，子索引 <span class="number">0x01</span>，<span class="number">16</span> 位</span><br><span class="line">CAN ID: <span class="number">0x602</span> (SDO 请求)</span><br><span class="line">Data: [<span class="number">2F</span> <span class="number">00</span> <span class="number">16</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>]  # 启用 RPDO 映射</span><br></pre></td></tr></table></figure>

<p>通过上述步骤配置 Node 2 的 RPDO 通信参数和映射参数，使其能够接收和处理来自 Node 3 的 TPDO 消息。这种配置确保了 Node 2 能够正确接收和解析 Node 3 发送的 TPDO 数据，完成数据的有效传输和处理。</p>
<h1 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h1><p>控制 NMT 状态</p>
<p><code>CAN0 000 [2] 01 04</code>&#x2F;<code>CAN0 000 [2] 02 04</code> 控制节点 4</p>
<p><code>CAN0 000 [2] 01 00</code>&#x2F;<code>CAN0 000 [2] 02 00</code> 控制所有节点</p>
<p>发送 SYNC 信号</p>
<p><code>CAN0 080 [0]</code></p>
<p>发送 ERROR 信号</p>
<p><code>CAN0 084 [8] 数据区根据实际错误定义</code></p>
<p>恢复参数，在 1011 的 01 写入 load</p>
<p><code>CAN0 604 [8] 2F 11 10 01 6C 6F 61 64</code></p>
<p>读取 1005 信息（SYNC 的 COB-ID）</p>
<p><code>CAN0 604 [8] 40 05 10 00 00 00 00 00</code></p>
<p>配置 1005 信息，设 SYNC 的 COB-ID 为 0x80（默认值）。</p>
<p>&#96;CAN0 604 [8] 23 05 10 00 80 00 00 00</p>
<p>读取 1006 信息(SYNC 通信周期)</p>
<p>&#96;CAN0 604 [8] 40 06 10 00 00 00 00 00</p>
<p>写入 1006 信息，将 SYNC 的通信周期设置为 100ms，那么需要写入到 <code>0x1006</code> 的值为 100000（100ms &#x3D; 100000us）。</p>
<p><code>CAN0 604 [8] 23 06 10 00 A0 86 01 00</code></p>
<p>读取心跳时间设置</p>
<p><code>CAN0 604 [8] 40 17 10 00 00 00 00 00</code></p>
<p>通过配置 0x1017 的 heartbeat 时间，自动上报设备状态。</p>
<p><code>CAN0 604 [8] 2B 17 10 00 E8 03 00 00</code></p>
<h2 id="设置一个-TPDO"><a href="#设置一个-TPDO" class="headerlink" title="设置一个 TPDO"></a>设置一个 TPDO</h2><p>配置 1800 的上报方式为异步，读取的话改 2F 为 40</p>
<p><code>CAN0 604 [8] 2F 00 18 02 FF 00 00 00</code></p>
<p>配置 1800 的上报事件为 100ms（子索引 05）（数据类型 uint16）</p>
<p><code>CAN0 604 [8] 2B 00 18 05 64 00 00 00</code>（单位为 ms）</p>
<p>设置子索引禁用</p>
<p><code>CAN0 604 [8] 2F 00 1A 00 00 00 00 00</code> </p>
<p>0x40300010，设置映射索引 0x4030，子索引 00，大小 0x10（16 位）</p>
<p><code>CAN0 604 [8] 23 00 1A 01 10 00 30 40</code></p>
<p>0x20100020，设置映射索引 0x2010，子索引 00，大小 0x20（32 位）</p>
<p><code>CAN0 604 [8] 23 00 1A 02 20 00 10 20</code></p>
<p>设置映射数量，用多少设多少，这里用了 2 个</p>
<p><code>CAN0 604 [8] 2F 00 1A 00 02 00 00 00</code> </p>
<h2 id="设置-RPDO"><a href="#设置-RPDO" class="headerlink" title="设置 RPDO"></a>设置 RPDO</h2><p>配置 1400 接收来自 181 的数据</p>
<p><code>CAN0 601 [8] 23 00 14 01 81 01 00 00</code></p>
<p>配置 1400 的上报方式为异步，读取的话改 2F 为 40</p>
<p><code>CAN0 601 [8] 2F 00 14 02 FF 00 00 00</code></p>
<p>配置 1400 的上报事件为 100ms（子索引 05）（数据类型 uint16）</p>
<p><code>CAN0 601 [8] 2B 00 14 05 64 00 00 00</code>（单位为 ms）</p>
<p>设置子索引禁用</p>
<p><code>CAN0 601 [8] 2F 00 1A 00 00 00 00 00</code> </p>
<p>0x40300010，设置映射索引 0x4030，子索引 00，大小 0x10（16 位）</p>
<p><code>CAN0 601 [8] 23 00 1A 01 10 00 30 40</code></p>
<p>0x20100020，设置映射索引 0x2010，子索引 00，大小 0x20（32 位）</p>
<p><code>CAN0 601 [8] 23 00 1A 02 20 00 10 20</code></p>
<p>设置映射数量，用多少设多少，这里用了 2 个</p>
<p><code>CAN0 601 [8] 2F 00 1A 00 02 00 00 00</code> </p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CANOpenNode 代码分析</title>
    <url>/2024/05/28/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CANOpenNode-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="主文件-CO-main-basic-c"><a href="#主文件-CO-main-basic-c" class="headerlink" title="主文件 CO_main_basic.c"></a>主文件 <code>CO_main_basic.c</code></h1><p>进入 Main 函数中运行，最开始都是一些关于存储&#x2F;多线程&#x2F;功能启用部分的配置代码，后面我们会根据宏定义来讲解。实际的第一行初始化代码从以下开始。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> heapMemoryUsed = <span class="number">0</span>;</span><br><span class="line">CO_config_t *config_ptr = <span class="literal">NULL</span>;</span><br><span class="line">CO = CO_new(config_ptr, &amp;heapMemoryUsed);</span><br></pre></td></tr></table></figure>

<p>该函数的作用是创建一个 CAN open 对象，在单个 OD 的情况下，config 应为 NULL，参数从默认的 “OD.h “文件中获取。如果定义了 CO_USE_GLOBALS，那么函数将为所有 CANopenNode 对象使用全局静态变量。否则，它将从堆中分配所有对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_epoll_t epMain;</span><br><span class="line">err = CO_epoll_create(&amp;epMain, MAIN_THREAD_INTERVAL_US);</span><br></pre></td></tr></table></figure>

<p>该函数创建 Linux epoll 监控 timerfd 和 eventfd。创建并配置多个 Linux 通知，以触发任务的执行。CO_epoll_create 中实现了 epoll 拦截并监控多个文件描述符，其中 timerfd 以恒定的定时器间隔触发，eventfd 则根据外部信号触发。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_CANptrSocketCan_t CANptr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">CANptr.can_ifindex = if_nametoindex(<span class="string">&quot;can0&quot;</span>);</span><br><span class="line">CANptr.epoll_fd = epMain.epoll_fd;</span><br></pre></td></tr></table></figure>

<p>设置用于 CO_CANinit 的指针参数，主要传入 CAN 设备名和监控的 epoll 描述符。</p>
<p>之后进入 CAN open 通讯初始化阶段，注意该阶段是可以通过 0x82 命令，即 CANopen communication reset 重置的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_CANsetConfigurationMode((<span class="type">void</span> *)&amp;CANptr);</span><br><span class="line">CO_CANmodule_disable(CO-&gt;CANmodule);</span><br></pre></td></tr></table></figure>

<p>进入 CAN 配置，主要还是在通过 0x82 命令重启后，禁用 CANmodule 模块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = CO_CANinit(CO, (<span class="type">void</span> *)&amp;CANptr, <span class="number">0</span> <span class="comment">/* bit rate not used */</span>);</span><br></pre></td></tr></table></figure>

<p>初始化 CAN 驱动，如果是通过 0x82 命令重启的通讯，也必须重新初始化。其中的波特率参数在 Linux 部分中还不被支持。之后是 LSS 部分的初始化，该部分内容属于 CiA 305，先略过，之后有时间在分析实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NMT_CONTROL \</span></span><br><span class="line"><span class="meta">            CO_NMT_STARTUP_TO_OPERATIONAL \</span></span><br><span class="line"><span class="meta">          | CO_NMT_ERR_ON_ERR_REG \</span></span><br><span class="line"><span class="meta">          | CO_ERR_REG_GENERIC_ERR \</span></span><br><span class="line"><span class="meta">          | CO_ERR_REG_COMMUNICATION</span></span><br><span class="line">          </span><br><span class="line">err = CO_CANopenInit(CO,            <span class="comment">/* CANopen object */</span></span><br><span class="line">				 <span class="literal">NULL</span>,              <span class="comment">/* alternate NMT */</span></span><br><span class="line">				 <span class="literal">NULL</span>,              <span class="comment">/* alternate em */</span></span><br><span class="line">				 OD,                <span class="comment">/* Object dictionary */</span></span><br><span class="line">				 <span class="literal">NULL</span>,              <span class="comment">/* Optional OD_statusBits */</span></span><br><span class="line">				 NMT_CONTROL,       <span class="comment">/* CO_NMT_control_t */</span></span><br><span class="line">				 <span class="number">500</span>,               <span class="comment">/* firstHBTime_ms */</span></span><br><span class="line">				 <span class="number">1000</span>,            <span class="comment">/* SDOserverTimeoutTime_ms */</span></span><br><span class="line">				 <span class="number">500</span>,             <span class="comment">/* SDOclientTimeoutTime_ms */</span></span><br><span class="line">				 <span class="literal">false</span>,           <span class="comment">/* SDOclientBlockTransfer */</span></span><br><span class="line">				 CO_activeNodeId, <span class="comment">//Node ID</span></span><br><span class="line">				 &amp;errInfo);</span><br></pre></td></tr></table></figure>

<p>初始化除 PDO 对象外的 CAN open 通讯协议（同样也必须在 0x82 命令后调用）。</p>
<ul>
<li>CO CANopen 对象。</li>
</ul>
<ul>
<li>em 紧急对象，用于不同的 CANopen 对象内部，通常用于错误报告。如果为空，则使用 <code>co-&gt;em</code>。如果为空，且 <code>co-&gt;CNT_EM</code> 为 0，则函数错误返回。</li>
<li>NMT 如果 <code>co-&gt;CNT_NMT</code> 为 0，则必须指定该对象；如果 <code>co-&gt;CNT_NMT</code> 为 1，则该对象将被忽略，可以为 NULL。<strong>NMT 对象用于 NMT 对象用于在 CO_process()内部检索 NMT 内部状态</strong>。</li>
<li>od CANopen 对象字典。之前有提到的 ODxyz.h 中定义。</li>
<li>OD_statusBits 传递给 CO_EM_init() 的参数。可以为空。</li>
<li>NMTcontrol 传递给 CO_NMT_init() 的参数。</li>
<li>firstHBTime_ms 传递给 CO_NMT_init() 的参数。</li>
<li>SDOserverTimeoutTime_ms 传递给 CO_SDOserver_init() 的参数。</li>
<li>SDOclientTimeoutTime_ms SDO 客户端的默认超时时间毫秒，一般为 500。</li>
<li>SDOclientBlockTransfer 如果为 “true”，则默认在 SDO 客户端设置块传输。</li>
<li>nodeId CANopen 节点 ID（1 … 127）或 0xFF（未配置）。在 CANopen 初始化中，它与 CO_LSSinit() 中的 pendingBitRate 相同。如果为未配置，则某些 CANopen 对象将不会被初始化或处理。</li>
<li>errInfo 也可以在函数返回 CO_ERROR_NO 的非关键错误中设置。</li>
<li>成功时返回 CO_ERROR_NO。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_epoll_initCANopenMain(&amp;epMain, CO);</span><br></pre></td></tr></table></figure>

<p>该函数用于配置 CAN 接收后的自定义回调。自定义回调函数可由应用程序选择性注册，并在操作系统中配置线程。回调函数会在高优先级线程预处理完某些内容后调用，并且必须由低优先级线程进一步处理。例如，当接收到 CAN 报文并进行预处理后，回调应唤醒主线程处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_EM_initCallbackRx(CO-&gt;em, EmergencyRxCallback);</span><br><span class="line">CO_NMT_initCallbackChanged(CO-&gt;NMT, NmtChangedCallback);</span><br><span class="line">CO_HBconsumer_initCallbackNmtChanged(CO-&gt;HBcons, <span class="number">0</span>, <span class="literal">NULL</span>, HeartbeatNmtChangedCallback);</span><br></pre></td></tr></table></figure>

<ul>
<li>CO_EM_initCallbackRx，初始化 Emergency 接收回调函数。该函数在收到错误条件后执行。</li>
<li>CO_NMT_initCallbackChanged，初始化 NMT 状态变化回调函数。该函数在 NMT 状态发生变化后被调用。该函数可能会唤醒处理 NMT 事件的外部任务。第一次调用会立即向消费者提供 当前的 NMT 状态。</li>
<li>CO_HBconsumer_initCallbackNmtChanged，初始化心跳消费者 NMT 更改回调函数，当 NMT 状态发生变化时调用的回调函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_TIME_set(CO-&gt;TIME, time_ms, time_days, TIME_STAMP_INTERVAL_MS);</span><br></pre></td></tr></table></figure>

<p>设置当前时间，并设置生产者的间隔时间为 <code>TIME_STAMP_INTERVAL_MS</code>，以毫秒为单位，此处设置为 10000ms。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = CO_CANopenInitPDO(CO,             <span class="comment">/* CANopen object */</span></span><br><span class="line">						CO-&gt;em,         <span class="comment">/* emergency object */</span></span><br><span class="line">						OD,             <span class="comment">/* Object dictionary */</span></span><br><span class="line">						CO_activeNodeId,</span><br><span class="line">						&amp;errInfo);</span><br></pre></td></tr></table></figure>

<p>必须在通信重置 0x82 部分的末尾调用该函数，否则某些 OD 变量将无法正确映射到 PDO 中。函数参数就是 CAN Open 对象，EM 对象，OD 对象，NodeID 以及错误信息这些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_CANsetNormalMode(CO-&gt;CANmodule);</span><br></pre></td></tr></table></figure>

<p>已完成所有对象初始化，设置状态，准备进入主循环函数。在主循环函数中，通过 epoll 监控多个文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_epoll_wait(&amp;epMain);</span><br><span class="line">CO_epoll_processRT(&amp;epMain, CO, <span class="literal">false</span>);</span><br><span class="line">CO_epoll_processMain(&amp;epMain, CO, GATEWAY_ENABLE, &amp;reset);</span><br><span class="line">CO_epoll_processLast(&amp;epMain);</span><br></pre></td></tr></table></figure>

<ul>
<li>CO_epoll_wait 函数会阻塞，直到 epoll 上注册了以下事件：timerfd、eventfd 或应用程序指定的事件。函数还会计算自上次调用以来的 timeDifference_us 并准备 timerNext_us。</li>
<li>CO_epoll_processLast，epoll 事件的关闭函数，此函数必须在 CO_epoll_wait() 之后调用。在它们之间是应用程序指定的处理函数，可以检查自己的事件并进行处理。应用程序还可以降低 timerNext_us 变量的值。如果将 timerNext_us 变量调低，则将重新配置间隔定时器，并提前触发 CO_epoll_wait()。</li>
<li>CO_epoll_processRT 和 CO_epoll_processMain 指定了处理函数，接下来先说明 CO_epoll_processRT 处理函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CO_CANrxFromEpoll 如果 epoll 事件与任何 CAN 接口匹配，则返回 True。</span></span><br><span class="line">CO_CANrxFromEpoll(co-&gt;CANmodule, &amp;ep-&gt;ev, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">syncWas = CO_process_SYNC(co, ep-&gt;timeDifference_us,pTimerNext_us);</span><br><span class="line">CO_process_RPDO(co, syncWas, ep-&gt;timeDifference_us,pTimerNext_us);</span><br><span class="line">CO_process_TPDO(co, syncWas, ep-&gt;timeDifference_us,pTimerNext_us);</span><br></pre></td></tr></table></figure>

<p>在 CO_epoll_processRT 中处理以上的 SYNC&#x2F;TPDO&#x2F;RPDO 协议。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CO_CANmodule_process(co-&gt;CANmodule);</span><br><span class="line"></span><br><span class="line">CO_EM_process(co-&gt;em, NMTisPreOrOperational, timeDifference_us, timerNext_us);</span><br><span class="line"></span><br><span class="line">CO_NMT_process(co-&gt;NMT,&amp;NMTstate,timeDifference_us,timerNext_us);</span><br><span class="line"></span><br><span class="line">CO_SDOserver_process(&amp;co-&gt;SDOserver[i], NMTisPreOrOperational, timeDifference_us,timerNext_us);</span><br><span class="line"></span><br><span class="line">CO_HBconsumer_process(co-&gt;HBcons, NMTisPreOrOperational, timeDifference_us, timerNext_us);</span><br><span class="line"></span><br><span class="line">CO_TIME_process(co-&gt;TIME, NMTisPreOrOperational, timeDifference_us);</span><br></pre></td></tr></table></figure>

<p>在 CO_epoll_processMain 中处理了以上的 EM&#x2F;NMT&#x2F;SDOServer&#x2F;HB&#x2F;TIME 协议。</p>
<h2 id="CO-SINGLE-THREAD"><a href="#CO-SINGLE-THREAD" class="headerlink" title="CO_SINGLE_THREAD"></a>CO_SINGLE_THREAD</h2><p>该参数在 Makefile 中通过-D 参数指定，作用是配置程序在单线程中运行。单线程运行时不同的事件（例如 CAN 接收或计时器到期）会触发循环通过堆栈（所有代码都是非阻塞的）。它需要较少的系统资源。</p>
<p>在多线程操作中，除了主线线程外，还建立了一个实时线程。RT 线程每毫秒运行一次，并使用外围设备读&#x2F;写、控制程序或类似程序处理 PDO 和可选应用程序代码。使用此配置必须考虑竞争条件，例如，从主线线程运行的应用程序代码在访问 OD 变量时必须使用 CO_(UN)LOCK_OD 宏。</p>
<h2 id="CO-CONFIG-STORAGE"><a href="#CO-CONFIG-STORAGE" class="headerlink" title="CO_CONFIG_STORAGE"></a>CO_CONFIG_STORAGE</h2><p>该参数由 <code>CO_CONFIG_STORAGE_ENABLE</code> 在 CO_config.h 中使能，主要作用是依据 CiA 301 标准对控制数据进行存储和恢复。数据源通常是对象字典中的一组变量，但并不局限于 OD。在生成对象字典（OD.h 和 OD.c 文件）时，会根据 “存储组 “参数将 OD 变量分组为结构。</p>
<h3 id="OD-对象-0x1010-存储参数"><a href="#OD-对象-0x1010-存储参数" class="headerlink" title="OD 对象 0x1010 - 存储参数"></a>OD 对象 0x1010 - 存储参数</h3><p>OD 对象 0x1010 - 存储参数：</p>
<ul>
<li>子索引 0：支持的最高子索引</li>
<li>子索引 1：保存所有参数，UNSIGNED32</li>
<li>子索引 2：保存通信参数，UNSIGNED32</li>
<li>子索引 3：保存应用参数，UNSIGNED32</li>
<li>子索引 4 - 127：特定于制造商，UNSIGNED32</li>
</ul>
<p>子索引 1 及以上：</p>
<ul>
<li>读取提供有关其存储功能的信息：<ul>
<li>位 0：如果设置，CANopen 设备根据命令保存参数</li>
<li>位 1：如果设置，CANopen 设备自主保存参数</li>
</ul>
</li>
<li>写入值 0x65766173（’s’、’a’、’v’、’e’，从 LSB 到 MSB）可存储相应数据。<br>相应数据。</li>
</ul>
<h3 id="OD-对象-0x1011-恢复默认参数"><a href="#OD-对象-0x1011-恢复默认参数" class="headerlink" title="OD 对象 0x1011 - 恢复默认参数"></a>OD 对象 0x1011 - 恢复默认参数</h3><ul>
<li>子索引 0：支持的最高子索引</li>
<li>子索引 1：恢复所有默认参数，UNSIGNED32</li>
<li>子索引 2：恢复通信默认参数，UNSIGNED32</li>
<li>子索引 3：恢复应用程序默认参数，UNSIGNED32</li>
<li>子索引 4 - 127：特定于制造商，UNSIGNED32</li>
</ul>
<ul>
<li></li>
</ul>
<p>子索引 1 及以上：</p>
<ul>
<li>读取提供有关其恢复能力的信息：<ul>
<li>位 0：如果设置，CANopen 设备恢复参数</li>
</ul>
</li>
<li>写入值 0x64616F6C（’l’、’o’、’a’、’d’从 LSB 到 MSB）可恢复相应数据。<br>相应数据。</li>
</ul>
<h2 id="CO-CONFIG-GTW"><a href="#CO-CONFIG-GTW" class="headerlink" title="CO_CONFIG_GTW"></a>CO_CONFIG_GTW</h2><p>网关对象由标准 CiA 309 - CANopen 从其他网络访问涵盖。它可以将 NMT 主站、SDO 客户端和 LSS 主站用作网关设备。</p>
<p>本次使用中不支持该形式，直接在 CO_config.h 中注释掉该模块即可。</p>
<h1 id="数据字典-OD-操纵"><a href="#数据字典-OD-操纵" class="headerlink" title="数据字典 OD 操纵"></a>数据字典 OD 操纵</h1><p>CANopen 数据字典 OD 基本上是一个 XML 文件，其中包含 CANopen 设备的所有信息。文件的大部分是所有对象字典变量的列表，其中包含所有必要的属性和文档。该文件可使用 OD 编辑器应用程序进行编辑，并可用作数据源，从中生成 CANopenNode 的对象字典。该文件还可用于 CANopen 配置工具，在运行的 CANopen 网络上与 CANopen 设备进行交互。</p>
<p>CANopen 还为 CANopen 设备描述指定了另一种类型的文件。它们是 INI 格式的 EDS 文件。可以在这两种格式之间进行转换。设备描述文件的扩展名为 “XDD”。该文件的名称应包含 CANopen 设备的供应商 ID，以 8 位十六进制数字的形式出现在名称的任意位置，并用下划线分隔。例如 “name1_12345678_name2.XDD”。CANopenNode 包含多个配置文件定义文件，每个 CANopen 对象一个。这些文件的扩展名为 “XPD”。它们采用与 XDD 文件相同的 XML 格式。XML 编辑工具可以使用 XPD 文件将准备好的数据插入正在编辑的设备描述文件 (XDD)。还有扩展名为 “XDC “的设备配置文件。这些文件描述了已配置的 CANopen 设备，并包含其他元素，如默认值、分母和设备调试元素。类似于 INI 格式的 “dcf “文件。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>OD object</strong>是指对象字典中位于特定 16 位索引的对象。CANopen 中有不同类型的 OD 对象：变量、数组和记录（结构）。每个 OD 对象都包含指向实际数据、数据长度和属性的指针。在 OD_objectTypes_t 中被定义。</p>
<p><strong>OD variable</strong> 是指定类型的基本变量。例如：int8_t、uint32_t、float64_t……或数据长度已知或未知的二进制数据序列。每个 OD 变量都以指定的 16 位索引和 8 位子索引存在于对象字典中。</p>
<p><strong>OD entry</strong>指的是结构元素，其中包含 OD 对象的一些基本属性、OD 对象的类型指示以及指向 OD 对象所有必要数据的指针。OD 条目数组以及 OD 条目总数信息代表 CANopenNode 内部定义的对象字典。参见 OD_entry_t 和 OD_t。</p>
<p>应用程序和堆栈可通过通用的 OD_t 对象和 OD_find() 函数访问 OD 对象。无需直接访问定义对象字典的自定义结构。特定 OD 变量的属性可通过 OD_getSub()函数获取。通过 <strong>read</strong> 和 <strong>write</strong> 函数访问实际变量。 OD_getSub() 可以获取这两个函数的指针。参见 OD_stream_t。另请参见快捷方式：  CO_ODgetSetters 用于访问不同类型的数据。</p>
<p><em>可以从不同的线程访问 OD 变量。CANopenNode 基本上在两个线程中运行：快速实时线程（PDO 处理等）和非关键时间主线程（SDO 等）。两个线程都可以访问 OD 变量，因此必须小心谨慎。CANopenNode 使用锁定机制，SDO 服务器在读取或写入 OD 变量时会阻止实时线程的执行。在 CO_storage 中也需要对 OD 变量进行同样的保护。更多信息请参见 CO_driver.h 中的 CO_critical_sections。</em></p>
<h2 id="OD-文件-ODxyz-c-h"><a href="#OD-文件-ODxyz-c-h" class="headerlink" title="OD 文件-ODxyz.c&#x2F;.h"></a>OD 文件-ODxyz.c&#x2F;.h</h2><p>一个 CANopen 设备的实际对象字典由一对 OD_xyz.h 和 ODxyz.c 文件定义。</p>
<p>后缀 “xyz “是对象字典的唯一名称。如果使用单个默认对象字典，则省略后缀。这样就可以配置多个对象字典。</p>
<p>用于定义 OD 的数据安排在多个结构中。不同的 OD 配置有不同的结构。用这些结构创建的数据对象可以是常量，也可以是变量。</p>
<p>实际的 OD 变量位于多个结构（即存储组）中。选定的组可以选择存储到非易失性存储器中。</p>
<p>手动编辑 ODxyz.h&#x2F;.c 文件非常容易出错。</p>
<p>OD 编辑工具可生成成对的 ODxyz.h&#x2F;.c 文件。该工具可以编辑 xml 格式的标准 CANopen 设备描述文件。Xml 文件可能还包括一些 CANopenNode 特有的非标准元素。然后，Xml 文件将用于自动生成 ODxyz.h&#x2F;.c 文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* OD data declaration of all groups ******************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> x1000_deviceType;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> maxSubIndex;</span><br><span class="line">        <span class="type">uint32_t</span> vendorID;</span><br><span class="line">        <span class="type">uint32_t</span> productCode;</span><br><span class="line">        <span class="type">uint32_t</span> revisionNumber;</span><br><span class="line">        <span class="type">uint32_t</span> serialNumber;</span><br><span class="line">    &#125; x1018_identity;</span><br><span class="line">&#125; ODxyz_PERSIST_COMM_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> x1001_errorRegister;</span><br><span class="line">    <span class="type">uint8_t</span> x1003_preDefinedErrorField_sub0;</span><br><span class="line">    <span class="type">uint32_t</span> x1003_preDefinedErrorField[<span class="number">8</span>];</span><br><span class="line">&#125; ODxyz_RAM_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> ODxyz_PERSIST_COMM_t ODxyz_PERSIST_COMM;</span><br><span class="line"><span class="keyword">extern</span> ODxyz_RAM_t ODxyz_RAM;</span><br><span class="line"><span class="keyword">extern</span> OD_t *ODxyz;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object dictionary entries - shortcuts **************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1000 &amp;ODxyz-&gt;list[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1001 &amp;ODxyz-&gt;list[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1003 &amp;ODxyz-&gt;list[2]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1018 &amp;ODxyz-&gt;list[3]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1000_deviceType &amp;ODxyz-&gt;list[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1001_errorRegister &amp;ODxyz-&gt;list[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1003_preDefinedErrorField &amp;ODxyz-&gt;list[2]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ODxyz_ENTRY_H1018_identity &amp;ODxyz-&gt;list[3]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OD_DEFINITION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;301/CO_ODinterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ODxyz.h&quot;</span></span></span><br><span class="line"><span class="comment">/* OD data initialization of all groups ***************************************/</span></span><br><span class="line">ODxyz_PERSIST_COMM_t ODxyz_PERSIST_COMM = &#123;</span><br><span class="line">    .x1000_deviceType = <span class="number">0</span>,</span><br><span class="line">    .x1018_identity = &#123;</span><br><span class="line">        .maxSubIndex = <span class="number">4</span>,</span><br><span class="line">        .vendorID = <span class="number">0</span>,</span><br><span class="line">        .productCode = <span class="number">0</span>,</span><br><span class="line">        .revisionNumber = <span class="number">0</span>,</span><br><span class="line">        .serialNumber = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ODxyz_RAM_t ODxyz_RAM = &#123;</span><br><span class="line">    .x1001_errorRegister = <span class="number">0</span>,</span><br><span class="line">    .x1003_preDefinedErrorField_sub0 = <span class="number">0</span>,</span><br><span class="line">    .x1003_preDefinedErrorField = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All OD objects (constant) **************************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    OD_obj_var_t o_1000_deviceType;</span><br><span class="line">    OD_obj_var_t o_1001_errorRegister;</span><br><span class="line">    OD_obj_array_t o_1003_preDefinedErrorField;</span><br><span class="line">    OD_obj_record_t o_1018_identity[<span class="number">5</span>];</span><br><span class="line">&#125; ODxyzObjs_t;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> CO_PROGMEM ODxyzObjs_t ODxyzObjs = &#123;</span><br><span class="line">    .o_1000_deviceType = &#123;</span><br><span class="line">        .dataOrig = &amp;ODxyz_PERSIST_COMM.x1000_deviceType,</span><br><span class="line">        .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">        .dataLength = <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .o_1001_errorRegister = &#123;</span><br><span class="line">        .dataOrig = &amp;ODxyz_RAM.x1001_errorRegister,</span><br><span class="line">        .attribute = ODA_SDO_R,</span><br><span class="line">        .dataLength = <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .o_1003_preDefinedErrorField = &#123;</span><br><span class="line">        .dataOrig0 = &amp;ODxyz_RAM.x1003_preDefinedErrorField_sub0,</span><br><span class="line">        .dataOrig = &amp;ODxyz_RAM.x1003_preDefinedErrorField[<span class="number">0</span>],</span><br><span class="line">        .attribute0 = ODA_SDO_RW,</span><br><span class="line">        .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">        .dataElementLength = <span class="number">4</span>,</span><br><span class="line">        .dataElementSizeof = <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    .o_1018_identity = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.maxSubIndex,</span><br><span class="line">            .subIndex = <span class="number">0</span>,</span><br><span class="line">            .attribute = ODA_SDO_R,</span><br><span class="line">            .dataLength = <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.vendorID,</span><br><span class="line">            .subIndex = <span class="number">1</span>,</span><br><span class="line">            .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">            .dataLength = <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.productCode,</span><br><span class="line">            .subIndex = <span class="number">2</span>,</span><br><span class="line">            .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">            .dataLength = <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.revisionNumber,</span><br><span class="line">            .subIndex = <span class="number">3</span>,</span><br><span class="line">            .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">            .dataLength = <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            .data = &amp;ODxyz_PERSIST_COMM.x1018_identity.serialNumber,</span><br><span class="line">            .subIndex = <span class="number">4</span>,</span><br><span class="line">            .attribute = ODA_SDO_R | ODA_MB,</span><br><span class="line">            .dataLength = <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object dictionary **********************************************************/</span></span><br><span class="line"><span class="type">static</span> OD_entry_t ODxyzList[] = &#123;</span><br><span class="line">    &#123;<span class="number">0x1000</span>, <span class="number">0x01</span>, ODT_VAR, &amp;ODxyzObjs.o_1000_deviceType, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1001</span>, <span class="number">0x01</span>, ODT_VAR, &amp;ODxyzObjs.o_1001_errorRegister, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1003</span>, <span class="number">0x09</span>, ODT_VAR, &amp;ODxyzObjs.o_1003_preDefinedErrorField, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x1018</span>, <span class="number">0x05</span>, ODT_REC, &amp;ODxyzObjs.o_1018_identity, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x0000</span>, <span class="number">0x00</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OD_t _ODxyz = &#123;</span><br><span class="line">    (<span class="keyword">sizeof</span>(ODxyzList) / <span class="keyword">sizeof</span>(ODxyzList[<span class="number">0</span>])) - <span class="number">1</span>,</span><br><span class="line">    &amp;ODxyzList[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OD_t *ODxyz = &amp;_ODxyz;</span><br></pre></td></tr></table></figure>

<h2 id="OD-find-查找指定对象"><a href="#OD-find-查找指定对象" class="headerlink" title="OD_find 查找指定对象"></a>OD_find 查找指定对象</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> OD_t *ODxyz;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunc</span><span class="params">(OD_t *od)</span> &#123;</span><br><span class="line">    ODR_t odRet;<span class="comment">//保存对象字典操作的返回值。</span></span><br><span class="line">    OD_entry_t *entry;<span class="comment">//指向对象字典条目的指针。</span></span><br><span class="line">    OD_IO_t io1008;<span class="comment">//用于对象字典I/O操作的结构体。</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    OD_size_t bytesRd;<span class="comment">//存储读取的字节数。</span></span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并初始化0x1008条目和其子索引0x00的IO结构体</span></span><br><span class="line">    entry = OD_find(od, <span class="number">0x1008</span>);<span class="comment">//查找对象字典中的条目。</span></span><br><span class="line">    odRet = OD_getSub(entry, <span class="number">0x00</span>, &amp;io1008, <span class="literal">false</span>);<span class="comment">//获取对象字典条目的子索引。</span></span><br><span class="line">    <span class="comment">// 读取制造商设备名称</span></span><br><span class="line">    <span class="keyword">if</span> (odRet == ODR_OK) &#123;</span><br><span class="line">        <span class="comment">/* Locking is necessary from mainline thread, but must not be used from</span></span><br><span class="line"><span class="comment">         * timer interval (real-time) thread. Locking is not necessary in the</span></span><br><span class="line"><span class="comment">         * CANoopen initialization section. Locking is also not necessary, if</span></span><br><span class="line"><span class="comment">         * OD variable is not mappable to PDO and not accessed from RT thread.*/</span></span><br><span class="line">        CO_LOCK_OD(CANmodule);</span><br><span class="line">        odRet = io1008.read(&amp;io1008.stream, &amp;buf[<span class="number">0</span>], <span class="keyword">sizeof</span>(buf), &amp;bytesRd);<span class="comment">//读取子索引的数据。</span></span><br><span class="line">        CO_UNLOCK_OD(CANmodule);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odRet != ODR_OK) error++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Use helper and set &quot;Producer heartbeat time&quot; at index 0x1017, sub 0x00 */</span></span><br><span class="line">    <span class="comment">// 设置生产者心跳时间</span></span><br><span class="line">    CO_LOCK_OD(CANmodule); <span class="comment">/* may not be necessary, see comment above */</span></span><br><span class="line">    odRet = OD_set_u16(OD_find(od, <span class="number">0x1017</span>), <span class="number">0x00</span>, <span class="number">500</span>, <span class="literal">false</span>);<span class="comment">//设置对象字典条目的子索引值。</span></span><br><span class="line">    CO_UNLOCK_OD(CANmodule);</span><br><span class="line">    <span class="keyword">if</span> (odRet != ODR_OK) error++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="直接根据结构体查找-OD-对象"><a href="#直接根据结构体查找-OD-对象" class="headerlink" title="直接根据结构体查找 OD 对象"></a>直接根据结构体查找 OD 对象</h2><p>如何直接访问和操作 CANopen 对象字典（Object Dictionary）中的条目，而不是通过查找函数 <code>OD_find</code> 来间接访问。直接访问对象字典条目和变量比通过函数查找要快，因为它避免了函数调用和查找过程。</p>
<p>对象字典的头文件 <code>ODxyz.h</code>，其中定义了对象字典的所有条目和相关结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ODxyz.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFuncGlob</span><span class="params">(<span class="type">void</span>)</span> &#123;     </span><br><span class="line">	<span class="comment">// Direct address instead of OD_find()     </span></span><br><span class="line">	OD_entry_t *entry_errReg = ODxyz_1001_errorRegister;      </span><br><span class="line">	<span class="comment">// Direct access to OD variable     </span></span><br><span class="line">	<span class="type">uint32_t</span> devType = ODxyz_0.x1000_deviceType;     </span><br><span class="line">	ODxyz_0.x1018_identity.serialNumber = <span class="number">0x12345678</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>OD_entry_t *entry_errReg = ODxyz_1001_errorRegister;</code> 直接获取对象字典中 <code>0x1001</code> 索引（错误寄存器）的条目指针 <code>entry_errReg</code>。这里使用的是直接声明的指针 <code>ODxyz_1001_errorRegister</code>，而不是通过 <code>OD_find</code> 函数查找。</p>
<p><code>uint32_t devType = ODxyz_0.x1000_deviceType;</code> 直接读取对象字典中 <code>0x1000</code> 索引（设备类型）的变量 <code>ODxyz_0.x1000_deviceType</code>，并将其存储到本地变量 <code>devType</code> 中。<code>ODxyz_0.x1018_identity.serialNumber = 0x12345678;</code> 直接修改对象字典中 <code>0x1018</code> 索引（设备标识）的 <code>serialNumber</code> 字段，将其设置为 <code>0x12345678</code>。</p>
<p><em>如果 OD 对象已启用 OD 扩展，则不得直接访问其 OD 变量。只有通过读、写或辅助函数访问才有效。</em></p>
<h1 id="修改-PDO-固定长度"><a href="#修改-PDO-固定长度" class="headerlink" title="修改 PDO 固定长度"></a>修改 PDO 固定长度</h1><p>在 PDO 协议中，数据的接收是严格按照 PDO 中映射的数据长度来读取的，当数据不足时，该数据帧会被丢弃，当数据过长时，该数据帧会被截断。</p>
<p>在此次的应用程序中，由于该设备配置的 PDO 存在两种长度数据，所以需要将 PDO 的数据长度更改为兼容自定义的两种数据长度。</p>
<p>在 CO_PDO.c 文件中，有 RPDO 处理函数 <code>CO_RPDO_process</code>，其中的 for 循环，当小于 <code>PDO-&gt;mappedObjectsCount</code> 数量时，执行 1byte 的拷贝，所以此处我们需要修改为当 <code>i&lt;CO_PDO_MAX_SIZE</code> 时执行拷贝，即对 PDO 中所有的数据进行拷贝，不管该字节是否有数据。</p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CAN和CANFD</title>
    <url>/2024/05/20/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN%E5%92%8CCANFD/</url>
    <content><![CDATA[<h1 id="CAN-和-CANFD"><a href="#CAN-和-CANFD" class="headerlink" title="CAN 和 CANFD"></a>CAN 和 CANFD</h1><p>对于 CAN-FD 而言，数据比特率要大于等于件裁比特率，用 <code> ip link set can0 type can bitrate 500000</code> 这个命令操作 <code>CAN-FD</code> 是有问题的，换成 <code>ip link set can0 type can bitrate 500000 dbitrate 500000 fd on</code>，而后就可以利用 CAN-FD 进行数据的收发</p>
<p>按照配置 CAN 的方式去配置 CAN-FD，导致少配置了 CAN-FD 的数据比特率，导致出错。之前配置 CAN 的指令为 <code> ip link set can0 type canbitrate 500000</code>，实际通过分析 CAN-FD 的驱动代码以及 CAN-FD 通信协议的报文格式发现，对于 CAN-FD，数据比特率是要大于仲裁比特率的。换用 <code> ip link set can0 type can bitrate 500000 dbitrate 500000 fd on</code> 配置数据比特率之后，CAN-FD 就可以正常收发数据了,</p>
<p>分析:CAN-FD 采用了两种方式来提高通信的效率，其中一种叫可变及更高的数据传输速率:从控制场中的 BRS 位到 ACK 场之前(含 CRC 但为了保证总线的健壮可靠，仲裁段(ID 和 ACK)保持不变，采用原分界符)为可变速率，CAN-FD 数据段的传输速率最大可达 5Mbit&#x2F;sCAN 总线用的速率(最高 1Mbit&#x2F;s)。</p>
<p>注意:两种速率各有一套位时间定义寄存器，对于 CAN-FD 来说均要配置。</p>
<h1 id="CAN-和-CANFD-1"><a href="#CAN-和-CANFD-1" class="headerlink" title="CAN 和 CANFD"></a>CAN 和 CANFD</h1><p>CAN 与 CAN-FD 主要区别：</p>
<ul>
<li>传输速率不同<br>  CAN：最大传输速率 1Mbps。<br>  CAN-FD：速率可变，仲裁比特率最高 1Mbps（与 CAN 相同），数据比特率最高 8Mbps。</li>
<li>数据长度不同<br>  CAN：一帧数据最长 8 字节<br>  CAN-FD：一帧数据最长 64 字节。</li>
<li>帧格式不同和 ID 长度不同。</li>
</ul>
<p>CANFD 不存在远程帧，CAN 报文中的 RTR（用于区别标准帧与远程帧）被替换为 RRS（远程请求替代位，默认值为 0）</p>
<p>CANFD 报文的标准帧和扩展帧—IDE 为 1 表示为扩展帧、为 0 表示标准帧</p>
<p>FDF 用于传统 CAN 报文和 CANFD 报文，FDF 位为 0 时为传统报文，FDF 为 1 时为 CANFD 报文</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520123827.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1726797665000nfhfpb.png" alt="gh"></p>
<p>BRS 位速率切换位，BRS 位为 0 时 CANFD 速率保持恒定速率、BRS 位为 1 时 CANFD 的数据段会被切换到高速率。</p>
<p>ESI 错误状态指示位：CAN 报文中发送节点的错误状态只有该节点自己知道，CANFD 报文中可以通过 ESI 标志位来告诉其他节点该节点的错误状态，当 ESI 为 1 时表示发送节点处于被动错误状态、当 ESI 为 0 时表示发送节点处于主动错误状态</p>
<p>CRC：随着数据场的扩大，为了保证信息发送的质量，CAN FD 的 CRC 计算不仅要包括数据段的位，还包括来自 SOF 的 Stuff Count 和填充位。通过比较 CRC 的计算结果，可以判断接收节点是否能够正常接收。</p>
<p>在 CAN 中，CRC 的位数是 15 位，而在 CAN FD 中，CRC 场扩展到了 21 位。</p>
<ul>
<li>当传输报文为 15 字节时：CRC 15 位</li>
<li>当传输数据为 16 字节或更少时：CRC 17 位</li>
<li>当传输数据超过 16 字节时：CRC 21 位</li>
</ul>
<h1 id="CAN-FD-DLC"><a href="#CAN-FD-DLC" class="headerlink" title="CAN FD DLC"></a>CAN FD DLC</h1><h2 id="DLC-和-数据长度的关系"><a href="#DLC-和-数据长度的关系" class="headerlink" title="DLC 和 数据长度的关系"></a>DLC 和 数据长度的关系</h2><p>在 Linux 的 SocketCAN 中，struct canfd_frame 中的 len 字段表示实际的有效负载长度（即数据长度），而 CAN FD 协议使用的是 4-bit 的 DLC（Data Length Code）来表示帧中数据的长度。这两者之间的关系是通过一组映射规则来转换的。</p>
<p>在 CAN FD 协议中，DLC 是一个 4 位的字段，允许的取值范围为 0 到 15。这些 DLC 值并不是直接表示字节长度，而是与有效负载长度之间有一个固定的映射关系。具体映射如下：</p>
<table>
<thead>
<tr>
<th align="center">DLC</th>
<th>数据字节数 (Payload Length)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0-8</td>
<td>0-8</td>
</tr>
<tr>
<td align="center">9</td>
<td>12</td>
</tr>
<tr>
<td align="center">10</td>
<td>16</td>
</tr>
<tr>
<td align="center">11</td>
<td>20</td>
</tr>
<tr>
<td align="center">12</td>
<td>24</td>
</tr>
<tr>
<td align="center">13</td>
<td>32</td>
</tr>
<tr>
<td align="center">14</td>
<td>48</td>
</tr>
<tr>
<td align="center">15</td>
<td>64</td>
</tr>
</tbody></table>
<h2 id="struct-canfd-frame-中-len-和-DLC-的转换"><a href="#struct-canfd-frame-中-len-和-DLC-的转换" class="headerlink" title="struct canfd_frame 中 len 和 DLC 的转换"></a>struct canfd_frame 中 len 和 DLC 的转换</h2><p>在 SocketCAN 中，应用程序通过 struct canfd_frame 来发送 CAN FD 帧。struct canfd_frame 中的 len 字段表示实际的有效负载长度，而内核会根据这个 len 值来确定对应的 DLC 值。转换规则如下：</p>
<ul>
<li>如果 len 的值在 0 到 8 ，DLC 的值与 len 直接相等。例如，len &#x3D; 5，则 DLC &#x3D; 5。</li>
<li>如果 len 的值大于 8，系统会根据 DLC 与有效负载长度的固定映射来选择最小的 DLC，使得能传输指定的字节数。例如：<ul>
<li>len &#x3D; 9 到 len &#x3D; 12，DLC &#x3D; 9，对应 12 字节的负载。</li>
<li>len &#x3D; 13 到 len &#x3D; 16，DLC &#x3D; 10，对应 16 字节的负载。</li>
<li>len &#x3D; 17 到 len &#x3D; 20，DLC &#x3D; 11，对应 20 字节的负载。</li>
<li>len &#x3D; 21 到 len &#x3D; 24，DLC &#x3D; 12，对应 24 字节的负载。</li>
<li>len &#x3D; 25 到 len &#x3D; 32，DLC &#x3D; 13，对应 32 字节的负载。</li>
<li>len &#x3D; 33 到 len &#x3D; 48，DLC &#x3D; 14，对应 48 字节的负载。</li>
<li>len &#x3D; 49 到 len &#x3D; 64，DLC &#x3D; 15，对应 64 字节的负载。</li>
</ul>
</li>
</ul>
<h2 id="实际发送时的-DLC-计算"><a href="#实际发送时的-DLC-计算" class="headerlink" title="实际发送时的 DLC 计算"></a>实际发送时的 DLC 计算</h2><p>当你在 SocketCAN 中使用 canfd_frame 结构体发送数据时：</p>
<ul>
<li>你在 len 字段中指定实际的数据长度。</li>
<li>内核会根据上述规则，自动计算并设置相应的 DLC 值，确保数据可以正确传输。</li>
</ul>
<p>如果 len 的值不直接对应某个 DLC（如 len &#x3D; 33），内核会自动选择能容纳该数据长度的最小 DLC（在这个例子中，DLC 会被设置为 14，对应 48 字节）。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你要发送 33 个字节的数据： struct canfd_frame 的 len 设置为 33。内核根据 len 值选择对应的 DLC 为 14（因为 DLC&#x3D;14 对应 48 字节的有效负载长度，可以容纳 33 个字节）。</p>
<p>实际发送时，CAN FD 帧会包含 33 字节的数据，DLC 会标记为 14，表示该帧允许的最大有效负载是 48 字节，尽管只使用了 33 字节。</p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CAN学习笔记</title>
    <url>/2024/05/17/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CAN 总线是一种串行通信协议，使用的是两条差分信号线，只能表达一个信号。简洁的物理层决定了 CAN 必然要配上一套复杂的协议。根据不同的距离、不同的网络，可配置不同的速度，最高速度为 1MBit&#x2F;s。</p>
<p>CAN 2.0A 为标准格式，CAN 2.0B 为扩展格式。</p>
<ul>
<li>可以多主方式工作，网络上的任意节点均可以在任意时刻主动地向网络上的其他节点发送信息，而不分主从，通信方式灵活。</li>
<li>网络上的节点 (信息) 可分成不同的优先级，可以满足不同的实时要求。</li>
<li>采用非破坏性位仲裁总线结构机制，当两个节点同时向网络上传送信息时，优先级低的节点主动停止数据发送，而优先级高的节点可不受影响地继续传输数据。</li>
</ul>
<h2 id="CAN-属性"><a href="#CAN-属性" class="headerlink" title="CAN 属性"></a>CAN 属性</h2><table>
<thead>
<tr>
<th align="center">属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">报文（Messages）</td>
<td>CAN 协议对数据、操作命令 (如读&#x2F;写) 以及同步信号进行打包，打包后的这些内容称为报文，简单来说就是具有固定格式的数据包。</td>
</tr>
<tr>
<td align="center">信息路由（Information Routing）</td>
<td>报文寻找结点的方式。</td>
</tr>
<tr>
<td align="center">位速率（Bit rate）</td>
<td>数据位的传输速度。</td>
</tr>
<tr>
<td align="center">优先权（Priorities）</td>
<td>报文发送的优先权。</td>
</tr>
<tr>
<td align="center">远程数据请求（Remote Data Request）</td>
<td>通过发送远程帧，需要数据的节点可以请求另一节点发送相应的数据帧。</td>
</tr>
<tr>
<td align="center">多主机（Multimaster）</td>
<td>总线空闲时，任何结点都可以开始传送报文。</td>
</tr>
<tr>
<td align="center">仲裁（Arbitration）</td>
<td>当 2 个及以上的单元同时开始传送报文，那么就会有总线访问冲突。仲裁是确定哪个单元的具有发送优先权。</td>
</tr>
<tr>
<td align="center">安全性（Safety）</td>
<td>CAN 的每一个节点均采取了强有力的措施以进行错误检测、错误标定及错误自检。</td>
</tr>
<tr>
<td align="center">错误检测（Error Detection）</td>
<td>包括监视、循环冗余检查、位填充、报文格式检查。</td>
</tr>
<tr>
<td align="center">错误检测的执行（Performance of Error Detection）</td>
<td></td>
</tr>
<tr>
<td align="center">错误标定和恢复时间（Error Sinalling and Recovery Time）</td>
<td>任何检测到错误的结点会标志出已损坏的报文。此报文会失效并将自动地开始重新传送。如果不再出现新的错误，从检测到错误到下一报文的传送开始为止，恢复时间最多为 29 个位的时间。</td>
</tr>
<tr>
<td align="center">故障界定（Fault Confinement）</td>
<td>CAN 结点能够把永久故障和短暂扰动区分开来。永久故障的结点会被关闭。</td>
</tr>
<tr>
<td align="center">连接（Connections）</td>
<td>CAN 串行通讯链路是可以连接许多结点的总线。理论上，可连接无数多的结点。但由于实际上受延迟时间或者总线线路上电气负载的影响，连接结点的数量是有限的。</td>
</tr>
<tr>
<td align="center">单通道（Single Channel）</td>
<td>总线是由单一进行双向位信号传送的通道组成。</td>
</tr>
<tr>
<td align="center">总线值（Bus value）</td>
<td>总线可以具有两种互补的逻辑值之一：“显性”（可表示为逻辑 0）或“隐性”（可表示为逻辑 1）。</td>
</tr>
<tr>
<td align="center">应答（Acknowledgment）</td>
<td>所有的接收器检查报文的连贯性。对于连贯的报文，接收器应答；对于不连贯的报文，接收器作出标志。</td>
</tr>
<tr>
<td align="center">睡眠模式／唤醒（Sleep Mode &#x2F; Wake-up）</td>
<td>为了减少系统电源的功率消耗，可以将 CAN 器件设为睡眠模式以便停止内部活动及断开与总线驱动器的连接。CAN 器件可由总线激活，或系统内部状态而被唤醒。</td>
</tr>
</tbody></table>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>当 CAN 总线上的节点发送数据时，以报文形式广播给网络中的所有节点，总线上的所有节点都不使用节点地址等系统配置信息，只根据每组报文开头的 11 位标识符解释数据的含义来决定是否接收。这种数据收发方式称为<strong>面向内容的编址方案</strong>。</p>
<p>当某个节点要向其他节点发送数据时，这个节点的处理器将要发送的数据和自己的标识符传送给该节点的 CAN 总线接口控制器，并处于准备状态；当收到总线分配时，转为发送报文状态。数据根据协议组织成一定的报文格式后发出，此时网络上的其他节点处于接收状态。处于接收状态的每个节点对接收到的报文进行检测，判断这些报文是否是发给自己的以确定是否接收。</p>
<h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p>CAN 被细分为三个层次，其中的对象层和传输层包括所有由 ISO&#x2F;OSI 模型定义的数据链路层的服务和功能。</p>
<ul>
<li>对象层（the object layer）的作用范围包括：<ul>
<li>查找被发送的报文。</li>
<li>确定由实际要使用的传输层接收哪一个报文。</li>
<li>为应用层相关硬件提供接口。</li>
</ul>
</li>
<li>传输层（the transfer layer）的作用主要：<ul>
<li>传送规则，也就是控制帧结构、执行仲裁、错误检测、出错标定、故障界定。</li>
<li>总线上什么时候开始发送新报文及什么时候开始接收报文，在传输层里确定。</li>
<li>位定时的一些普通功能也可以看作是传输层的一部分。</li>
<li>传输层的修改是受到限制的。</li>
</ul>
</li>
<li>物理层（the phyical layer）的作用：<ul>
<li>在不同节点之间根据所有的电气属性进行位信息的实际传输。当然，同一网络内，物理层对于所有的节点必须是相同的。</li>
</ul>
</li>
</ul>
<p>编程在对象层进行，这一层直接与应用层交互，并且提供了管理和处理 CAN 消息的接口。通过对象层，应用程序可以发送和接收 CAN 的打包消息。打包的过程就是在原始数据的基础上再加上帧起始段、仲裁段、控制段、CRC 校验、应答和帧结束，把这些内容按特定的格式打包好，就可以用一个通道表达各种信号了，当数据包被发送时，只要接收方按约定格式去解读，就能还原出原始数据。</p>
<p>传输层的功能主要由 CAN 控制器硬件和驱动程序实现。通常，程序员不直接操作传输层，而是通过对象层的 API 间接利用传输层的功能。传输层负责处理 CAN 协议的低级细节，如位级传输、错误处理和仲裁。</p>
<p>位填充是为了防止突发错误而设定的功能。位填充的规则如下：</p>
<ul>
<li>5 位连续相同电平之后，必须填充一位反向位，即不允许有 6 个连续相同位；</li>
<li>SOF 之前为总线空闲状态，不需要同步，因此不需要位填充；</li>
<li>CRC 之后为固定格式，不允许填充；</li>
<li><strong>由 CAN 控制器自动实现</strong>；</li>
</ul>
<p>物理层通常由 CAN 收发器硬件和相关电气接口组成。</p>
<h2 id="仲裁方式"><a href="#仲裁方式" class="headerlink" title="仲裁方式"></a>仲裁方式</h2><p>在总线空闲态，最先开始发送消息的单元获得发送权。多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。<strong>连续输出显性电平最多的单元继续发送</strong>。即逐位地对比 各个结点发出的报文 ID。</p>
<p>由于线与的关系，显示位“0”可以覆盖隐性位“1”，因此 ID 最小的节点赢得仲裁，总线上表现为该结点的报文，其他结点失去仲裁，退出发送，转为接收状态。</p>
<p>标准格式 ID 与具有相同 ID 的远程帧或者扩展格式的数据帧在总线上竞争时，标准格式的 RTR 位为显性位的具有优先权，可继续发送。</p>
<h2 id="位时序"><a href="#位时序" class="headerlink" title="位时序"></a>位时序</h2><p>CAN 协议的通信方法位 NRZ(non-return to zero)方式。各个位的开头或结尾都没有附加同步信号。</p>
<ul>
<li>发送单元以与位时序同步的方式开始发送数据。</li>
<li>接收单元根据总线上电平的变化进行同步并进行接收工作。</li>
</ul>
<p>由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为 4 段。</p>
<ul>
<li>同步段（SS）</li>
<li>传播时间段（PTS）</li>
<li>相位缓冲段 1（PBS1）</li>
<li>相位缓冲段 2（PBS2）</li>
</ul>
<p>这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。</p>
<p>1 位分为 4 个段，每个段又由若干个 Tq 构成，这称为位时序。</p>
<p>1 位由多少个 Tq 构成、每个段又由多少个 Tq 构成等，可以任意设定位时序。通过设定位时序，多个单元可同时采样，也可任意设定采样点。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523155731.png" alt="image.png"></p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/23/20240523155741.png" alt="image.png"></p>
<p><em>采样点：是读取总线电平，并将读到的电平作为位值的点，位置在 PBS1 结束处。</em></p>
<h3 id="设置位时序和计算位速率"><a href="#设置位时序和计算位速率" class="headerlink" title="设置位时序和计算位速率"></a>设置位时序和计算位速率</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ip link set can0 type cantq <span class="number">125</span> prop-seg <span class="number">6</span> phase-seg1 <span class="number">7</span> phase-seg2 <span class="number">2</span> sjw <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同步段（Sync Segment）: 固定为 1 TQ，用于同步位定时器。</li>
<li>传播时间段（Propagation Segment, prop-seg）: 用于补偿信号在总线上传播的时间延迟</li>
<li>相位缓冲段 1（Phase Buffer Segment 1, phase-seg1）: 用于提高抗干扰能力，允许时间调整。</li>
<li>相位缓冲段 2（Phase Buffer Segment 2, phase-seg2）: 也用于提高抗干扰能力，允许时间调整。</li>
<li>ip link set can0 type can: 设置名为 can0 的网络接口的类型为 CAN。<br>  tq 125: 设置时间量化（Time Quantum，TQ）为 125 ns。TQ 是 CAN 控制器内部的基本时间单位，用于划分整个位时间。<br>  prop-seg 6: 设置传播时间段（Propagation Segment）为 6 TQ。传播时间段用于补偿信号在 CAN 总线上传播的延迟。为 6 个时间量化，6 * 125 ns &#x3D; 750 ns。<br>  phase-seg1 7: 设置相位缓冲段 1（Phase Buffer Segment 1）为 7 TQ。这个时间段用于调整边沿相位，通常包括采样点之前的时间。为 7 个时间量化，875 ns。<br>  phase-seg2 2: 设置相位缓冲段 2（Phase Buffer Segment 2）为 2 TQ。这个时间段用于调整边沿相位，通常包括采样点之后的时间。为 2 个时间量化，250 ns。<br>  sjw 1: 设置同步跳跃宽度（Synchronization Jump Width，SJW）为 1 TQ。SJW 用于重新同步时可以跳跃的最大时间量。为 1 个时间量化，1 * 125 ns &#x3D; 125 ns。</li>
</ul>
<ul>
<li>计算位时间和位速率<br>  总位时间是所有段的时间总和：<br>  Sync Segment: 1 TQ<br>  Propagation Segment: 6 TQ<br>  Phase Buffer Segment 1: 7 TQ<br>  Phase Buffer Segment 2: 2 TQ<br>  总时间量化数 &#x3D; 1 + 6 + 7 + 2 &#x3D; 16 TQ<br>  总位时间 &#x3D; 16 * 125 ns &#x3D; 2000 ns &#x3D; 2 μs<br>  位速率（Bit Rate） &#x3D; 1 &#x2F; 总位时间 &#x3D; 1 &#x2F; 2 μs &#x3D; 500 kbps</li>
</ul>
<h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><h4 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h4><p>接收单元在总线空闲状态检测出帧起始时进行的同步调整。</p>
<p>在检测出边沿的地方不考虑 SJW 的值而认为是 SS 段</p>
<h4 id="在同步"><a href="#在同步" class="headerlink" title="在同步"></a>在同步</h4><p>在接收过程中检测出总线上的电平变化时进行大的同步调整。</p>
<p>当检测出边沿时，根据 SJW 的值通过加长 PBS1 或缩短 PBS2（采样点位置在 PBS1 结束处），以调整同步，最大调整量不超过 SJW 的值。</p>
<ul>
<li>边沿出现在 PTS 和 PBS1 之间时，通过加长 PBS1</li>
<li>边沿出现在 PBS2 时，通过缩短 PBS2</li>
</ul>
<h2 id="位填充"><a href="#位填充" class="headerlink" title="位填充"></a>位填充</h2><p>位填充时为防止突发错误而设定的功能。在同样的电平持续 5 位时添加一个位的反型数据。</p>
<ul>
<li>发送单元<br>  发送数据帧和遥控帧时，SOF~CRC 段的数据，相同电平持续 5bits，下一位插入反型数据。</li>
<li>接收单元<br>  接收数据帧和遥控帧时，SOF~CRC 段的数据，相同电平持续 5bits，需要删除下一个位再接收。如果数据仍然和前 5bits 相同，则被视为错误并发送错误帧。</li>
</ul>
<h1 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h1><h2 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h2><p>为了更有效地控制通讯，CAN 一共规定了 5 种类型的帧</p>
<ul>
<li>数据帧：发送单元向接收单元传送数据的帧。</li>
<li>远程帧：接收单元向发送单元请求数据的帧。</li>
<li>错误帧：检测出错误时向其它单元通知错误的帧。</li>
<li>过载帧：接收单元通知其尚未就绪的帧。</li>
<li>间隔帧：将数据帧及遥控帧与前面的帧分离开来的帧。</li>
</ul>
<h2 id="CAN-帧定义"><a href="#CAN-帧定义" class="headerlink" title="CAN 帧定义"></a>CAN 帧定义</h2><p>数据帧由帧起始、仲裁段、控制段、数据段、CRC、ACK、帧结束共 7 个段构成。数据帧和遥控帧有<strong>标准帧和扩展帧</strong>两种帧，标准帧有 11 个位的标识符 ID，扩展帧有 29 个位的 ID。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520113845.png" alt="image.png"></p>
<ul>
<li>帧起始 (Start Of Frame,SOF)，1bit<br>  表示帧开始的段，设置为 0。</li>
<li>仲裁段（Identifier，ID），11bits&#x2F;29bits<br>  表示数据帧优先级的段<br>  标准帧与扩展帧的构成有所不同，均禁止高 7 位为隐性 (ID&#x3D;1111111XXXX…)<br>  仲裁段的内容主要为本数据帧的 ID，标准帧的 ID 有 11 个位，扩展帧的 ID 有 29 个位，在 CAN 协议中，ID 决定着数据帧发送的优先级，也决定着其它节点是否会接收这个数据帧。CAN 总线不对挂载在它之上的节点分配优先级和地址，对总线的占有权是由信息的 ID 决定的，即对于重要的信息，优先级高的 ID，能够优先发送出去</li>
<li>RTR 位 (Remote Transmission Request Bit)<br>  远程传输请求位，用于区分数据帧和遥控帧的，为 0 表示数据帧，1 表示遥控帧。</li>
<li>控制段<br>  控制段由 6 个位构成，表示数据段的字节数  </li>
<li>IDE 位 (Identifier Extension Bit)<br>  标识符扩展位，用于区分标准帧与扩展帧，为 0 表示标准帧，1 表示扩展帧</li>
<li>SRR 位 (Substitute Remote Request Bit)<br>  只存在于扩展帧，它用于替代标准帧中的 RTR 位，扩展帧中的 SRR 位固定为 1，RTR 在数据帧中为 0，所以两个 ID 相同的标准帧与扩展帧，标准帧的优先级较高 </li>
<li>DLC 数据长度码（Data Length Code）<br>  数据的字节数必须为 0～8 字节</li>
<li>数据段（Data Field）<br>  数据段可包含 0～8 个字节的数据</li>
<li>CRC 段<br>   CRC 段是检查帧传输错误的段，由 15 个位的 CRC 值和 1 个位的 CRC 界定符 (隐性分隔位) 构成<br>   CRC 是根据多项式生成的 CRC 值，CRC 的计算范围包括帧起始、仲裁段、控制段、数据段  </li>
<li>接收方以同样的方式计算 CRC 值并进行比较，不一致时利用错误帧请求重新发送</li>
<li>ACK 段<br>  ACK 段包括 ACK 槽位、ACK 界定符位 2 个位<br>  发送单元的 ACK 段：发送单元在 ACK 段发送 2 个位的隐性位<br>  接收单元的 ACK 段：接收到正确消息的单元在 ACK 槽发送显性位，通知发送单元正常接收结束，这称作“发送 ACK”或者“返回 ACK”</li>
<li>帧结束 (End Of Frame，EOF)<br>  帧结束是表示该帧结束的段，由发送节点发送 7 个位的隐性位构成<br>  CAN 数据帧的结束符长度并不是完全不定的，而是根据数据位速率（Data Bit Rate，DBR）而定。CAN 总线协议规定，对于数据位速率低于等于 125kbps 的网络，CAN 数据帧的结束符长度为 7 个位；对于数据位速率大于 125kbps 的网络，CAN 数据帧的结束符长度为 3 个位。这是因为在高速网络中，由于数据传输速率更快，所以 CAN 控制器可以更快地检测到结束位，因此可以减少结束符的长度，从而提高网络的传输效率。而在低速网络中，由于数据传输速率较慢，所以 CAN 控制器需要更长的时间来检测结束位，因此需要一个更长的结束符来确保数据帧传输的正确性和完整性。因此，CAN 数据帧的结束符长度是根据数据位速率而定的，并不是完全不定的。</li>
</ul>
<h3 id="Socket-CAN-帧结构体"><a href="#Socket-CAN-帧结构体" class="headerlink" title="Socket CAN 帧结构体"></a>Socket CAN 帧结构体</h3><ul>
<li>帧头，<code>canid_t</code> 定义了一个无符号的 32 位整形数，按位确定功能<br>   0-28 位为标识符，如果是扩展帧，则高 11 位为标准 ID<br>   29 位标识是数据帧还是错误消息<br>   30 位说明是否是远程帧<br>   31 位说明是标准帧还是扩展帧。</li>
<li>帧长，8 位无符号表示数据区长度</li>
<li>数据区，定义 <code>CAN_MAX_DLEN</code> 个 8 位无符号数，按照数组的形式申请</li>
</ul>
<p>*<code>__attribute__((aligned(8)))</code> 告诉编译器，将变量 <code>data</code> 放在一个地址是 8 的倍数的内存位置上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CAN payload length and DLC definitions according to ISO 11898-1 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_MAX_DLC 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_MAX_DLEN 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> &#123;</span><br><span class="line"> <span class="type">canid_t</span> can_id; <span class="comment">/* 32 bit CAN_ID + EFF/RTR/ERR flags */</span></span><br><span class="line"> __u8 can_dlc; <span class="comment">/* frame payload length in byte */</span></span><br><span class="line"> __u8 data[CAN_MAX_DLEN] __attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Controller Area Network Identifier structure</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* bit 0-28 : CAN identifier (11/29 bit)</span></span><br><span class="line"><span class="comment">* bit 29 : error message frame flag (0 = data frame, 1 = error message)</span></span><br><span class="line"><span class="comment">* bit 30 : remote transmission request flag (1 = rtr frame)</span></span><br><span class="line"><span class="comment">* bit 31 : frame format flag (0 = standard 11 bit, 1 = extended 29 bit)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> __u32 <span class="type">canid_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> __u8;</span><br></pre></td></tr></table></figure>

<p>帧类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* special address description flags for the CAN_ID */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_EFF_FLAG	0x80000000U		<span class="comment">/* EFF/SFF is set in the MSB */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_RTR_FLAG	0x40000000U		<span class="comment">/* 远程帧 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_ERR_FLAG	0x20000000U		<span class="comment">/* error frame */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* valid bits in CAN ID for frame formats */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_SFF_MASK	0x000007FFU		<span class="comment">/* 标准帧 (SFF) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_EFF_MASK	0x1FFFFFFFU		<span class="comment">/* 扩展帧 (EFF) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_ERR_MASK	0x1FFFFFFFU		<span class="comment">/* omit EFF, RTR, ERR flags */</span></span></span><br></pre></td></tr></table></figure>

<p>实际对 can_frame 发送的处理是在 mcp251x_hw_tx 中进行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mcp251x_hw_tx</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> can_frame *frame, <span class="type">int</span> tx_buf_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mcp251x_priv</span> *priv = <span class="built_in">spi_get_drvdata</span>(spi);</span><br><span class="line">	u32 sid, eid, exide, rtr;</span><br><span class="line">	u8 buf[SPI_TRANSFER_BUF_LEN];</span><br><span class="line">	<span class="comment">//取can_id的31位，判断是标准帧还是扩展帧</span></span><br><span class="line">	exide = (frame-&gt;can_id &amp; CAN_EFF_FLAG) ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span> (exide)<span class="comment">//如果是扩展帧，can_id的0-28位为ID，其中高11位为标准ID</span></span><br><span class="line">		sid = (frame-&gt;can_id &amp; CAN_EFF_MASK) &gt;&gt; <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sid = frame-&gt;can_id &amp; CAN_SFF_MASK; <span class="comment">/* Standard ID */</span></span><br><span class="line">	eid = frame-&gt;can_id &amp; CAN_EFF_MASK; <span class="comment">/* Extended ID */</span></span><br><span class="line">	rtr = (frame-&gt;can_id &amp; CAN_RTR_FLAG) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">/* 是否是远程帧*/</span></span><br><span class="line">	buf[TXBCTRL_OFF] = <span class="built_in">INSTRUCTION_LOAD_TXB</span>(tx_buf_idx); <span class="comment">//发送缓冲器控制寄存器地址</span></span><br><span class="line">	buf[TXBSIDH_OFF] = sid &gt;&gt; SIDH_SHIFT; <span class="comment">//发送缓冲器标准ID高8位</span></span><br><span class="line">	<span class="comment">//5-7位存放发送缓冲器低3位,3位存放帧格式，0-1位存放扩展标识符低18位的高两位（16-17）</span></span><br><span class="line">	buf[TXBSIDL_OFF] = ((sid &amp; SIDL_SID_MASK) &lt;&lt; SIDL_SID_SHIFT) | (exide &lt;&lt; SIDL_EXIDE_SHIFT) | ((eid &gt;&gt; SIDL_EID_SHIFT) &amp; SIDL_EID_MASK);</span><br><span class="line">	buf[TXBEID8_OFF] = <span class="built_in">GET_BYTE</span>(eid, <span class="number">1</span>); <span class="comment">//存放扩展标识符低18位的8-15位</span></span><br><span class="line">	buf[TXBEID0_OFF] = <span class="built_in">GET_BYTE</span>(eid, <span class="number">0</span>); <span class="comment">//扩展标识符低18位的低8位（0-7）</span></span><br><span class="line">	buf[TXBDLC_OFF] = (rtr &lt;&lt; DLC_RTR_SHIFT) | frame-&gt;can_dlc; <span class="comment">//6位存放远程帧标识符，0-3存放数据长度码</span></span><br><span class="line">	<span class="built_in">memcpy</span>(buf + TXBDAT_OFF, frame-&gt;data, frame-&gt;can_dlc);<span class="comment">//拷贝要发送的数据</span></span><br><span class="line">	<span class="built_in">mcp251x_hw_tx_frame</span>(spi, buf, frame-&gt;can_dlc, tx_buf_idx);</span><br><span class="line">	<span class="comment">/* use INSTRUCTION_RTS, to avoid &quot;repeated frame problem&quot; */</span></span><br><span class="line">	priv-&gt;spi_tx_buf[<span class="number">0</span>] = <span class="built_in">INSTRUCTION_RTS</span>(<span class="number">1</span> &lt;&lt; tx_buf_idx);</span><br><span class="line">	<span class="built_in">mcp251x_spi_trans</span>(priv-&gt;spi, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="帧长度"><a href="#帧长度" class="headerlink" title="帧长度"></a>帧长度</h1><p>位填充 3bits</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520113845.png" alt="image.png"></p>
<h2 id="Classic-CAN-Standard-Frame"><a href="#Classic-CAN-Standard-Frame" class="headerlink" title="Classic CAN Standard Frame"></a>Classic CAN Standard Frame</h2><p>标准帧（不考虑位填充）共：108Bit</p>
<p>帧起始（1bit）、仲裁段（12bit）、控制段（6bit）、数据段（8×8bit）、循环冗余码段（16bit）、应答段（2bit）和帧结束（7bit）</p>
<h2 id="Classic-CAN-Extended-Frame"><a href="#Classic-CAN-Extended-Frame" class="headerlink" title="Classic CAN Extended Frame"></a>Classic CAN Extended Frame</h2><p>扩展帧（不考虑位填充）共：128Bit</p>
<p>帧起始（1bit）、仲裁段（32bit）、控制段（6bit）、数据段（8×8bit）、循环冗余码段（16bit）、应答段（2bit）和帧结束（7bit）</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520123827.png" alt="image.png"></p>
<h2 id="CANFD-Standard-Frame"><a href="#CANFD-Standard-Frame" class="headerlink" title="CANFD Standard Frame"></a>CANFD Standard Frame</h2><p>标准帧（不考虑位填充；DLC &#x3D; 8）共：117Bit</p>
<p>帧起始（1bit）、仲裁段（12bit）、控制段（9bit）、数据段（8×8bit）、循环冗余码段（22bit）、应答段（2bit）和帧结束（7bit）</p>
<h2 id="CANFD-Standard-Frame-1"><a href="#CANFD-Standard-Frame-1" class="headerlink" title="CANFD Standard Frame"></a>CANFD Standard Frame</h2><p>标准帧（不考虑位填充；DLC &#x3D; 64）共：569Bit</p>
<p>帧起始（1bit）、仲裁段（12bit）、控制段（9bit）、数据段（64×8bit）、循环冗余码段（26bit）、应答段（2bit）和帧结束（7bit）</p>
<h2 id="CANFD-CAN-Extended-Frame"><a href="#CANFD-CAN-Extended-Frame" class="headerlink" title="CANFD CAN Extended Frame"></a>CANFD CAN Extended Frame</h2><p>扩展帧（不考虑位填充；DLC &#x3D; 8）共：136Bit</p>
<p>帧起始（1bit）、仲裁段（32bit）、控制段（8bit）、数据段（8×8bit）、循环冗余码段（22bit）、应答段（2bit）和帧结束（7bit）</p>
<h2 id="CANFD-CAN-Extended-Frame-1"><a href="#CANFD-CAN-Extended-Frame-1" class="headerlink" title="CANFD CAN Extended Frame"></a>CANFD CAN Extended Frame</h2><p>扩展帧（不考虑位填充；DLC &#x3D; 64）共：588Bit</p>
<p>帧起始（1bit）、仲裁段（32bit）、控制段（8bit）、数据段（64×8bit）、循环冗余码段（26bit）、应答段（2bit）和帧结束（7bit）</p>
<h1 id="SocketCAN-实例"><a href="#SocketCAN-实例" class="headerlink" title="SocketCAN 实例"></a>SocketCAN 实例</h1><h2 id="CAN-功能分析"><a href="#CAN-功能分析" class="headerlink" title="CAN 功能分析"></a>CAN 功能分析</h2><p>一个标准的 CAN 功能包括：</p>
<ul>
<li>CAN 接口号指定 CAN 接口号 <code>can0</code></li>
<li>指定 CAN 通讯波特率或 TQ，单位 Kbps，默认为 500 Kbps</li>
<li>指定 CAN 发送帧 ID</li>
<li>指定 CAN 发送帧数据</li>
</ul>
<ul>
<li>需要包含数据的大小端模式转换</li>
</ul>
<ul>
<li>指定 CAN 帧发送间隔，单位 ms， 默认为 250ms, 最小值为 1ms  </li>
<li>指定 CAN 帧发送次数</li>
<li>指定 CAN 发送帧为标准帧&#x2F;扩展帧  </li>
<li>发送数据时错误判断，本地环回功能<br>基于 LINUX SOCKET 机制实现的 CAN 接口，其基本的流程如下所示：</li>
<li>设置套接字 <code>socket</code></li>
<li>指定 CAN 设备 <code>ioctl</code></li>
<li>绑定套接字与设备 <code>bind</code></li>
<li>设置过滤规则 <code>setsockopt</code></li>
<li>发送&#x2F;接受报文 <code>read/write</code></li>
<li>关闭套接字 <code>close</code></li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can/raw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_can</span> addr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ifreq</span> ifr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">can_frame</span> frames[<span class="number">10</span>]; <span class="comment">// 一次最多读取10个CAN数据包</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msghdr</span> msg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov;</span><br><span class="line">    <span class="type">char</span> ctrlmsg[<span class="built_in">CMSG_SPACE</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> timeval) + <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> timespec) + <span class="built_in">sizeof</span>(__u32))];</span><br><span class="line">    <span class="type">int</span> nbytes;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span>);</span><br><span class="line">    <span class="built_in">ioctl</span>(sock, SIOCGIFINDEX, &amp;amp;ifr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.can_family = AF_CAN;</span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;amp;iov, <span class="number">0</span>, <span class="built_in">sizeof</span>(iov));</span><br><span class="line">    iov.iov_base = frames;</span><br><span class="line">    iov.iov_len = <span class="built_in">sizeof</span>(frames);</span><br><span class="line">    msg.msg_name = &amp;amp;addr;</span><br><span class="line">    msg.msg_namelen = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    msg.msg_iov = &amp;amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    msg.msg_control = &amp;amp;ctrlmsg;</span><br><span class="line">    msg.msg_controllen = <span class="built_in">sizeof</span>(ctrlmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        nbytes = <span class="built_in">recvmsg</span>(sock, &amp;amp;msg, MSG_DONTWAIT);</span><br><span class="line">        <span class="keyword">if</span> (nbytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> num_frames = nbytes / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> can_frame);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received %d CAN frames:\n&quot;</span>, num_frames);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_frames; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;  ID: 0x%X, DLC: %d, Data: &quot;</span>, frames[i].can_id, frames[i].can_dlc);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; frames[i].can_dlc; j++) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, frames[i].data[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>SocketCAN 中大部分的数据结构和函数在头文件 linux&#x2F;can.h 中进行了定义。 CAN 总线套接字的创建采用标准的网络套接字操作来完成。网络套接字在头文件 sys&#x2F;socket.h 中定义。 套接字的初始化方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_can</span> addr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ifreq</span> ifr;</span><br><span class="line">s = <span class="built_in">socket</span>(PF_CAN, SOCK_RAW, CAN_RAW);<span class="comment">//创建SocketCAN 套接字</span></span><br><span class="line"><span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span>);</span><br><span class="line"><span class="built_in">ioctl</span>(s, SIOCGIFINDEX, &amp;ifr);<span class="comment">//指定 can0 设备</span></span><br><span class="line">addr.can_family = AF_CAN;</span><br><span class="line">addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line"><span class="built_in">bind</span>(s, (structsockaddr *)&amp;addr,<span class="built_in">sizeof</span>(addr)); <span class="comment">//将套接字与 can0 绑定</span></span><br></pre></td></tr></table></figure>

<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can/raw.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can/error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sockios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_INTERFACE <span class="string">&quot;can0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITRATE 500000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBITRATE 4000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_bitrate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ifname, <span class="type">int</span> bitrate, <span class="type">int</span> dbitrate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ifreq</span> ifr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">can_bittiming</span> bt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">can_bittiming</span> dbt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open socket</span></span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specify the interface name</span></span><br><span class="line">    <span class="built_in">strncpy</span>(ifr.ifr_name, ifname, IFNAMSIZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bring the interface down</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(s, SIOCGIFFLAGS, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;SIOCGIFFLAGS&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ifr.ifr_flags &amp;= ~IFF_UP;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(s, SIOCSIFFLAGS, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;SIOCSIFFLAGS&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bitrate for classical CAN</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bt, <span class="number">0</span>, <span class="built_in">sizeof</span>(bt));</span><br><span class="line">    bt.bitrate = bitrate;</span><br><span class="line">    ifr.ifr_data = (<span class="type">void</span> *)&amp;bt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(s, SIOCSCANBT, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;SIOCSCANBT&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set data bitrate for CAN FD</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dbt, <span class="number">0</span>, <span class="built_in">sizeof</span>(dbt));</span><br><span class="line">    dbt.bitrate = dbitrate;</span><br><span class="line">    ifr.ifr_data = (<span class="type">void</span> *)&amp;dbt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(s, SIOCSCANDBT, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;SIOCSCANDBT&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bring the interface up</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(s, SIOCGIFFLAGS, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;SIOCGIFFLAGS&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ifr.ifr_flags |= IFF_UP;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(s, SIOCSIFFLAGS, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;SIOCSIFFLAGS&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket</span></span><br><span class="line">    <span class="built_in">close</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ifname = CAN_INTERFACE;</span><br><span class="line">    <span class="type">int</span> bitrate = BITRATE;</span><br><span class="line">    <span class="type">int</span> dbitrate = DBITRATE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set_bitrate</span>(ifname, bitrate, dbitrate) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to set CAN interface settings\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CAN interface %s configured with bitrate %d and dbitrate %d\n&quot;</span>, ifname, bitrate, dbitrate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参数查看"><a href="#参数查看" class="headerlink" title="参数查看"></a>参数查看</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ip -details -statistics link show can0 </span><br><span class="line">canconfig can0</span><br></pre></td></tr></table></figure>

<h2 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h2><p>在数据收发的内容方面， CAN 总线与标准套接字通信稍有不同，每一次通信都采用 can_ frame 结构体将数据封装成帧。 结构体定义如 <a href="#Socket%20CAN%20%E5%B8%A7%E7%BB%93%E6%9E%84%E4%BD%93">Socket CAN 帧结构体</a></p>
<p>数据发送使用 write 函数来实现。 如果发送的数据帧 (标识符为 0x123) 包含单个字节 (0xAB) 的数据，可采用如下方法进行发送：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_can</span> addr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> frame;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ifreq</span> ifr;</span><br><span class="line"><span class="comment">//如果为扩展帧，那么frame.can_id = CAN_EFF_FLAG | 0x123;</span></span><br><span class="line">frame.can_id = <span class="number">0x123</span>;</span><br><span class="line"></span><br><span class="line">frame.can_dlc = <span class="number">1</span>; <span class="comment">//数据长度为 1</span></span><br><span class="line">frame.data[<span class="number">0</span>] = <span class="number">0xAB</span>; <span class="comment">//数据内容为 0xAB</span></span><br><span class="line"><span class="type">int</span> nbytes = <span class="built_in">write</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame));<span class="comment">//发送数据</span></span><br><span class="line">nbytes = <span class="built_in">send</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame), <span class="number">0</span>);</span><br><span class="line">nbytes = <span class="built_in">sendto</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"><span class="comment">//sendmsg </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> msg;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> iov;</span><br><span class="line"><span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line">msg.msg_name = &amp;addr;</span><br><span class="line">msg.msg_namelen = <span class="built_in">sizeof</span>(addr);</span><br><span class="line"></span><br><span class="line">iov.iov_base = &amp;frame;</span><br><span class="line">iov.iov_len = <span class="built_in">sizeof</span>(frame);</span><br><span class="line">msg.msg_iov = &amp;iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">nbytes = <span class="built_in">sendmsg</span>(s, &amp;msg, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>如果要发送远程帧 (标识符为 0x123)，可采用如下方法进行发送：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> frame;</span><br><span class="line">frame.can_id = CAN_RTR_FLAG | <span class="number">0x123</span>;</span><br><span class="line"><span class="built_in">write</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame));</span><br></pre></td></tr></table></figure>

<h2 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h2><p>数据接收使用 read 函数来完成，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> frame;</span><br><span class="line"><span class="type">int</span> nbytes = <span class="built_in">read</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame));</span><br><span class="line">nbytes = <span class="built_in">recv</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame), <span class="comment">/*0*/</span>MSG_DONTWAIT);</span><br><span class="line">nbytes = <span class="built_in">recvfrom</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> msg;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> iov;</span><br><span class="line"><span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line"><span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="built_in">sizeof</span>(iov));</span><br><span class="line"></span><br><span class="line">iov.iov_base = &amp;frame;</span><br><span class="line">iov.iov_len = <span class="built_in">sizeof</span>(frame);</span><br><span class="line">msg.msg_iov = &amp;iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">nbytes = <span class="built_in">recvmsg</span>(s, &amp;msg, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当帧接收后，可以通过判断 can_id 中的 <code>CAN_ERR_FLAG</code> 位来判断接收的帧是否为错误帧。 如果为错误帧，可以通过 can_id 的其他符号位来判断错误的具体原因。</p>
<p>错误帧的符号位在头文件 <code>linux/can/error.h</code> 中定义。</p>
<p>例如以下代码用于设置 CAN 接口的错误过滤器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">can_err_mask_t</span> err_mask;</span><br><span class="line">err_mask = CAN_ERR_ACK | CAN_ERR_CRTL | CAN_ERR_BUSOFF | CAN_ERR_BUSERROR;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">setsockopt</span>(interface-&gt;fd, SOL_CAN_RAW, CAN_RAW_ERR_FILTER, &amp;err_mask, <span class="built_in">sizeof</span>(err_mask));</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">log_printf</span>(LOG_ERR, CAN_ERROR_FILTER_FAILED, interface-&gt;ifName);</span><br><span class="line">	<span class="built_in">log_printf</span>(LOG_DEBUG, DBG_ERRNO, <span class="string">&quot;setsockopt(can err)&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> CO_ERROR_SYSCALL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CAN_ERR_ACK</code>, <code>CAN_ERR_CRTL</code>, <code>CAN_ERR_BUSOFF</code>, <code>CAN_ERR_BUSERROR</code> 是 <code>CAN</code> 错误的不同类型。这些标志位分别表示收到错误应答、控制器错误、总线关闭、总线错误。</p>
<ul>
<li><code>SOL_CAN_RAW</code> 表示操作的是原始 CAN 套接字。</li>
<li><code>CAN_RAW_ERR_FILTER</code> 是设置原始 CAN 套接字的错误过滤器选项。</li>
</ul>
<h2 id="过滤规则设置"><a href="#过滤规则设置" class="headerlink" title="过滤规则设置"></a>过滤规则设置</h2><p>在数据接收时，系统可以根据预先设置的过滤规则，实现对报文的过滤。过滤规则使用 can_filter 结构体来实现，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_filter</span> &#123;</span><br><span class="line">	<span class="type">canid_t</span> can_id;</span><br><span class="line">	<span class="type">canid_t</span> can_mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>过滤器工作原理：CAN 过滤器使用按位与（&amp;）操作来决定是否接收一个帧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((received_can_id &amp; filter.mask) == (filter.can_id &amp; filter.mask))</span><br><span class="line">    <span class="comment">// 接收此帧</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 丢弃此帧</span></span><br></pre></td></tr></table></figure>

<p>通过这条规则可以在系统中过滤掉所有不符合规则的报文，使得应用程序不需要对无关的报文进行处理。在 <code>can_filter</code> 结构的 <code>can_id</code> 中，符号位 <code>CAN_INV_FILTER</code> 在置位时可以实现 <code>can_id</code> 在执行过滤前的位反转。</p>
<p>用户可以为每个打开的套接字设置多条独立的过滤规则，使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">structcan_filter rfilter[<span class="number">2</span>];</span><br><span class="line">rfilter[<span class="number">0</span>].can_id = <span class="number">0x123</span>;</span><br><span class="line">rfilter[<span class="number">0</span>].can_mask = CAN_SFF_MASK;</span><br><span class="line"><span class="comment">//#define CAN_SFF_MASK 0x000007FFU</span></span><br><span class="line">rfilter[<span class="number">1</span>].can_id = <span class="number">0x200</span>;</span><br><span class="line">rfilter[<span class="number">1</span>].can_mask = <span class="number">0x700</span>;</span><br><span class="line"><span class="comment">//设置规则</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_FILTER,&amp;rfilter, <span class="built_in">sizeof</span>(rfilter));</span><br></pre></td></tr></table></figure>

<p>第一个过滤器 (rfilter):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">can_id: <span class="number">0x123</span></span><br><span class="line">mask: <span class="number">0x7FF</span> (CAN_SFF_MASK)</span><br><span class="line">这个过滤器将只接收 ID 为 <span class="number">0x123</span> 的标准帧。因为掩码是 <span class="number">0x7FF</span>，所以 ID 必须完全匹配。</span><br></pre></td></tr></table></figure>

<p>第二个过滤器 (rfilter):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">can_id: <span class="number">0x200</span></span><br><span class="line">mask: <span class="number">0x700</span></span><br></pre></td></tr></table></figure>

<p>这个过滤器将接收 ID 范围从 0x200 到 0x2FF 的帧。因为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0x200</span> &amp; <span class="number">0x700</span> = <span class="number">0x200</span></span><br></pre></td></tr></table></figure>

<p>任何 0x2XX 的 ID 与 0x700 进行按位与操作后都等于 0x200</p>
<p>过滤规则禁用。原始套接字就会忽略所有接收到的报文。在仅需要发送数据的应用中，可以在内核中省略接收队列，以此减少 CPU 资源的消耗。禁用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//禁用过滤规则</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_FILTER, <span class="literal">NULL</span>, <span class="number">0</span>); </span><br></pre></td></tr></table></figure>

<p>通过错误掩码可以实现对错误帧的过滤， 例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">can_err_mask_t</span> err_mask = (CAN_ERR_TX_TIMEOUT | CAN_ERR_BUSOFF );</span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW,CAN_RAW_ERR_FILTER,err_mask,<span class="built_in">sizeof</span>(err_mask));</span><br></pre></td></tr></table></figure>

<h2 id="缓冲区大小设置"><a href="#缓冲区大小设置" class="headerlink" title="缓冲区大小设置"></a>缓冲区大小设置</h2><p>以下代码用于设置缓冲区大小为 512KB，并查询设置之后的缓冲区大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//todo - modify rx buffer size? first one needs root</span></span><br><span class="line">bytes = <span class="number">512</span>*<span class="number">1024</span>;</span><br><span class="line">sLen = <span class="built_in">sizeof</span>(bytes);</span><br><span class="line">ret = <span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_RCVBUFFORCE, (<span class="type">void</span> *)&amp;bytes, sLen);</span><br><span class="line">ret = <span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span> *)&amp;bytes, sLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* print socket rx buffer size in bytes (In my experience, the kernel reserves</span></span><br><span class="line"><span class="comment"> * around 450 bytes for each CAN message) */</span></span><br><span class="line">sLen = <span class="built_in">sizeof</span>(bytes);</span><br><span class="line"><span class="built_in">getsockopt</span>(interface-&gt;fd, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span> *)&amp;bytes, &amp;sLen);</span><br><span class="line"><span class="keyword">if</span> (sLen == <span class="built_in">sizeof</span>(bytes)) &#123;</span><br><span class="line">    <span class="built_in">log_printf</span>(LOG_INFO, CAN_SOCKET_BUF_SIZE, interface-&gt;ifName,</span><br><span class="line">               bytes / <span class="number">446</span>, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>root 用户使用 SO_RCVBUFFORCE 设置缓冲区大小。</li>
<li>普通用户使用 SO_RCVBUF 设置缓冲区大小</li>
</ul>
<h2 id="回环功能设置"><a href="#回环功能设置" class="headerlink" title="回环功能设置"></a>回环功能设置</h2><p>在默认情况下， 本地回环功能是开启的，可以使用下面的方法关闭回环&#x2F;开启功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> loopback = <span class="number">0</span>; <span class="comment">// 0 表示关闭, 1 表示开启( 默认)</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_LOOPBACK,&amp;loopback, <span class="built_in">sizeof</span>(loopback));</span><br></pre></td></tr></table></figure>

<p>在本地回环功能开启的情况下，所有的发送帧都会被回环到与 CAN 总线接口对应的套接字上。 默认情况下，发送 CAN 报文的套接字不想接收自己发送的报文，因此发送套接字上的回环功能是关闭的。</p>
<p>可以在需要的时候改变这一默认行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ro = <span class="number">1</span>; <span class="comment">// 0 表示关闭( 默认), 1 表示开启</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &amp;ro, <span class="built_in">sizeof</span>(ro));</span><br></pre></td></tr></table></figure>

<h2 id="套接字状态"><a href="#套接字状态" class="headerlink" title="套接字状态"></a>套接字状态</h2><p>利用 ioctl() 检查套接字状态</p>
<p>使用 ioctl() 函数结合 FIONREAD 命令可以查询当前套接字接收缓冲区中等待读取的字节数。如果返回的字节数大于 0，则表示有数据可供接收。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> bytes_available;</span><br><span class="line"><span class="built_in">ioctl</span>(sock, FIONREAD, &amp;bytes_available);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytes_available &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;套接字中有 %d 字节的CAN数据可接收\n&quot;</span>, bytes_available);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以读取数据</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;套接字中没有可接收的CAN数据\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ioctl() 函数和 SIOCSIFFLAGS</p>
<ul>
<li>ioctl() 函数：这是一个系统调用函数，用于在用户空间程序中向内核发出特定的控制命令，以实现对设备、接口等的配置和管理。</li>
<li>SIOCSIFFLAGS：这是 ioctl() 函数使用的一个常量，用于设置网络接口的标志。通过 ioctl() 和 SIOCSIFFLAGS，可以启用或禁用一个网络接口，设置接口的工作模式和其他标志位。</li>
</ul>
<h1 id="CAN-通讯设计"><a href="#CAN-通讯设计" class="headerlink" title="CAN 通讯设计"></a>CAN 通讯设计</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>ARM 需要有 CAN 控制器和 CAN 收发器</p>
<ul>
<li>CAN 控制器（CAN Controller）是负责实现 CAN 协议的逻辑部分的组件</li>
<li>CAN 收发器（CAN Transceiver）是负责 CAN 总线电平信号和 CAN 控制器之间的电信号转换的组件</li>
</ul>
<p><strong>CAN 控制器</strong>示例：</p>
<ul>
<li>内置于微控制器中的 CAN 模块（例如 STM32 系列微控制器的内置 CAN 控制器）。</li>
<li>独立的 CAN 控制器芯片（例如 MCP2515）。</li>
</ul>
<p><strong>CAN 收发器</strong>示例：</p>
<ul>
<li>常见的独立 CAN 收发器芯片（例如 MCP2551、TJA1050 等）。</li>
</ul>
<p>先选择 CAN 控制器芯片，一般的 PC 和 ARM 都没有 CAN 控制器，一般是 MCP2515 和 SJA1000，主要区别是 MCP2515 是 SPI 接口，SJA1000 是 I&#x2F;O 接口。所以 MCP2515 占用资源少，5-6 个管脚就可以控制，SJA1000 占用的管脚就多。</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>Linux 中有对 CAN（Controller Area Network）总线的支持，主要通过 SocketCAN 子系统实现。内核编译时选择响应的支持芯片。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ make linux-menuconfig</span><br><span class="line">Networking support ---&gt;</span><br><span class="line">	CAN bus subsystem support ---&gt;</span><br><span class="line">	--- <span class="function">CAN bus subsystem support</span></span><br><span class="line"><span class="function">		Raw CAN <span class="title">Protocol</span> <span class="params">(raw access with CAN-ID filtering)</span></span></span><br><span class="line"><span class="function">		Broadcast Manager CAN <span class="title">Protocol</span> <span class="params">(with content filtering)</span></span></span><br><span class="line"><span class="function">		CAN Device Drivers ---&gt;</span></span><br><span class="line"><span class="function">			Virtual Local CAN <span class="title">Interface</span> <span class="params">(vcan)</span></span></span><br><span class="line"><span class="function">			Platform CAN drivers with Netlink support</span></span><br><span class="line"><span class="function">			[*] CAN bit-timing calculation</span></span><br><span class="line"><span class="function">			Microchip 251x series SPI CAN Controller</span></span><br></pre></td></tr></table></figure>

<p>SocketCAN 支持多种 CAN 控制器硬件，通过不同的内核驱动程序实现对具体硬件的支持。例如，以下是一些常见的 CAN 控制器驱动程序：</p>
<ul>
<li><code>sja1000</code>：Philips&#x2F;NXP SJA1000 CAN 控制器</li>
<li><code>mcp251x</code>：Microchip MCP251x SPI CAN 控制器系列（如 MCP2515）</li>
<li><code>flexcan</code>：Freescale&#x2F;NXP FlexCAN 模块</li>
</ul>
<p>这些驱动程序通常位于内核源代码树的 <code>drivers/net/can</code> 目录下。</p>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p>需要支持 CAN 控制器驱动，控制 CAN 控制器发送 CAN 帧。对于一般的 CAN 控制器，进行初始化时，最关键的是以下两步：</p>
<ol>
<li>配置 CAN 的位时序；</li>
<li>配置 CAN 的消息报文；</li>
</ol>
<h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><h3 id="CAN-数据发送跟踪"><a href="#CAN-数据发送跟踪" class="headerlink" title="CAN 数据发送跟踪"></a>CAN 数据发送跟踪</h3><p>当我们在用户层通过 socket 进行 CAN 数据的发送时，需要进行以下操作：</p>
<ol>
<li>创建一个套接字 <code>socket</code>，采用 <code>AF_CAN</code> 协议。</li>
<li>将创建的套接字返回描述符 <code>sockfd</code>，绑定到本地的地址。</li>
<li>通过 <code>sendto</code> 系统调用函数进行发送，<code>sendto</code> 的系统调用会发送一帧数据报到指定的地址，在 CAN 协议调用之前把该地址移到内核空间和检查用户空间数据域是否可读。</li>
<li>在 <code>net/socket.c</code> 源文件中，在 <code>sendto</code> 的系统调用 <code>（sys_sendto）</code> 里，会调用到 <code>sock_sendmsg()</code> 函数，接下来调用 <code>__sock_sendmsg()</code> 函数。</li>
<li>再往下一步就是 <code>__sock_sendmsg_nosec</code> 函数。在 <code>__sock_sendmsg_nosec()</code> 函数中会返回一个 <code>sendmsg</code> 函数指针。</li>
<li>在 <code>/net/can/raw.c</code> 源文件中，将 <code>raw_sendmsg</code> 函数地址赋给 <code>sendmsg</code> 函数指针，即在函数 <code>__sock_sendmsg_nosec()</code> 中 <code>return sock-&gt;ops-&gt;sendmsg(iocb,sock, msg, size)</code>，返回的函数指针将指向 <code>raw_sendmsg()</code> 函数。</li>
<li>在 <code>net/can/af_can.c</code> 源文件中，<code>can_send</code> 函数负责 CAN 协议层的数据传输，即传输一帧 CAN 报文（可选本地回环）。参数 <code>skb</code> 指针指向套接字缓冲区和在数据段的 CAN 帧。loop 参数是在本地 CAN 套接字上为监听者提供回环。</li>
</ol>
<p>以下开始进行到 CAN 的底层驱动代码了，由于 CAN 驱动是编译进内核中，所以在系统启动时会注册 CAN 驱动。</p>
<ul>
<li>注册 CAN 驱动过程中会初始化 <code>d_can_netdev_ops</code> 结构体变量。</li>
<li>在这个过程中，<code>d_can_netdev_ops</code> 结构体变量定义了 3 个函数指针，其中 <code>(*ndo_start_xmit)</code> 函数指针指向 <code>d_can_start_xmit</code> 函数的入口地址。</li>
<li>在 <code>d_can_start_xmit()</code> 函数中，会调用 <code>d_can_write_msg_object()</code> 函数准备消息报文进行传输。</li>
</ul>
<h3 id="CAN-数据接收跟踪"><a href="#CAN-数据接收跟踪" class="headerlink" title="CAN 数据接收跟踪"></a>CAN 数据接收跟踪</h3><p>对于网络设备，数据接收大体上采用中断 +NAPI 机制进行数据的接收。同样，我们现在的 CAN 模块也是采用同样的方式进行数据的接收。由于我们只针对 CAN 总线接收数据这条主线进行分析。因些，会忽略一些针对 CAN 协议的设置及初始化等相关代码。</p>
<blockquote>
<p>NAPI（New API）是一种改进的网络数据接收机制，它通过减少中断处理的次数来提高性能。NAPI 的基本思想是延迟数据包的处理，使得多个数据包可以一次性地在中断处理程序中进行处理，从而减少了中断的数量，提高了系统的处理效率。</p>
</blockquote>
<p>中断 +NAPI 机制的工作原理大致如下：</p>
<ul>
<li>当网络数据包到达时，网络接口卡会生成一个中断通知操作系统。</li>
<li>中断服务程序会执行一些必要的处理，然后调用 NAPI 机制。</li>
<li>NAPI 机制会检查网络接口缓冲区中是否有足够的数据需要处理。</li>
<li>如果有足够的数据，NAPI 会立即开始处理这些数据，而不会再次触发中断。如果数据量不足，NAPI 会退出，并要求在将来的某个时候再次调用。</li>
<li>处理完数据后，系统可以选择性地决定是否重新启用中断服务程序。</li>
</ul>
<p>通过将数据包的处理延迟到一组数据包到达时再进行，中断 +NAPI 机制能够大大减少中断的数量，提高系统的处理效率，特别是在高负载情况下。</p>
<ul>
<li>在初始化 CAN 设备时，我们需要给 CAN 设备分配 NAPI 功能。我们通过 <code>netif_napi_add()</code> 函数将 CAN 设备添加到 NAPI 机制列表中。</li>
<li>将 CAN 设备添加到 NAPI 机制列表中后，在中断处理函数 <code>d_can_isr</code> 中，我们通过 <code>napi_schedule()</code> 函数调度已经在 NAPI 机制列表中的 <code>d_can_poll()</code> 函数。该函数会通过轮询的方式接收数据。而根据 NAPI 机制，当中断产生后，会调度轮询机制同时关闭所有的中断。</li>
<li>当中断产生时，会调用函数 <code>d_can_poll()</code>，该函数即采用轮询的方式进行数据的接收。由于 CAN 总线状态中断具有最高优先权，在接收数据之前，需要对 CAN 总线的状态进行判断。而对于 CAN 总线错误状态有三种：主动&#x2F;被动&#x2F;关闭。</li>
<li>当总线状态数据状态正常时，从 CAN 模块的接收寄存器中接收数据。</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>要在 linux 下面配置和测试 CAN，需要安装以下三个组件。</p>
<ul>
<li>iproute2 （配置 CAN 接口时需要）</li>
<li>libsocketcan（使用 CAN 必须）</li>
<li>CAN 的测试小工具 can-utils <a href="https://github.com/linux-can/can-utils">https://github.com/linux-can/can-utils</a></li>
</ul>
<p>可以直接通过命令行形式控制 CAN</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置CAN接口（假设设备名为`can0`）：</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 500000</span><br><span class="line"><span class="comment"># 启动CAN接口</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> up can0</span><br><span class="line"><span class="comment"># 查看CAN接口状态</span></span><br><span class="line">ip -details <span class="built_in">link</span> show can0</span><br><span class="line"><span class="comment"># CAN 2.0 linkup</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 100000</span><br><span class="line"><span class="comment"># CAN 2.0 FD linkup</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 500000 dbitrate 2000000 fd on</span><br><span class="line"><span class="comment"># 命令来配置 CAN 总线的位速率：</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> cantq 125 prop-seg 6 phase-seg1 7 phase-seg2 2 sjw 1</span><br><span class="line"><span class="comment"># 可以使用 ip 命令直接设定位速率500kbps：</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> can bitrate 500000</span><br><span class="line"><span class="comment"># 当设置完成后，可以通过下面的命令查询 can0 设备的参数设置：</span></span><br><span class="line">ip -details <span class="built_in">link</span> show can0</span><br><span class="line"><span class="comment"># 当设置完成后，可以使用下面的命令使能 can0 设备：</span></span><br><span class="line">ifconfig can0 up</span><br><span class="line"><span class="comment"># 使用下面的命令取消 can0 设备使能：</span></span><br><span class="line">ifconfig can0 down</span><br><span class="line"><span class="comment"># 在设备工作中，可以使用下面的命令来查询工作状态：</span></span><br><span class="line">ip -details -statistics <span class="built_in">link</span> show can0</span><br></pre></td></tr></table></figure>

<h1 id="负载计算"><a href="#负载计算" class="headerlink" title="负载计算"></a>负载计算</h1><p>在 CAN 总线上，发送一帧数据所需的时间可以通过帧的总位数和波特率来计算。</p>
<p>发送时间计算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">发送时间 = 总位数 / 波特率</span><br><span class="line">= <span class="number">111</span> 位 / <span class="number">500000</span> 位/秒</span><br><span class="line">= <span class="number">222</span> * <span class="number">10</span>^<span class="number">-6</span> 秒</span><br></pre></td></tr></table></figure>

<p>总线负载计算，是总线实际使用的带宽与总带宽的比值，通常表示为百分比。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">总线负载 = ((总帧时间秒×每秒发送的帧数)/总可用时间秒)×<span class="number">100</span>%</span><br><span class="line">总帧时间：一帧数据的发送时间</span><br><span class="line">每秒发送的帧数：一秒钟内发送的帧数</span><br><span class="line">总可用时间：每秒可用的时间，即 <span class="number">1</span> 秒</span><br></pre></td></tr></table></figure>

<p>假设每秒发送 1000 帧数据，则 1 秒内该总线上的负载为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">总帧时间：<span class="number">222</span> 微秒 = <span class="number">222</span> * <span class="number">10</span>^<span class="number">-6</span> 秒</span><br><span class="line">每秒发送的帧数：<span class="number">1000</span> 帧/秒</span><br><span class="line">总可用时间：<span class="number">1</span> 秒</span><br><span class="line">总线负载=((<span class="number">222</span>*<span class="number">10</span>^−<span class="number">6</span> * <span class="number">1000</span>) / <span class="number">1</span>)×<span class="number">100</span>%</span><br><span class="line">总线负载=<span class="number">22.2</span>%</span><br></pre></td></tr></table></figure>

<h1 id="Qt-中的-CAN-插件"><a href="#Qt-中的-CAN-插件" class="headerlink" title="Qt 中的 CAN 插件"></a>Qt 中的 CAN 插件</h1><p>需要编译安装 socketCAN 插件， <a href="https://doc.qt.io/qt-5/qtserialbus-socketcan-overview.html">https://doc.qt.io/qt-5/qtserialbus-socketcan-overview.html</a> ，关键字【Using SocketCAN Plugin】</p>
<p>pro 文件中添加 <code>QT += serialbus</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString errorString;</span><br><span class="line"><span class="type">const</span> QList&lt;QCanBusDeviceInfo&gt; devices = QCanBus::<span class="built_in">instance</span>()-&gt;<span class="built_in">availableDevices</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;socketcan&quot;</span>), &amp;errorString);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!errorString.<span class="built_in">isEmpty</span>())</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; errorString;</span><br></pre></td></tr></table></figure>

<h2 id="多线程下利用线程权限进行高速的-CAN-通信"><a href="#多线程下利用线程权限进行高速的-CAN-通信" class="headerlink" title="多线程下利用线程权限进行高速的 CAN 通信"></a>多线程下利用线程权限进行高速的 CAN 通信</h2><p>用 PC 里能达到的 CAN 通信（使用 USBCAN-II）速度是 1ms</p>
<ul>
<li>使用 3 个线程类：1 个用来接收，1 个用来发送，1 个用来解析</li>
<li>接收线程使用最高线程权限：<strong>QThread::HighestPriority</strong>，其余线程用 <strong>QThread::HighPriority</strong></li>
<li>如何循环发送报文：在发送线程里再多加一个定时器，timeout 时间为需要循环发送的时间（可达到 1ms）；</li>
<li>用户在主界面设置需要发送的报文为 OBJ 结构体数组，然后通过构造函数的方式传到发送线程，最后发送就行了。</li>
<li>解析过程：接收函数循环接收报文，每接收到 n 帧就发送到解析线程，然后根据 ID 解析，将解析数据发送主界面显示（不要 append）</li>
</ul>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><p>RK3568 在高速接收 CAN 帧消息时，出现 RCU 告警 <code>rcu INFO: rcu_sched self-detected stall on CPU</code>，CPU 占用跑满，该问题原因是错误帧中断过多导致的系统卡顿问题。</p>
<p>原因为 RK3568 默认的 CAN 驱动位 CANFD，调整设备树中的驱动为 CAN 后正常接收。</p>
<blockquote>
<p>《Rockchip RK3568&amp;RK3568B2&amp;RK3568J Application Notice-RKAN18055》中提到存在以下设计缺陷：<br>RK3568 作为发送方，扩展帧概率性变成标准帧，导致接收方存在丢帧情况，进而影响设备的正常通讯或者控制。产生原因是在发送扩展帧时候，内部寄存器状态值在特定组合条件下，触发 load 失败，从而最后按标准帧而非扩展帧的格式来发送 ID 和 DLC 段。<br>RK3568 作为 接收方 概率性出现 CRC 校验错误和 ID 段填充位错误 ，导致接收方会往总线发送错误帧，由发送方进行重发。</p>
</blockquote>
<h1 id="3568-原生-CAN-驱动使用自收方案"><a href="#3568-原生-CAN-驱动使用自收方案" class="headerlink" title="3568 原生 CAN 驱动使用自收方案"></a>3568 原生 CAN 驱动使用自收方案</h1><p>修改 kernel&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568.dtsi 文件，注释掉下图部分，取消 workround 帧的配置，修改后会自动打开 CAN 的 TXtoRX，原生 CAN 发送扩展帧数据时，会收回自己发出的数据做校验，若校验不是扩展帧将重新发送一帧。</p>
<p>注意：此方案在扩展出来的 ID 部分 ID 为 0 时，会触发无限重发机制，慎用。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/17274058680004x1gan.png" alt="gh"></p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CAN总线的网络拓扑结构</title>
    <url>/2024/09/24/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN%E6%80%BB%E7%BA%BF%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>线性拓扑结构通常指的是一种基于多点连接的拓扑结构，信号线为 CAN-高电平和 CAN-低电平，两端端接一个 120 欧姆终端电阻，该线路称为主干线，也称为总线。所有的设备连接到共同的传输介质上，总线上任意节点发送信息，其它节点都能收到，这种从主干线分出的短分支线（也称为 stub）。Stub length（分支线长度）是指从主干线到终端节点的短分支线的长度。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1727159921000xqgz8o.png" alt="gh"></p>
<blockquote>
<p>根据 CAN 规范和实际工程经验，stub length 的长度应尽量保持短，以减少信号反射和失真。过长的 stub 会导致信号的反射，增加网络中的噪声和误码率。ISO 11898 CAN 标准：建议 stub length 应保持在 0.3 米（30 厘米） 以下。不同的速度对分支线长度的要求可能不同：在 1 Mbps 的速率下，stub length 通常被建议小于 30 厘米。在较低速率下，允许的 stub length 可以稍长，但一般不超过 3 米。</p>
</blockquote>
<h1 id="星型结构"><a href="#星型结构" class="headerlink" title="星型结构"></a>星型结构</h1><p>在 CAN 网络中，多个节点通过各自的分支线连接到一个中心节点或集线器上，由中央节点向目的节点传送信息，中央节点执行集中式通信控制策略。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1727163711000nguy97.png" alt="gh"></p>
<h1 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h1><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1727163740000c15bkd.png" alt="gh"></p>
<h1 id="环型结构"><a href="#环型结构" class="headerlink" title="环型结构"></a>环型结构</h1><p>环形拓扑是将 CAN 总线首尾相接，形成环状，保证线缆的任意位置断开依然可以保证通讯。环形拓扑的终端电阻匹配采用分布式匹配方法，保证总体阻抗为 60 欧姆。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1727163443000etart4.png" alt="gh"></p>
<h1 id="CAN-网络"><a href="#CAN-网络" class="headerlink" title="CAN 网络"></a>CAN 网络</h1><p>在<strong>CAN 总线</strong>（Controller Area Network）系统中，<strong>CAN 网桥</strong>和<strong>CAN 网关</strong>是两种用于连接多个 CAN 网络的设备，网桥和网关都是为了扩展系统的功能和灵活性，但网桥更关注物理层面的连接和扩展，而网关则在网络层面管理和优化数据传输。</p>
<ul>
<li><strong>CAN 网桥</strong>：用于物理连接不同的 CAN 网络，简单地转发报文，适用于同协议的网络互连，能够解决波特率不同或物理距离受限的问题。</li>
<li><strong>CAN 网关</strong>：功能更强大，支持报文过滤、数据处理和协议转换，适用于连接不同协议的网络或需要智能数据管理的场景。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>CAN 网桥</th>
<th>CAN 网关</th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能</strong></td>
<td>转发 CAN 报文</td>
<td>转发、过滤、处理报文，协议转换</td>
</tr>
<tr>
<td><strong>网络连接</strong></td>
<td>连接同协议的 CAN 网络</td>
<td>连接不同协议或不同波特率的网络</td>
</tr>
<tr>
<td><strong>报文处理</strong></td>
<td>不修改报文，直接转发</td>
<td>可以修改、过滤或组合报文</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>连接多个 CAN 网络，延长物理距离</td>
<td>连接不同协议网络，过滤数据流</td>
</tr>
</tbody></table>
<h2 id="CAN-网桥（CAN-Bridge）"><a href="#CAN-网桥（CAN-Bridge）" class="headerlink" title="CAN 网桥（CAN Bridge）"></a>CAN 网桥（CAN Bridge）</h2><p><strong>CAN 网桥</strong>是一种用于连接<strong>两个或多个 CAN 网络</strong>的设备，使它们可以在相同或不同的波特率下进行通信。网桥的主要目的是物理上连接这些网络，<strong>透明地转发 CAN 报文</strong>，而不做协议转换或处理。</p>
<ul>
<li><strong>连接不同波特率的 CAN 网络</strong>：CAN 网桥允许将运行在不同波特率的 CAN 网络连接起来。例如，一个 CAN 网络可能运行在 1 Mbps，而另一个 CAN 网络可能运行在 500 kbps。CAN 网桥会在这些网络之间转发报文。</li>
<li><strong>透明传输</strong>：CAN 网桥通常不改变报文的内容，它只是将接收到的报文从一个 CAN 网络转发到另一个网络。</li>
<li><strong>延长 CAN 网络的物理距离</strong>：由于 CAN 总线的物理长度与波特率成反比，网桥可以通过将多个短的 CAN 网络连接在一起，<strong>间接增加网络的覆盖范围</strong>，而不会超出单个 CAN 网络的距离限制。</li>
</ul>
<h2 id="CAN-网关（CAN-Gateway）"><a href="#CAN-网关（CAN-Gateway）" class="headerlink" title="CAN 网关（CAN Gateway）"></a>CAN 网关（CAN Gateway）</h2><p><strong>CAN 网关</strong>是一种<strong>智能设备</strong>，不仅可以连接多个 CAN 网络，还能执行报文过滤、协议转换、数据处理等功能。相比 CAN 网桥，CAN 网关的功能更加灵活且复杂，它不仅仅是简单地转发数据，还能够根据设定的规则对数据进行转换或过滤。</p>
<ul>
<li><strong>协议转换</strong>：CAN 网关可以连接不同的网络协议，如将 CAN 报文转换为 LIN、FlexRay、Ethernet 等报文格式，并在不同网络之间进行数据交换。</li>
<li><strong>报文过滤和路由</strong>：网关可以根据预设的规则对报文进行<strong>过滤、路由</strong>，即只转发部分符合条件的报文，或修改报文内容后再转发。这可以有效地降低网络负载，并增加数据传输的安全性。</li>
<li><strong>数据处理</strong>：CAN 网关可以执行特定的应用逻辑，如根据收到的 CAN 消息执行某些操作，甚至可以将多条消息组合为一条消息再转发。</li>
<li><strong>网络隔离和保护</strong>：CAN 网关在连接不同网络时，可以隔离这些网络，防止故障或攻击在不同网络之间传播。</li>
</ul>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>RK3568内核CAN修改验证笔记</title>
    <url>/2024/07/09/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-RK3568%E5%86%85%E6%A0%B8CAN%E4%BF%AE%E6%94%B9%E9%AA%8C%E8%AF%81%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="修改方案说明"><a href="#修改方案说明" class="headerlink" title="修改方案说明"></a>修改方案说明</h1><ol>
<li>设备树中原节点配置为 CANFD，修改为 CAN</li>
<li>设备树中修改节点接收缓冲区，由原来的 6 改为 32</li>
<li>修改驱动中的中断处理机制，原来是进中断直接处理，修改为 NAPI 的方式进入中断进行轮询处理</li>
</ol>
<h1 id="CAN-控制器工作原理"><a href="#CAN-控制器工作原理" class="headerlink" title="CAN 控制器工作原理"></a>CAN 控制器工作原理</h1><p>Rockchip 的 CAN 控制器包含以下主要模块:</p>
<ul>
<li>接口管理逻辑：连接外部主控制器，解释命令，控制寄存器寻址。</li>
<li>CAN 核心模块：负责 CAN 帧的串并转换。</li>
<li>发送缓冲器：存储待发送的完整报文。</li>
<li>验收滤波器：过滤不需要接收的报文。</li>
<li>接收 FIFO：存储从 CAN 总线接收的报文。</li>
</ul>
<h1 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h1><p>输入 <code>ip -details link show can0</code> 查看节点信息</p>
<ul>
<li><p>CANFD 节点信息，节点中带有 <code>&lt;FD&gt;</code> 字样<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407120918780.png" alt="image.png"></p>
</li>
<li><p>CAN 节点信息<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407120918781.png" alt="image.png"></p>
</li>
</ul>
<h1 id="设备树配置"><a href="#设备树配置" class="headerlink" title="设备树配置"></a>设备树配置</h1><p>Rockchip 的 CAN 控制器在设备树中进行配置。定义了 CAN 控制器的兼容性、寄存器地址、中断、时钟、复位、引脚配置等信息。设备树地址</p>
<ul>
<li><code>kernel/arch/arm64/boot/dts/rockchip/OK3568-C-common.dtsi</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&amp;can0 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;rockchip,can-1.0&quot;</span>;</span><br><span class="line">	assigned-clocks = &lt;&amp;cru CLK_CAN0&gt;;</span><br><span class="line">	assigned-clock-rates = &lt;<span class="number">300000000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;can0m0_pins&gt;;</span><br><span class="line">	rx-fifo-depth = &lt;<span class="number">32</span>&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kernel/arch/arm64/boot/dts/rockchip/rk3568.dtsi</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">can0: can@fe570000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;rockchip,rk3568-can-2.0&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x0</span> <span class="number">0xfe570000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">1</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;cru CLK_CAN0&gt;, &lt;&amp;cru PCLK_CAN0&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;baudclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span>;</span><br><span class="line">	resets = &lt;&amp;cru SRST_CAN0&gt;, &lt;&amp;cru SRST_P_CAN0&gt;;</span><br><span class="line">	reset-names = <span class="string">&quot;can&quot;</span>, <span class="string">&quot;can-apb&quot;</span>;</span><br><span class="line">	tx-fifo-depth = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">	rx-fifo-depth = &lt;<span class="number">6</span>&gt;;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>compatible</code> 用来配置 CAN 控制器的驱动，默认启用的 CANFD</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rockchip,can-1.0用来匹配can控制器驱动</span></span><br><span class="line">compatible=<span class="string">&quot;rockchip,can-1.0&quot;</span></span><br><span class="line"><span class="comment"># rockchip,can-2.0用来匹配canfd控制器驱动。</span></span><br><span class="line">compatible=<span class="string">&quot;rockchip,can-2.0&quot;</span></span><br><span class="line">rockchip,can-1.0</span><br><span class="line">rockchip,canfd-1.0</span><br></pre></td></tr></table></figure>

<p><code>assigned-clock-rates</code> 用来配置 <code>can</code> 的时钟频率，如果 CAN 的比特率低于 1M 建议修改 CAN 时钟到 200M，信号更稳定。高于 1M 比特率的，时钟设置 300M 就可以。</p>
<p><code>pinctrl</code> 根据实际连接情况配置 <code>can h</code> 和 <code>can l</code> 的 <code>iomux</code> 作为 can 功能使用。</p>
<blockquote>
<p>IOMUX 是 Input&#x2F;Output Multiplexer 的缩写，意思是输入&#x2F;输出多路复用器。在嵌入式系统和微控制器中，IOMUX 是一种硬件机制，用于配置芯片的引脚功能。</p>
</blockquote>
<p><code>rx-fifo-depth:</code> 决定接收 <code>FIFO</code> 缓冲区可以存储的 <code>CAN</code> 消息数量。默认该值设置为 <code>&lt;6&gt;</code>，这意味着接收 <code>FIFO</code> 可以容纳多达 6 条 <code>CAN</code> 消息，然后由软件处理，从而有助于确保消息接收的可靠性而不会丢失。需要在缓冲容量和资源使用间的权衡</p>
<blockquote>
<p><code>rx-fifo-depth</code> 的影响<br> <strong>缓冲容量</strong>: 更深的 FIFO 缓冲区可以存储更多的消息，这在 CAN 控制器以高频率接收消息且软件无法立即处理时非常有用，这有助于防止消息丢失。<br><strong>延迟</strong>: 更大的 FIFO 可能会引入轻微的延迟，因为消息可能会在缓冲区中等待更长时间才被处理。然而，与避免消息丢失的好处相比，这种延迟通常是最小的。<br><strong>资源使用</strong>: 增加 FIFO 深度可能会使用更多的硬件资源（例如内存），但对于合理的值来说，这通常可以忽略不计。<br><strong>系统响应性</strong>: 如果读取 FIFO 消息的软件不够快，拥有更深的 FIFO 可以帮助吸收突发的输入消息，从而使系统更具响应性并避免丢失消息。</p>
</blockquote>
<h1 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h1><p>要使用 CAN 功能，需要在内核配置中启用相关选项，内核配置文件地址 <code>kernel/arch/arm64/configs/OK3568-C-linux_defconfig</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#y编译进内核</span></span><br><span class="line"><span class="meta">#n不编译</span></span><br><span class="line"><span class="meta">#m模块方式加载</span></span><br><span class="line">CONFIG_CAN=y</span><br><span class="line">CONFIG_CAN_ROCKCHIP=y</span><br><span class="line">CONFIG_CANFD_ROCKCHIP=y</span><br></pre></td></tr></table></figure>

<p><del>修改内核中的 CAN FD 节点为 CAN 节点并关闭内核中的 CANFD 功能。修改 <code> vi ./kernel/arch/arm64/configs/OK3568-C-linux_defconfig</code> 中的 <code>CONFIG_CANFD_ROCKCHIP=n</code>，关闭 CANFD</del></p>
<h1 id="驱动文件"><a href="#驱动文件" class="headerlink" title="驱动文件"></a>驱动文件</h1><p>Rockchip 的 CAN 驱动文件通常位于内核源码的 <code>drivers/net/can/rockchip/</code> 目录下。</p>
<p><a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/Linux/%E9%A9%B1%E5%8A%A8/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86.md">网络设备驱动的中断处理</a> 中说明了关于网络设备中断的处理</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407091330129.png" alt="image.png"></p>
<p>将给定的 CAN 驱动代码改为使用 NAPI(New API)进行开发，我们需要进行以下主要修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在 struct rockchip_can 中添加 NAPI 结构：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rockchip_can</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">can_priv</span> can;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">napi_struct</span> napi;</span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 NAPI 轮询函数：</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rockchip_can_poll</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="type">int</span> budget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//budget 每次调用 NAPI 轮询函数时最多处理的包数量。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rockchip_can</span> *rcan = <span class="built_in">container_of</span>(napi, <span class="keyword">struct</span> rockchip_can, napi);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">net_device</span> *ndev = rcan-&gt;can.dev;</span><br><span class="line">    <span class="type">int</span> work_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (work_done &lt; budget) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">readl</span>(rcan-&gt;base + CAN_STATE) &amp; RX_BUF_FULL))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rockchip_can_rx</span>(ndev);</span><br><span class="line">        work_done++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (work_done &lt; budget) &#123;</span><br><span class="line">        <span class="built_in">napi_complete_done</span>(napi, work_done);</span><br><span class="line">        <span class="comment">// 重新启用中断</span></span><br><span class="line">        <span class="built_in">writel</span>(<span class="built_in">readl</span>(rcan-&gt;base + CAN_INT_MASK) &amp; ~RX_FINISH, rcan-&gt;base + CAN_INT_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> work_done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改中断处理函数：</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title">rockchip_can_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">net_device</span> *ndev = dev_id;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rockchip_can</span> *rcan = <span class="built_in">netdev_priv</span>(ndev);</span><br><span class="line">    u32 isr;</span><br><span class="line"></span><br><span class="line">    isr = <span class="built_in">readl</span>(rcan-&gt;base + CAN_INT);</span><br><span class="line">    <span class="keyword">if</span> (!isr)</span><br><span class="line">        <span class="keyword">return</span> IRQ_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理接收中断</span></span><br><span class="line">    <span class="keyword">if</span> (isr &amp; RX_FINISH) &#123;</span><br><span class="line">        <span class="comment">// 禁用接收中断</span></span><br><span class="line">        <span class="built_in">writel</span>(<span class="built_in">readl</span>(rcan-&gt;base + CAN_INT_MASK) | RX_FINISH, rcan-&gt;base + CAN_INT_MASK);</span><br><span class="line">        <span class="built_in">napi_schedule</span>(&amp;rcan-&gt;napi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理其他中断...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在驱动初始化函数中设置 NAPI：</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rockchip_can_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 其他初始化代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">netif_napi_add</span>(ndev, &amp;rcan-&gt;napi, rockchip_can_poll, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他初始化代码 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 rockchip_can_open 函数中启用 NAPI：</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rockchip_can_open</span><span class="params">(<span class="keyword">struct</span> net_device *ndev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 其他初始化代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">napi_enable</span>(&amp;rcan-&gt;napi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他初始化代码 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 rockchip_can_stop 函数中禁用 NAPI：</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rockchip_can_stop</span><span class="params">(<span class="keyword">struct</span> net_device *ndev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rockchip_can</span> *rcan = <span class="built_in">netdev_priv</span>(ndev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他清理代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">napi_disable</span>(&amp;rcan-&gt;napi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他清理代码 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在驱动卸载函数中删除 NAPI：</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rockchip_can_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">net_device</span> *ndev = <span class="built_in">platform_get_drvdata</span>(pdev);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rockchip_can</span> *rcan = <span class="built_in">netdev_priv</span>(ndev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他清理代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">netif_napi_del</span>(&amp;rcan-&gt;napi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他清理代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 NAPI 来处理接收数据能够提高性能并减少中断负载。NAPI 允许驱动在高负载情况下轮询接收数据，而不是为每个接收的帧生成中断。这可以显著提高系统的效率，特别是在高数据率的情况下。</p>
<h2 id="LED-状态指示"><a href="#LED-状态指示" class="headerlink" title="LED 状态指示"></a>LED 状态指示</h2><p>可以通过修改内核驱动，实现 LED 状态灯根据 CAN 收发数据情况变化，以显示 CAN 活动状态。</p>
<h1 id="测试和使用"><a href="#测试和使用" class="headerlink" title="测试和使用"></a>测试和使用</h1><ul>
<li>can-utils 工具包进行 CAN 接口的测试和使用</li>
<li>candump 用于接收数据</li>
<li>cansend 用于发送数据<br><a href="source/_posts/2.%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/CAN/CANOpen%20%E8%B0%83%E8%AF%95.md">CANOpen 调试</a> 中说明了相关命令的使用</li>
</ul>
<h1 id="OK3568-的-UART8-复用为-CAN2"><a href="#OK3568-的-UART8-复用为-CAN2" class="headerlink" title="OK3568 的 UART8 复用为 CAN2"></a>OK3568 的 UART8 复用为 CAN2</h1><p>设备树中使能 CAN 功能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">设备树</span><br><span class="line">kernel/arch/arm64/boot/dts/rockchip/OK3568-C-common.dtsi</span><br><span class="line">节点</span><br><span class="line">&amp;can2</span><br><span class="line">属性</span><br><span class="line">status = “okay”</span><br></pre></td></tr></table></figure>

<p>关闭 UART8 功能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">设备树</span><br><span class="line">kernel/arch/arm64/boot/dts/rockchip/OK3568-C-common.dtsi</span><br><span class="line">节点</span><br><span class="line">&amp;uart8</span><br><span class="line">属性</span><br><span class="line">status=”disabled”</span><br></pre></td></tr></table></figure>

<p>修改完成后回到 OK3568-linux-source 目录执行.&#x2F;build.sh kernel 编译完成后单独烧写 OK3568-linux-source&#x2F;kernel&#x2F;boot.img 镜像文件即可。</p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>USB挂载监测</title>
    <url>/2024/05/17/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-USB-USB%E6%8C%82%E8%BD%BD%E7%9B%91%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><pre><code>程序监测到插入U盘后，自动执行执行U盘内和本地指定文件夹双向同步功能
</code></pre>
<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol>
<li>Linux 下如何用 QT 检测到 U 盘已经插入，并实现 mount 与 umount</li>
</ol>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>使用 qt 自带的 QDBus 可以实现，下面为连接代码，当系统有设备插入时，可以调用 <code>slotDeviceAdded(QString udi)</code> 函数。</p>
<p>在 pro 文件中应该加入</p>
<p><code>QT +=dbus</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtDBus/QDBusConnection&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDbusInterface&gt;</span></span></span><br><span class="line"><span class="comment">//以下为检测设备的插入</span></span><br><span class="line">      QDBusConnection::<span class="built_in">systemBus</span>().<span class="built_in">connect</span>(    <span class="string">&quot;org.freedesktop.Hal&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/org/freedesktop/Hal/Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;org.freedesktop.Hal.Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;DeviceAdded&quot;</span>,</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        <span class="built_in">SLOT</span>(<span class="built_in">slotDeviceAdded</span>(QString )));</span><br><span class="line"><span class="comment">//以下为检查设备的拨出</span></span><br><span class="line">    QDBusConnection::<span class="built_in">systemBus</span>().<span class="built_in">connect</span>(    <span class="string">&quot;org.freedesktop.Hal&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/org/freedesktop/Hal/Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;org.freedesktop.Hal.Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;DeviceRemoved&quot;</span>,</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        <span class="built_in">SLOT</span>(<span class="built_in">slotDeviceRemoved</span>(QString )));</span><br></pre></td></tr></table></figure>

<p>在 slotDeviceAdded(QString udi) 函数中，要使用到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QDBusInterface <span class="title">device</span><span class="params">(<span class="string">&quot;org.freedesktop.Hal&quot;</span>, udi, <span class="string">&quot;org.freedesktop.Hal.Device&quot;</span> , QDBusConnection::systemBus())</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过 HAL 可以查询到设备为 volume 的设备，然后通过判断是否为&#x2F;dev&#x2F;sd 的设备，就可以判断出是否为 U 盘，然后调用 mount 就可以了。</p>
<p>这时记录下 U 盘的 UDI，在检测到设备拨出时，再查询一下 U 盘的 UDI 是否还在，就知道 U 盘是否被拨出了。</p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>USB权限设置</title>
    <url>/2024/05/20/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-USB-USB%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>因 Linux 系统下将涉及到 usb 底层驱动的调用，运行时，一定要加 sudo 获取权限运行，否则 USB 设备没有权限操作。 </p>
<p>现通过创建 UDEV 规则，配置 USB 权限后，可以调用指定设备不加权限运行。</p>
<p>输入 lsusb，查看当前的 USB 设备的 ID，确定需要配置的 USB。</p>
<p>创建一个新的 udev 规则。名称取为：99-myusb.rules</p>
<p><code>sudo vi /etc/udev/rules.d/99-myusb.rules</code></p>
<p>在 99-myusb.rules 文件中，输入以下内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">##</span><br><span class="line">ACTION==<span class="string">&quot;add&quot;</span>,SUBSYSTEMS==<span class="string">&quot;usb&quot;</span>, ATTRS&#123;idVendor&#125;==<span class="string">&quot;04d8&quot;</span>, ATTRS&#123;idProduct&#125;==<span class="string">&quot;0053&quot;</span>, GROUP=<span class="string">&quot;users&quot;</span>, MODE=<span class="string">&quot;0777&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这条 <code>udev</code> 规则的作用是，当供应商 ID 为 <code>04d8</code> 且产品 ID 为 <code>0053</code> 的 USB 设备插入系统时，将该设备的用户组设置为 <code>users</code>，并赋予所有用户读、写、执行的全部权限。</li>
</ul>
<p>插拔一下 USBCAN 设备或重启一下电脑后，即可不加 sudo 权限运行程序了</p>
<p>对某个特定 USB 设备设置权限。每当这个设备插入系统时，规则会自动应用。</p>
<ol>
<li><code>ACTION==&quot;add&quot;</code>：这表示规则在设备添加（插入）时生效。<code>udev</code> 可以根据不同的动作（如添加、移除等）触发规则，<code>add</code> 动作指设备插入时。</li>
<li><code>SUBSYSTEMS==&quot;usb&quot;</code>：表示规则适用于 USB 子系统的设备。<code>udev</code> 管理系统中的设备，子系统用于分类，USB 是其中一种。</li>
<li><code>ATTRS&#123;idVendor&#125;==&quot;04d8&quot;</code>：表示设备的供应商 ID（Vendor ID）为 <code>04d8</code>。每个 USB 设备都有唯一的供应商 ID，用于标识设备的制造商。</li>
<li><code>ATTRS&#123;idProduct&#125;==&quot;0053&quot;</code>：表示设备的产品 ID（Product ID）为 <code>0053</code>。每个供应商的不同产品有不同的产品 ID，用于区分供应商的各个设备。</li>
<li><code>GROUP=&quot;users&quot;</code>：表示设备的用户组被设置为 <code>users</code>。这决定了哪些用户组的成员有权访问该设备。</li>
<li><code>MODE=&quot;0777&quot;</code>：表示设备的权限模式被设置为 <code>0777</code>，即所有用户对该设备都有读、写、执行权限。</li>
</ol>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>USB的权限设置最高</title>
    <url>/2024/07/12/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-USB-USB%E7%9A%84%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%E6%9C%80%E9%AB%98/</url>
    <content><![CDATA[<ol>
<li><p>使用 lsusb -vvv 命令找出 USB 设备的 vendorID 和 productID<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407121318841.png" alt="image.png"></p>
</li>
<li><p>创建一个新的 udev 规则<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407121319079.png" alt="image.png"><br>红色框中的为新建的 udev 规则</p>
</li>
<li><p>新建文件内容：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ sudo vi/etc/udev/rules.d/<span class="number">50</span>-myusb.rules</span><br><span class="line"></span><br><span class="line">SUBSYSTEMS==<span class="string">&quot;usb&quot;</span>, ATTRS&#123;idVendor&#125;==<span class="string">&quot;067b&quot;</span>, ATTRS&#123;idProduct&#125;==<span class="string">&quot;2303&quot;</span>, GROUP=<span class="string">&quot;users&quot;</span>, MODE=<span class="string">&quot;0666&quot;</span></span><br></pre></td></tr></table></figure>

<p>用你自己的”idVendor”和”idProduct”来替换。MODE&#x3D;”0666”表示 USB 设备的权限。建立新文件内容</p>
<p> <img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407121319781.png" alt="image.png"></p>
<p>建立好文件之后重启即可</p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>USB设备节点名不固定</title>
    <url>/2024/07/12/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-USB-USB%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E5%90%8D%E4%B8%8D%E5%9B%BA%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="Linux-下-USB-设备节点名不固定"><a href="#Linux-下-USB-设备节点名不固定" class="headerlink" title="Linux 下 USB 设备节点名不固定"></a>Linux 下 USB 设备节点名不固定</h1><p>以 USB 转串口设备为例，通常设备节点名为 ttyUSBx（x 为 0~n）,Linux 内核会根据设备插入的先后顺序进行编号的分配，比如第一个插入的设备编号为 ttyUSB0，然后依此加 1，变为 ttyUSB1，ttyUSB2……</p>
<p>如果仅仅以设备节点 ttyUSBx 来区别具体是哪个设备，因为末位的编号是随时会变的，所以就会造成混乱。无法保证 A 设备就是 ttyUSB0，B 设备就是 ttyUSB1。在设备文件&#x2F;dev 目录下并没有提供固定显示 ttyUSB 的方法，但是，其实，每个 USB 端口都有唯一的端口号，相当于每个门店的门牌号。只要我们依据端口号来进行设备的区分，那么问题就迎刃而解了。简单点来说就是找到端口号，然后根据端口号找到挂载在这个端口号上面的 USB 设备是 ttyUSB0 还是 ttyUSB1….(这个是变化的，前面讲到了)。</p>
<h1 id="关于端口号的查看方法"><a href="#关于端口号的查看方法" class="headerlink" title="关于端口号的查看方法"></a>关于端口号的查看方法</h1><p>连接好两个 USB 转串口设备之后:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ls -l/sys/<span class="keyword">class</span>/tty/ttyUSB*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lrwxrwxrwx root root <span class="number">2017</span><span class="number">-08</span><span class="number">-0113</span>:<span class="number">40</span> ttyUSB0 -&gt;../../devices/ff540000.usb/usb3/<span class="number">3</span><span class="number">-1</span>/<span class="number">3</span><span class="number">-1.1</span>/<span class="number">3</span><span class="number">-1.1</span>:<span class="number">1.0</span>/ttyUSB0/tty/ttyUSB0</span><br><span class="line">lrwxrwxrwx root root <span class="number">2017</span><span class="number">-08</span><span class="number">-0113</span>:<span class="number">43</span> ttyUSB1 -&gt;../../devices/ff540000.usb/usb3/<span class="number">3</span><span class="number">-1</span>/<span class="number">3</span><span class="number">-1.2</span>/<span class="number">3</span><span class="number">-1.2</span>:<span class="number">1.0</span>/ttyUSB1/tty/ttyUSB1</span><br></pre></td></tr></table></figure>

<p>其中 ttyUSB0 所在的端口号为 3-1.1，而 ttyUSB1 所在的端口号为 3-1.2，可以看出，这里的 3-1.1 端口上比 3-1.2 上提前插上 USB 设备，所以会以这种方式命名。如果插入设备的顺序相反，那么端口号 3-1.1 上对应的设备应该是 ttyUSB1，而 3-1.2 上对应的设备应该是 ttyUSB0。但是如果在实际过程中我们只需要采集端口 3-1.1 传来的数据，我们该如何通过 ttyUSBx 不定的设备节点，获取到固定端口的数据呢？</p>
<p>实际工程中，碰到的一个问题是：硬件上连接有两个 USB 转串口设备，硬件只要一上电，两个 USB 设备几乎是同时上电的，这将导致 ttyUSB0 或者 ttyUSB1 无法每次固定的对应到上一次的那个相同端口，上层软件需要通过串口设备节点&#x2F;dev&#x2F;ttyUSBx 来打开一个串口，并从串口获取数据，但是这个 ttyUSBx 设备并不是一直都指向固定的一个 usb 端口号，这直接导致我们无法往下操作了。</p>
<p>这里使用 bash 语言加 Python 正则表达式的相关知识解决这个问题：</p>
<ol>
<li>第一次上电的时候，我们需要确定哪个端口上的数据是我们所需要的：<code>ls -l/sys/class/tty/ttyUSB*</code> 假设是 3-1.1 这个端口是我们的 data 端口。</li>
<li>以后每次上电，我们要找到 3-1.1 这个端口后面挂载的 ttyUSB 设备是 ttyUSB0 还是 ttyUSB1，并建立一个软链接将当时获取到的 ttyUSBx 生成一个软链接，名字固定为 ttydata,那么以后每次打开&#x2F;dev&#x2F;ttydata 就能找到正确 3-1.1 这个端口，并获取数据了。</li>
<li>建立一个文件夹 getUSB，该文件夹下面包含：</li>
</ol>
<ul>
<li>cmd.sh 是利用 bash 脚本获取 <code>/sys/class/tty/ttyUSB*</code> 的一些信息保存在 device_usb.txt 中</li>
<li>getUSB.py 是通过 device_usb.txt 中的信息，获取到当前挂着在端口 3-1.1 上的是 ttyUSB0 还是 ttyUSB1 并保存在 usbdev 中</li>
</ul>
<h1 id="cmd-sh"><a href="#cmd-sh" class="headerlink" title="cmd.sh"></a><code>cmd.sh</code></h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> -i a=0</span><br><span class="line"><span class="built_in">declare</span> -i b=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#等待一段时间没有检测ttyUSB0设备到会自动跳出while</span></span><br><span class="line"><span class="keyword">while</span> [[ ! -e <span class="string">&quot;/sys/class/tty/ttyUSB0&quot;</span> ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	sudo <span class="built_in">sleep</span> 0.01s</span><br><span class="line">	a=a+1</span><br><span class="line">	<span class="keyword">if</span> [ <span class="variable">$a</span> -eq 300 ];<span class="keyword">then</span> </span><br><span class="line">		<span class="built_in">break</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if USB0been detected ,also get out of while</span></span><br><span class="line"><span class="keyword">while</span> [[ ! -e <span class="string">&quot;/sys/class/tty/ttyUSB1&quot;</span> ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	sudo <span class="built_in">sleep</span> 0.01s</span><br><span class="line">	b=b+1</span><br><span class="line">	<span class="keyword">if</span> [[ <span class="variable">$b</span> -eq 300||<span class="variable">$a</span> -ne 0 ]];<span class="keyword">then</span> </span><br><span class="line">		<span class="built_in">break</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不存在ttyUSB设备</span></span><br><span class="line"><span class="comment">#如果完美检测到了两个ttyUSB设备，则将信息log到device_usb.txt当中</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -e /sys/class/tty/ttyUSB0&amp;&amp;! -e/sys/class/tty/ttyUSB1 ]]; <span class="keyword">then</span> </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Not have ttyUSB0 or not have ttyUSB1&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	tty1=$(<span class="built_in">ls</span> -l /sys/class/tty/ttyUSB0)</span><br><span class="line">	tty2=$(<span class="built_in">ls</span> -l /sys/class/tty/ttyUSB1)</span><br><span class="line">	sudo <span class="built_in">ls</span> -l /sys/class/tty/ttyUSB0 /sys/class/tty/ttyUSB1 &gt;./device_usb.txt</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#非空检测</span></span><br><span class="line"><span class="keyword">if</span> [ ! -n <span class="string">&quot;<span class="variable">$tty1</span>&quot;</span> ] ;<span class="keyword">then</span> <span class="comment"># &quot;! -n&quot; showsblank var </span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;tty1 is empty&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#delay 0.01s to make sure the device_usb.txt complete</span></span><br><span class="line">sudo <span class="built_in">sleep</span> 0.01s</span><br><span class="line"></span><br><span class="line"><span class="comment">#remove the old USB device shortcut</span></span><br><span class="line"><span class="keyword">if</span> [ ! -e <span class="string">&quot;/dev/ttydata&quot;</span> ] ;<span class="keyword">then</span> <span class="comment"># 如果/dev/ttydata本身不存在</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;-------------/dev/ttydata not found&quot;</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">#如果存在，则需删除之，然后重新创建之</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;/dev/ttydata is exist&quot;</span></span><br><span class="line">	sudo <span class="built_in">rm</span> /dev/ttydata</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#exct Python language to get the rignt USB interface</span></span><br><span class="line"><span class="comment">#调用当前路径下的getUSB.py这个Python语言，明确此次是哪个,ttyUSB0,或者ttyUSB1挂载在端口3-1.1上</span></span><br><span class="line">./getUSB.py </span><br><span class="line"><span class="comment">#获取到这个设备</span></span><br><span class="line">usbdev=$(<span class="built_in">cat</span> ./usbdev) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;the device is : &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$usbdev</span></span><br><span class="line"><span class="comment">#将这个设备软连接到/dev/ttydata以后每次打开这个ttydata即可</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /dev/<span class="variable">$usbdev</span> /dev/ttydata</span><br></pre></td></tr></table></figure>

<h1 id="getUSB-py"><a href="#getUSB-py" class="headerlink" title="getUSB.py"></a><code>getUSB.py</code></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re <span class="comment">#正则表达式</span></span><br><span class="line"></span><br><span class="line">sss = <span class="built_in">open</span>(<span class="string">&quot;./device_usb.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>)<span class="comment">#打开 device_usb.txt 设备，并读取内容</span></span><br><span class="line">www = <span class="built_in">open</span>(<span class="string">&quot;./usbdev&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="comment">#当前路径下创建usbdev文件，后续会写入内容</span></span><br><span class="line"></span><br><span class="line">s_read = sss.read() usb3/<span class="number">3</span>-<span class="number">1</span>/<span class="number">3</span>-<span class="number">1.1</span>/</span><br><span class="line"></span><br><span class="line">r = <span class="string">r&quot;usb3/3-1/3-1\.1.+(ttyUSB[0-9])&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#正则中“.”需要转义，所以使用“\.”表示“.”</span></span><br><span class="line"><span class="comment">#这个规则是找到usb3/3-1/3-1.1/这个字符串后面紧跟的是此次上电生成的 ttyUSB0 或者ttyUSB1</span></span><br><span class="line"></span><br><span class="line">output = re.findall(r,s_read)</span><br><span class="line"></span><br><span class="line">www.write(output[<span class="number">0</span>]) <span class="comment">#将结果写到usbdev中</span></span><br><span class="line"></span><br><span class="line">www.close()</span><br><span class="line"></span><br><span class="line">sss.close()</span><br></pre></td></tr></table></figure>

<p>完成之后设置开机项目，将文件夹当道一个位置，然后设置开机启动 cmd.sh（在&#x2F;etc&#x2F;rc.local 中设置）则每次开机之后，会从&#x2F;dev&#x2F;ttydata 获取到固定端口的数据</p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>自动挂载U盘</title>
    <url>/2024/07/12/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-USB-%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDU%E7%9B%98/</url>
    <content><![CDATA[<p>某些场景下，服务器可能没有必要的键盘等输入设备、屏幕等输出设备。此时需要在没有人为干预的情况下实现当插入 U 盘或者硬盘后自动挂载，并执行某些脚本动作。</p>
<h1 id="必要组件"><a href="#必要组件" class="headerlink" title="必要组件"></a>必要组件</h1><p>udev,udisks</p>
<p>busybox (需要用到 blkid)可以直接获取到设备的卷标，这样就可以指定挂载路径名称了。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="规则编写"><a href="#规则编写" class="headerlink" title="规则编写"></a>规则编写</h2><p>编写 udev 规则实现 U 盘插入时候的动作。规则文件写在&#x2F;etc&#x2F;udev&#x2F;rules.d 下。</p>
<p>如上， 通过规则定义 U 盘插入与拔出的动作即可，动作的具体实现可以在规则中编写，也可以通过指定执行脚本来实现。本文的规则中仅指定执行脚本。</p>
<p>规则如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ENV&#123;DEVTYPE&#125;=<span class="string">&quot;partition&quot;</span>,RUN+=<span class="string">&quot;/lib/udev/automount.sh&quot;</span>,ENV&#123;REMOVE_CMD&#125;=<span class="string">&quot;/lib/udev/autounmount.sh&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>将脚本文件写在 <code>/lib/udev</code> 下，根据上文规则，应该分别实现插入的动作脚本和拔出的动作脚本。</p>
<h3 id="插入动作脚本"><a href="#插入动作脚本" class="headerlink" title="插入动作脚本"></a>插入动作脚本</h3><p>主要在于需要获取到设备的卷标，来确定挂载的路径(即$ID_FS_LABEL)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount_point=<span class="variable">$ID_FS_LABEL</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$mount_point</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">mount_point=<span class="variable">$&#123;DEVNAME##*/&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="variable">$mount_point</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /media/<span class="variable">$mount_point</span></span><br><span class="line">mount -t <span class="variable">$ID_FS_TYPE</span> -o gid=100,dmask=000,fmask=111,utf8,flush,rw,noatime,<span class="built_in">users</span></span><br><span class="line"><span class="variable">$DEVNAME</span> /media/<span class="variable">$mount_point</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="拔出动作脚本"><a href="#拔出动作脚本" class="headerlink" title="拔出动作脚本"></a>拔出动作脚本</h3><p>在 U 盘拔出时候，及时删掉挂载的路径</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount_point=<span class="variable">$ID_FS_LABEL</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$mount_point</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">mount_point=<span class="variable">$&#123;DEVNAME##*/&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="variable">$mount_point</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">umount -l /media/<span class="variable">$mount_point</span> <span class="built_in">rm</span> -r /media/<span class="variable">$mount_point</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="自动执行动作脚本"><a href="#自动执行动作脚本" class="headerlink" title="自动执行动作脚本"></a>自动执行动作脚本</h2><p>这样，当 U 盘插入时，&#x2F;media&#x2F; 下就会出现于卷标相同的文件夹，并挂载上了 U 盘。因此，需要实现 U 盘插入自动执行的话，通过轮询探测&#x2F;media&#x2F; 下相应目录是否存在即可。如:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">UDISK=<span class="variable">$1</span></span><br><span class="line"><span class="comment"># ---------------main control area ---------------</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="comment"># probe mounted disk</span></span><br><span class="line">	<span class="keyword">if</span> [ -e<span class="string">&quot;<span class="variable">$UDISK</span>&quot;</span> ];</span><br><span class="line">	<span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span><span class="string">&quot;Mounted device [<span class="variable">$UDISK</span>] found !&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span><span class="string">&quot;Device not found [<span class="variable">$UDISK</span>] !&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	<span class="built_in">echo</span><span class="string">&quot;Sleep for sometime...&quot;</span></span><br><span class="line">	<span class="built_in">sleep</span> 3s</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h1 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h1><p>新版本的 udev 可能会遇到 mount 失效的问题，通过查询资料可知，udev 的 rules 运行于独立的文件空间上，与用户的文件空间不同，因此及时挂载上了，用户也无法访问。因此需要将 udev 的运行方式改为共享。</p>
<p>修改方式如下：</p>
<ul>
<li>拷贝一份 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;systemd-udevd.service 到 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F; （推荐）</li>
<li>编辑&#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 将 MountFlags 改为 shared</li>
<li>重启即可。</li>
</ul>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下的CH34x串口识别</title>
    <url>/2024/05/21/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-%E4%B8%B2%E5%8F%A3-Linux%E4%B8%8B%E7%9A%84CH34x%E4%B8%B2%E5%8F%A3%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>ch341.ko 是一个 Linux 内核模块，用于支持 CH341 USB 转串口芯片。要在内核中编译该模块，需要找到其配置选项。这个配置选项通常在 Linux 内核的配置文件中定义，并且可以通过配置内核选项来启用。</p>
<h1 id="判断是否识别"><a href="#判断是否识别" class="headerlink" title="判断是否识别"></a><strong>判断是否识别</strong></h1><p>使用 <code>lsusb</code> 命令可以看到有 <code>Bus 001 Device 005: ID 1a86:7523 QinHeng Electronics CH340 serial converter</code> 是能识别出 ch34x 设备</p>
<h1 id="检查串口是否被驱动加载"><a href="#检查串口是否被驱动加载" class="headerlink" title="检查串口是否被驱动加载"></a><strong>检查串口是否被驱动加载</strong></h1><p>输入指令 <code>ls /dev/ttyUSB*</code> 将会列出 USB 的加载情况。如果提示 No such file or directory 则是没有被驱动加载。</p>
<h1 id="占用情况"><a href="#占用情况" class="headerlink" title="占用情况"></a><strong>占用情况</strong></h1><p>因报文件不存在错误，采用 <code>dmesg|grep tty</code> 命令检查发现，被 <code>brltty</code> 进程占用。</p>
<p><code>brltty</code> 是一个后台进程（守护进程），为盲人提供对 Linux&#x2F;Unix 控制台的访问（当处于文本模式时），使用可刷新盲文显示。</p>
<p>移除该 <code>apt remove brltty</code>。</p>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a><strong>权限</strong></h1><p><code>chmod a+rw /dev/ttyUSB0</code> 即可</p>
<h1 id="重装驱动-单独编译"><a href="#重装驱动-单独编译" class="headerlink" title="重装驱动-单独编译"></a><strong>重装驱动-单独编译</strong></h1><p>下载最新的驱动 CH341SER_LINUX</p>
<p><a href="https://github.com/WCHSoftGroup/ch341ser_linux">https://github.com/WCHSoftGroup/ch341ser_linux</a> </p>
<ol>
<li>解压后进入 “driver” 目录下</li>
<li>输入 <code>make</code> 命令编译驱动，正常编译完成后，将会看到生成了 <code>ch341.ko</code> 模块</li>
<li>输入 <code>sudo make load</code> 或者 <code>sudo insmod ch341.ko</code> 动态加载驱动（重启需要再次加载），或者输入 <code>sudo make install</code> 安装驱动（重启不丢失）</li>
<li>输入 <code>sudo make unload</code> 或者 <code>sudo rmmod ch341.ko</code> 或者 <code>sudo make uninstall</code> 卸载驱动</li>
</ol>
<ul>
<li><p>如果编译失败，可能是 ch34x.c 和实际内核版本不匹配，<code>uname -r</code> 可查看操作系统的发行版号，之后在 <a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source</a> 中查找对应内核版本的源代码文件，一般位于 <code>/drivers/usb/serial/ch341.c</code>，替换后重新编译</p>
</li>
<li><p>如果 insmod 失败，查看 <code>/lib/modules/$(uname -r)/kernel/drivers/usb/serial</code> 目录下是否已经有了 ko 模块，将目录中生成 ko 文件复制到此处，使用 <code>lsmod</code> 查看模块</p>
</li>
</ul>
<h1 id="重装驱动-交叉编译"><a href="#重装驱动-交叉编译" class="headerlink" title="重装驱动-交叉编译"></a><strong>重装驱动-交叉编译</strong></h1><p>编译一个 <code>ARM64</code> 的 <code>ch341</code> 的 <code>ko</code> 文件，用于 <code>4.19.206</code> 内核的 <code>Linux</code>，<code>ch341.ko</code> 模块的定义位于 <code>drivers/usb/serial/Kconfig</code> 文件中，通过配置 <code>USB_SERIAL_CH341</code> 选项可以在内核中启用该模块。编译内核时根据配置生成相应的模块文件，然后通过 <code>modprobe</code> 加载即可使用该模块。</p>
<p>在 <code>drivers</code> 目录下的所有文件中，在文件的内容中查找字符串 CH341<code>grep -r &quot;CH341&quot; drivers/</code></p>
<ol>
<li>确认串口类型，是 <code>CH341</code> 还是 <code>PLX2303</code></li>
<li><code>ch341.c</code> 文件中的 <code>usb_device_id</code> 是否包含要使用的 <code>VID</code>，<code>PID</code>（<code>lsusb</code> 命令查看）</li>
<li>查找配置选项，在 Linux 内核源代码目录中，驱动程序的配置选项通常定义在 Kconfig 文件中。要查找 ch341 驱动的配置选项，可以在内核源代码目录下运行以下命令：<code>grep -r &quot;CH341&quot; drivers/</code> 这将搜索包含 CH341 字符串的所有文件，通常会找到类似以下的条目：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">drivers/usb/serial/Kconfig:config USB_SERIAL_CH341</span><br><span class="line">drivers/usb/serial/Kconfig:	tristate <span class="string">&quot;USB CH341 single port serial driver&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>配置内核，知道配置选项后，可以使用 <code>make menuconfig</code> 或 <code> make nconfig</code> 等工具来配置内核。在 <code>USB Serial Converter support</code> 菜单下，找到并启用 <code>USB CH341 single port serial driver</code> 选项。或者配置 <code>USB_SERIAL_CH341=m</code>，将其设置为模块（M）或内联（*），如果希望编译为模块，选择 M。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Device Drivers  ---&gt;</span><br><span class="line">    [*] USB support  ---&gt;</span><br><span class="line">        &lt;*&gt; USB Serial Converter support  ---&gt;</span><br><span class="line">            &lt;*&gt; USB CH341 single port serial driver</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>编译内核和模块，配置完成后，编译内核和模块：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make modules</span><br><span class="line">make modules_install</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>加载模块，编译完成后，可以使用 modprobe 加载模块：<br><code>modprobe ch341</code></p>
</li>
<li><p>验证模块加载，使用 lsmod 验证模块是否成功加载，如果显示 ch341 模块，则说明加载成功。<br><code>lsmod | grep ch341</code></p>
</li>
</ol>
<h1 id="重装驱动-apt"><a href="#重装驱动-apt" class="headerlink" title="重装驱动-apt"></a>重装驱动-apt</h1><p>包提供了一些可能默认没有包含的额外内核模块。</p>
<p><code>sudo apt install linux-modules-extra-$(uname -r)</code></p>
<p>手动加载 ch341 驱动程序：</p>
<p><code>sudo modprobe ch341</code></p>
<p>检查驱动程序是否已加载：</p>
<p><code>lsmod | grep ch341</code></p>
<p>检查设备是否被识别：</p>
<p><code>dmesg | grep ch341</code></p>
<h1 id="KO-文件开机自动加载"><a href="#KO-文件开机自动加载" class="headerlink" title="KO 文件开机自动加载"></a>KO 文件开机自动加载</h1><h2 id="etc-modules-文件中添加模块"><a href="#etc-modules-文件中添加模块" class="headerlink" title="/etc/modules  文件中添加模块"></a><code>/etc/modules </code> 文件中添加模块</h2><p>打开 <code> /etc/modules</code> 文件：</p>
<p><code>sudo vi /etc/modules</code></p>
<p>在文件末尾添加你想要加载的 KO 文件的名字（不需要路径，只需要模块名），比如：</p>
<p><code>my_module</code></p>
<h2 id="使用-modprobe-配置文件"><a href="#使用-modprobe-配置文件" class="headerlink" title="使用 modprobe 配置文件"></a>使用 modprobe 配置文件</h2><p>创建一个新的文件在 <code> /etc/modprobe.d/</code> 目录，例如 <code>custom.conf</code>：</p>
<p><code>sudo vi /etc/modprobe.d/custom.conf</code></p>
<p>添加如下内容，指定模块名称：</p>
<p><code>install your_module_name /sbin/insmod /path/to/your/module.ko</code></p>
<h2 id="使用-rc-local-文件"><a href="#使用-rc-local-文件" class="headerlink" title="使用 rc.local 文件"></a>使用 rc.local 文件</h2><p>打开 <code>/etc/rc.local</code> 文件：</p>
<p><code>sudo vi /etc/rc.local</code></p>
<p>在 exit 0 之前添加 insmod 命令，指定模块的完整路径：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo insmod /path/to/your/<span class="keyword">module</span>.ko</span><br><span class="line">exit <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="创建-systemd-服务"><a href="#创建-systemd-服务" class="headerlink" title="创建 systemd 服务"></a>创建 <code>systemd</code> 服务</h2><p>创建一个新的服务文件，例如 <code> load-module.service</code>：</p>
<p><code>sudo vi /etc/systemd/system/load-module.service</code></p>
<p>在文件中添加以下内容，指定模块路径：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Load custom kernel <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/sbin/insmod /path/to/your/<span class="keyword">module</span>.ko</span><br><span class="line">ExecStop=/sbin/rmmod your_module_name</span><br><span class="line">RemainAfterExit=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>串口</category>
      </categories>
  </entry>
  <entry>
    <title>UART</title>
    <url>/2024/08/27/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-%E4%B8%B2%E5%8F%A3-UART/</url>
    <content><![CDATA[<h1 id="UART-协议概述"><a href="#UART-协议概述" class="headerlink" title="UART 协议概述"></a>UART 协议概述</h1><p>UART（通用异步收发器）是一种广泛应用于设备间通信的异步串行通信协议。它通过串行方式逐位传输数据，通常用于连接计算机与各种外部设备，如调制解调器、传感器和微控制器等。UART 具有全双工通信能力，意味着数据可以同时在两个方向上传输。</p>
<h2 id="同步串口与异步串口"><a href="#同步串口与异步串口" class="headerlink" title="同步串口与异步串口"></a>同步串口与异步串口</h2><h3 id="同步串口"><a href="#同步串口" class="headerlink" title="同步串口"></a>同步串口</h3><p>同步串口通过专门的时钟信号线来实现数据传输的同步。发送方和接收方依赖于时钟信号将数据流转换为电平信号。这种方式适合需要高数据传输速率和精确时序的应用场景。</p>
<h3 id="异步串口"><a href="#异步串口" class="headerlink" title="异步串口"></a>异步串口</h3><p>异步串口则不使用共享时钟信号。定位信息包含在电平序列中，通信双方需事先约定数据帧的格式，包括波特率、数据位、停止位和奇偶校验等。线路空闲时，电平为高，一旦检测到下降沿，则视为起始位。接收方根据约定格式接收数据帧，并继续检测下一个起始位。异步串口的同步是以帧为单位的，适用于大多数低速通信场景。</p>
<h1 id="UART-的工作特点"><a href="#UART-的工作特点" class="headerlink" title="UART 的工作特点"></a>UART 的工作特点</h1><h2 id="数据采样"><a href="#数据采样" class="headerlink" title="数据采样"></a>数据采样</h2><p>UART 协议是一种低速数据通信标准，典型波特率为 115200 或 9600。UART 字符格式通常包含 1 个起始位、5~8 个数据位、1 个可选的奇偶位和 1 个停止位。由于接收器和发送器异步工作，接收器通常采用对输入数据流的高度采样方式，通常为 16 次采样，以确保数据的准确性。</p>
<h2 id="UART-帧区分"><a href="#UART-帧区分" class="headerlink" title="UART 帧区分"></a>UART 帧区分</h2><p>在 UART 中，MAX-IDL 参数用于设置空闲字符的数量。UART 控制器会开始计数接收到的空闲字符。如果在接收下一数据字符之前，接收到的空闲字符数量超过 MAX-IDL，则会产生空闲时间，缓冲区被关闭，并向 CPU 发出中断请求。这种机制有助于区分不同的数据帧。</p>
<p>空闲字符的位数计算公式为：1（起始位）+ 数据长度（5、6、7、8）+ 1（若使用奇偶校验）+ 停止位（1）。例如，1 个起始位，8 位数据，无校验，1 个停止位，则空闲字符 MAX-IDL 为 10 位。</p>
<h2 id="UART-地址识别"><a href="#UART-地址识别" class="headerlink" title="UART 地址识别"></a>UART 地址识别</h2><p>在多站系统中，可能存在多个设备，每个设备都有特定的地址。UART 帧可以扩展一位，以区别地址字符和正常数据字符。UART 支持两种操作模式：</p>
<ul>
<li><strong>自动多站模式</strong>：当地址与预置值匹配时，UART 控制器自动接收随后的数据。</li>
<li><strong>非自动多站模式</strong>：UART 控制器接收所有数据，地址字符被写入新的缓冲区。</li>
</ul>
<p>综上所述，UART 协议通过数据采样来确定位值，具有简单准确的定帧模式，并广泛用于多站系统中，支持自动多站和非自动多站两种模式，以区分地址和数据。</p>
<h1 id="几种重要寄存器"><a href="#几种重要寄存器" class="headerlink" title="几种重要寄存器"></a>几种重要寄存器</h1><p>在 UART 的工作中，对寄存器的理解和正确配置至关重要。以下是 MPC860 的一些重要寄存器：</p>
<ul>
<li><strong>管脚配置寄存器</strong>：用于设置收发管脚的功能。</li>
<li><strong>波特率配置寄存器</strong>：负责配置波特率。</li>
<li><strong>通信处理命令寄存器</strong>：用于发出和阻止命令的判断。</li>
<li><strong>SCC 通用模式寄存器</strong>：用于选择协议和配置传输格式。</li>
<li><strong>发送和接收缓冲区描述器</strong>：用于数据的收发和错误判断。</li>
<li><strong>UART 的特定参数</strong>：用于初始化 UART。</li>
<li><strong>SCC 协议专用模式寄存器</strong>：用于设置 UART 的多站模式。</li>
<li><strong>事件寄存器</strong>：用于判断中断类型。</li>
<li><strong>屏蔽寄存器</strong>：用于收发使能。</li>
</ul>
<h2 id="UART-与-RS-232-和-COM-口"><a href="#UART-与-RS-232-和-COM-口" class="headerlink" title="UART 与 RS-232 和 COM 口"></a>UART 与 RS-232 和 COM 口</h2><p>UART 是异步串行通信的总称，包括 RS-232、RS-499、RS-423、RS-422 和 RS-485 等接口标准。UART 主要定义了通信口的电气特性、传输速率、连接特性和机械特性。COM 口是 PC 上的异步串行通信口的简称，通常基于 RS-232 标准。</p>
<h1 id="嵌入式开发中的-UART-应用"><a href="#嵌入式开发中的-UART-应用" class="headerlink" title="嵌入式开发中的 UART 应用"></a>嵌入式开发中的 UART 应用</h1><p>UART 协议广泛应用于嵌入式系统中，支持 RS-232、RS-422、RS-485 串口通信和红外（IrDA）等。UART 的工作原理是逐位传输数据，包含以下几个关键部分：</p>
<ul>
<li><strong>起始位</strong>：发送逻辑“0”信号，表示数据传输开始。</li>
<li><strong>数据位</strong>：构成一个字符的数据位，通常为 5 至 8 位。</li>
<li><strong>奇偶校验位</strong>：用于校验数据传输的正确性。</li>
<li><strong>停止位</strong>：表示字符数据的结束，可以是 1 位、1.5 位或 2 位的高电平。</li>
<li><strong>空闲位</strong>：表示线路上没有数据传送，处于逻辑“1”状态。</li>
<li><strong>波特率</strong>：衡量数据传送速率的指标，通常以每秒传送的位数表示。</li>
</ul>
<p>在实际应用中，UART 通过 SCI（串行通信接口）模块进行控制，广泛应用于工控、手机、PC 等设备中。通过合理配置 UART，可以实现高效的数据传输和设备间的通信。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>UART（Universal Asynchronous Receiver and Transmitter）共有</p>
<ul>
<li>256 bytesin Ch0</li>
<li>64 bytesin Ch1 and Ch4</li>
<li>16 bytesin Ch2 and Ch3</li>
</ul>
<p>其中 ch0 和 ch4 有其他特殊作用</p>
<p>Thissection includes UART operationssuch as:</p>
<ul>
<li>Data transmission &amp;Data reception</li>
<li>Interrupt generation &amp;Baud-rate generation</li>
<li>Loop-back mode &amp;Infrared modes</li>
<li>AFC</li>
</ul>
<p>The data frame for transmission is programmable. Itconsists of these bitsthat are specified bythe line control register(ULCONn):</p>
<ul>
<li>A Start bit</li>
<li>Five to eight data bits</li>
<li>An optional parity bit（校验位）</li>
<li>One to two stop bits</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724726253000krt3ip.png" alt="gh"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724726267000adsjku.png" alt="gh"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724726282000m6a66l.png" alt="gh"></p>
<h1 id="UART-的实现与代码示例"><a href="#UART-的实现与代码示例" class="headerlink" title="UART 的实现与代码示例"></a>UART 的实现与代码示例</h1><p>在实现 UART 时，通常需要配置波特率、数据格式和工作模式。以下是一个简单的 UART 初始化和数据发送接收的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置通道工作模式（中断模式/查询模式）</span></span><br><span class="line"><span class="comment">//设置数据传输格式</span></span><br><span class="line"><span class="comment">//发送数据/接收数据（TXDn-----发送/RXDn-----接受）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serial_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GPA1.GPA1CON = (GPA1.GPA1CON &amp; ~<span class="number">0xFF</span>) | (<span class="number">0x22</span>); <span class="comment">// GPA1_0: RX; GPA1_1: TX</span></span><br><span class="line">    UART2.ULCON2 = <span class="number">0x3</span>; <span class="comment">// Normal mode, No parity, One stop bit, 8 data bits</span></span><br><span class="line">    UART2.UCON2 = <span class="number">0x5</span>; <span class="comment">// Interrupt request or polling mode</span></span><br><span class="line">    <span class="comment">/* Baud-rate 115200: src_clock: 100MHz</span></span><br><span class="line"><span class="comment">    * DIV_VAL = (100*10^6 / (115200*16) - 1) = (54.3 - 1) = 53.3</span></span><br><span class="line"><span class="comment">    * UBRDIV2 = (Integer part of 53.3) = 53 = 0x35</span></span><br><span class="line"><span class="comment">    * UFRACVAL2 = 0.3*16 = 0x5 */</span></span><br><span class="line">    UART2.UBRDIV2 = <span class="number">0x35</span>;</span><br><span class="line">    UART2.UFRACVAL2 = <span class="number">0x5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">getchar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (!(UART2.UTRSTAT2 &amp; <span class="number">0X1</span>)); <span class="comment">// 等待接收数据</span></span><br><span class="line">    c = UART2.URXH2; <span class="comment">// 读取接收到的数据</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!(UART2.UTRSTAT2 &amp; <span class="number">0X2</span>)); <span class="comment">// 等待发送缓冲区空</span></span><br><span class="line">    UART2.UTXH2 = data; <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 如果发送的是换行符，则发送回车符</span></span><br><span class="line">        <span class="built_in">putc</span>(<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>串口</category>
      </categories>
  </entry>
  <entry>
    <title>IIC总线</title>
    <url>/2024/08/27/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-%E5%85%B6%E4%BB%96-IIC%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<p>三轴陀螺仪的芯片 MPU-6050 芯片驱动是采用 IIC 总线协议和处理器进行通信。学习一下 IIC 总线的协议并总结在此：</p>
<p>处理器和芯片间的通信可以形象的比喻成两个人讲话：</p>
<ul>
<li>你说的别人得能听懂：双方约定信号的协议。</li>
<li>你的语速别人得能接受：双方满足时序要求。</li>
</ul>
<p> IIC 协议（传输数据的通道）：两条线可以挂多个设备。（只有主设备具有控制 SCL）</p>
<p>区分设备：IIC 设备里有个固化的地址。只有在两条线上传输的值等于 IIC 设备的地址时，才作出响应。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/17247264800004y3483.png" alt="gh"></p>
<p>开始信号：处理器让 SCL 时钟保持高电平，然后让 SDA 数据信号由高变低就表示一个开始信号。同时 IIC 总线上的设备检测到这个开始信号它就知道处理器要发送数据了。</p>
<p>停止信号：处理器让 SCL 时钟保持高电平，然后让 SDA 数据信号由低变高就表示一个停止信号。同时 IIC 总线上的设备检测到这个停止信号它就知道处理器已经结束了数据传输。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724726534000pmdl2w.png" alt="gh"></p>
<p>再看数据怎么传：SDA 上传输的数据必须在 SCL 为高电平期间保持稳定：因为外接 IIC 设备在 SCL 为高电平的期间采集数据方知 SDA 是高或低电平。SDA 上的数据只能在 SCL 为低电平期间翻转变化。</p>
<p>响应信号（ACK）：处理器把数据发给外接 IIC 设备，如何知道 IIC 设备数据已经收到呢？就需要外接 IIC 设备回应一个信号给处理器。处理器发完 8bit 数据后就不再驱动总线了（SDA 引脚变输入），而 SDA 和 SCL 硬件设计时都有上拉电阻，所以这时候 SDA 变成高电平。那么在第 8 个数据位，如果外接 IIC 设备能收到信号的话接着在第 9 个周期把 SDA 拉低，那么处理器检测到 SDA 拉低就能知道外接 IIC 设备数据已经收到。</p>
<p>IIC 数据从最高位开始传输。</p>
<p>多个设备挂载情况下如何访问其中一个设备而不影响其他设备</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1724726586000qwtpvz.png" alt="gh"></p>
<p>用 7bit 表示从地址，那么可以挂载的从设备数是 2 的 7 次方 128 个。处理器想写的话：先发送起始位，再发一个 8bit 数据：前 7bit 表示从地址，第 8bit 表示读或者写。0write 是处理器往 IIC 从设备发，1read 是 IIC 从设备往处理器发。第 9 个时钟周期回复响应信号。下面就以 AT24Cxx 为例详细说明一下：</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/17247265980002pzcuh.png" alt="gh"></p>
<p>首先发出一个 start 信号，从设备地址，R&#x2F;W（0，写），回应 ACK 表示有这个从设备存在。这时候是处理器从指定的从设备读数据的从设备里 8bit 存储地址的指定。所以这里 R&#x2F;W 是 0 为写。ACK 回应有这个设备的话，处理器把要访问的从设备里的 8bit 存储地址写好。ACK 对方回应。继续一个 start 信号+从设备地址，最低位是高电平表示读数据，回应 ACK 表示有这个从设备存在。在读数据的时候，每发出一个时钟，处理器会将 SDA 上的数据存起来。那么发出 8 个时钟后处理器就能得到 8 位的数据。这时候若想连续读就不断回应 ACK 信号否则就发出停止信号。</p>
<p>读的过程：</p>
<ul>
<li>start 信号，从设备地址，《写（ack），待读取存储地址（ack）》</li>
<li>start 信号，从设备地址，《读（ack），8 个时钟（no ack）》</li>
</ul>
<p>从设备就把对应的数据反馈给处理器。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/17247266170004avvxn.png" alt="gh"></p>
<ul>
<li>start 信号，从设备地址，写，紧跟连续两个字节的数据：要写的地址，对方收到 8bit 地址后回应 ACK，再 8bit 数据发给从设备，对方收到 8bit 数据后回应 ACK，处理器写完后发送停止信号。</li>
</ul>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Socket套接字</title>
    <url>/2024/05/20/2-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C-Socket%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<p>Socket 最初是作为网络上不同主机之间进程的通信接口，后来应用越来越广，在同一主机上的不同进程之间通信也可以用 Socket。</p>
<p>简单来说，当网络上不同主机之间的两个进程（A、B）采用 Socket 进行通信时，那么它们之间需要建立一个通信端点，即创建 Socket，创建 Socket 时就分配端口号和网络地址。当进程 A 向进程 B 发送数据时，那么进程 A 必须要知道进程 B 的网络地址及端口号。</p>
<p>Socket 采用 C&#x2F;S 模型进行设计的，即 Client&#x2F;Server，面向客户端—服务器模型。</p>
<p>每一个 Socket 都用一个半相关描述：</p>
<p>{协议，本地地址，本地端口}</p>
<p>一个完整的 Socket 则用一个相关描述:</p>
<p>{协议，本地地址，本地端口，远程地址，远程端口}</p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="字节流套接字（SOCK-STREAM）"><a href="#字节流套接字（SOCK-STREAM）" class="headerlink" title="字节流套接字（SOCK_STREAM）"></a>字节流套接字（SOCK_STREAM）</h2><p>字节流的套接字可以提供可靠的数据传输、面向连接的通讯流。数据按何种顺序发送，就按何种顺序接收。例如，当我们按顺序发送 A-B-C，那么在数据到达接收端时，它的顺序也是 A-B-C。字节流套接字采用的是 TCP（Transmission Control Protocol）协议。保证了数据传输的可靠性。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520132726.png" alt="image.png"></p>
<h2 id="数据报套接字（SOCK-DGRAM）"><a href="#数据报套接字（SOCK-DGRAM）" class="headerlink" title="数据报套接字（SOCK_DGRAM）"></a>数据报套接字（SOCK_DGRAM）</h2><p>数据报套接字定义了一种无连接的服务。所谓无连接服务，简单来说，即在发送数据时，无需在收发两端建立类似 TCP 那样的握手连接，在发送时，将数据打包，然后加上远程 IP 地址，即可把该数据包发送出去。</p>
<p>数据通过相互独立的报文进行传输。并且是无序的、不可靠的传输。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520132823.png" alt="image.png"></p>
<h2 id="原始套接字（SOCK-ROW）"><a href="#原始套接字（SOCK-ROW）" class="headerlink" title="原始套接字（SOCK_ROW）"></a>原始套接字（SOCK_ROW）</h2><p>先启动服务器，通过调用 socket() 函数建立一个套接字，然后调用 bind() 函数将该套接字和本地网络地址联系在一起，再调用 listen() 函数使套接字做好侦听的准备，并规定它的请求队列的长度，之后就调用 accept() 函数来接收连接。</p>
<p>客户端在建立套接字之后就可调用 connect() 和服务器建立连接。</p>
<p>连接一旦建立，客户端和服务器之间就可以通过调用 recv()&#x2F;recvfrom() 函数和 send()&#x2F;sendto 函数来进行发收数据。</p>
<p>最后，待数据传送结束后，双方调用 close() 函数关闭套接字。</p>
]]></content>
      <categories>
        <category>2.通讯协议</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>16-8禁食软件架构设计</title>
    <url>/2024/05/22/3-%E8%BD%AF%E4%BB%B6-0-%E9%A1%B9%E7%9B%AE-16-8%E7%A6%81%E9%A3%9F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用于记录每日的禁食时间，保证不间断禁食时间保持十六个小时</p>
<p>如何提供奖励机制</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p> - 点击按钮开始计时<br> - 再次点击按钮结束计时<br> - 期间中途如果 APP 有退出情况，应记录中途退出情况，并能够续写禁食时间</p>
<p>程序启动时，开始时读取上次的计时状态和禁食日志</p>
<p>如果之前的禁食状态未为结束，根据中间经过的时间间隔继续计时，接着开始禁食</p>
<p>否则进入正常流程，等待重新开始计时</p>
<p>点击开始计时后</p>
<p>判断日志中是否已经有今日的禁食时间，是否覆盖？</p>
<p>如果否，则不启动计时</p>
<p>如果是，则清除文件中已保存的禁食时间，启动定时器</p>
<p>定时器启动，实时写入当前的禁食数值及禁食状态</p>
<p> - 2023-07-26-10-10-10-1</p>
<p>点击结束计时后，</p>
<p>停止计时器</p>
<p>覆写当前时间和禁食时间以及禁食状态</p>
<p> - 2023-07-26-10-10-30-0</p>
<p>写入当前当前日期和禁食时间</p>
<p> - 2023-07-26-0-0-20</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>能够查询到每日的禁食时间</p>
<p> - 保存每日的禁食数据，如果有重复的禁食数据，弹窗提示，让用户选择哪条禁食数据有效</p>
<p> - 查询每日禁食数据，根据点击的日期显示禁食时长</p>
<p> - 表格显示禁食进度完成情况，绿色代表完成，红色代表未完成</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>建立每日目标及目标达成情况</p>
<p> - 表格显示每日目标及目标达成情况</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p> - 能够设置每日禁食时长<br> - 能够手动设立目标</p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>0.项目</category>
      </categories>
  </entry>
  <entry>
    <title>ETF小助手功能更新</title>
    <url>/2024/07/19/3-%E8%BD%AF%E4%BB%B6-0-%E9%A1%B9%E7%9B%AE-ETF%E5%B0%8F%E5%8A%A9%E6%89%8B%E5%8A%9F%E8%83%BD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<ol>
<li>管理功能，添加&#x2F;删除</li>
<li>计算功能，今日估值，持仓成本，</li>
<li>显示功能，显示当前估值和成本比较</li>
<li>历史记录，显示历史曲线</li>
<li>10 日&#x2F;20 日等均线</li>
<li>【×】北向资金&#x3D;&#x3D;&gt;实现方式</li>
</ol>
<p>API</p>
<h1 id="实时涨跌"><a href="#实时涨跌" class="headerlink" title="实时涨跌"></a>实时涨跌</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//fundgz.1234567.com.cn/js/007345.js?v=20200908175500</span></span><br></pre></td></tr></table></figure>

<p>数字为基金代码，rt 为时间戳，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">功能：获取基金实时信息，天天基金数据接口：http://fundgz.1234567.com.cn/js/基金代码.js</span></span><br><span class="line"><span class="comment">传入：基金代码</span></span><br><span class="line"><span class="comment">输出：基金实时信息 --&gt; dict</span></span><br><span class="line"><span class="comment">fundcode -- 基金代码</span></span><br><span class="line"><span class="comment">name     -- 基金名称</span></span><br><span class="line"><span class="comment">jzrqv    -- 上一交易日</span></span><br><span class="line"><span class="comment">dwjz     -- 基金净值（截止上一交易日）</span></span><br><span class="line"><span class="comment">gsz      -- 估算净值（实时）</span></span><br><span class="line"><span class="comment">gszzl    -- 估算涨幅（实时）</span></span><br><span class="line"><span class="comment">gztime   -- 更新时间（实时）</span></span><br><span class="line"><span class="comment">******/</span></span><br><span class="line"><span class="built_in">jsonpgz</span>(&#123;</span><br><span class="line">  <span class="string">&quot;fundcode&quot;</span>: <span class="string">&quot;007345&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;: &quot;</span>富国科技创新灵活配置混合<span class="string">&quot;,</span></span><br><span class="line"><span class="string">  &quot;</span>jzrq<span class="string">&quot;: &quot;</span><span class="number">2020</span><span class="number">-09</span><span class="number">-17</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">  &quot;</span>dwjz<span class="string">&quot;: &quot;</span><span class="number">1.9441</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">  &quot;</span>gsz<span class="string">&quot;: &quot;</span><span class="number">1.9717</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">  &quot;</span>gszzl<span class="string">&quot;: &quot;</span><span class="number">1.42</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">  &quot;</span>gztime<span class="string">&quot;: &quot;</span><span class="number">2020</span><span class="number">-09</span><span class="number">-18</span> <span class="number">15</span>:<span class="number">00</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>

<h1 id="基金净值数据"><a href="#基金净值数据" class="headerlink" title="基金净值数据"></a>基金净值数据</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&amp;code=007345&amp;page=1&amp;per=49&amp;sdate=2020-09-01&amp;edate=2020-09-18</span></span><br></pre></td></tr></table></figure>

<h1 id="基金列表"><a href="#基金列表" class="headerlink" title="基金列表"></a>基金列表</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//fund.eastmoney.com/js/fundcode_search.js</span></span><br></pre></td></tr></table></figure>

<p>返回数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var r = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;000001&quot;</span>,</span><br><span class="line">    <span class="string">&quot;HXCZHH&quot;</span>,</span><br><span class="line">    <span class="string">&quot;华夏成长混合&quot;</span>,</span><br><span class="line">    <span class="string">&quot;混合型&quot;</span>,</span><br><span class="line">    <span class="string">&quot;HUAXIACHENGZHANGHUNHE&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;000002&quot;</span>,</span><br><span class="line">    <span class="string">&quot;HXCZHH&quot;</span>,</span><br><span class="line">    <span class="string">&quot;华夏成长混合(后端)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;混合型&quot;</span>,</span><br><span class="line">    <span class="string">&quot;HUAXIACHENGZHANGHUNHE&quot;</span></span><br><span class="line">  ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="基金详情"><a href="#基金详情" class="headerlink" title="基金详情"></a>基金详情</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//fund.eastmoney.com/pingzhongdata/007345.js?v=20200908175500</span></span><br></pre></td></tr></table></figure>

<h1 id="基金公司列表"><a href="#基金公司列表" class="headerlink" title="基金公司列表"></a>基金公司列表</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//fund.eastmoney.com/js/jjjz_gs.js</span></span><br></pre></td></tr></table></figure>

<p>返回数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var gs=&#123;</span><br><span class="line">  op: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;80163340&quot;</span>,</span><br><span class="line">      <span class="string">&quot;安信基金&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;80036782&quot;</span>,</span><br><span class="line">      <span class="string">&quot;招商基金&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基金增幅排名"><a href="#基金增幅排名" class="headerlink" title="基金增幅排名"></a>基金增幅排名</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//fund.eastmoney.com/data/rankhandler.aspx?op=ph&amp;dt=kf&amp;ft=gp&amp;rs=&amp;gs=0&amp;sc=zzf&amp;st=desc&amp;sd=2016-03-29&amp;ed=2017-03-29&amp;qdii=&amp;tabSubtype=,,,,,&amp;pi=1&amp;pn=50&amp;dx=1&amp;v=0.6370068000914493</span></span><br></pre></td></tr></table></figure>

<p>ft： fund type 类型 所有-all 股票型-gp 混合型-hh 债券型-zq 指数型-zs 保本型-bb QDII-qdii LOF-lof</p>
<h1 id="当前基金净值"><a href="#当前基金净值" class="headerlink" title="当前基金净值"></a>当前基金净值</h1><p><a href="http://fundgz.1234567.com.cn/js/[%E5%9F%BA%E9%87%91%E4%BB%A3%E7%A0%81].js?rt=%5B%E6%97%B6%E9%97%B4%E6%88%B3%5D">http://fundgz.1234567.com.cn/js/[基金代码].js?rt=[时间戳]</a> （其中时间戳 rt 用于避免浏览器缓存数据，可省略）。</p>
<p>例如，<a href="http://fundgz.1234567.com.cn/js/001186.js%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E7%B1%BB%E4%BC%BC%E4%BA%8E%EF%BC%9Ajsonpgz">http://fundgz.1234567.com.cn/js/001186.js，返回的结果类似于：jsonpgz</a>({“fundcode”:”001186”,”name”:”富国文体健康股票”,”jzrq”:”2022-09-20”,”dwjz”:”1.9300”,”gsz”:”1.9187”,”gszzl”:”-0.58”,”gztime”:”2022-09-21 15:00”});。这是一个文本数据，需要进一步处理。可以使用 Python 中的 requests、re、json 等库进行处理，将文本转化为字典格式，以便提取所需信息，代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">import</span> requests</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> json</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> re</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">realtmfundinfo</span><span class="params">(fundcode)</span>:</span></span><br><span class="line"><span class="function">    fund_id =</span> fundcode</span><br><span class="line">    real_time_url = f<span class="string">&quot;http://fundgz.1234567.com.cn/js/&#123;fund_id&#125;.js&quot;</span></span><br><span class="line">    org_content = requests.<span class="built_in">get</span>(real_time_url)</span><br><span class="line">    fund_info = org_content.text</span><br><span class="line">    fund_info = re.<span class="built_in">findall</span>(r<span class="string">&quot;\&#123;.+\&#125;&quot;</span>, fund_info)</span><br><span class="line">    fund_info = json.<span class="built_in">loads</span>(fund_info[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> fund_info</span><br><span class="line"></span><br><span class="line">fund_info = <span class="built_in">realtmfundinfo</span>(<span class="string">&quot;001186&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fund_info)</span><br></pre></td></tr></table></figure>

<h1 id="历史基金净值"><a href="#历史基金净值" class="headerlink" title="历史基金净值"></a>历史基金净值</h1><p><a href="http://fund.eastmoney.com/pingzhongdata/[%E5%9F%BA%E9%87%91%E4%BB%A3%E7%A0%81].js?v=%5B%E6%97%B6%E9%97%B4%E6%88%B3%5D">http://fund.eastmoney.com/pingzhongdata/[基金代码].js?v=[时间戳]</a> （时间戳 v 可省略）。</p>
<p>例如，<a href="http://fund.eastmoney.com/pingzhongdata/001186.js%EF%BC%8C%E5%8F%AF%E8%8E%B7%E5%8F%96%E8%AF%A5%E5%9F%BA%E9%87%91%E7%9A%84%E7%94%B3%E8%B4%AD%E8%B4%B9%E7%8E%87%E3%80%81%E6%8C%81%E4%BB%93%E8%82%A1%E7%A5%A8%E3%80%81%E5%8E%86%E5%8F%B2%E5%8D%95%E4%BD%8D%E5%87%80%E5%80%BC%E3%80%81%E5%8E%86%E5%8F%B2%E7%B4%AF%E8%AE%A1%E5%87%80%E5%80%BC%E7%AD%89%E5%A4%9A%E4%B8%AA%E4%BF%A1%E6%81%AF%E3%80%82%E8%BF%94%E5%9B%9E%E5%9F%BA%E9%87%91%E7%9A%84%E5%87%80%E5%80%BC%E6%97%A5%E6%9C%9F%EF%BC%88date%EF%BC%89%E3%80%81%E5%8D%95%E4%BD%8D%E5%87%80%E5%80%BC%EF%BC%88nav%EF%BC%89%E3%80%81%E7%B4%AF%E8%AE%A1%E5%87%80%E5%80%BC(cumnav)%E3%80%81%E5%87%80%E5%80%BC%E5%9B%9E%E6%8A%A5%E7%8E%87(equityReturn)%E3%80%81%E6%AF%8F%E4%BB%BD%E6%B4%BE%E9%80%81%E9%87%91(unitMoney).%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E7%9A%84%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9A%84">http://fund.eastmoney.com/pingzhongdata/001186.js，可获取该基金的申购费率、持仓股票、历史单位净值、历史累计净值等多个信息。返回基金的净值日期（date）、单位净值（nav）、累计净值(cumnav)、净值回报率(equityReturn)、每份派送金(unitMoney).处理返回的文本数据的</a> Python 代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">import</span> requests</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> json</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> re</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> pandas as pd</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">htrfundinfo</span><span class="params">(fundcode)</span>:</span></span><br><span class="line"><span class="function">    fund_id =</span> fundcode</span><br><span class="line">    history_tmurl = f<span class="string">&quot;http://fund.eastmoney.com/pingzhongdata/&#123;fund_id&#125;.js&quot;</span></span><br><span class="line">    org_content = requests.<span class="built_in">get</span>(history_tmurl)</span><br><span class="line">    fund_info = org_content.text</span><br><span class="line">    # 提取单位净值</span><br><span class="line">    temp_nav = re.<span class="built_in">findall</span>(r<span class="string">&quot;data_networthtrend\s=\s(\(\&#123;.+\&#125;\));\/\*累计净值走势\*\/&quot;</span>, fund_info)[<span class="number">0</span>]</span><br><span class="line">    temp_nav = json.<span class="built_in">loads</span>(temp_nav)</span><br><span class="line">    temp_nav = pd.<span class="built_in">DataFrame</span>(temp_nav)</span><br><span class="line">    temp_nav.<span class="built_in">rename</span>(columns=&#123;<span class="string">&quot;x&quot;</span>:<span class="string">&quot;date&quot;</span>,<span class="string">&quot;y&quot;</span>:<span class="string">&quot;nav&quot;</span>&#125;, inplace=True)</span><br><span class="line">    n = <span class="built_in">len</span>(temp_nav[<span class="string">&quot;date&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">        temp_nav[<span class="string">&quot;date&quot;</span>][i] = time.<span class="built_in">strftime</span>(<span class="string">&#x27;%y-%m-%d&#x27;</span>, time.<span class="built_in">localtime</span>(temp_nav[<span class="string">&quot;date&quot;</span>][i]/<span class="number">1000.</span>))</span><br><span class="line">    temp_nav = temp_nav.<span class="built_in">set_index</span>(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">    # 提取累计净值</span><br><span class="line">    temp_cumnav = re.<span class="built_in">findall</span>(r<span class="string">&quot;data_acworthtrend\s=\s(\(.+\));\/\*累计收益率走势\*\/&quot;</span>, fund_info)[<span class="number">0</span>]</span><br><span class="line">    temp_cumnav = <span class="built_in">eval</span>(temp_cumnav) </span><br><span class="line">    <span class="keyword">return</span> temp_nav</span><br><span class="line"></span><br><span class="line">fund_nav = <span class="built_in">htrfundinfo</span>(<span class="string">&quot;001186&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fund_nav)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>0.项目</category>
      </categories>
  </entry>
  <entry>
    <title>云电脑性能</title>
    <url>/2024/08/23/3-%E8%BD%AF%E4%BB%B6-0-%E9%A1%B9%E7%9B%AE-%E4%BA%91%E7%94%B5%E8%84%91%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>参数</th>
<th>海马云</th>
<th>ToDesk</th>
<th>网易云游戏</th>
<th>腾讯 START</th>
<th>海星云</th>
<th>顺网云电脑</th>
<th>极云普惠云电脑</th>
</tr>
</thead>
<tbody><tr>
<td>云 (电脑&#x2F;游戏) 名称</td>
<td>海马云</td>
<td>ToDesk</td>
<td>网易云游戏</td>
<td>腾讯 START</td>
<td>海星云</td>
<td>顺网云电脑</td>
<td>极云普惠云电脑</td>
</tr>
<tr>
<td>运行平台</td>
<td>PC&#x2F;安卓</td>
<td>PC&#x2F;安卓</td>
<td>PC&#x2F;安卓&#x2F;TV</td>
<td>PC&#x2F;安卓&#x2F;TV</td>
<td>PC&#x2F;安卓&#x2F;TV</td>
<td>pc&#x2F;安卓</td>
<td>pc&#x2F;安卓&#x2F;ios</td>
</tr>
<tr>
<td>游戏库</td>
<td>500+</td>
<td>自带游戏</td>
<td>排队严重</td>
<td>WeGame 游戏居多</td>
<td>300+</td>
<td>200+</td>
<td>200+</td>
</tr>
<tr>
<td>配置</td>
<td>12700kf+4090</td>
<td>8 核 16 线程+RTX 3060</td>
<td>高端配置</td>
<td></td>
<td>10 代 i5+RTX 3070</td>
<td>12 代 i5+4070&#x2F;10 代 i5+2060s</td>
<td>10 代 i5+2060&#x2F;12 代 i5+3060Ti 或 4070</td>
</tr>
<tr>
<td>最高卡支持</td>
<td>4090</td>
<td>3060</td>
<td>未知</td>
<td></td>
<td>3070</td>
<td>4070</td>
<td>4070</td>
</tr>
<tr>
<td>默认支持最高分辨率</td>
<td>4K</td>
<td>2K 144Hz</td>
<td>未知</td>
<td>1080p</td>
<td>4K</td>
<td>2K</td>
<td>1080p</td>
</tr>
<tr>
<td>内存</td>
<td>64G&#x2F;32G</td>
<td>32G</td>
<td>未知</td>
<td>依赖云端配置</td>
<td>32G</td>
<td>32G</td>
<td>32G&#x2F;16G</td>
</tr>
<tr>
<td>延迟</td>
<td>低</td>
<td>低</td>
<td>未知</td>
<td>超低</td>
<td>低</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>资费</td>
<td>2.4 元&#x2F;小时 420~1020 金币&#x2F;小时</td>
<td>1.98 ~ 3.6 元&#x2F;小时</td>
<td>180 云币&#x2F;小时</td>
<td>未知</td>
<td>4 ~ 6 元&#x2F;小时</td>
<td>1.6 ~ 4 元&#x2F;小时</td>
<td>2.7 ~ 4 元&#x2F;小时（冲 50 ）</td>
</tr>
<tr>
<td>综合评分</td>
<td>⭐⭐⭐</td>
<td>⭐⭐⭐</td>
<td>⭐⭐</td>
<td>⭐⭐</td>
<td>⭐⭐</td>
<td>⭐⭐</td>
<td>⭐⭐</td>
</tr>
<tr>
<td>主页网址</td>
<td><a href="https://pc.haimacloud.com/">海马云</a></td>
<td><a href="https://www.todesk.com/">ToDesk</a></td>
<td><a href="https://cg.163.com/">网易云游戏</a></td>
<td><a href="https://start.qq.com/">腾讯START</a></td>
<td><a href="https://www.haixingcloud.com/#/Home">海星云</a></td>
<td><a href="https://cpc.icloud.cn/">顺网云电脑</a></td>
<td><a href="https://www.ji-cloud.cn/">极云普惠云电脑</a></td>
</tr>
</tbody></table>
<p>青椒云 支持 PC&#x2F;安卓&#x2F;IOS</p>
<p>另有<em>不适用于游戏服务或者可能服务已经关闭</em>的尚未介绍的有以下平台：</p>
<ul>
<li>虎牙 YOWA 云游戏</li>
<li>达龙云游戏</li>
<li>咪咕快游</li>
<li>蘑菇云游戏						</li>
<li>易云咖	</li>
<li>领沃云游戏	</li>
<li>小悟云			</li>
<li>鲸云游戏		</li>
<li>菜鸡云游戏				</li>
<li>天翼云游戏</li>
</ul>
<p>国外有</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>GeForce NOW</th>
<th>Xbox Cloud Gaming</th>
<th>Shadow</th>
<th>Amazon Luna</th>
<th>PlayStation Plus</th>
<th>Boosteroid</th>
<th>网易云游戏</th>
<th>腾讯 START</th>
</tr>
</thead>
<tbody><tr>
<td>云游戏名称</td>
<td>GeForce NOW</td>
<td>Xbox Cloud Gaming (xCloud)</td>
<td>Shadow</td>
<td>Amazon Luna</td>
<td>PlayStation Plus Premium</td>
<td>Boosteroid</td>
<td>网易云游戏</td>
<td>腾讯 START</td>
</tr>
<tr>
<td>运行平台</td>
<td>PC&#x2F;Mac&#x2F;Android&#x2F;iOS&#x2F;智能电视 Xbox&#x2F;PC&#x2F;Android&#x2F;iOS</td>
<td>PC&#x2F;Mac&#x2F;Android&#x2F;iOS</td>
<td>PC&#x2F;Mac&#x2F;Android&#x2F;iOS&#x2F;Fire TV</td>
<td>PS4&#x2F;PS5&#x2F;PC</td>
<td>PC&#x2F;Mac&#x2F;Android&#x2F;iOS</td>
<td>Android&#x2F;iOS&#x2F;PC</td>
<td>Android&#x2F;iOS&#x2F;PC</td>
<td></td>
</tr>
<tr>
<td>游戏库</td>
<td>1500+</td>
<td>350+</td>
<td>自带游戏</td>
<td>100+</td>
<td>800+</td>
<td>400+</td>
<td>100+</td>
<td>100+</td>
</tr>
<tr>
<td>最高分辨率</td>
<td>4K&#x2F;60fps</td>
<td>1080p&#x2F;60fps</td>
<td>4K&#x2F;60fps</td>
<td>1080p&#x2F;60fps</td>
<td>1080p&#x2F;60fps</td>
<td>1080p&#x2F;60fps</td>
<td>1080p&#x2F;60fps</td>
<td>1080p&#x2F;60fps</td>
</tr>
<tr>
<td>延迟</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>中</td>
<td>低</td>
<td>中</td>
<td>未知</td>
<td>低</td>
</tr>
<tr>
<td>功能</td>
<td>游戏&#x2F;跨平台同步</td>
<td>游戏&#x2F;跨平台同步</td>
<td>完整 PC 体验</td>
<td>游戏&#x2F;Twitch 集成</td>
<td>游戏&#x2F;PS 独占</td>
<td>游戏</td>
<td>游戏</td>
<td>游戏</td>
</tr>
<tr>
<td>月费 (美元)</td>
<td>$9.99-$19.99</td>
<td>$14.99 (Game Pass Ultimate)</td>
<td>$29.99</td>
<td>$9.99</td>
<td>$17.99</td>
<td>$9.99</td>
<td>¥59 (~$8)</td>
<td>按时计费</td>
</tr>
<tr>
<td>数据中心</td>
<td>全球 30+</td>
<td>全球 26 个地区</td>
<td>美国&#x2F;欧洲</td>
<td>美国</td>
<td>未公开</td>
<td>欧洲&#x2F;北美</td>
<td>中国</td>
<td>中国</td>
</tr>
<tr>
<td>综合评分</td>
<td>9&#x2F;10</td>
<td>8.5&#x2F;10</td>
<td>8&#x2F;10</td>
<td>7.5&#x2F;10</td>
<td>8&#x2F;10</td>
<td>7.5&#x2F;10</td>
<td>7&#x2F;10</td>
<td>7&#x2F;10</td>
</tr>
</tbody></table>
<p>注意:</p>
<ol>
<li>评分和部分技术细节可能因个人体验和网络条件而异。</li>
<li>价格可能会随时间变化,建议查看最新官方定价。</li>
<li>游戏库数量可能会随时间增减,数据仅供参考。</li>
</ol>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>0.项目</category>
      </categories>
  </entry>
  <entry>
    <title>基于Qt的RSS阅读器开发</title>
    <url>/2024/07/12/3-%E8%BD%AF%E4%BB%B6-0-%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8EQt%E7%9A%84RSS%E9%98%85%E8%AF%BB%E5%99%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="什么是-RSS"><a href="#什么是-RSS" class="headerlink" title="什么是 RSS"></a>什么是 RSS</h1><h1 id="RSS-语法"><a href="#RSS-语法" class="headerlink" title="RSS 语法"></a>RSS 语法</h1><table>
<thead>
<tr>
<th align="center">channel 元素</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;category&gt;</code></td>
<td align="center">可选的。为 feed 定义所属的一个或多个种类。</td>
</tr>
<tr>
<td align="center"><code>&lt;cloud&gt;</code></td>
<td align="center">可选的。注册进程，以获得 feed 更新的立即通知。</td>
</tr>
<tr>
<td align="center"><code>&lt;copyright&gt;</code></td>
<td align="center">可选。告知版权资料。</td>
</tr>
<tr>
<td align="center"><code>&lt;description&gt;</code></td>
<td align="center">必需的。描述频道。</td>
</tr>
<tr>
<td align="center"><code>&lt;docs&gt;</code></td>
<td align="center">可选的。规定指向当前 RSS 文件所用格式说明的 URL。</td>
</tr>
<tr>
<td align="center"><code>&lt;generator&gt;</code></td>
<td align="center">可选的。规定用于生成 feed 的程序。</td>
</tr>
<tr>
<td align="center"><code>&lt;image&gt;</code></td>
<td align="center">可选的。在聚合器呈现某个 feed 时，显示一个图像。</td>
</tr>
<tr>
<td align="center"><code>&lt;language&gt;</code></td>
<td align="center">可选的。规定编写 feed 所用的语言。</td>
</tr>
<tr>
<td align="center"><code>&lt;lastBuildDate&gt;</code></td>
<td align="center">可选的。定义 feed 内容的最后修改日期。</td>
</tr>
<tr>
<td align="center"><code>&lt;link&gt;</code></td>
<td align="center">必需的。定义指向频道的超链接。</td>
</tr>
<tr>
<td align="center"><code>&lt;managingEditor&gt;</code></td>
<td align="center">可选的。定义 feed 内容编辑的电子邮件地址。</td>
</tr>
<tr>
<td align="center"><code>&lt;pubDate&gt;</code></td>
<td align="center">可选的。为 feed 的内容定义最后发布日期。</td>
</tr>
<tr>
<td align="center"><code>&lt;rating&gt;</code></td>
<td align="center">可选的。feed 的 PICS 级别。</td>
</tr>
<tr>
<td align="center"><code>&lt;skipDays&gt;</code></td>
<td align="center">可选的。规定忽略 feed 更新的天。</td>
</tr>
<tr>
<td align="center"><code>&lt;skipHours&gt;</code></td>
<td align="center">可选的。规定忽略 feed 更新的小时。</td>
</tr>
<tr>
<td align="center"><code>&lt;textInput&gt;</code></td>
<td align="center">可选的。规定应当与 feed 一同显示的文本输入域。</td>
</tr>
<tr>
<td align="center"><code>&lt;title&gt;</code></td>
<td align="center">必需的。定义频道的标题。</td>
</tr>
<tr>
<td align="center"><code>&lt;ttl&gt;</code></td>
<td align="center">可选的。指定从 feed 源更新此 feed 之前，feed 可被缓存的分钟数。</td>
</tr>
<tr>
<td align="center"><code>&lt;webMaster&gt;</code></td>
<td align="center">可选的。定义此 feed 的 web 管理员的电子邮件地址。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">item 元素</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;author&gt;</code></td>
<td align="center">可选的。规定项目作者的电子邮件地址。</td>
</tr>
<tr>
<td align="center"><code>&lt;category&gt;</code></td>
<td align="center">可选的。定义项目所属的一个或多个类别。</td>
</tr>
<tr>
<td align="center"><code>&lt;comments&gt;</code></td>
<td align="center">可选的。允许项目连接到有关此项目的注释（文件）。</td>
</tr>
<tr>
<td align="center"><code>&lt;description&gt;</code></td>
<td align="center">必需的。描述此项目。</td>
</tr>
<tr>
<td align="center"><code>&lt;enclosure&gt;</code></td>
<td align="center">可选的。允许将一个媒体文件导入一个项中。</td>
</tr>
<tr>
<td align="center"><code>&lt;guid&gt;</code></td>
<td align="center">可选的。为项目定义一个唯一的标识符。</td>
</tr>
<tr>
<td align="center"><code>&lt;link&gt;</code></td>
<td align="center">必需的。定义指向此项目的超链接。</td>
</tr>
<tr>
<td align="center"><code>&lt;pubDate&gt;</code></td>
<td align="center">可选的。定义此项目的最后发布日期。</td>
</tr>
<tr>
<td align="center"><code>&lt;source&gt;</code></td>
<td align="center">可选的。为此项目指定一个第三方来源。</td>
</tr>
<tr>
<td align="center"><code>&lt;title&gt;</code></td>
<td align="center">必需的。定义此项目的标题。</td>
</tr>
</tbody></table>
<h1 id="RSS-阅读器功能"><a href="#RSS-阅读器功能" class="headerlink" title="RSS 阅读器功能"></a>RSS 阅读器功能</h1><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><pre><code>**字体**
**字号**
**背景**
**翻页**
</code></pre>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code>**缩放**
**移动**
**下载**
</code></pre>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><pre><code>**播放/暂停**
**快进**
**进度条**
**音量**
**下载**
</code></pre>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><pre><code>**订阅**
**自动/手动同步**
</code></pre>
<h1 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h1><h2 id="多线程处理等待消息返回"><a href="#多线程处理等待消息返回" class="headerlink" title="多线程处理等待消息返回"></a>多线程处理等待消息返回</h2><h2 id="xml-文件本地缓存的命名方式"><a href="#xml-文件本地缓存的命名方式" class="headerlink" title="xml 文件本地缓存的命名方式"></a>xml 文件本地缓存的命名方式</h2><p>eg. <a href="https://rsshub.app/6v123/latestMovies">https://rsshub.app/6v123/latestMovies</a></p>
<p>&#x3D;&#x3D;&#x3D;&gt;&#96;6v123_latestMovies</p>
<p>eg. <a href="https://rsshub.app/t66y/20/2">https://rsshub.app/t66y/20/2</a></p>
<p>&#x3D;&#x3D;&#x3D;&gt;&#96;t66y_20_2</p>
<h2 id="页面元素布局"><a href="#页面元素布局" class="headerlink" title="页面元素布局"></a>页面元素布局</h2><p>根据实际返回的页面元素，分别显示不同的页面</p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>0.项目</category>
      </categories>
  </entry>
  <entry>
    <title>游戏架构</title>
    <url>/2024/05/22/3-%E8%BD%AF%E4%BB%B6-0-%E9%A1%B9%E7%9B%AE-%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>solaRTS 的设计架构</p>
<p>目标类</p>
<ul>
<li>地图类</li>
<li>生产类</li>
<li>子弹类</li>
</ul>
<p>主程序</p>
<ul>
<li>关卡&#x2F;得分基础属性</li>
<li>游戏窗口加载</li>
<li>地图绘制</li>
<li>坐标点初始化</li>
<li>友军加载</li>
<li>敌军加载</li>
<li>子弹加载</li>
<li>事件加载</li>
<li>开始游戏</li>
<li>结束游戏</li>
</ul>
<p>玩法<br>长按屏幕弹出菜单，创建</p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>0.项目</category>
      </categories>
  </entry>
  <entry>
    <title>3D打印控制命令</title>
    <url>/2024/05/21/3-%E8%BD%AF%E4%BB%B6-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="限位开关"><a href="#限位开关" class="headerlink" title="限位开关"></a>限位开关</h1><p>确保 X、Y 和 Z 轴的限位开关都没有被触发，然后通过控制台发送命令：</p>
<p><code>QUERY_ENDSTOPS</code></p>
<p>返回值是 <code>open</code> 打开，则限位触发电平类型设置正确，如果是 <code>triggered</code>（触发），则需要修改限位的电平类型（以 X 轴为例）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[stepper_X]</span><br><span class="line">endstop_pin: ^PE5   #修改前</span><br><span class="line">endstop_pin: ^!PE5    #修改后</span><br></pre></td></tr></table></figure>

<h1 id="热床-PID-校正"><a href="#热床-PID-校正" class="headerlink" title="热床 PID 校正"></a>热床 PID 校正</h1><p>G28 归零后，将喷嘴移至热床中心，高出床面约 5-10mm，然后发送命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PID_CALIBRATE HEATER=heater_bed TARGET=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>它将执行一个 PID 校准程序，将持续约 10 分钟，完成后控制台将会返回 PID 数值，将其复制到热床的 PID 设置即可。</p>
<h1 id="挤出头-PID-校正"><a href="#挤出头-PID-校正" class="headerlink" title="挤出头 PID 校正"></a>挤出头 PID 校正</h1><p>先将模型冷却风扇设置为 25% 的转速 <code>M106 S64</code> ，然后发送命令</p>
<p><code>PID_CALIBRATE HEATER=extruder TARGET=245</code></p>
<p>它将执行一个 PID 校准程序，将持续约 5 分钟，完成后控制台将返回 PID 数值，将其复制到配置文件即可。</p>
<h2 id="GCode-协议指令"><a href="#GCode-协议指令" class="headerlink" title="GCode 协议指令"></a>GCode 协议指令</h2><p>Klipper  G-Code 协议指令 <a href="https://www.klipper3d.org/G-Codes.html">https://www.klipper3d.org/G-Codes.html</a></p>
<p>marlin G-Code 协议指令 <a href="https://marlinfw.org/meta/gcode/">https://marlinfw.org/meta/gcode/</a></p>
<p><strong>部分我使用到的命令</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M112</td>
<td align="center">使 Klipper 进入 “shutdown”（关闭）状态</td>
</tr>
<tr>
<td align="center">FIRMWARE_RESTART</td>
<td align="center">重新加载配置文件并重启</td>
</tr>
<tr>
<td align="center">SAVE_CONFIG</td>
<td align="center">保存配置文件</td>
</tr>
<tr>
<td align="center">GET_POSITION</td>
<td align="center">获取位置</td>
</tr>
<tr>
<td align="center"><code>ps -ef | grep klippy</code></td>
<td align="center">查看使用的 printer.cfg 文件位置</td>
</tr>
<tr>
<td align="center"><code>QUAD_GANTRY_LEVEL</code></td>
<td align="center">调平</td>
</tr>
</tbody></table>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133821.png" alt="image_c7a7cda2a2274479a4842a06aa6ee475.png"></p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>3D打印机</category>
      </categories>
  </entry>
  <entry>
    <title>3D打印机环境配置</title>
    <url>/2024/05/30/3-%E8%BD%AF%E4%BB%B6-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="3D-打印机"><a href="#3D-打印机" class="headerlink" title="3D 打印机"></a>3D 打印机</h1><p>3D 打印（3D printing）是一种快速成型技术，也被称为添加制造（Additive Manufacturing，AM）。它是一种通过将材料逐层叠加以构建三维实体物体的过程。与传统的制造方法不同，3D 打印不需要模具或切削工具，而是通过从计算机辅助设计（CAD）模型中生成的数字模型直接创建物体。</p>
<p><strong>FDM（熔融沉积成型）</strong>：FDM 是目前最常见的 3D 打印技术，它使用热塑性材料通过打印头喷出的方式逐层堆积，最终形成所需的物体。FDM 打印机的结构和控制系统比较简单，价格也比较实惠，因此广泛应用于家庭、办公室和教育等领域。</p>
<p><strong>SLA（光固化成型）</strong>：SLA 使用紫外线激光器或 LED 光源照射光敏树脂，使其逐层固化成为所需的物体。SLA 打印机的精度和表面光滑度比 FDM 更高，但价格也更贵。</p>
<p><strong>SLS（选择性激光烧结）</strong>：SLS 使用激光束将热塑性粉末烧结在一起，逐层堆积形成所需的物体。SLS 打印机可以使用多种材料，可以打印出更复杂的结构，但价格也更昂贵。</p>
<p><strong>DLP（数字光处理）</strong>：DLP 使用光敏树脂和数字投影仪，通过投影仪将光固化在涂层的树脂上，逐层堆积形成所需的物体。DLP 打印机的速度和精度都比较高，但价格也较贵。</p>
<h1 id="FDM"><a href="#FDM" class="headerlink" title="FDM"></a>FDM</h1><p>通过将加热的材料挤出打印头，逐层堆积形成打印件</p>
<ul>
<li>打印头</li>
<li>打印床&#x2F;热床</li>
<li>控制系统（主板、电机、传感器和用户界面）</li>
<li>打印材料</li>
<li>G-Code<ul>
<li>一种用于控制数控机床（包括 3D 打印机、数控铣床、数控车床等）运动和操作的编程语言。</li>
</ul>
</li>
</ul>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>结构主要分为两部分：</p>
<ul>
<li>一个负责三维空间的移动的组件 (三维移动部分)</li>
<li>一个负责进料、融化材料和挤出材料的组件（挤出部分）</li>
</ul>
<p>打印时材料会一层又一层地堆积在之前已经「挤出来」的材料上，所以在这两个组件共同协作下就能打印出一个完成的 3D 物体了。</p>
<h2 id="结构-三维移动部分"><a href="#结构-三维移动部分" class="headerlink" title="结构 - 三维移动部分"></a>结构 - 三维移动部分</h2><p>打印机在 3D 的空间运动的传动方式有很多种，一般较为便宜的打印机会选择笛卡尔结构。笛卡尔结构指的是 X Y Z 方向上的运动是独立的，这种方式比较直观，结构也比较简单。常用的 3D 打印机的结构有以下几种：</p>
<p><strong>Prusa i3 型：</strong><br>控制 X&#x2F;Z 轴，Y 轴通过工作台的移动来实现。<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522114837.png" alt="image-1689840246601.png"><br><strong>CoreXY 型：</strong><br>CoreXY 最大的特别之处在于其 X、Y 电机是协同运作的，并且它的同步带在不同同步轮的摆放下能够形成多种不一样的缠绕方法。由于两个电机的协同运动，电机带动的力比单一电机的力要大，且会减少在 XY 方向面上的一个电机重量，提高精准性。<br>**<strong>CoreXY 结构</strong>：CoreXY 结构采用的是两个电机通过传动带和滑块来实现打印头的运动，其中 X 和 Y 轴的传动带交叉布置，使得打印头的运动方向可以在 X 和 Y 轴上独立控制。CoreXY 结构的优点是打印速度快，同时打印头的重量对定位精度的影响较小，同时可以实现较大的打印范围。缺点是结构复杂，需要更多的零件和更高的制造精度，同时维护和升级也较为困难。<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133729.png" alt="image.png"></p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522114901.png" alt="image-1689840339161.png"></p>
<p><strong>Um &#x2F;Ultimaker 型：</strong><br>X 轴、Y 轴的电机都在静止的框架上，但挤出头在两个互相垂直的光轴的交叉处。<br>**<strong>UM 结构（Ultimaker 结构）</strong>：UM 结构采用的是直线轴承和滑块来实现运动，其中 X 和 Y 轴分别由两个电机驱动，通过传动带和滑块来实现打印头的运动。UM 结构的优点是定位精度高，速度快，同时结构简单，易于维护和升级。缺点是打印头的质量和稳定性对定位精度有较大影响，同时打印头的重量也会影响打印速度。<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522114935.png" alt="image-1689840409065.png"></p>
<p><strong>MB：</strong><br>主要体现在挤出电机一般都装在喷头旁，近程进丝，双光轴承载挤出组件，X 方向的运动一般是通过电机带动同步带，通过带传动使两边一起运动。</p>
<p><strong>delta 三角洲（并联臂）型</strong></p>
<h2 id="结构-挤出部分"><a href="#结构-挤出部分" class="headerlink" title="结构 - 挤出部分"></a>结构 - 挤出部分</h2><p>挤出部分分为以下：</p>
<ul>
<li>挤出头</li>
<li>送料步进电机</li>
<li>送料步进电机驱动板</li>
</ul>
<p>FDM 3D 打印机除了怎么动的很关键以外，怎么取料、融化材料、挤出材料也非常重要。</p>
<p>其中取料和挤出材料是由挤出机处理的，融化材料则是由热端处理的。</p>
<p>挤出机从材料盘中将材料拉出来，送进去热端融化。</p>
<p>并持续往热端送更多的料让融化的材料从喷嘴中挤出来。</p>
<ul>
<li>其中挤出机的精度和挤出的速度决定了打印质量和速度。精度高意味着可以更好的控制挤出的量。挤出的材料太多或者太少对打印的质量影响都非常大。挤出的速度快就很直接的决定了你能打印多快。</li>
</ul>
<p>而影响挤出机的精度和速度的两个关键因素就是：</p>
<ul>
<li>挤出机的类型</li>
<li>挤出机的齿轮数量</li>
</ul>
<p>FDM 挤出机分为两个大类：</p>
<ul>
<li>远端挤出机（鲍登挤出机）<ul>
<li>优点<ul>
<li>轻量化喷头：由于挤出机和步进电机位于机器外壳，喷头的重量较轻，惯性小，能够实现更高的移动速度（可达 200~300mm&#x2F;s），因此适合高速打印。</li>
<li>精准定位：轻量的喷头使得定位更为精准，适合需要高精度的打印任务。</li>
</ul>
</li>
<li>缺点<ul>
<li>送料阻力大：由于送料距离较远，材料在特氟龙管中的摩擦阻力较大，要求步进电机具备更大的力矩，增加了电机的负担。</li>
<li>回抽不精准：在高速打印时，远端挤出机的回抽距离和速度要求较大，导致在使用弹性材料时可能出现输送不畅的情况。</li>
<li>维护复杂：由于挤出机与喷头分离，连接部分（如特氟龙管和气动接头）容易出现故障，维护相对复杂。</li>
</ul>
</li>
</ul>
</li>
<li>近端挤出机（直接挤出机）<ul>
<li>优点<ul>
<li>精准控制：近端挤出机对送料量的控制更为精确，回抽也更为精准，适合高速打印时的细节处理。</li>
<li>低力矩要求：对步进电机的力矩要求相对较低，能够在高速情况下保持稳定的挤出性能。</li>
<li>换料方便：由于结构紧凑，换料过程相对简单，适合频繁更换材料的应用场景。</li>
</ul>
</li>
<li>缺点<ul>
<li>重量问题：喷头较重，尤其是在双喷头打印机中，增加了运动时的惯性，可能导致加速和减速困难，从而影响打印精度。</li>
<li>维护不便：喷头、挤出机和步进电机集成在一起，拆装和维护相对不便。</li>
<li>压力影响：较重的喷头对光轴或导轨的压力较大，可能导致长时间使用后出现的调平困难.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>另外一个影响挤出机精度的就是挤出机的齿轮了。较低端的机器一般都是配备都是单齿轮，虽然对比双齿轮的挤出机，无论是对材料的咬合能力还是挤出精度都表现更差，但它便宜而且工作，对于预算相对比较紧张的朋友是一个不错的选择。</p>
<h2 id="传动系统"><a href="#传动系统" class="headerlink" title="传动系统"></a>传动系统</h2><p>传动系统分为以下几个部分：</p>
<ul>
<li>Xyz 步进电机</li>
<li>限位开关</li>
<li>步进电机驱动板</li>
<li>同步带</li>
</ul>
<p>传动系统是 3D 打印机中负责移动打印头（或喷嘴）和打印平台的机械组件。它在 3D 打印过程中发挥以下作用：</p>
<ul>
<li>控制位置：传动系统通过精确的运动控制，将打印头定位在正确的位置，以便在每个层次上精确地添加材料。</li>
<li>三维定位：传动系统的运动控制使得打印头可以在 X、Y、Z 三个方向上精确移动，从而实现三维打印。</li>
<li>打印速度：传动系统的运动控制还影响到打印速度。更快的传动系统能够加快打印速度，但需要保持精确性和稳定性，以确保打印质量不受影响。</li>
<li>自动校准：一些高级的传动系统具备自动校准功能，能够自动检测打印平台和打印头的位置，从而保持打印的准确性和稳定性。</li>
</ul>
<h2 id="加热部分"><a href="#加热部分" class="headerlink" title="加热部分"></a>加热部分</h2><p>加热部分分为以下：</p>
<ul>
<li>热床</li>
<li>MOS 管</li>
</ul>
<p>打印机的热床就是用来承载挤出机挤出来的材料。是 3D 打印机上的一个移动平台，用于支撑正在打印的物体。其主要作用如下：</p>
<ul>
<li>粘附和稳定：打印平台上的特殊表面或涂层（例如热床、胶水、胶带等）可以提供粘附性，确保打印的第一层材料牢固地附着在平台上，并防止其在打印过程中发生位移或变形。<br>   - 塑料在不同的温度下粘性不一样，控制床的温度可以让不同的塑料在保持形状的同时达到最大的粘性。如果温度太高则有可让打印的形状变形，温度太低则有可能让打印的材料不粘床。床的温度和热端的温度共同决定了可以打印什么材料。如果能顺利融化材料，但是他并不能稳定的黏在床上，打印也会有非常大几率失败。</li>
<li>平整度：打印平台的调平性（平整度）对于打印质量至关重要。如果平台不平整，可能导致打印的物体底部出现变形或不平整的表面。</li>
<li>防止翘曲：特定类型的 3D 打印材料，例如 ABS（丙烯腈 - 丁二烯 - 苯乙烯）等，有时容易在冷却过程中产生翘曲。热床可以在打印过程中加热，有助于减少材料翘曲，提高打印的成功率。</li>
</ul>
<h2 id="电气系统"><a href="#电气系统" class="headerlink" title="电气系统"></a>电气系统</h2><p>电气系统分为以下几个模块：</p>
<ul>
<li>电源</li>
<li>主板（需要烧录固件代码如 Marlin）</li>
<li>显示屏</li>
<li>传感器&#x2F;加热模块等</li>
</ul>
<ul>
<li>了解各模块的所需电源电压，功耗等信息选取合适电源</li>
</ul>
<ul>
<li>了解打印机的所需功能，进行针对性选择主板</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li><p><strong>Octoprint 远程监控模块</strong><br>  3d 打印的成功率和模型文件、材料、切片 gcode 代码、天气、机器等关联，然后只有在打印中才能知道模型有没有出问题，octoprint 连接 Wifi，通过网页端远程摄像头监控进度，同时能够开始和停止打印机的操作。</p>
</li>
<li><p><strong>自动调平</strong><br>  通常机器在几天内调平过一次之后很大几率不用重新调平，但是你对机器的一举一动包括机器自己的老化都会影响热床的位置移动和变形，自动调平模块 3D touch（也有别的）能够让完全手动的调平变成半自动调平。</p>
</li>
<li><p><strong>双 Z 结构</strong><br>  顾名思义就是有两根 Z 轴。 单一的 Z 轴由于在一边容易导致 Z 轴变形造成模型垂直方向变形。同时也可能会让 XY 平面在变形的 Z 轴运动受阻。 双 Z 结构不仅能够减少变形，同时增强 Z 轴的稳定性。</p>
</li>
</ul>
<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><p>硬件采用 MKS Gen L v2.1，固件采用 Klipper</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522120145.png" alt="image-1689907869032.png"></p>
<p>pin 口图</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133116.png" alt="image.png"></p>
<p>硬件相关主要考虑因素:</p>
<ol>
<li>驱动电机数量（根据 3D 打印机的结构方案确定）</li>
<li>限位开关</li>
<li>风扇控制</li>
<li>挤出头控制</li>
<li>热敏电阻（热床&#x2F;加热棒&#x2F;挤出头）</li>
<li>单下位机方案需要支持屏幕接口</li>
<li>上位机方案需要支持 USB 连接</li>
</ol>
<h1 id="控制架构"><a href="#控制架构" class="headerlink" title="控制架构"></a>控制架构</h1><p>目前 3D 打印机的主流架构一般情况下，有以下两种方式：</p>
<ol>
<li><p>上位机（运行 fluidd 控制软件）+ 下位机（运行 kilpper 固件）+Web 显示</p>
<ul>
<li>由于手头上正好有一块 Linux 开发板，所以准备采用上位机方案，局域网部署（<code>OctoPrint</code> 和 <code>Fluidd</code> 二选一安装配置即可。）</li>
</ul>
</li>
<li><p>下位机（运行 marlin 固件）+ 串口屏显示</p>
<ul>
<li>优点：只需要一块控制板加上串口屏，不需要上位机控制软件，节约成本 </li>
<li>缺点：屏幕小，显示的信息少</li>
</ul>
</li>
</ol>
<h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><p>在 3D 打印机中，固件控制着 3D 打印机的运动和操作。3D 打印机的固件通常是预装在单片机上的，但用户也可以根据需要进行更新和修改，以实现更好的性能和功能。</p>
<ul>
<li>负责将 G 代码转换为实际的运动和操作，例如将 G 代码中的坐标转换为电机的运动，控制加热器的温度等。 </li>
<li>负责处理传感器的输入，例如温度传感器、限位开关等，并根据这些输入控制 3D 打印机的运动和操作。</li>
</ul>
<p>在 3D 打印领域，主流的固件有以下几种：</p>
<ol>
<li>Marlin：3D 打印机领域最流行的固件之一，因为它具有广泛的硬件支持和强大的功能。Marlin 支持多种传感器和功能，如自动床平衡、断电续打、LCD 屏幕等。Marlin 还提供了一套易于使用的配置文件，可以通过修改这些文件来对 3D 打印机进行高度自定义。由于 Marlin 是开源软件，因此用户可以根据自己的需要进行修改和定制，以实现更好的性能和功能。</li>
<li>Klipper：Klipper 是一款比较新的开源固件，它具有更高的计算能力，可以实现更快的运动和更高的精度。</li>
<li>Repetier：Repetier 是另一款流行的开源固件，它具有类似于 Marlin 的功能和支持。</li>
<li>Smoothie：Smoothie 是一款基于 ARM 处理器的开源固件，它支持多个独立的电机和传感器，并具有良好的可扩展性。</li>
</ol>
<p>本次机器组装选择的方案是 klipper，可以很方便的直接在上位机修改打印机参数，不需要每次修改参数后重新烧写固件</p>
<h3 id="Klipper-固件配置及烧写"><a href="#Klipper-固件配置及烧写" class="headerlink" title="Klipper 固件配置及烧写"></a>Klipper 固件配置及烧写</h3><p>Klipper 官方文档 <a href="https://www.klipper3d.org/zh/Overview.html">https://www.klipper3d.org/zh/Overview.html</a> ，建议详细阅读，很多参数和问题都有说明，首先获取 klipper 源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/Klipper3d/klipper.git</span></span><br></pre></td></tr></table></figure>

<p>执行脚本安装一些系统依赖、设置。<em>安装很慢时，可以更换下 pip 的源 <a href="source/_posts/1.%E8%AF%AD%E8%A8%80/Python/pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.md">pip下载网络问题</a></em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">./klipper/scripts/install-ubuntu<span class="number">-22.04</span>.sh</span><br></pre></td></tr></table></figure>

<p>然后配置和构建 <code>elf</code> 文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd ~/klipper/</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>需要确定连接到微控制器的串行端口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ls /dev/serial/by-id<span class="comment">/*</span></span><br><span class="line"><span class="comment">ls /dev/ttyUSB*</span></span><br></pre></td></tr></table></figure>

<p>可以用命令行或软件工具来刷写固件，<strong>刷写时要确保端口没有被占用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo service klipper stop</span><br><span class="line">make flash FLASH_DEVICE=/dev/ttyUSB0</span><br><span class="line">sudo service klipper start</span><br></pre></td></tr></table></figure>

<h2 id="控制软件"><a href="#控制软件" class="headerlink" title="控制软件"></a>控制软件</h2><p>上位机主板采用一块手头空余的 Linux 主板，软件采用 <del>Fluidd</del>Mainsail，如果是上位机的形式，则由运行在上位机的 3D 打印机控制软件来控制 3D 打印机，主要考虑因素:</p>
<ol>
<li>ARM 架构，功耗低（需要长时间工作）</li>
<li>USB 接口，连接下位机</li>
<li>网口，局域网 Web 显示打印机控制（可选）</li>
<li>显示屏，本地显示打印机控制（可选）</li>
<li>WIFI，可以无线打印（可选）</li>
<li>监控模块，可以远程查看打印情况（可选）</li>
</ol>
<p>先在 WSL 环境下搭建调试 Fluidd， 适用于 3D 打印机的 Klipper 固件，提供 WEB 页面和控制。</p>
<h3 id="KIAUH"><a href="#KIAUH" class="headerlink" title="KIAUH"></a>KIAUH</h3><p>KIAUH 全称 Klipper Installation And Update Helper，该脚本可以直接完成所有环境配置。</p>
<p><em>在通过该脚本进行安装时，需要实时从 github 和 pip 下载文件，由于网络不稳定的情况导致安装失败的，可以下载 klipper&#x2F;mooraker&#x2F;fluidd 等文件后，置于~目录下，并修改 kiauh 中的 scripts 文件夹下的相关脚本，将脚本中的 clone 部分注释，避免网络不稳定导致的错误。pip 部分可以修改 pip 源，稳定下载。</em></p>
<p>界面如下所示：</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522120520.png" alt="image-1689908818765.png"></p>
<p>执行脚本前需要安装 git</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install git -y</span><br></pre></td></tr></table></figure>

<p>下载 KIAUH 到本地：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/dw-0/kiauh.git</span></span><br></pre></td></tr></table></figure>

<p>执行脚本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">./kiauh/kiauh.sh</span><br></pre></td></tr></table></figure>

<p>KIAUH 的主菜单中。您将看到多个操作可供选择，具体取决于您想要执行的操作。要选择操作，只需在“执行操作”提示中输入相应的数字，然后按 ENTER 确认即可。</p>
<h4 id="moonraker"><a href="#moonraker" class="headerlink" title="moonraker"></a><a href="https://github.com/Arksine/moonraker.git">moonraker</a></h4><p>选择 1 Install,需要输入密码，之后选择 2 moonraker，安装完成后进入浏览器输入 <a href="http://127.0.0.1:7125/server/info">http://127.0.0.1:7125/server/info</a> 测试 moonraker 是否正常安装。</p>
<p><code>moonraker</code> 的作用：</p>
<p><em>Moonraker is the API that fluidd communicates with, which in turn communicates with Klipper. All three components are required for a healthy printer.</em></p>
<ul>
<li>如果出现 <code>pip</code> 下载速度太慢导致的失败，参阅 <a href="source/_posts/1.%E8%AF%AD%E8%A8%80/Python/pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.md">pip下载网络问题</a></li>
<li>无法构建 <code>pillow</code> 和 <code>streaming-form-data</code> 这两个包的轮子（<code>wheels</code>），检查发现是头文件没有导致的错误，将 <code>/usr/include/python3.6</code> 下的所有头文件拷贝至 <code>/usr/include</code></li>
</ul>
<h4 id="fluidd"><a href="#fluidd" class="headerlink" title="fluidd"></a><del><code>fluidd</code></del></h4><p>选择 <code>1 Install</code></p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522120716.png" alt="image-1689908842123.png"></p>
<p>之后选择 <code>4 Fluidd</code> 进行安装，安装完成后访问 <a href="http://127.0.0.1/">http://127.0.0.1</a> 正常打开 <code>fluidd</code> 页面</p>
<p><em>安装之前进入 <code>kiauh/resources</code> 下，编辑 <code>fluidd</code> 文件可以更改端口。</em></p>
<h4 id="Mainsail"><a href="#Mainsail" class="headerlink" title="Mainsail"></a><code>Mainsail</code></h4><p>修改 <code>/kiauh/resources/mainsail</code> 中的 80 端口为 9090，安装 <code>mainsail</code> 到 9090 端口</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>打印机配置文件，一般在用户主目录中名为 <code>printer.cfg</code> 的文件</p>
<p><a href="source/_posts/3.%E8%BD%AF%E4%BB%B6/3D%E6%89%93%E5%8D%B0%E6%9C%BA/printer.cfg">配置文件示例</a></p>
<p><code>/home/linux/printer.cfg</code>。</p>
<p>刷写 Klipper 后，名称可能会改变，检查 USB 节点名称：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/serial/by-id/*</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">ls</span> /dev/ttyUSB*</span><br></pre></td></tr></table></figure>

<p>确认节点名称并写入配置文件中去。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0</span><br><span class="line">或者</span><br><span class="line">/dev/ttyUSB0</span><br></pre></td></tr></table></figure>

<p>用这个唯一的名字更新配置文件。更新 [mcu] 部分，类似于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[mcu]</span><br><span class="line">serial: /dev/ttyUSB0</span><br></pre></td></tr></table></figure>

<p>在编辑该文件后，发出 <code>restart</code> 或 <code>FIREWARE_RESTART</code> 命令以重新加载配置（命令根据实际上位机）。如果 Klipper 配置文件被成功读取，并且成功找到并配置了微控制器，那么 “status” 命令将报告打印机已准备就绪。</p>
<ul>
<li>默认的 Klipper 启动脚本在 <code>/tmp/klippy.log</code> 中放置日志，提供更详细的信息。</li>
</ul>
<h3 id="WSL-问题解决"><a href="#WSL-问题解决" class="headerlink" title="WSL 问题解决"></a>WSL 问题解决</h3><p>由于本次安装是在 WSL 中的 Ubuntu 进行安装的，所以有以下两个问题需要解决</p>
<p>1）systemd 中的服务无法启动导致的 moonraker.service 无法运行</p>
<p>Windows 版本要求 (已验证 Win11 22H2)</p>
<p>启动 windows Power Shell，更新 wsl</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure>

<p>进入 Ubuntu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wsl ~</span><br></pre></td></tr></table></figure>

<p>编辑配置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/wsl.conf</span><br></pre></td></tr></table></figure>

<p>添加以下内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[boot]</span><br><span class="line">systemd=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>保存并退出 ubuntu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>在 windows power shell 中关闭 ubuntu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>

<p>然后重新进入 ubuntu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wsl ~</span><br></pre></td></tr></table></figure>

<p>查询 systemd 服务</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo systemctl status</span><br></pre></td></tr></table></figure>

<p>2）在 WSL 中无法打开 Windows 的 USB 端口</p>
<p>WSL2 内核要求 &gt;&#x3D; 5.10.60.1</p>
<p>进入 Ubuntu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wsl ~</span><br></pre></td></tr></table></figure>

<p>查询内核版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<p>退出 Ubuntu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>安装 usbipd-win</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">winget install usbipd</span><br></pre></td></tr></table></figure>

<p>进入 Ubuntu，安装客户端工具</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install linux-tools-<span class="keyword">virtual</span> hwdata</span><br><span class="line">sudo update-alternatives --install /usr/local/bin/usbip usbip `ls /usr/lib/linux-tools<span class="comment">/*/usbip | tail -n1` 20</span></span><br></pre></td></tr></table></figure>

<p>退出 Ubuntu，添加 USB 设备到 WSL 中去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">usbipd wsl list <span class="comment">//列出所有连接到Windows的USB设备。</span></span><br><span class="line">usbipd wsl attach --busid <span class="comment">//添加USB设备进入Ubuntu，需要管理员权限</span></span><br><span class="line">usbipd wsl detach --busid <span class="comment">//停止USB设备共享</span></span><br><span class="line">usbipd wsl attach -a --busid <span class="number">2</span><span class="number">-7</span>    <span class="comment">// -a 自动绑定</span></span><br></pre></td></tr></table></figure>

<p>进入 Ubuntu，查看已经连接的 USB 设备</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure>

<p><em>配置 <code>udev</code>，允许非 <code>root</code> 用户访问 <code>USB</code> 设备,需要在设备连接前完成该操作。需要将根据自己 <code>USB</code> 设备编写的 <code>60-myusb.rules</code> 文件复制到 <code>/etc/udev/rules.d</code></em></p>
<h3 id="嵌入式部署时相关问题"><a href="#嵌入式部署时相关问题" class="headerlink" title="嵌入式部署时相关问题"></a>嵌入式部署时相关问题</h3><p>部署 3d 打印机环境到开发板，所有环境已部署完毕，目前需要解决的问题点是需要编译 ch341 在 linux 环境下的驱动，驱动内核版本 4.19.204</p>
<p>详见 <a href="source/_posts/2.%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/%E4%B8%B2%E5%8F%A3/Linux%E4%B8%8B%E7%9A%84CH34x%E4%B8%B2%E5%8F%A3%E8%AF%86%E5%88%AB.md">Linux下的CH34x串口识别</a></p>
<h1 id="切片软件-Cura-的使用"><a href="#切片软件-Cura-的使用" class="headerlink" title="切片软件-Cura 的使用"></a>切片软件-Cura 的使用</h1><h2 id="设置打印机"><a href="#设置打印机" class="headerlink" title="设置打印机"></a>设置打印机</h2><p>长宽高&#x3D;<code>200*200*200mm</code></p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132404.png" alt="image-1689916973688.png"></p>
<p>打印头孔径 0.4mm</p>
<p>材料直径 1.75mm</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202406241335104.png" alt="image.png"></p>
<h2 id="配置-Cura-设置可见性"><a href="#配置-Cura-设置可见性" class="headerlink" title="配置 Cura 设置可见性"></a>配置 Cura 设置可见性</h2><p>可以根据自己在切片时实际需要调整的相关参数进行显示</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522133018.png" alt="image-1689918511713.png"></p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132411.png" alt="image-1689917153639.png"></p>
<h2 id="移动和缩放模型"><a href="#移动和缩放模型" class="headerlink" title="移动和缩放模型"></a>移动和缩放模型</h2><p>长按鼠标滚轮中键，可平移视角</p>
<p>长按鼠标右键，可旋转视角</p>
<p>滚动鼠标滚轮，可放大缩小视角</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132419.png" alt="image-1689917822752.png"></p>
<p>选中模型后，在 Cura 的左侧，依次功能为</p>
<ul>
<li>移动</li>
<li>缩放</li>
<li>旋转</li>
<li>镜像</li>
<li><em>单一模型设置</em></li>
<li>支撑拦截器<br>  在相应位置添加方块减少支撑应用<br>右击模型，可进行“复制”、“清空平台”、“居中模型等设置</li>
</ul>
<h2 id="设置打印参数"><a href="#设置打印参数" class="headerlink" title="设置打印参数"></a>设置打印参数</h2><p>点击右侧的打印参数设置栏，选择多种模式</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132446.png" alt="image-1689918511713.png"></p>
<h2 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h2><p>即层高：数值越小，打印物体表面效果越好，打印时间越长。默认选择 0.15mm</p>
<h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p>打印模型内部的模型密度，默认以网格状的形式填充。默认选择 20%</p>
<p>如果填充率过低，也会有一定程度导致翘边，不同的内部填充图案也可以有效减少翘边。</p>
<h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>主要设置打印时喷嘴和热床的温度。一般耗材上会写有打印温度。也可通过打印温度塔测试出每种最耗材品牌最佳的打印温度。建议首层温度用 230°C，容易粘床。</p>
<p>打印 PLA，热床的温度建议在 50-60°C。</p>
<h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><p>PLA 建议打印速度为 60mm&#x2F;s，±20 也在常用速度。</p>
<p>过快步进电机会丢步，按实际情况设置</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>当喷嘴移动到非打印区域上方时回抽耗材</p>
<p>当打印出现拉丝情况，可调整回抽设置。建议回抽距离用 2.0mm，回抽速度用 50mm&#x2F;s，加大数值可减少拉丝情况。如果打印过程中喷嘴有碰到打印物的情况，可勾选 Z 轴抬升。</p>
<h2 id="附着"><a href="#附着" class="headerlink" title="附着"></a>附着</h2><p>加大模型第一层与打印平台的接触面积，增加附着力，让模型在打印过程中更稳固。当打印模型的高度较高，接触面积较小时使用。</p>
<p>skirt 裙边</p>
<ul>
<li>在打印模型前，在模型外围打印一圈，让喷头里面的出丝比较顺滑,主要用于擦净喷头</li>
</ul>
<p>brim</p>
<ul>
<li>在模型的边缘处加上薄薄的一层，防止翘边，适用于打印较高的物体且接触面较小，容易倒塌的时候</li>
</ul>
<p>raft</p>
<ul>
<li>底座，在底座上在打印模型，适用于接触面多且复杂的情况</li>
</ul>
<h2 id="支撑"><a href="#支撑" class="headerlink" title="支撑"></a>支撑</h2><p>在模型的悬垂部分生成支撑结构，防止模型倒塌。作为入门最难的一个设置。通常角度过大，打印过程中悬空部位则需要添加支撑，否则容易下垂。支撑与模型接触面往往很粗糙，影响模型质量。</p>
<p><strong>支撑悬垂角度</strong>越大，需要支撑部位（红色部分）则越小。建议 45-50 间。</p>
<p>添加支撑的最小悬垂角度，当角度为 0 时，将支撑所有悬垂，当角度为 90 度时，不提供任何支持</p>
<p>Cura 提供普通支撑和树型支撑两种选择。</p>
<ul>
<li>树型支撑对模型影响更小，也节省材料。注意，它只适合于非平面的悬空，如鼻尖，指尖或拱形。对于平面的悬空，树形支撑无法提供足够的稳定性。</li>
</ul>
<p><strong>正常支撑建议参数</strong><br>支撑图案：锯齿形<br>支撑密度：15-20<br>支撑墙行数：0<br>支撑 Z 距离：推荐比层高略小（如：0.2 层高，设置为 0.15）<br>一般此参数为 0.6~1.5 倍层高。当模型底面较为平缓时，可设置较大的间隙，减少拆支撑难度。当模型底面变化大时，应设置较小的间隙。同时，支撑间隙与支撑密度也有关联，支撑密度较高时，可适当拉大间隙。<br>支撑 X&#x2F;Y 距离：1-1.5mm</p>
<p><strong>树形支撑建议参数</strong><br>支撑图案：锯齿形<br>支撑密度：15-20<br>支撑墙行数：1<br>连接支撑锯齿形: 勾选<br>支撑 Z 距离：推荐比层高略小（如：0.2 层高，设置为 0.15）<br>一般此参数为 0.6~1.5 倍层高。<br>支撑 X&#x2F;Y 距离：1-1.5</p>
<h2 id="保存和预览"><a href="#保存和预览" class="headerlink" title="保存和预览"></a>保存和预览</h2><p>点击右下角的切片，等待切片完毕后，可在预览界面预览打印效果、耗材用量及预计用时。拉动最右边进度条，可查看每层打印情况。点击右下角保存 gcode 文件准备打印。</p>
<h2 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h2><ul>
<li>偏好设置”—“基本”—“自动下降模型到打印平台”<br>  假如只想打印一半模型，可解除 Z 轴限制，可使模型下降至负数。切片后只会打印平台上方部分。</li>
</ul>
<h1 id="3D-打印机问题总结"><a href="#3D-打印机问题总结" class="headerlink" title="3D 打印机问题总结"></a>3D 打印机问题总结</h1><p><strong>平台上的蓝色纸有什么用处，用到什么程度需要更换？</strong><br>美纹纸，它的作用一是防止刮坏喷嘴，二让模型与平台粘接更稳。 由于打印材料的热胀冷缩效应，当打印大体积模型时，可能会发生翘边现象，建议打印前先贴上蓝色美纹纸，才开始打印。该纸可反复使用，直到破损或者明显粘不住模型为止。</p>
<p>大部分人都在用 PEI 喷涂的钢板作为底面。PEI 的特性是冷的时候不粘，热的时候具有一定的粘性。</p>
<p>新的 PEI 床和旧的自带的床。更换 PEI 后打印 PETG 就非常好用了。等床凉了以后轻轻一拿就可以从床上拿起来了，不像是原来那张床用铲子翘半天。</p>
<p>不过新床目前也是遇到了一些问题，就是打 PLA 没有原来粘了。所以用 PLA 打印第一层得时候需要压得更低一点，才能获得最佳得粘性。</p>
<p><strong>哪些模型要加支撑？如何判断？</strong></p>
<p>红色位置是需要加支撑的位置，Cura 右侧可以设置支撑的相关参数</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132634.png" alt="image-1689903635099.png"></p>
<p><strong>调平台这个步骤怎么确保距离调的 ok 呢？喷嘴距离平台距离太远或太近有什么区别？为什么模型打印过程中直接被拖走？</strong></p>
<p>首先在调节平台之前我们需要先保证 X 轴在丝杆上移动是水平的</p>
<p>喷嘴和平台的距离标准为一张 A4 纸的距离，如果不好判断，塞张纸在平台和喷嘴之间，以正常抽拉并附带阻力为标准；</p>
<p>在不会刮伤平台的前提下，调的越近模型粘的越牢固！</p>
<p>我们还可以通过模型打印第一层的状态来判断距离是否调好，有以下三种情况：</p>
<p>1、正确的距离：扁平，无间隙，铺在平台上面很平整无毛刺,喷头与热床是最佳距离能保证打印出的耗材被紧压在热床上成平整的带状（扁皮状）。如图所示：</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132656.png" alt="image-1689841940812.png"></p>
<p>2、不正确的距离：细圆的，粘上去时铺的不均匀，有空隙和翘起，说明距离太远,耗材是靠重力作用垂到热床，形成圆润的条状，其黏附效果不佳，模型容易移动，打印效果非常不理想。如图所示：</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132703.png" alt="image-1689841950878.png"></p>
<p>3、不正确的距离：出丝时，压在平台上会出现中间薄两边有不规则突起（有毛刺）的，说明贴的太紧，或者可能造成无法出丝以及喷头移动时会刮带到之前打印的地方，相关形状如图所示：</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132724.png" alt="image-1689841961988.png"></p>
<p>以上情况均可以通过调节热床下方的弹簧来调整。</p>
<p><strong>调节平台需要注意什么？而且每次打印前都需要检查平台吗？</strong></p>
<ul>
<li>调节弹簧螺丝时，请注意按住下方的羊角螺母，不然在拧的过程中也会一起转动；</li>
<li>每次调完或检查平台操作后，都必须移动喷嘴在平台上走一圈，确保不会刮伤平台才能进行下一步操作；</li>
<li>虽然不需要您每次在打印前调节平台，但需要以 1 天 1 次作为周期性检查，平台距离合适；</li>
</ul>
<p><strong>为什么预热后上料？为何我感觉插到底了，下方喷嘴却不出丝？换料的时候需要注意哪些情况？</strong></p>
<ul>
<li>上料时，如果喷头没有加热，耗材插到底也不会吐丝，客户就无法判断是否已正常上料，所以必须先预热，再上料！</li>
<li>在上料时，插入进料口后一段距离感觉已经无法插入，但是喷头下方并没有出丝，因为在耗材在进入进料口后需要穿过挤出轮和压料轮中间后再<strong>进入下方喷嘴导料管</strong>，在上耗材的时候没有把耗材前段剪尖和捋直，导致耗材插入时没能直接进入下方导料口而被旁边阻挡，如图：<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132739.png" alt="image-1689841982153.png"></li>
</ul>
<p>  正确上料步骤：预热—剪尖并捋直耗材—下压螺丝—笔直插入耗材—出丝</p>
<p><strong>每次打模型前都需要预热吗？</strong><br>提前预热的情况只有在进行换料前才需要提前预热，正常打印时，您只需要选择打印的模型文件即可自动加热；</p>
<p><strong>模型打印过程中停电了能否继续打印？</strong><br>如果停电了模型直接终止打印，下次开机无法延续打印（但可以通过测量已打印高度，仅将未打印的部分切片进行打印，再粘上，仅适合非精密零件模型）</p>
<p><strong>那中途可以暂停再继续打吗？</strong><br>看机器是否有设计暂停打印功能</p>
<p>在打印时暂停喷嘴依旧处于加热状态，耗材因重力作用会下垂流出，影响模型外观；</p>
<p><strong>中途耗材用完怎么办？</strong></p>
<ul>
<li>首先模型在软件进行切片转换格式的时候就会显示所需打印的时间，耗材长度以及重量，那您需要判断机器上余下的耗材能否支持本次打印完成，避免中途打印耗材用完；</li>
<li>若碰到耗材中途快用完，请在耗材还没进入进料口的时候及时的进行暂停，并迅速拔出剩余耗材，将新的耗材插入至喉管的深度即可</li>
</ul>
<p><strong>每次打完需要将耗材取出来做排空处理吗？</strong><br>不是，距离下次打印超过 72 小时，则需要排空处理；</p>
<p><strong>喷头需要定期清理吗？</strong><br>需要！</p>
<p>挤出头加热到指定温度后用最小号的内六角螺丝刀，压下进料弹簧，插入进料口，往下挤压，挤压的时候扳手插慢慢插到底时，来回挤压三次，扳手回抽不要过急或过长，插进去后小幅度的在里面挤压三次即可，再迅速拔出，空烧 1 分钟左右注意观察下方是否有东西流出，流完或没东西流出一分钟后请用我们配送的小捅针，从下方喷嘴插入，抽拉三次没东西流出即可；最后一步，请弄根新耗材，插入到底向下挤压出丝后猛的迅速拔出，尽量带出内壁附着物即可；</p>
<p><strong>模型刚开始打印第一层就不出丝，怎么回事？</strong><br>如果这种情况发生在您刚才有换过耗材的情况下，那您需要确定耗材已上到底，并出丝；确保喷嘴是否顶到平台，导致无间隙空间吐丝；</p>
<p><strong>打出来的模型很脆，外壁像网丝状，很脆，一捏就瘪了？</strong><br>此情况属于出丝量很小，需要检查以下几点：</p>
<ul>
<li>拉料正常，料盘上的耗材没有打结等缠住现象；</li>
<li>耗材在进入导料管与喷嘴（加热管&#x2F;喉管）之前，要穿过一个 u 型轮和挤出电机齿轮中间，u 型轮压住耗材让齿轮把耗材往下挤送，u 型轮压住耗材的力量是由旁边的六角螺钉顶着弹簧的力度来决定的，螺丝扭紧弹簧弹性越大，u 型轮压料就越紧，反之越松， 进料口旁螺丝太松或者太紧都有可能导致耗材挤出速度受到影响</li>
<li>齿轮本身带动耗材挤压也有许多因素，耗材从上往下经过齿轮的时候是否有在齿轮的中间，如果齿轮脱位，耗材在齿轮的牙边下去的，可能出现带不动耗材往下的情况而出丝不顺</li>
</ul>
<p><strong>模型打印时，突然在某一层高处整体向 X（左右）&#x2F;Y（前后）方向偏移？</strong><br>首先需要确定机器传动系统问题，再来排除软件参数和主板固件问题，排除方法如下：</p>
<ul>
<li>首先需要判断你的模型摆放在平台上时，偏移的方向是 x（横向）还是 y（纵向），然后我们需要检查对应的 xy 轴的传动系统是否正常，第一先检查皮带是否松动脱落；第二检查同步轮固定螺丝是否松动<br>  ① 带松动加紧： 首先，如果是 X 轴皮带松动，必须拉紧至绷紧状态，切平行；<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132757.png" alt="image-1689842003037.png"></li>
</ul>
<p>  ②同步轮松动：Y 轴传动系统同步轮和 X 轴同步轮都需要检查到；</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132803.png" alt="image-1689842010248.png"></p>
<ul>
<li>排除完机器问题，建议看下软件参数是否存在问题</li>
</ul>
<p>  例如检查是否是电机运动速度过快或出现阻碍导致的丢步</p>
<ul>
<li>以上两点排除完毕，需要对主板固件程序进行重新烧录来解决问题</li>
</ul>
<p><strong>打印模型过程中中间断了几层，但是上面打印还可以？为什么模型突然中途就不出丝，喷嘴一直在空走打印不出丝？</strong><br>这几种问题都属于前期能正常打，但是中途不出丝的情况，这种情况需要从以下几点判断：</p>
<ul>
<li>挤出电机接线口处四针排线松动，导致电机挤出齿轮来回正反转，耗材送不下去； 打印不出丝时，可以从电机右侧方弹簧方向往里面看到齿轮转到情况，如果齿轮来回摆动不定，说明接线出有问题，将接线拔掉重新插入尝试即可；</li>
<li>进料口旁螺丝太松或者太紧都有可能导致耗材挤出速度受到影响</li>
<li>耗材在料盘上缠住，导致进料不顺,检查料盘的耗材缠绕是否有拉扯住</li>
<li>喷嘴可能有残料堵塞,可以把喷头首先预热 230，一手按住进料口旁螺丝，一手快速挤压耗材（多送点丝），再迅速拔出，然后让喷嘴空烧一会儿，直到有黑色物质从喷嘴里流出，然后用钢丝从喷嘴端插入，抽拉，拔出，让里面剩余的耗材掉出，重复抽拉动作，直到喷嘴没料自然流出为止，最后上料，重新打印；</li>
</ul>
<p><strong>为什么打印模型在中途过程中，喷嘴周边缠着很多耗材，模型变成一团乱丝，不成形？</strong><br>这种情况分两种：</p>
<ul>
<li>刚开始打印阶段，此情况一般是喷嘴和平台之间的距离过远，喷嘴出丝无法粘住平台，就会被喷嘴带走并一直出丝形成一坨；</li>
<li>打印过程中出丝不均匀，有断层现象，打印模型比实际高度低，超过一定间隙距离后出料正常是没附着下面的模型上面就会缠成一坨；</li>
</ul>
<p><strong>打印过程中喷嘴突然停止在打印模型上方不打印，并未回原点，怎么回事？</strong></p>
<ul>
<li>切片问题,重新切片打印测试</li>
<li>内存卡松及读取问题</li>
<li>主板固件问题</li>
</ul>
<p><strong>为什么把模型保存在卡里是显示 ok，但插入机器后选择模型打印后不加热也没反应？为什么 SD 卡在电脑读取正常放入机器缺显示无卡？</strong><br>一般由于保存文件时的文件名上，切片完成后进行保存时文件名请使用英文字母或数字.</p>
<p><strong>为什么 SD 卡在电脑读取正常放入机器缺显示无卡？</strong><br>这种问题首先要排除卡和卡槽是否正常配合，保证卡和卡槽读取正常，如果重新插入还是无法读取，可用您身边的内存卡保存文件插入机器是否能正常读取</p>
<p><strong>为什么选择模型打印，机器没任何反应？或者加热了很久但是不打印？</strong><br>这种情况可能喷嘴冷却风扇提前开启，导致实际温度和设置温度总有 1-2 度差距，导致无法打印，请您选择停止打印并关掉风扇开关后，重新选择打印模型即可；</p>
<p><strong>宽度 5mm 高度 6mm 的字体打得出来不,类似这种小模型需要修改哪些参数呢？</strong><br>小模型打印需要将速度和挤出量降低，模型可以打得更好看。比如打 5mm 左右的字体，可以采用 22 左右的速度配合 85 的挤出量来进行切片打印，温度采用 190 左右的即溶温度即可，这适合小模型打印哦；</p>
<p><strong>为什么在打印模型时，某个位置会剧烈振动，机器声音很大？</strong><br>这种位置一般是模型实体部分的填充，特别是交窄的壁厚，填充为波浪形，打印速度很快的时候 xy 配合产生共振引起的</p>
<p><strong>为什么在打印很大模型例如 190*190*180 和平台尺寸相近的模型时，喷头移动到某个方向极限值时，会有振动然后再改方向进行移动呢？</strong><br>打印前，喷嘴会在模型周围打一圈进行排空出料的操作，这样的话就实际增加了大模型的成型空间，导致直接碰到机箱，可以把此设置关掉即可</p>
<p>查看切片时是否有裙边设置</p>
<p><strong>打印模型经常翘边问题怎么解决？</strong><br>PLA 与 ABS 通用原因：</p>
<ul>
<li><p>喷嘴距离与平台太远，没能充分贴紧平台</p>
</li>
<li><p>模型与热床接触面积太小，导致附着力不够</p>
</li>
</ul>
<p>  解决办法：可增加 brim 或者 raft 垫子 ；打印 ABS 的话 Brim 效果更理想；</p>
<ul>
<li>打印 ABS 时开了散热风扇。</li>
</ul>
<p>  解决办法：在打印是进入主界面的控制 – 温度 – 风扇速度 Bed 中由最高转速 255 改成 100 减少冷却效果，直接关闭风扇开关效果更理想；</p>
<p>  - 挤出头或热床温度不合适，挤出头温度不够可能导致挤出的材料流动性不够，无法完美的平铺在热床上，影响其粘滞力。热床温度过高也可能导致翘边，原因是材料受热流动性变大，不能稳固黏在热床上。</p>
<p>  - 热床表面不干净。手的汗与油粘在胶带上，表面上看不见，但也导致表面打滑，影响黏附效果。这种情况在湿度大的南方比较常见。</p>
<p>    ABS 材料很特殊因为它有一定的收缩率，打印较大的物体时，效果更佳明显，整体收缩导致底面翘起。最好能配合洞洞板。</p>
<p><strong>显示屏下方显示 Err 报错，挤出头&#x2F;热床温度温度显示不正常？</strong><br>喷头上热敏电阻的接触不良或者损坏了</p>
<p>拆下热敏电阻，若是接触不良，则重新拔插接好；若是线的焊点脱落，用电烙铁焊好否则易损坏电阻；若是损坏，则更换新的热敏电阻。注：固定线时螺丝不宜拧过紧</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132936.png" alt="image-1689842115318.png"></p>
<p>这个黑色螺丝拧松，热敏电阻取出来，同时热敏电阻线也从主板上拔下来，用万用表测一下阻值，80-100K 正常</p>
<p><strong>打完第一层，打印头在左边，要打上面一层的时候，打印头不是要回到右边的吗，回去的时候就会刮在之前打印的第一层上并留下一条线呢？</strong><br>那是距离平台过近，会刮到上一层打印的耗材</p>
<ul>
<li>平台距离喷嘴近有利于粘住平台，不会翘边;</li>
<li>会轻微刮到上一层打印模型，但不影响模型成型过程，最多挂点料在喷嘴上挂着，然后在掉下来</li>
</ul>
<p><strong>模型平面上字体打出来效果不好怎么办？</strong><br>如果字写在模型上，此情况可以将模型竖起来打，层厚 0.1 能更为细腻的打出字体；</p>
<p><strong>为什么从绘图软件里导出来的模型放在 cura 里显示不规整，弧面都是棱面组成的？</strong><br>在绘图软件里导出 stl 的时候会有二进制和 ASCⅡ，通常选择二进制并将角度和弦值设置默认最小值，但在 maya 等一些软件里，文件导出的时候 stl 格式是默认设置的，这是软件的特性，但是这个默认数值会随着你文件的建模时的网格细腻程度增加，也就是说文件平滑原本是一倍的，现在加到三倍导出来的 STL 就会比一倍的细腻很多</p>
<p><strong>调试机器时选择自动丝出来都不是直的，是弯曲的?</strong><br>如果出丝是弯曲的</p>
<ul>
<li>挤出量有关；挤出量一般由温度以及进料口旁边的螺丝松紧度有关，需要检查进料口旁边的螺丝</li>
<li>温度原因，1.风扇吹的 2.温度可以适当加高到 200 度左右</li>
</ul>
<p><strong>温度总是上不去或者不稳定？</strong></p>
<ul>
<li>挤出头的热敏感应件没固定好在铝块里，打印的时候易松，导致探温不准；</li>
<li>导风嘴冷却风扇的风是吹到喷嘴下方的模型，如果没有调好就会吹到 喷嘴，导致温度下降；</li>
</ul>
<p><strong>如果出现以下情况是怎么导致？</strong><br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132822.png" alt="image-1689842137085.png"></p>
<p>挤出齿轮底部缠料，一般是由此部位温度过高引起耗材变软，送丝过程中导致齿轮下部耗材折断而缠住；</p>
<ul>
<li>遇到此情况首先需检查电机前方的方形冷却风扇是否工作以及叶片是否完整，避免冷却不够而导致堵料；</li>
<li>请检查耗材是否长时间未密封保存而变脆，取一段从中间这段，若折后显白痕且有韧性即正常，若折后直接啪的应声而断即已变脆；</li>
</ul>
<p><strong>X 轴架构在 Z 轴电机丝杆控制上下过程中，会导致一边高一边低，每次都需要重新调节平台高度呢？</strong></p>
<ul>
<li>x 轴本身没有平衡，在移动过程中反应更明显；</li>
</ul>
<p>  请解决 X 轴调平问题；</p>
<ul>
<li>黄色 T 型螺母太紧，导致 T 型螺母与丝杆紧配受力不均匀，移动不顺畅；</li>
</ul>
<p>  将固定 T 型螺母上的螺丝不要拧紧，留半个螺纹的缝隙，给予缓冲，再将 x 轴调至平衡，移动 z 轴电机调试！</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132835.png" alt="image-1689842144121.png"></p>
<ul>
<li>x 轴光杆太长，没有完全捅到底去，顶住丝杆，导致移动不顺</li>
</ul>
<p>  检查光杆插入深度；</p>
<ul>
<li>将 Z 轴两边的两个光杆去掉，控制电机上升是否正常，排除光杆弯曲配合滑动轴承配合不顺问题（可以单独将光杆插入滑动轴承，上下移动是否顺滑）</li>
</ul>
<p>  更换光杆或者滑动轴承</p>
<ul>
<li>以上问题都检查后就可能: 移动不顺畅的丝杆部分弯曲或者螺纹损伤，更换丝杆</li>
</ul>
<p><strong>在更新固件后，挤出电机齿轮检测出反转，无法正常下料</strong></p>
<ul>
<li>固件中电机引脚配置反了</li>
<li>拔出挤出电机后端电机线接口，按照现在正常 1234 线序，把其中‘一组’12 对调或者 34 对掉即可</li>
</ul>
<p><strong>如果模型摆放在软件里为中心点，但在实际打印过程中并不在平台中间；</strong><br>因为机器喷嘴回原点的时候并不在热床平台上方而是在外面，而 cura 软件的机器设置里原点就在平台某个角的正上方，为了补偿原点所在误差，需要将软件的平台设置扩大，才能让模型打印在正中间，如图操作更改即可：<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132852.png" alt="image-1689842164637.png"></p>
<p><strong>加热后拔料感觉扯不出来，也无法下压了</strong><br>铝块融化处剩余耗材口径较大，加热后直接上拉耗材，易堵在口径较小的喉管处，并迅速冷却，以至堵塞喉管</p>
<p>预热达到温度后，一只手按住进料口旁边的螺丝，另一只手将耗材往下挤压，让前端耗材挤出一段距离后，再迅速拔出耗材即可避免堵塞喉管</p>
<p><strong>选择自动回原点时，当喷头移动至限位开关的时候，电机一直不停的往前走，撞击限位开关并抖动，这是怎么回事？</strong></p>
<ul>
<li>您需要检查在部件回原点触碰到限位开关之前是否有东西挡住它前进才无法触碰到限位开关而不停止运动；<br>  - 可能是限位开关坏了导致的，检查方法是将每个轴的移动部件移至轴中部，选择自动回原点，在部件向原点限位开关移动的过程中，请按住限位开关，观察部件是否停止移动，如果没有停止，请马上切断电源，基本上可以确定限位开关问题</li>
</ul>
<p><strong>为什么 X 轴上的喷头在移动过程中，一顿一顿的，特别是在回原点的时候，移动时几乎在抖动很不顺畅？</strong></p>
<ul>
<li>排除下电机线与电机的问题：拆卸底板：需要用万用表检查 x 轴四根电机线是否都是通路，如果正常就是电机本身问题；</li>
<li>可以断电后手动运动下挤出头，是否丝杆或滑块中的钢珠生锈导致运动不流畅</li>
</ul>
<p><strong>超出打印范围</strong><br>安装软件的时候初始设置选择错误机型导致的，重新设置机型即可</p>
<p><strong>不粘床，找平</strong></p>
<p>自动找平后，但有的时候打印出来的第一层还是和床粘的不紧密</p>
<ul>
<li>Z Offset 设置也会影响粘不粘床。<br>  其中白色部分为压力传感器（BLTouch），右边蓝色硅胶罩下面的为喷头<br>  可以看到左边白色的压力传感器的高度和右边蓝色硅胶套下面的喷嘴是不在一个高度的。设置喷嘴和床之前的距离是以压力传感器的反馈为准的。但是压力传感器测到的距离是传感器本身到床的距离，并不是喷嘴到床的距离。所以压力传感器到喷嘴之间的高度差就是 Z Offset，需要通过调整它来设置合适的喷嘴高度。</li>
</ul>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522132911.png" alt="image-1689841590481.png"></p>
<p><strong>手动调平</strong></p>
<p>需要用到一张纸，一般打印用的 A4 即可。</p>
<p>然后在床的中点进行 Z Offset 调整，在四个角落（螺丝位置）手动调整床的高低。具体步骤如下： 中点 Z-Offset 调整 首先通过控制面板将喷嘴移动到床的中间的正上方，接下来将纸放喷嘴下方的床上，紧接着慢慢将 Z 轴的高度降低到 0（如果降不下去不要硬来），喷嘴可能会压住纸或者没碰到纸；尝试前后不停的移动纸张。 如果纸张能移动并且刚好有一点阻力就是合适的喷嘴高度不需要调节，通常而言不会那么顺利；如果如果喷嘴完全没碰到纸张，或者纸张移动完全没有任何阻力，可以尝试通过调整 Z-Offset ，一点点降低喷嘴高度。直到达到上述的移动纸张有一点点阻力的状态；如果纸张被压的很死无法动弹，则先将 Z 轴升高到 5mm 然后尝试调整 Z-Offset 升高喷嘴，然后再继续尝试慢慢降低 Z 轴到 0mm，反复调整直到移动纸张有一点点阻力的状态。</p>
<p>使用一张纸来手动找到喷头合适高度的方法。但是这个能移动但是有一点点阻力状态有点模糊，它并不是一个固定的点，是一段区间内都可以感觉到能移动但是有摩擦力。我建议是选摩擦力稍微轻一点的力度的点，这样喷嘴高度较高，后面调整的时候不容易刮伤床上的底板。</p>
<p>四周螺丝调整 在中间确定了最基本的 Z 轴的高度之后则需要物理调整四周的螺丝了，调整四周的螺丝需要按照顺序一个一个的调整，并且需要多次调整和确认，具体步骤如下： 首先抬起 Z 轴让喷嘴距离床大概 5mm 的距离，再移动到任意一个距离调整螺母的正上方，将纸放在喷嘴正下方的床上，紧接着一点点尝试往下移动 Z 轴到 0mm，和上面一样如果降不下去不要硬来；接下来就和上面一样，尝试移动不停的前后移动纸张，如果处于能移动但是有摩擦力的状态则是合适的，如果完全没碰到纸张，在移动纸张的同时旋转下方的螺丝来物理调节这个角落的高度，直到纸张处于能移动但是有摩擦力的状态。最后将 Z 抬起到 5mm 左右，顺&#x2F;逆时针移动到下一个调节螺母的上方，重复以上步骤。 上面步骤是单个角落手动物理调整床高度的方法，完成四个点（上图的床只有四个螺丝，有几个螺丝就校准几个点）为一个循环。因为打印机的床是一个固体，所以当你上下移动某一个角落的高度的时候另外三个角落的高低也是会受到影响的，尤其是相邻的两个角落。所以这里需要多个循环来拧螺丝调整各个角落的高度，直到四个角落的高度都合适的情况，即为纸张能移动但是有阻力的状态。 在拧玩螺丝校准完四个角落的高度后，需要再次通过 Z-Offset 校准中间喷嘴的高度。因为在调整四角的螺丝的时候可能会整体抬高或者降低了床的高度，所以中间的喷嘴高度需要再一次校准。重复上面中点 Z-Offset 校准即可。</p>
<p>如果固件自带自动找平还是比较简单的，选择自动找平等就好了。虽然手动找平完之后床基本上是处于可以用的状态了，但是便宜的桌面打印机的床它本身可能就是凹凸不平的，所以需要自动找平来弥补床本身的凹凸起伏的部分。如果没有自动找平的打印机就没有太好的办法避免这个了。只能通过稍微压低一点点喷嘴来做到尽量都粘到床。 测试调平是否成功 在做完上述的调整后就可以进行最终的调整了。这一步是通过打印一些模型来确认喷嘴的高度是否合适。</p>
<p>虽然用纸调整好了喷嘴的高度，但是纸有薄有厚，调整出来的喷嘴高度并不一定是最好的打印高度，所以最终还是需要通过打印来调整。 打印测试时尽量选择有颜色的材料，透明透明材料会看不清楚第一层有没有打好，在打印模型的时候，手需要在电源附近随时待命。在喷嘴高度设置错误或者床不平的时能及时停止打印机降低损失。 打印出来的模型主要是用来检查喷嘴的高度和床是否倾斜的，四周的圆柱和绕场一周的线条用来检查床的倾斜度。 外围线条如果高低不平均，薄的那边就是较高的地方，厚的那边则是较低的地方。四角的圆柱则可以和上述的 Raise 3D 的示意图来比较确认喷头的高度是否合适。如果不合适可能需要重新手动找平。中间的圆形是确认喷嘴高度用的。同样通过对比来观察高度是否合适，如果床并没有很严重的倾斜，则只需要调整 Z-Offset 来移动喷嘴。然后重新打印确认。如果确认床有倾斜，就要重新走一遍手动找平的流程的了，然后重新打印确认。</p>
<p>当然找平也不是一定完美的。但是有自动找平后，整个过程还是比较简单的。但是也有无论怎么调整，都觉得床有倾斜或者高度不对的时候。这里就要分两种情况讨论了。如果能正常打印不想折腾了就选一个能调整到的最好的状态直接用吧。如果严重到了无法打印的程度，则需要检查打印的装配是不是有问题了。</p>
<p><strong>过度挤出</strong></p>
<p>打印出来的东西都有奇怪的纹理。而且质量也参差不齐。</p>
<p>检查之后是 klipper 配置里面的挤出机的「roration_distance」配错了。导致挤出机往外挤的时候给了远比正常情况多的料，进而溢出到边缘产生了神奇的纹理。</p>
<p>Klipper 配置里面的挤出机转一圈挤多少料这些东西都需要自己配置。所以配置挤出参数时是需要校准的，当你给指令让他挤 100mm 的材料的时候，他应该就挤出来 100mm 左右的材料。没有校准所以导致了非常严重的过度挤出，配置正确后打印的东西表面的问题就漂亮多了。 正常挤出打印的零件的表面质感</p>
<h1 id="材料与环境湿度"><a href="#材料与环境湿度" class="headerlink" title="材料与环境湿度"></a>材料与环境湿度</h1><p>由于 FDM 3D 打印件一般都需要将材料加热到 200 摄氏度或以上的温度才能打印，所以当材料通过热端的时候，其中的水蒸气会蒸发出来，造成喷嘴里面的材料有间隙，这些现象还会造成打印件在物理特性上的改变： 水汽膨胀造成挤出原料不均匀导致的表面粗糙 水汽膨胀造成材料之间有很多空隙导致的强度下降 水汽膨胀喷嘴中黏在一块的材料有缝隙，导致拉丝。</p>
<p>材料均需要密封干燥保存！买干燥盒</p>
<table>
<thead>
<tr>
<th align="center">主要成分简称</th>
<th align="center">推荐打印喷嘴温度</th>
<th align="center">推荐打印床温度</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PLA</td>
<td align="center">190˚C – 230˚C</td>
<td align="center">25˚C-60˚C</td>
<td align="center">易受潮</td>
</tr>
<tr>
<td align="center">TPU</td>
<td align="center">200˚C – 210˚C</td>
<td align="center">50˚C</td>
<td align="center">易拉丝</td>
</tr>
<tr>
<td align="center">PETG</td>
<td align="center">230˚C – 240˚C</td>
<td align="center">70˚C – 80˚C</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ABS</td>
<td align="center">245˚C – 265˚C</td>
<td align="center">90˚C – 100˚C</td>
<td align="center">有毒</td>
</tr>
<tr>
<td align="center">ASA</td>
<td align="center">240˚C – 260˚C</td>
<td align="center">75˚C – 95˚C</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PC</td>
<td align="center">250˚C – 270˚C</td>
<td align="center">90˚C – 105˚C</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PA6</td>
<td align="center">250˚C – 270˚C</td>
<td align="center">25˚C – 50˚C</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PA6-CF</td>
<td align="center">280˚C – 300˚C</td>
<td align="center">25˚C – 50˚C</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>3D打印机</category>
      </categories>
  </entry>
  <entry>
    <title>3D打印相关软件</title>
    <url>/2024/05/21/3-%E8%BD%AF%E4%BB%B6-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="系统固件"><a href="#系统固件" class="headerlink" title="系统固件"></a>系统固件</h1><p><strong>Klipper</strong><br>Klipper 是一个高性能、灵活的 3D 打印机固件，它通过将一些计算工作转移到更强大的主机（如 Raspberry Pi）上来提高打印质量和速度。</p>
<p><strong>Marlin</strong><br>Marlin 是目前最流行的 3D 打印机固件之一，支持广泛的硬件平台和 3D 打印机模型，具有丰富的功能和高度的可定制性。</p>
<h1 id="控制软件"><a href="#控制软件" class="headerlink" title="控制软件"></a>控制软件</h1><p><strong>fluidd</strong><br>Fluidd 是一个基于网页的控制界面，用于管理和监控运行 Klipper 固件的 3D 打印机。它提供了用户友好的界面和实时监控功能。<br>GitHub 地址: <a href="https://github.com/fluidd-core/fluidd">https://github.com/fluidd-core/fluidd</a><br>安装手册: <a href="https://github.com/dw-0/kiauh">https://github.com/dw-0/kiauh</a></p>
<p><strong>Make-me</strong><br>Make-me 是一个通过 WiFi 控制 Replicator 2 打印机的开源项目，使用 GitHub 的聊天机器人 Hubot 来监控和完成打印任务。目前只支持 Mac 的 OS X。</p>
<p><strong>Pepeteir-Server</strong><br>Pepeteir-Server 是一个新型的 Repeteir 产品，可以在 Raspberry Pi 上运行，支持控制多台打印机，内存消耗极小。它的网页操作界面简单，但不支持 Mac 和 PC。</p>
<p><strong>Octoprint</strong><br>Octoprint 是一个完全基于网页的 3D 打印机控制程序，可以远程控制打印机，并通过网络摄像头监控打印过程。支持 Raspberry Pi。</p>
<p><strong>Botqueue</strong><br>Botqueue 是一个开源的远程打印机控制软件，可以控制多台打印机。用户上传 .stl 文件后，软件会完成切片和打印工作。它支持为每台打印机设置独立的切片特性。</p>
<h1 id="切片软件"><a href="#切片软件" class="headerlink" title="切片软件"></a>切片软件</h1><p>切片软件用于将 3D 模型按层切片，并生成用于打印的 G 代码。</p>
<p><strong>Cura</strong><br>Cura 由 Ultimaker 开发，兼容多种 3D 打印机。它不仅可以切片，还提供 3D 打印机控制界面，尤其适用于 Ultimaker 的 3D 打印机。</p>
<p><strong>Slic3r</strong><br>Slic3r 是开源且免费的切片软件，因其快捷性和高度可定制化而广受欢迎。许多 3D 打印机制造商提供默认的 Slic3r 配置文件（.INI 文件），可以用作初始设置。</p>
<p><strong>Skeinforge</strong><br>另一款非常流行的切片软件。同样开源，免费。</p>
<p><strong>kisslicer</strong><br>KISSlicer 是一款跨平台的切片软件，名称源自 “Keep It Simple”（保持简单），目标是提供一个简单易用的界面。</p>
<p><strong>Printrun</strong><br>Printrun 既是控制软件，也是切片软件，可以独立完成从切片到打印的整个过程。支持 Mac、Linux 和 PC 操作平台。</p>
<p><strong>Repetier-Host</strong><br>Repetier-Host 与 Printrun 类似，是一款综合性软件，具有切片、零件定位和机器控制功能。用户界面相对更复杂但更直观，同样支持 Mac、Linux 和 PC 操作平台。</p>
<h1 id="3D-建模软件"><a href="#3D-建模软件" class="headerlink" title="3D 建模软件"></a>3D 建模软件</h1><p><strong>Blender</strong><br>Blender 是一款开源的 3D 建模软件，功能强大且完全免费。它不仅可以用于 3D 建模，还支持动画、渲染、雕刻等多种功能，适用于各种复杂的 3D 设计和制作。</p>
<p><strong>Tinkercad</strong><br>Tinkercad 是一个由 Autodesk 开发的在线 3D 建模工具，适合初学者使用。它基于浏览器，无需下载软件，界面友好且易于使用。</p>
<p><strong>Fusion 360</strong><br>Fusion 360 同样由 Autodesk 开发，是一款功能强大的云端 3D CAD、CAM 和 CAE 工具。它适用于从初学者到专业人士的各个层级，提供了全面的建模、仿真和制造功能。</p>
<p><strong>SketchUp</strong><br>SketchUp 是一款广受欢迎的 3D 建模软件，以其直观的用户界面和易用性著称。它有免费版本（SketchUp Free）和专业版本（SketchUp Pro），适用于建筑、工程、游戏开发等多个领域。</p>
<p><strong>FreeCAD</strong><br>FreeCAD 是一款开源的 3D CAD 建模软件，适合于产品设计、机械工程以及建筑设计。它具有模块化的架构，可以通过插件扩展其功能。</p>
<p><strong>SolidWorks</strong><br>SolidWorks 是一款由 Dassault Systèmes 开发的专业 3D CAD 软件，广泛应用于工程设计、产品设计和制造业。它功能强大，但价格较高，通常用于工业级应用。</p>
<p><strong>Onshape</strong><br>Onshape 是一个基于云的 3D CAD 建模软件，适用于团队协作和设计项目。它无需安装，直接在浏览器中运行，支持实时协作和版本控制。</p>
<p><strong>OpenSCAD</strong><br>OpenSCAD 是一款开源的 3D CAD 建模软件，适用于创建精确的 3D 模型。它使用编程语言来定义模型，适合那些有编程经验的用户。</p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>3D打印机</category>
      </categories>
  </entry>
  <entry>
    <title>AI应用软件了解</title>
    <url>/2024/05/24/3-%E8%BD%AF%E4%BB%B6-AI-AI%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-文本生成-AI"><a href="#1-文本生成-AI" class="headerlink" title="1. 文本生成 AI"></a>1. 文本生成 AI</h1><table>
<thead>
<tr>
<th>名称</th>
<th>公司</th>
<th>是否开源</th>
<th>功能简介</th>
</tr>
</thead>
<tbody><tr>
<td>ChatGPT-4</td>
<td>OpenAI</td>
<td>否</td>
<td>最先进的大语言模型之一,具有强大的自然语言理解和生成能力,可用于写作、编程、分析等复杂任务</td>
</tr>
<tr>
<td>Claude3</td>
<td>Anthropic</td>
<td>否</td>
<td>擅长长文本处理和信息整理,最新版本在多项基准测试中表现优异</td>
</tr>
<tr>
<td>Gemini</td>
<td>Google</td>
<td>否</td>
<td>多模态 AI 模型,具备出色的语音和图像理解能力</td>
</tr>
<tr>
<td>Poe</td>
<td>Quora</td>
<td>否</td>
<td>集成多个顶级大语言模型的平台,用户可选择不同模型对话</td>
</tr>
<tr>
<td>NewBing</td>
<td>Microsoft</td>
<td>否</td>
<td>基于 GPT-4 开发的 AI 搜索助手,集成在 Bing 搜索引擎中</td>
</tr>
<tr>
<td>通义千问</td>
<td>阿里巴巴</td>
<td>否</td>
<td>支持 10 万字长文本处理的大语言模型</td>
</tr>
<tr>
<td>豆包</td>
<td>字节跳动</td>
<td>否</td>
<td>注重陪伴和对话体验的 AI 助手</td>
</tr>
<tr>
<td>天工</td>
<td>昆仑万维</td>
<td>否</td>
<td>可生成文本、图像和音乐的 AI 平台</td>
</tr>
<tr>
<td>扣子</td>
<td>-</td>
<td>-</td>
<td>专注于创建和部署自定义 AI 智能体的平台</td>
</tr>
</tbody></table>
<h1 id="2-图像生成-AI"><a href="#2-图像生成-AI" class="headerlink" title="2. 图像生成 AI"></a>2. 图像生成 AI</h1><table>
<thead>
<tr>
<th>名称</th>
<th>公司</th>
<th>是否开源</th>
<th>功能简介</th>
</tr>
</thead>
<tbody><tr>
<td>Stable Diffusion</td>
<td>Stability AI</td>
<td>是</td>
<td>开源的文本到图像生成模型,可免费使用</td>
</tr>
<tr>
<td>Midjourney</td>
<td>Midjourney</td>
<td>否</td>
<td>付费的高质量图像生成服务,以艺术风格著称</td>
</tr>
<tr>
<td>DALL-E 3</td>
<td>OpenAI</td>
<td>否</td>
<td>最新图像生成模型,集成在 ChatGPT 中</td>
</tr>
<tr>
<td>Dreamina</td>
<td>字节跳动</td>
<td>否</td>
<td>字节跳动开发的图像生成 AI</td>
</tr>
<tr>
<td>通义万象</td>
<td>阿里巴巴</td>
<td>否</td>
<td>集成在通义千问中的图像生成模型</td>
</tr>
<tr>
<td>混元助手</td>
<td>腾讯</td>
<td>否</td>
<td>腾讯开发的图文生成 AI</td>
</tr>
<tr>
<td>Akuma</td>
<td>-</td>
<td>-</td>
<td>新兴的 AI 图像生成平台,提供多样化创作工具</td>
</tr>
</tbody></table>
<h1 id="3-视频生成-AI"><a href="#3-视频生成-AI" class="headerlink" title="3. 视频生成 AI"></a>3. 视频生成 AI</h1><table>
<thead>
<tr>
<th>名称</th>
<th>公司</th>
<th>是否开源</th>
<th>功能简介</th>
</tr>
</thead>
<tbody><tr>
<td>Sora</td>
<td>OpenAI</td>
<td>否</td>
<td>文本到视频生成模型,能创建高质量、逼真的视频内容</td>
</tr>
<tr>
<td>Stable Video Diffusion</td>
<td>Stability AI</td>
<td>是</td>
<td>开源的视频生成模型</td>
</tr>
<tr>
<td>Runway</td>
<td>Runway</td>
<td>否</td>
<td>提供 AI 视频编辑和生成工具的平台</td>
</tr>
<tr>
<td>Pika</td>
<td>Pika Labs</td>
<td>否</td>
<td>专注于短视频创作的 AI 工具</td>
</tr>
<tr>
<td>Haiper</td>
<td>-</td>
<td>-</td>
<td>新兴的 AI 视频生成平台</td>
</tr>
<tr>
<td>Dreamina</td>
<td>字节跳动</td>
<td>否</td>
<td>字节跳动的视频生成 AI 产品</td>
</tr>
<tr>
<td>Pixverse</td>
<td>-</td>
<td>-</td>
<td>提供 AI 视频创作和编辑功能的平台</td>
</tr>
<tr>
<td>Vidu</td>
<td>清华大学</td>
<td>-</td>
<td>清华大学开发的视频生成 AI</td>
</tr>
<tr>
<td>Money Print Turbo</td>
<td>-</td>
<td>-</td>
<td>全自动视频制作工具,可生成文案、素材、字幕和背景音乐</td>
</tr>
</tbody></table>
<h1 id="4-音频生成-AI"><a href="#4-音频生成-AI" class="headerlink" title="4. 音频生成 AI"></a>4. 音频生成 AI</h1><table>
<thead>
<tr>
<th>名称</th>
<th>公司</th>
<th>是否开源</th>
<th>功能简介</th>
</tr>
</thead>
<tbody><tr>
<td>Suno</td>
<td>Suno</td>
<td>否</td>
<td>AI 音乐创作平台,提供免费额度</td>
</tr>
<tr>
<td>Stable Audio</td>
<td>Stability AI</td>
<td>是</td>
<td>Stability AI 开发的音频生成模型</td>
</tr>
<tr>
<td>天工音乐</td>
<td>昆仑万维</td>
<td>否</td>
<td>AI 音乐创作工具</td>
</tr>
<tr>
<td>网易天音</td>
<td>网易</td>
<td>否</td>
<td>网易开发的 AI 音乐生成平台</td>
</tr>
</tbody></table>
<h1 id="5-AI-浏览器和编程助手"><a href="#5-AI-浏览器和编程助手" class="headerlink" title="5. AI 浏览器和编程助手"></a>5. AI 浏览器和编程助手</h1><table>
<thead>
<tr>
<th>名称</th>
<th>公司</th>
<th>是否开源</th>
<th>功能简介</th>
</tr>
</thead>
<tbody><tr>
<td>Perplexity</td>
<td>Perplexity AI</td>
<td>否</td>
<td>基于 AI 的智能搜索引擎,提供精准的信息检索和问答服务</td>
</tr>
<tr>
<td>GitHub Copilot</td>
<td>Microsoft&#x2F;OpenAI</td>
<td>否</td>
<td>AI 编程助手,集成在多个代码编辑器中</td>
</tr>
</tbody></table>
<h1 id="6-照片说话和音频模仿"><a href="#6-照片说话和音频模仿" class="headerlink" title="6. 照片说话和音频模仿"></a>6. 照片说话和音频模仿</h1><table>
<thead>
<tr>
<th>名称</th>
<th>公司</th>
<th>是否开源</th>
<th>功能简介</th>
</tr>
</thead>
<tbody><tr>
<td>Emo</td>
<td>阿里巴巴</td>
<td>否</td>
<td>AI 换脸和表情动画工具</td>
</tr>
<tr>
<td>SadTalk</td>
<td>-</td>
<td>是</td>
<td>开源的 AI 换脸和口型同步技术</td>
</tr>
<tr>
<td>GPT-SoVITS</td>
<td>-</td>
<td>是</td>
<td>开源的 AI 语音克隆和转换工具</td>
</tr>
<tr>
<td>Openvoice</td>
<td>微软</td>
<td>否</td>
<td>微软开发的 AI 语音克隆技术</td>
</tr>
<tr>
<td>剪映</td>
<td>字节跳动</td>
<td>否</td>
<td>短视频编辑 App,集成 AI 语音克隆功能</td>
</tr>
<tr>
<td>魔音工坊</td>
<td>-</td>
<td>-</td>
<td>专注于 AI 语音合成和克隆的在线平台</td>
</tr>
</tbody></table>
<h1 id="7-PPT-制作和视频编辑"><a href="#7-PPT-制作和视频编辑" class="headerlink" title="7. PPT 制作和视频编辑"></a>7. PPT 制作和视频编辑</h1><table>
<thead>
<tr>
<th>名称</th>
<th>公司</th>
<th>是否开源</th>
<th>功能简介</th>
</tr>
</thead>
<tbody><tr>
<td>讯飞智文</td>
<td>科大讯飞</td>
<td>否</td>
<td>AI 辅助文档创作工具</td>
</tr>
<tr>
<td>Gamma</td>
<td>Gamma</td>
<td>否</td>
<td>基于 AI 的演示文稿制作平台</td>
</tr>
<tr>
<td>WPS AI</td>
<td>金山办公</td>
<td>否</td>
<td>集成的 AI 助手,支持 PPT 等文档智能生成</td>
</tr>
<tr>
<td>腾讯智影</td>
<td>腾讯</td>
<td>否</td>
<td>AI 视频创作和编辑平台</td>
</tr>
<tr>
<td>剪映</td>
<td>字节跳动</td>
<td>否</td>
<td>短视频编辑 App,集成多种 AI 功能</td>
</tr>
</tbody></table>
<h1 id="其他说明："><a href="#其他说明：" class="headerlink" title="其他说明："></a>其他说明：</h1><p>PyTorch 2.0.1</p>
<p>CUDA 11</p>
<p>conda</p>
<p>FastGPT+ollama</p>
<p>订阅号对接 ollma 模型—云服务器资源不足</p>
<p>微软 E5 开发者订阅</p>
<h1 id="huggingface-co"><a href="#huggingface-co" class="headerlink" title="huggingface.co"></a>huggingface.co</h1><p>Hugging Face Transformers 是一个开源 Python 库，其提供了数以千计的预训练 transformer 模型，可广泛用于自然语言处理 (NLP) 、计算机视觉、音频等各种任务。</p>
<p>Hugging Face Hub 是一个协作平台，其中托管了大量的用于机器学习的开源模型和数据集，你可以将其视为 ML 的 Github。</p>
<p>Hugging Face Spaces 是 Hugging Face Hub 上提供的一项服务，它提供了一个易于使用的 GUI，用于构建和部署 Web 托管的 ML 演示及应用。该服务使得用户可以快速构建 ML 演示、上传要托管的自有应用，甚至即时部署多个预配置的 ML 应用。</p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>ollama笔记</title>
    <url>/2024/05/17/3-%E8%BD%AF%E4%BB%B6-AI-ollama%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://huggingface.co/">https://huggingface.co/</a></p>
<p>Llama 中文社区 <a href="https://github.com/LlamaFamily/Llama-Chinese?tab=readme-ov-file">https://github.com/LlamaFamily/Llama-Chinese?tab=readme-ov-file</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:<span class="comment">//ollama.com/install.sh | sh</span></span><br></pre></td></tr></table></figure>

<h1 id="支持的模型"><a href="#支持的模型" class="headerlink" title="支持的模型"></a>支持的模型</h1><p>访问地址 <a href="https://ollama.com/library">https://ollama.com/library</a></p>
<ul>
<li>ollama.exe list 列出本地模型</li>
<li>ollama run qwen 运行 qwen 模型，如果没有则下载</li>
</ul>
<table>
<thead>
<tr>
<th>NAME</th>
<th>SIZE</th>
<th>FEATURES</th>
</tr>
</thead>
<tbody><tr>
<td>codellama:latest</td>
<td>3.8 GB</td>
<td></td>
</tr>
<tr>
<td>llama3:latest</td>
<td>4.7 GB</td>
<td></td>
</tr>
<tr>
<td>starcoder2:3b</td>
<td>1.7 GB</td>
<td></td>
</tr>
<tr>
<td>qwen:4b</td>
<td>2.3G</td>
<td></td>
</tr>
<tr>
<td>nomic-embed-text</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="更换保存位置"><a href="#更换保存位置" class="headerlink" title="更换保存位置"></a>更换保存位置</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows 下 Ollama 默认使用系统盘（一般为 C 盘）来存放模型文件，先来看看帮助:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ollama.exe serve --help</span><br></pre></td></tr></table></figure>

<p>返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Start ollama</span><br><span class="line">Usage:</span><br><span class="line">  ollama serve [flags]</span><br><span class="line">Aliases:</span><br><span class="line">  serve, start</span><br><span class="line">Flags:</span><br><span class="line">  -h, --help   help <span class="keyword">for</span> serve</span><br><span class="line">Environment Variables:</span><br><span class="line">    OLLAMA_HOST         The host:<span class="function">port to bind <span class="title">to</span> <span class="params">(<span class="keyword">default</span> <span class="string">&quot;127.0.0.1:11434&quot;</span>)</span></span></span><br><span class="line"><span class="function">    OLLAMA_ORIGINS      A comma separated list of allowed origins.</span></span><br><span class="line"><span class="function">    OLLAMA_MODELS       The path to the models <span class="title">directory</span> <span class="params">(<span class="keyword">default</span> is <span class="string">&quot;~/.ollama/models&quot;</span>)</span></span></span><br><span class="line"><span class="function">    OLLAMA_KEEP_ALIVE   The duration that models stay loaded in <span class="title">memory</span> <span class="params">(<span class="keyword">default</span> is <span class="string">&quot;5m&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>从帮助文件可以看，我们通过设置环境变量（<code>OLLAMA_MODELS</code>）来指定模型目录，可以通过系统设置里来配置环境变量（系统变量或者用户变量），也可以通过命令行来配置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set OLLAMA_MODELS=d:\ollama</span><br></pre></td></tr></table></figure>

<h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p>默认地址是~&#x2F;.ollama&#x2F;models， 如果想移到别的目录，同样是设置环境变量 <code>OLLAMA_MODELS</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> OLLAMA_MODELS=/data/ollama</span><br></pre></td></tr></table></figure>

<h1 id="导出模型"><a href="#导出模型" class="headerlink" title="导出模型"></a>导出模型</h1><p>这里以 qwen:7b 为例，先查看模型信息，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ollama show --modelfile qwen:<span class="number">7b</span></span><br></pre></td></tr></table></figure>

<p>返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># Modelfile generated by <span class="string">&quot;ollama show&quot;</span></span><br><span class="line"># To build a <span class="keyword">new</span> Modelfile based on <span class="keyword">this</span> one, replace the FROM line with:</span><br><span class="line"># FROM qwen:<span class="number">7b</span></span><br><span class="line"></span><br><span class="line">FROM /Users/m2max/.ollama/models/blobs/sha256<span class="number">-87f</span>26aae09c7f052de93ff98a2282f05822cc6de4af1a2a159c5bd1acbd10ec4</span><br><span class="line">TEMPLATE <span class="string">&quot;&quot;</span><span class="string">&quot;&#123;&#123; if .System &#125;&#125;&lt;|im_start|&gt;system</span></span><br><span class="line"><span class="string">&#123;&#123; .System &#125;&#125;&lt;|im_end|&gt;&#123;&#123; end &#125;&#125;&lt;|im_start|&gt;user</span></span><br><span class="line"><span class="string">&#123;&#123; .Prompt &#125;&#125;&lt;|im_end|&gt;</span></span><br><span class="line"><span class="string">&lt;|im_start|&gt;assistant</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">PARAMETER stop <span class="string">&quot;&lt;|im_start|&gt;&quot;</span></span><br><span class="line">PARAMETER stop <span class="string">&quot;&lt;|im_end|&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>从模型文件信息里得知 <code>/Users/m2max/.ollama/models/blobs/sha256-46bb65206e0e2b00424f33985a5281bd21070617ebcfda9be86eb17e6e00f793</code> 即为我们想要的 qwen:7b （格式为 gguf），导出代码为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cp /Users/m2max/.ollama/models/blobs/sha256<span class="number">-46b</span>b65206e0e2b00424f33985a5281bd21070617ebcfda9be86eb17e6e00f793 qwen_7b.gguf</span><br></pre></td></tr></table></figure>

<h1 id="导入模型"><a href="#导入模型" class="headerlink" title="导入模型"></a>导入模型</h1><h2 id="下载模型"><a href="#下载模型" class="headerlink" title="下载模型"></a>下载模型</h2><p>可以从 hugggingface.co 或者镜像网站 hf-mirror.com 下载所需 gguf 格式的大模型（不然得自己转） 假设我们要下载的是这两天大火的斯坦福的模型 Octopus-v2， 搜 Octopus-v2，找有 GGUF 标识的，比如我们选择个链接 <a href="https://hf-mirror.com/brittlewis12/Octopus-v2-GGUF/tree/main">https://hf-mirror.com/brittlewis12/Octopus-v2-GGUF/tree/main</a> 下载 octopus-v2.Q8_0.gguf</p>
<h2 id="导入模型-1"><a href="#导入模型-1" class="headerlink" title="导入模型"></a>导入模型</h2><p>需要准备 Modelfile 文件，From &#x2F;path&#x2F;to&#x2F;qwen_7b.gguf。上面是最简单的办法 当然可以从上面模型信息生成完成版本的 Modelfile</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># Modelfile generated by <span class="string">&quot;ollama show&quot;</span></span><br><span class="line"># To build a <span class="keyword">new</span> Modelfile based on <span class="keyword">this</span> one, replace the FROM line with:</span><br><span class="line"># FROM qwen:<span class="number">7b</span></span><br><span class="line"></span><br><span class="line">FROM /path/to/qwen_7b.gguf</span><br><span class="line">TEMPLATE <span class="string">&quot;&quot;</span><span class="string">&quot;&#123;&#123; if .System &#125;&#125;&lt;|im_start|&gt;system</span></span><br><span class="line"><span class="string">&#123;&#123; .System &#125;&#125;&lt;|im_end|&gt;&#123;&#123; end &#125;&#125;&lt;|im_start|&gt;user</span></span><br><span class="line"><span class="string">&#123;&#123; .Prompt &#125;&#125;&lt;|im_end|&gt;</span></span><br><span class="line"><span class="string">&lt;|im_start|&gt;assistant</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">PARAMETER stop <span class="string">&quot;&lt;|im_start|&gt;&quot;</span></span><br><span class="line">PARAMETER stop <span class="string">&quot;\&quot;&lt;|im_end|&gt;\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>记得替换你的模型的完整路径 另外不同模型的 template 和 stop parameter 不同，这个不知道就不写，或者网上搜索 然后执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ollama create qwen:<span class="number">7b</span> -f Modelfile</span><br></pre></td></tr></table></figure>

<p>导入模型的时候，确保硬盘可用空间在模型大小的 2 倍以上，transferring model data 复制一个完整的模型。creating model layer 生成一个新的模型文件。</p>
<h1 id="第三方访问"><a href="#第三方访问" class="headerlink" title="第三方访问"></a>第三方访问</h1><p><a href="https://ollama.fan/reference/api/">https://ollama.fan/reference/api/</a></p>
<p>ollama 提供了 OpenAI 的兼容 API 这里以沉浸式翻译为例 需要设置环境变量 <code>OLLAMA_ORIGINS</code>，设置任何应用都可以访问 ollama。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OLLAMA_ORIGINS=*</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>人工智能知识结构</title>
    <url>/2024/07/02/3-%E8%BD%AF%E4%BB%B6-AI-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ol>
<li><p>Python 编程语言</p>
<ul>
<li>基础语法与数据结构</li>
<li>常用库：NumPy、Pandas、Matplotlib</li>
<li>面向对象编程与函数式编程</li>
</ul>
</li>
<li><p>机器学习基础</p>
<ul>
<li>监督学习与非监督学习</li>
<li>回归、分类、聚类算法</li>
<li>评估指标：准确率、召回率、F1-score 等</li>
</ul>
</li>
<li><p>自然语言处理（NLP）基础</p>
<ul>
<li>文本预处理：分词、词性标注、命名实体识别等</li>
<li>经典模型：TF-IDF、Word2Vec、GloVe 等</li>
</ul>
</li>
<li><p>数学基础</p>
<ul>
<li>线性代数：矩阵运算、特征值与特征向量等</li>
<li>微积分：导数、积分、多变量函数等</li>
<li>概率统计：概率分布、贝叶斯定理、假设检验等</li>
</ul>
</li>
</ol>
<h1 id="前沿算法和框架"><a href="#前沿算法和框架" class="headerlink" title="前沿算法和框架"></a>前沿算法和框架</h1><ol>
<li><p>Transformer、BERT 等算法原理</p>
<ul>
<li>Transformer 架构及其注意力机制</li>
<li>BERT、GPT 等模型的工作原理与应用场景</li>
</ul>
</li>
<li><p>深度学习框架</p>
<ul>
<li>TensorFlow</li>
<li>PyTorch</li>
<li>框架对比与选择</li>
</ul>
</li>
<li><p>NLP 技术</p>
<ul>
<li>词嵌入（Word Embeddings）</li>
<li>循环神经网络（RNN）及其变种（LSTM、GRU）</li>
<li>自然语言生成（NLG）与理解（NLU）</li>
</ul>
</li>
</ol>
<h1 id="工程化实践"><a href="#工程化实践" class="headerlink" title="工程化实践"></a>工程化实践</h1><ol>
<li><p>模型部署</p>
<ul>
<li>REST API 部署</li>
<li>云服务（如 AWS、GCP、Azure）</li>
<li>边缘设备部署</li>
</ul>
</li>
<li><p>模型优化</p>
<ul>
<li>模型压缩：量化、剪枝、知识蒸馏等</li>
<li>高效推理：ONNX、TensorRT 等</li>
</ul>
</li>
<li><p>集成与应用</p>
<ul>
<li>将 LLM 集成到 Web 应用、移动应用等</li>
<li>构建对话系统、自动摘要等具体应用</li>
</ul>
</li>
</ol>
<h1 id="实践项目"><a href="#实践项目" class="headerlink" title="实践项目"></a>实践项目</h1><ol>
<li><p>参与开源 LLM 项目</p>
<ul>
<li>贡献代码、文档或测试</li>
<li>学习社区最佳实践</li>
</ul>
</li>
<li><p>自主实现 LLM 应用</p>
<ul>
<li>选题、需求分析</li>
<li>数据收集与清洗</li>
<li>模型训练与调优</li>
<li>应用部署与测试</li>
</ul>
</li>
</ol>
<h1 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h1><ol>
<li><p>关注 LLM 领域最新研究成果</p>
<ul>
<li>阅读顶会论文（如 ACL、EMNLP、NeurIPS 等）</li>
<li>关注相关技术博客与新闻</li>
</ul>
</li>
<li><p>参加机器学习比赛</p>
<ul>
<li>Kaggle 比赛</li>
<li>各类 NLP 挑战赛（如文本生成、对话系统等）</li>
</ul>
</li>
</ol>
<h1 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h1><ol>
<li><p>性能优化</p>
<ul>
<li>提高模型推理速度</li>
<li>减少资源占用</li>
</ul>
</li>
<li><p>模型调整</p>
<ul>
<li>调整超参数</li>
<li>修改模型结构</li>
</ul>
</li>
<li><p>数据扩充</p>
<ul>
<li>增加训练数据量</li>
<li>进行数据增强</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub加速访问</title>
    <url>/2024/06/22/3-%E8%BD%AF%E4%BB%B6-Git-GitHub%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="Git-clone"><a href="#Git-clone" class="headerlink" title="Git clone"></a>Git clone</h1><p>gitclone.com 是一个 github.com 缓存加速网站，通过缓存经常访问的 github 仓库，加速 git clone from github 操作。当你使用 clone 仓库时 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//gitclone.com/github.com/xxxxx/xxxxx</span></span><br></pre></td></tr></table></figure>

<p>会创建一个镜像，以后其他开发者 clone 时就可以使用镜像缓存进行 clone，速度得到了很大的提升，一般 git clone from github 只能达到 20k&#x2F;s，经过 gitclone.com 加速后可以达到 1.2M&#x2F;s。</p>
<h2 id="第三方加速镜像站"><a href="#第三方加速镜像站" class="headerlink" title="第三方加速镜像站"></a>第三方加速镜像站</h2><p>通过第三方 github 镜像站进行加速访问，网站的内容跟 GitHub 是完整同步的镜像，然后在这个网站里面进行下载克隆等操作。</p>
<p>镜像站 <a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/xxxxx/xxxxx</span></span><br><span class="line">替换为</span><br><span class="line">git clone https:<span class="comment">//github.com.cnpmjs.org/xxxxx/xxxxx</span></span><br></pre></td></tr></table></figure>

<p>镜像站 <a href="https://hub.fastgit.org/">https://hub.fastgit.org</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/xxxxx/xxxxx</span></span><br><span class="line">替换为</span><br><span class="line">git clone https:<span class="comment">//hub.fastgit.org/xxxx/xxxx</span></span><br></pre></td></tr></table></figure>

<h1 id="GitHub-文件加速"><a href="#GitHub-文件加速" class="headerlink" title="GitHub 文件加速"></a>GitHub 文件加速</h1><p>利用 Cloudflare Workers 对 github release 、 archive 以及项目文件进行加速，部署无需服务器且自带 cdn.</p>
<p><a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz</a></p>
<p><a href="https://g.ioiox.com/">https://g.ioiox.com</a></p>
<h2 id="GitHub-Raw"><a href="#GitHub-Raw" class="headerlink" title="GitHub-Raw"></a>GitHub-Raw</h2><p>通过 GitHub raw 域名并非 <code>github.com</code> 而是 <code>raw.githubusercontent.com</code>，上方的 GitHub 加速如果不能加速这个域名，那么可以使用 Static CDN 提供的反代服务。</p>
<p>将 <code>raw.githubusercontent.com</code> 替换为 <code>raw.staticdn.net</code> 即可加速</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//github.com/xxxxx/xxxxx</span></span><br><span class="line">替换为</span><br><span class="line">https:<span class="comment">//raw.githubusercontent.com/xxxx/xxxx</span></span><br><span class="line">https:<span class="comment">//raw.staticdn.net/xxxx/xxxx</span></span><br></pre></td></tr></table></figure>

<h1 id="jsdelivr-加速"><a href="#jsdelivr-加速" class="headerlink" title="jsdelivr 加速"></a>jsdelivr 加速</h1><p>通过 jsdelivr 唯一美中不足的就是它不能获取 exe 文件以及 Release 处附加的 exe 和 dmg 文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//github.com/xxxxx/xxxxx</span></span><br><span class="line">替换为下面 jsdelivr 地址</span><br><span class="line">https:<span class="comment">//cdn.jsdelivr.net/gh/xxxxx/xxxxx/ </span></span><br></pre></td></tr></table></figure>

<h1 id="部署免费-gh-proxy"><a href="#部署免费-gh-proxy" class="headerlink" title="部署免费 gh-proxy"></a>部署免费 gh-proxy</h1><p>通过 Cloudflare Workers 和 gh-proxy 开源项目对 GitHub 文件加速,通过 Cloudflare Workers 部署无需服务器且自带 CDN。开源项目: <a href="https://github.com/hunshcn/gh-proxy">gh-proxy</a> 文件加速自行部署。</p>
<h1 id="使用-Github-镜像站"><a href="#使用-Github-镜像站" class="headerlink" title="使用 Github 镜像站"></a>使用 Github 镜像站</h1><p>你可以通过修改 Github 的链接来加速访问。例如，如果你直接访问 <a href="https://github.com/">https://github.com</a> 速度很慢，你可以尝试将其改为 <a href="https://github.hscsec.cn/">https://github.hscsec.cn</a> 以加速访问。当 GitHub 资源访问缓慢时使用下面任意网址仅替换掉 <a href="https://github.com/">https://github.com</a> 域名即可。</p>
<p>推荐的镜像站有：</p>
<p><a href="https://github.hscsec.cn/">https://github.hscsec.cn</a></p>
<p><a href="https://521github.com/">https://521github.com</a></p>
<p><a href="https://mirror.ghproxy.com/">https://mirror.ghproxy.com</a></p>
<p><a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz</a></p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git介绍和基本命令</title>
    <url>/2024/05/17/3-%E8%BD%AF%E4%BB%B6-Git-Git%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理。</p>
<p>Git 是免费、开源的<strong>分布式版本控制系统</strong>。</p>
<h2 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h2><p>集中管理的中央服务器，保存着所有文件的修改历史版本。</p>
<p>协同开发者通过客户端连接到这台服务器，从服务器上同步更新或上传自己的修改。</p>
<h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><p>远程仓库同步所有版本信息到本地的每个用户</p>
<ol>
<li>本地可以查看所有的历史版本信息，偶尔远程更新，查看其他用户修改提交到远程</li>
<li>用户即使离线也可以本地提交，push 推送到远程服务器才需要联网</li>
<li>每个用户都保存了历史版本</li>
</ol>
<h1 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h1><p><strong>Workspace</strong>：电脑本地看到的文件和目录，在 Git 的版本控制下，构成了工作区。</p>
<p><strong>Index&#x2F;Stage</strong>：暂存区，一般存放在.git 目录下，即.git&#x2F;index,它又叫待提交更新区，用于临时存放你未提交的改动。<strong>执行 git add，这些改动就添加到这个区域</strong>。</p>
<p><strong>Repository</strong>：本地仓库，你执行 git clone 地址，就是把远程仓库克隆到本地仓库。它是一个存放在本地的版本库，其中 HEAD 指向最新放入仓库的版本。当你执行 git commit，文件改动就到本地仓库。</p>
<p><strong>Remote</strong>：远程仓库，云端版本库</p>
<h1 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h1><p><strong>Untracked</strong>: 文件未加入到 git 库，未参与版本控制，处于未跟踪状态。通过 git add，可以变为 Staged 状态</p>
<p><strong>Unmodified</strong>：文件已经加入 git 库，版本库中的文件快照内容与文件夹中还完全一致。 Unmodified 的文件如果被修改, 就会变为 Modified。如果使用 git remove 移出版本库，则成为 Untracked 文件。</p>
<p><strong>Modified</strong>：文件被修改进入 modified 状态，文件这个状态通过 stage 命令可以进入 staged 状态</p>
<p><strong>staged</strong>：暂存状态. 执行 git commit 则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为 Unmodified 状态。</p>
<h1 id="正向工作流"><a href="#正向工作流" class="headerlink" title="正向工作流"></a>正向工作流</h1><p>git 的正向工作流程一般就这样：</p>
<ol>
<li>从远程仓库拉取文件代码回来；<code>git pull</code></li>
<li>在工作目录，增删改文件；</li>
<li>把改动的文件放入暂存区；<code>git add</code></li>
<li>将暂存区的文件提交本地仓库；<code>git commit</code></li>
<li>将本地仓库的文件推送到远程仓库；<code>git push</code></li>
</ol>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone [url] #克隆远程仓库</span><br><span class="line">git add [dir/file]#添加目录/文件到暂存区</span><br><span class="line">git commit [--amend] -m [msg] #提交暂存区到仓库区,msg为说明信息(amend用新的commit覆盖提交)</span><br><span class="line">git log [--oneline] [-p [file]]#查看提交历史(online精简模式)(p指定文件)</span><br><span class="line">git blame #列表方式查看指定文件的提交历史</span><br><span class="line">git diff #显示暂存区和工作区的差异</span><br><span class="line">git diff #显示暂存区和工作区的差异</span><br><span class="line">git diff filepath   <span class="meta">#filepath路径文件中，工作区与暂存区的比较差异</span></span><br><span class="line">git diff HEAD filepath #工作区与<span class="built_in">HEAD</span> ( 当前工作分支)的比较差异</span><br><span class="line">git diff branchName filepath #当前分支文件与branchName分支的文件的比较差异</span><br><span class="line">git diff commitId filepath #与某一次提交的比较差异</span><br><span class="line">git status [-s] [--show-stash] #查看当前工作区暂存区变动(-s概要信息)（show-stash显示暂存文件）</span><br><span class="line">git pull/fetch #拉取远端代码</span><br><span class="line"><span class="meta">#git pull = git fetch+ git merge。pull的话，拉取远程分支并与本地分支合并</span></span><br><span class="line"><span class="meta">#fetch只是拉远程分支，怎么合并，可以自己再做选择。</span></span><br><span class="line">git pull  #拉取远程仓库所有分支更新并合并到本地分支。</span><br><span class="line">git pull origin master #将远程master分支合并到当前本地master分支</span><br><span class="line">git pull origin master:master #将远程master分支合并到当前本地master分支，冒号后面表示本地分支</span><br><span class="line">git fetch --all  #拉取所有远端的最新代码</span><br><span class="line">git fetch origin master #拉取远程最新master分支代码</span><br><span class="line">git push #推送到远端</span><br><span class="line">git push origin master #将本地分支的更新全部推送到远程仓库master分支。</span><br><span class="line">git push origin -d    #删除远程branchname分支</span><br><span class="line">git push --tags #推送所有标签</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># git rebase</span></span><br><span class="line"></span><br><span class="line">`rebase`又称为衍合，是合并的另外一种选择。 `rebase`好处是： 获得更优雅的提交树，可以线性的看到每一次提交，并且没有增加提交节点。所以很多时候，看到有些伙伴都是这个命令拉代码：`git pull --rebase`</span><br><span class="line"></span><br><span class="line"><span class="meta"># git stash</span></span><br><span class="line"></span><br><span class="line">`stash`命令可用于临时保存和恢复修改</span><br><span class="line"></span><br><span class="line">git stash  把当前的工作隐藏起来 等以后恢复现场后继续工作</span><br><span class="line">git stash list 显示保存的工作进度列表</span><br><span class="line">git stash pop stash@&#123;num&#125; 恢复工作进度到工作区</span><br><span class="line">git stash show ：显示做了哪些改动</span><br><span class="line">git stash drop stash@&#123;num&#125; ：删除一条保存的工作进度</span><br><span class="line">git stash clear 删除所有缓存的stash。</span><br><span class="line"><span class="meta"># git reflog</span></span><br><span class="line"></span><br><span class="line">显示当前分支的最近几次提交</span><br><span class="line"></span><br><span class="line"><span class="meta"># git blame</span></span><br><span class="line"></span><br><span class="line">`git blame filepath`记录了某个文件的更改历史和更改人</span><br><span class="line"></span><br><span class="line"><span class="meta"># git remote</span></span><br><span class="line"></span><br><span class="line">git remote   查看关联的远程仓库的名称</span><br><span class="line">git remote add url   添加一个远程仓库</span><br><span class="line">git remote show [remote] 显示某个远程仓库的信息</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git常用操作</title>
    <url>/2024/05/17/3-%E8%BD%AF%E4%BB%B6-Git-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><h2 id="对于网络项目"><a href="#对于网络项目" class="headerlink" title="对于网络项目"></a>对于网络项目</h2><p><code>git clone [url]</code> 将 GitHub 中的网络项目复制到本地，只需在修改完之后 commit 即可，然后更新仓库代码，就可同步修改。</p>
<h2 id="对于本地项目"><a href="#对于本地项目" class="headerlink" title="对于本地项目"></a>对于本地项目</h2><p>首先要创建一个文件夹用以存放文件，然后使用</p>
<ul>
<li><code>git init</code> 对进行初始化操作</li>
<li><code>git status</code> 得到 git 中文件的状态</li>
<li><code>git add filename</code> 将 filename 文件加入到 git 本地仓库中去（git rm -cached 可移除）</li>
<li><code>git commit -m ‘status’</code> 表示提交信息（status 表示附加信息）</li>
</ul>
<p>之后对本地项目进行关联</p>
<ul>
<li><code>git remote add origin [url]</code> 添加本地到远程 origin 仓库</li>
<li><code>git remote -v</code> 查看当前项目有哪些远程仓库 关联之后可以向远程仓库提交代码（更新仓库代码）</li>
</ul>
<h2 id="日常-push"><a href="#日常-push" class="headerlink" title="日常 push"></a>日常 push</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">`git status` #获取状态</span><br><span class="line">`git add . `#添加文件到暂存区</span><br><span class="line">`git commit -m <span class="string">&quot;20191121 push&quot;</span> `#提交文件</span><br><span class="line">`git push origin master `#推送</span><br></pre></td></tr></table></figure>

<h2 id="日常-pull"><a href="#日常-pull" class="headerlink" title="日常 pull"></a>日常 pull</h2><ul>
<li><code>git diff</code> <em>比较工作目录和 Index 中的代码。</em></li>
<li><code>git fetch</code> <em>当于从远程获取最新版本到本地，不会自动 merge ，比 Git pull 更安全些</em></li>
<li><code>git checkout app/model/user.rb</code> <em>将 user.rb 文件从上一个已提交的版本中更新回来，未提交的工作目录中的内容全部会被覆盖</em></li>
</ul>
<h2 id="首次使用配置-ssh"><a href="#首次使用配置-ssh" class="headerlink" title="首次使用配置 ssh"></a>首次使用配置 ssh</h2><ul>
<li><code>ssh-keygen -t rsa</code></li>
<li><code>ssh -T &lt;git@github.com&gt;</code></li>
</ul>
<p>将.ssh 下的 pub 公钥复制到 github 账号中的设置-SSH，添加密钥即可</p>
<h2 id="首次使用设置用户"><a href="#首次使用设置用户" class="headerlink" title="首次使用设置用户"></a>首次使用设置用户</h2><ul>
<li><code>git config (--global) user.name &quot;username&quot;</code></li>
<li><code>git config (--global) user.email &quot;&lt;username@gmail.com&gt;&quot;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git config --global user.name liuluhua</span><br><span class="line">git config --global user.email <span class="number">718050012</span>@qq.com</span><br></pre></td></tr></table></figure>

<h2 id="上传-下载常用命令"><a href="#上传-下载常用命令" class="headerlink" title="上传&#x2F;下载常用命令"></a>上传&#x2F;下载常用命令</h2><ul>
<li><code>git push origin（仓库名） master（分支）</code> <em>更新仓库代码（上传）</em></li>
<li><code>git pull origin（仓库名） master（分支）</code> <em>更新本地代码（下载）</em></li>
</ul>
<h2 id="回退历史版本"><a href="#回退历史版本" class="headerlink" title="回退历史版本"></a>回退历史版本</h2><ul>
<li><code>git log</code></li>
<li><code>git reset --hard \[commit\_id]</code></li>
<li><code>git revert \[commit\_id]</code></li>
</ul>
<h2 id="网络项目"><a href="#网络项目" class="headerlink" title="网络项目"></a>网络项目</h2><ul>
<li><code>git clone \[url]</code></li>
<li><code>git remote add origin \[url]</code> <em>添加本地到远程 origin 仓库</em></li>
<li><code>git remote -v</code> <em>查看当前项目有哪些远程仓库</em></li>
</ul>
<h2 id="版本情况"><a href="#版本情况" class="headerlink" title="版本情况"></a>版本情况</h2><ul>
<li><code>git tag</code> <em>查看版本情况</em></li>
<li><code>git tag V1.0</code> <em>新建版本</em></li>
<li><code>git checkout V1.0</code> <em>切换至版本 V1.0</em></li>
</ul>
<h2 id="分支情况"><a href="#分支情况" class="headerlink" title="分支情况"></a>分支情况</h2><ul>
<li><code>git branch</code> <em>查看当前分支情况</em></li>
<li><code>git checkout a</code> <em>切换到分支 a</em></li>
<li><code>git checkout -b a</code> <em>新建分支 a 并切换到分支 a</em></li>
<li><code>git branch -d a</code> <em>删除 a 分支</em></li>
<li><code>git merge a</code> <em>将 a 分支的代码合并到 master 分支上</em></li>
</ul>
<h2 id="撤销或回退"><a href="#撤销或回退" class="headerlink" title="撤销或回退"></a>撤销或回退</h2><p>在 Git 中，撤销和回退是指<strong>撤销</strong>或<strong>回退</strong>先前的提交或更改。 简单介绍下 Git 中的撤销和回退操作，以及如何使用它们来管理代码库。</p>
<p>可以把版本库上的提交回退到暂存区，修改记录保留 <code>git reset –-soft []</code></p>
<p>可以把版本库上的提交回退到工作区，修改记录保留 <code>git reset –-mixed []</code></p>
<p>可以把版本库上的提交彻底回退，修改的记录全部 revert。<code>git reset –-hard</code></p>
<h2 id="reset-和-revert-的区别"><a href="#reset-和-revert-的区别" class="headerlink" title="reset 和 revert 的区别"></a>reset 和 revert 的区别</h2><p><code>git reset</code> 和 <code> git revert</code> 的主要区别在于它们对历史记录的处理方式。git reset 会删除历史记录并永久删除更改，而 git revert 会创建一个新的提交来撤销更改并保留历史记录。</p>
<p><code>git reset</code> 命令会将 HEAD 指针指向指定的 commit，并将暂存区和工作目录恢复到该 commit 的状态。这意味着在执行 <code>git reset</code> 后，之前的更改将不再存在于工作目录和暂存区中。如果您希望永久删除一些更改并且不再需要它们，可以使用 <code>git reset</code>。</p>
<p><code>git revert</code> 命令会创建一个新的提交来撤销指定的提交。这意味着在执行 <code>git revert</code> 后，之前的更改仍然存在于工作目录和暂存区中，并且您需要提交一个新的撤销提交。如果您想要保留更改历史记录并且不想永久删除更改，可以使用 <code>git revert</code>。</p>
<h2 id="获取-ID"><a href="#获取-ID" class="headerlink" title="获取 ID"></a>获取 ID</h2><p><code>git log</code> 获取到想要回退的 commit_id</p>
<h2 id="撤销-回退未提交的更改"><a href="#撤销-回退未提交的更改" class="headerlink" title="撤销&#x2F;回退未提交的更改"></a>撤销&#x2F;回退未提交的更改</h2><p>**(add 之后，commit 之前)** 要撤销未提交的更改，请使用以下命令： <code>git checkout &lt;file-name&gt;</code> 将名为 file-name 的文件恢复到上一个提交的状态。</p>
<blockquote>
<p>本地本次的更改也不再保存，恢复到上一个提交 (commit) 的状态</p>
</blockquote>
<p><code>git reset HEAD --file </code> 回退暂存区里的某个文件，回退到当前版本工作区状态</p>
<blockquote>
<p>保存工作区的更改，只是撤销 <code>git add</code> 这一步操作</p>
</blockquote>
<p><code>git checkout .</code> 将所有文件恢复到最新提交的状态。请注意，此操作将删除所有未提交的更改。</p>
<h2 id="撤销-回退上一个提交"><a href="#撤销-回退上一个提交" class="headerlink" title="撤销&#x2F;回退上一个提交"></a>撤销&#x2F;回退上一个提交</h2><p>**(commit 之后，push 之前)** 撤销上一个提交 <code>git reset HEAD~1</code> 将 HEAD 指针移动到上一个提交。</p>
<blockquote>
<p>工作区保留先前的更改，需要重新添加到暂存区 (git add)</p>
</blockquote>
<p>回退到上一个提交 <code>git reset --hard HEAD~1</code> 将 HEAD 指针和工作树都重置为上一个提交的状态。</p>
<blockquote>
<p>请注意，此操作将删除所有未提交 (commit) 的更改。</p>
</blockquote>
<h2 id="撤销-回退到特定的提交"><a href="#撤销-回退到特定的提交" class="headerlink" title="撤销&#x2F;回退到特定的提交"></a>撤销&#x2F;回退到特定的提交</h2><p>**(push 之后)** 撤销到特定版本 <code>git revert &lt;commit_id&gt;</code> 这将创建一个新的提交，该提交撤销名为 commit-hash 的提交所做的更改。</p>
<blockquote>
<p>本次撤销操作也会作为一次提交 (push) 进行保存</p>
</blockquote>
<p>回退到特定版本 <code>git reset --hard &lt;commit_id&gt;</code> 将 HEAD 指针和工作树都重置为名为 commit-hash 的提交的状态。</p>
<blockquote>
<p>请注意，此操作将删除所有未提交的更改。</p>
</blockquote>
<p>回退完成后，git push -f 强制提交</p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>Git 是一个流行的分布式版本控制系统，一般都是存在多个分支的，开发分支，回归测试分支以及主干分支等 在 Git 中，分支是指指向 Git 提交历史中某个特定提交的指针。 每个分支都包含在 Git 提交历史中的一系列提交，这些提交构成了分支的历史记录。 分支在 Git 中非常重要，因为它们允许多个开发人员同时在同一个代码库中工作，而不会相互干扰。 通过创建分支，每个开发人员都可以在自己的分支上进行工作，而不会影响其他人的工作。 这样，开发人员可以在不干扰其他人的情况下，独立地开发和测试新功能，最终将这些更改合并到主分支中。</p>
<p>在 Git 中，分支操作非常简单。以下是一些常用的 Git 分支操作：</p>
<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>要创建一个新分支，请使用以下命令： <code>git branch &lt;branch-name&gt;</code> 这将创建一个名为 branch-name 的新分支。</p>
<blockquote>
<p>注意，此时仍然在当前分支上工作。</p>
</blockquote>
<p><code>git checkout -b &lt;branch-name&gt;</code> 新建一个分支，并且切换到新的分支 branch-name</p>
<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>要查看所有分支，请使用以下命令： <code>git branch</code> 这将列出所有分支，当前分支将用一个星号标记。</p>
<blockquote>
<p>git branch -r 查看所有远程的分支 git branch -a 查看所有远程分支和本地分支</p>
</blockquote>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>要删除一个分支，请使用以下命令： <code>git branch -d &lt;branch-name&gt;</code> 这将删除名为的分支。</p>
<blockquote>
<p>注意，如果该分支包含未合并的更改，则必须使用 <code>-D</code> 选项而不是 <code>-d</code> 选项来强制删除该分支。</p>
</blockquote>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>要切换到另一个分支，请使用以下命令： <code>git checkout &lt;branch-name&gt;</code> 这将使您从当前分支切换到名为 branch-name 的分支。</p>
<blockquote>
<p>注意，需要在切换分支之前将所有更改提交或保存。</p>
</blockquote>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>要将一个分支合并到另一个分支，请使用以下命令： <code>git merge &lt;branch-name&gt;</code> 将名为 branch-name 的分支合并到当前分支中。</p>
<blockquote>
<p>注意，如果两个分支上都有对同一文件的更改，则可能会发生冲突。在这种情况下，需要手动解决冲突并提交更改。 git merge –no-ff origin&#x2F;dev 在当前分支上合并远程分支 dev git merge –abort 终止本次 merge，并回到 merge 前的状态</p>
</blockquote>
<p>以上是一些常用的 Git 分支操作。使用这些操作，您可以轻松地创建、切换、合并和删除分支。这些操作使多人协作变得更加容易，因为每个开发人员都可以在自己的分支上进行工作，并将更改合并到主分支中。在实际开发中，分支操作是非常重要的，最好能够熟练掌握并运用这些操作</p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>在 Git 中，tag 是用于标记某个特定提交的名称。它类似于一个<strong>快照</strong>，可以用于标记版本、发布或重要的里程碑。Git 中有两种类型的 tag：轻量级标签和附注标签。</p>
<p>轻量级标签是一个简单的指向某个特定提交的<strong>引用</strong>，类似于一个分支，但不会随着新的提交而移动。创建轻量级标签的方法很简单，只需在命令行中输入 <code>git tag &lt;tag-name&gt; </code> 即可。例如，<code>git tag v1.0</code> 将创建一个名为 v1.0 的轻量级标签。</p>
<p>附注标签是一个包含标签名称、标签创建者、标签创建日期和标签说明的 Git 对象。它们是 Git 中最常用的标签类型，可以用于发布版本、重要的里程碑和其他<strong>重要的提交</strong>。创建附注标签的方法是使用 -a 标志和标签名称，然后输入标签说明。例如，<code>git tag -a v1.0 -m &quot;Release version 1.0&quot;</code> 将创建一个名为 v1.0 的附注标签，并将其说明设置为 “Release version 1.0”。</p>
<p>标签可以使用 <code>git push</code> 命令推送到远程存储库中，以便在其他计算机上使用。例如，要将名为 v1.0 的标签推送到远程存储库，可以使用 <code>git push origin v1.0</code> 命令。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git tag  #列出所有tag</span><br><span class="line">git tag [tag] #新建一个tag在当前commit</span><br><span class="line">git tag [tag] [commit] #新建一个tag在指定commit</span><br><span class="line">git tag -d [tag] #删除本地tag</span><br><span class="line">git push origin [tag] #推送tag到远程</span><br><span class="line">git show [tag] #查看特定tag</span><br><span class="line">git checkout -b [branch] [tag] #新建一个分支，指向某个tag</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git服务器环境搭建和客户端使用</title>
    <url>/2024/05/17/3-%E8%BD%AF%E4%BB%B6-Git-Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><del>服务端</del></h1><p>安装 <code>git</code> 和 <code>ssh</code></p>
<p><code>sudo apt-get install git</code></p>
<p><code>sudo apt-get install openssh-server openssh-client</code></p>
<p>增加 git 用户并生成文件夹</p>
<p><code>sudo adduser git</code></p>
<p><code>sudo mkdir /home/git</code></p>
<p>创建 ssh 证书认证文件</p>
<p><code>sudo mkdir /home/git/.ssh</code></p>
<p><code>sudo touch /home/git/.ssh/authorized_keys</code></p>
<p>临时修改 authorized_keys 文件的权限</p>
<p><code>sudo chmod 777 /home/git/.ssh/authorized_keys</code></p>
<p>把需要访问 git 服务器的<strong>客户端公钥 id_rsa.pub</strong>的内容复制到 authorized_keys 文件</p>
<p>修改 authorized_keys 文件的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 700 /home/git</span><br><span class="line">sudo chmod 700 /home/git/.ssh</span><br><span class="line">sudo chmod 600 /home/git/authorized_keys</span><br><span class="line">sudo chown -R git:git /home/git</span><br><span class="line">sudo chown -R git:git /home/git/.ssh</span><br><span class="line">sudo chown -R git:git /home/git/.ssh/authorized_keys</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>为了安全考虑禁止登录 git 服务器的 shell，修改 git 的 shell</p>
<p>用 <code>/usr/bin/git-shell</code> 把 <code>/etc/passwd</code> 的 <code>git:x:1004:1004:,,,:/home/git:/bin/bash</code></p>
<p>改成： <code>git:x:1004:1004:,,,:/home/git:/usr/bin/git-shell</code> 保存</p>
<p>建代码仓库</p>
<p><code>sudo mkdir /home/Repo #创建仓库的目录</code></p>
<p><code>sudo git init --bare /home/Repo/test.git #创建仓库</code></p>
<p><code>sudo chown -R git:git /home/Repo/test.git #修改权限为git</code></p>
<blockquote>
<p>以后每创建一个新的仓库，记得最后一步操作: 修改仓库所属用户为 git。</p>
</blockquote>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>安装 <code>git</code></p>
<p><code>Linux</code> 环境下 <code>sudo apt-get install git</code></p>
<p>Windows 环境下直接安装 <a href="https://git-scm.com/downloads">Git安装包</a></p>
<p>配置连接</p>
<p>通过密钥方式 <code>ssh-keygen -t rsa [-C &quot;你的邮箱地址&quot;]</code> 会生成 <code>id_rsa.pub</code> 文件</p>
<p>添加该公钥到到服务器</p>
<p>Linux 环境下，密钥默认位于 <code>/home/ubuntu/.ssh/id\_rsa</code></p>
<p>Windows 环境下密钥位于 <code>C:\Users\xxx.ssh\id\_rsa.pub</code></p>
<p>通过用户名&#x2F;密码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git config –global user.name “username”</span><br><span class="line">git config –global user.email “username@gmail.com”</span><br></pre></td></tr></table></figure>

<p>在连接 git 时，会需要输入账号密码，直接输入即可</p>
<h1 id="附注：增量备份-Git-服务器备份"><a href="#附注：增量备份-Git-服务器备份" class="headerlink" title="附注：增量备份 -Git 服务器备份"></a>附注：增量备份 -Git 服务器备份</h1><p><strong>使用 crontab 建立每天凌晨 3 点定时触发的任务</strong><code>crontab -e </code></p>
<p><code>0 3 * * * * rsync -av -e &quot;ssh -i /path/to/id_rsa&quot; /homt/git/ remote_user@X.X.X.X:~/backup</code></p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>版本控制方案</title>
    <url>/2024/05/17/3-%E8%BD%AF%E4%BB%B6-Git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="Git-方案"><a href="#Git-方案" class="headerlink" title="Git 方案"></a>Git 方案</h1><p>1.      仓库创建</p>
<p>仓库创建基于当前的项目，例如备份仪表项目仓库，LSA 项目等</p>
<p>2.      分支创建</p>
<p>项目主分支保存项目代码及文档，负责发布代码</p>
<p>项目开发分支保存项目源码，分支仅管理员可见</p>
<p>项目运行分支保存项目头文件及库文件代码，分支所有人可见</p>
<p>项目人员开发分支基于运行分支创建，仅该人员有权限，该人员开发任务基于该分支进行修改代码</p>
<p>3.      代码提交</p>
<p>各人员代码仅提交在单独分支，提交完成后，由管理员审核后，同步源代码至开发分支</p>
<p>4.      版本回退</p>
<h1 id="SVN-方案"><a href="#SVN-方案" class="headerlink" title="SVN 方案"></a>SVN 方案</h1>]]></content>
      <categories>
        <category>3.软件</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>vim安装</title>
    <url>/2024/05/22/3-%E8%BD%AF%E4%BB%B6-VIM-vim%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>配置文件 <a href="source/_posts/3.%E8%BD%AF%E4%BB%B6/VIM/vimrc.cfg">地址</a></p>
<ol>
<li>安装环境</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install git cscope</span><br><span class="line">wget -qO - https:<span class="comment">//raw.github.com/ma6174/vim/master/setup.sh | sh -x</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>wget 是一个用于从网络下载文件的命令行工具。<br>-q 表示静默模式，不显示下载进度和其他信息。<br>-O - 指定输出到标准输出（stdout），而不是保存到文件。这样下载的文件内容就会直接输出到终端。<br><a href="https://raw.github.com/ma6174/vim/master/setup.sh">https://raw.github.com/ma6174/vim/master/setup.sh</a> 是要下载的文件的 URL 地址。<br>| 是管道符号，用于将前一个命令的输出作为后一个命令的输入。<br>sh 是一个用于执行 Shell 脚本的命令。<br>-x 表示在执行脚本时显示详细的调试信息。</p>
</blockquote>
<p><strong>setup.sh 内容</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;安装将花费一定时间，请耐心等待直到安装完成~~&quot;</span></span><br><span class="line"><span class="keyword">if</span> which apt-get &gt;/dev/null; then</span><br><span class="line">	sudo apt-get install -y vim vim-gnome ctags xclip astyle python-setuptools python-dev git</span><br><span class="line">elif which yum &gt;/dev/null; then</span><br><span class="line">	sudo yum install -y gcc vim git ctags xclip astyle python-setuptools python-devel</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">##Add HomeBrew support on Mac OS</span><br><span class="line"><span class="keyword">if</span> which brew &gt;/dev/null;then</span><br><span class="line">	echo <span class="string">&quot;You are using HomeBrew tool&quot;</span></span><br><span class="line">	brew install vim ctags git astyle</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">sudo easy_install -ZU autopep8</span><br><span class="line">sudo ln -s /usr/bin/ctags /usr/local/bin/ctags</span><br><span class="line">mv -f ~/vim ~/vim old</span><br><span class="line">cd ~/ &amp;&amp; git clone https:<span class="comment">//github.com/ma6174/vim.git</span></span><br><span class="line">mv -f ~/.vim ~/.vim_old </span><br><span class="line">mv -f ~/vim ~/.vim</span><br><span class="line">mv -f ~/.vimrc ~/.vimrc_old</span><br><span class="line">mv -f ~/.vim/.vimrc ~/  </span><br><span class="line"></span><br><span class="line">git clone https:<span class="comment">//github.com/gmarik/vundle.git ~/.vim/bundle/vundle</span></span><br><span class="line">echo <span class="string">&quot;ma6174正在努力为您安装bundle程序&quot;</span> &gt; ma6174</span><br><span class="line">echo <span class="string">&quot;安装完毕将自动退出&quot;</span> &gt;&gt; ma6174</span><br><span class="line">echo <span class="string">&quot;请耐心等待&quot;</span> &gt;&gt; ma6174</span><br><span class="line">vim ma6174 -c <span class="string">&quot;BundleInstall&quot;</span> -c <span class="string">&quot;q&quot;</span> -c <span class="string">&quot;q&quot;</span></span><br><span class="line">rm ma6174</span><br><span class="line">echo <span class="string">&quot;安装完成&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd /usr/include</span><br><span class="line">sudo ctags -R</span><br><span class="line">cd -</span><br><span class="line">vim .vimrc</span><br></pre></td></tr></table></figure>

<p>修改最后一行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set tags=/usr/include/tags</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装 zsh<br>Zsh 是一种替代默认的命令行 Shell（如 Bash）的 Shell。<br>Zsh（Z Shell）是一种强大的命令行 Shell，它具有许多增强的功能和可定制选项。相较于传统的 Bash Shell，Zsh 提供了更好的自动补全、历史记录管理、拼写修正、主题定制等功能。它还支持丰富的插件和扩展，可以根据用户的需求进行定制和配置。</li>
</ol>
<p>接下来，<code>chsh -s /bin/zsh</code> 是一个用于更改当前用户的默认 Shell 的命令。chsh 是 “change shell” 的缩写，-s 选项指定要更改为的新 Shell，<code>/bin/zsh</code> 是指要更改为 Zsh 的路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>VIM</category>
      </categories>
  </entry>
  <entry>
    <title>FTP 配置</title>
    <url>/2024/08/17/3-%E8%BD%AF%E4%BB%B6-Web%E7%9B%B8%E5%85%B3-FTP-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="FTP-配置-用于图床"><a href="#FTP-配置-用于图床" class="headerlink" title="FTP 配置 - 用于图床"></a>FTP 配置 - 用于图床</h1><p>安装 ftp 服务端</p>
<p>sudo apt install vsftpd -y</p>
<p>修改配置文件</p>
<p>sudo vi &#x2F;etc&#x2F;vsftpd.conf</p>
<blockquote>
<p>禁止匿名访问<br>anonymous_enable&#x3D;NO</p>
<h1 id="接受本地用户"><a href="#接受本地用户" class="headerlink" title="接受本地用户"></a>接受本地用户</h1><p>local_enable&#x3D;YES</p>
<h1 id="允许上传"><a href="#允许上传" class="headerlink" title="允许上传"></a>允许上传</h1><p>write_enable&#x3D;YES</p>
<h1 id="更改创建文件权限"><a href="#更改创建文件权限" class="headerlink" title="更改创建文件权限"></a>更改创建文件权限</h1><p>local_umask&#x3D;022</p>
</blockquote>
<p>重启服务</p>
<p>sudo service vsftpd restart</p>
<p>创建 FTP 用户</p>
<p>sudo useradd -d &#x2F;home&#x2F;lemonade -M lemonade</p>
<p>sudo passwd lemonade</p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>Web相关</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx学习笔记</title>
    <url>/2024/05/16/3-%E8%BD%AF%E4%BB%B6-Web%E7%9B%B8%E5%85%B3-Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>功能：</p>
<ul>
<li>Web 服务器</li>
<li>负载均衡</li>
<li>API 网关</li>
<li>DDoS 防御</li>
<li>反向代理</li>
<li>Web 应用防火墙</li>
<li>缓存</li>
</ul>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><code>sudo apt install nginx -y</code></p>
<p>访问公网 IP，发现 nginx 页面安装成功</p>
<h1 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h1><p>nginx 的配置文件位于 <code>/etc/nginx/</code>，修改 nginx 配置文件 &#96;sudo vi &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;default</p>
<p>根据配置文件中的 <code>root</code> 确定根目录位置 <code>/var/www/html</code></p>
<p>链接网页根目录到指定位置</p>
<p><code>ln -s /var/www/html ~/html</code></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>cd /etc/nginx/sites-enable</code></p>
<p>原来的配置为 default（链接到 sites-avaliable），删除并添加自己的页面</p>
<p>输入下列内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen    <span class="number">8080</span> default_server;# 注意这里，要把默认的那个default_server去掉,因为我们在下面要单独配置域名访问，所以这里不要留default_server，不然会报错。</span><br><span class="line">  #server_name mytest.com; <span class="comment">//这里写你想设置的域名，可以写多个，与名之间用空格隔开</span></span><br><span class="line">  root     /home/ubuntu/html;#  <span class="comment">//这里是你虚拟机的根目录，写绝对路径</span></span><br><span class="line">  # Load configuration files <span class="keyword">for</span> the <span class="keyword">default</span> server block.</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    index index.php index.html index.htm;# <span class="comment">//这里配置默认访问的页面</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#location ~* \.php$ &#123;  <span class="comment">//这里配置php解析.php文件</span></span></span><br><span class="line"></span><br><span class="line">  #  fastcgi_index  index.php;</span><br><span class="line">  #  fastcgi_pass  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9000</span>;</span><br><span class="line">  <span class="meta">#  <span class="keyword">include</span>     fastcgi_params;</span></span><br><span class="line">  #  fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">  #  fastcgi_param  SCRIPT_NAME    $fastcgi_script_name;</span><br><span class="line">  #&#125;</span><br><span class="line">  #error_page <span class="number">404</span> /<span class="number">404.</span>html;  <span class="comment">//默认的错误页面</span></span><br><span class="line">  <span class="meta">#  location = /40x.html &#123;</span></span><br><span class="line">  #&#125;</span><br><span class="line">  #error_page <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /<span class="number">50</span>x.html;</span><br><span class="line">  <span class="meta">#  location = /50x.html &#123;</span></span><br><span class="line">  #&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend1 &#123;</span><br><span class="line">        server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>;  # 本地端口 <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream backend2 &#123;</span><br><span class="line">        server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8001</span>;  # 本地端口 <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen <span class="number">80</span>;  # 远程访问的端口</span><br><span class="line"></span><br><span class="line">        location /service1/ &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//backend1;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /service2/ &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//backend2;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入 <code>nginx -t</code> 检查配置文件</p>
<p>之后重新启动 <code>nginx</code> 并访问</p>
<p><code>sudo systemctl start nginx</code></p>
<p><code>sudo systemctl enable nginx</code></p>
<p>直接输入 IP 地址即可访问，根据设置的端口进行访问</p>
<h1 id="修改页面，重载页面"><a href="#修改页面，重载页面" class="headerlink" title="修改页面，重载页面"></a>修改页面，重载页面</h1><p><code>sudo nginx -s reload</code></p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>查看 nginx 版本</p>
<p><code>nginx -v</code></p>
<p>配置文件所在位置 <code>/etc/nginx</code>，文件名 <code>nginx.conf</code></p>
<p>检查配置文件是否有问题</p>
<p><code>nginx -t</code></p>
<p>重新加载 nginx 配置文件</p>
<p><code>nginx -s reload</code></p>
<p>关闭 nginx</p>
<p><code>nginx -s quit</code> 或 <code>nginx -s stop</code></p>
<p><strong>events</strong><br><strong>http</strong><br><strong>server</strong><br><strong>include</strong><br><strong>listen</strong><br><strong>server_name</strong><br><strong>root</strong> 根目录节点<br><strong>index</strong> 指定页面<br><strong>return</strong><br><strong>location</strong> &#x3D;(完全匹配)  ~(启用正则表达式)<br><strong>rewrite</strong>  重写<br><strong>proxy_pass</strong></p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>Web相关</category>
      </categories>
  </entry>
  <entry>
    <title>Nodejs和npm</title>
    <url>/2023/05/28/3-%E8%BD%AF%E4%BB%B6-Web%E7%9B%B8%E5%85%B3-Nodejs%E5%92%8Cnpm/</url>
    <content><![CDATA[<h1 id="更新-nodejs-到最新版本"><a href="#更新-nodejs-到最新版本" class="headerlink" title="更新 nodejs 到最新版本"></a>更新 nodejs 到最新版本</h1><p>卸载自带的 nodejs</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt autoremove nodejs</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt purge nodejs</span><br></pre></td></tr></table></figure>

<p>安装 20 版本的 nodejs</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:<span class="comment">//deb.nodesource.com/setup_20.x | sudo -E bash - &amp;&amp; sudo apt-get install -y nodejs</span></span><br></pre></td></tr></table></figure>

<p>查看版本是否更新，否则关闭命令行重新打开</p>
<p><code>nodejs -v</code></p>
<p><del>安装 nodejs 安装工具到全局</del></p>
<p><del>sudo npm install n -g</del></p>
<p><del>安装稳定版本 nodejs</del></p>
<p><del>sudo n stable</del></p>
<h1 id="安装-npm"><a href="#安装-npm" class="headerlink" title="安装 npm"></a>安装 npm</h1><p><code>sudo apt install npm -y</code></p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>Web相关</category>
      </categories>
  </entry>
  <entry>
    <title>curl 命令</title>
    <url>/2024/08/14/3-%E8%BD%AF%E4%BB%B6-Web%E7%9B%B8%E5%85%B3-curl-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h1><p><a href="https://curl.se/libcurl/">libcurl</a></p>
<p>安装示例如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ubuntu</span></span><br><span class="line">sudo apt-get install libcurl4-openssl-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">#centos</span></span><br><span class="line">yum install libcurl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment">#macos（本身自带curl，这一步非必须）</span></span><br><span class="line">brew install curl</span><br><span class="line"></span><br><span class="line"><span class="comment">#windows（这里的 cpu 架构请根据实际环境灵活选择）</span></span><br><span class="line">vcpkg install curl:x64-windows</span><br></pre></td></tr></table></figure>

<p>备注：建议安装最新版的 libcurl 库，否则可能存在 libcurl 库内存泄露 bug 问题。</p>
<h1 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h1><p>是一个功能强大的命令行传输工具，用于发送请求和下载文件。它支持多种协议，如 HTTP、HTTPS、FTP 等，可以设置请求头、请求参数等</p>
<h2 id="发送-GET-请求"><a href="#发送-GET-请求" class="headerlink" title="发送 GET 请求"></a>发送 GET 请求</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">curl URL</span><br><span class="line"></span><br><span class="line">curl URL?a=<span class="number">1</span>&amp;b=nihao</span><br></pre></td></tr></table></figure>

<h2 id="发送-POST-请求"><a href="#发送-POST-请求" class="headerlink" title="发送 POST 请求"></a>发送 POST 请求</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&#x27;a=1&amp;b=nihao&#x27;</span> URL</span><br></pre></td></tr></table></figure>

<h2 id="发送-json-格式请求："><a href="#发送-json-格式请求：" class="headerlink" title="发送 json 格式请求："></a>发送 json 格式请求：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X POST -d <span class="string">&#x27;&#123;&quot;abc&quot;:123,&quot;bcd&quot;:&quot;nihao&quot;&#125;&#x27;</span> URL</span><br><span class="line"></span><br><span class="line">curl -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X POST -d @test.json URL</span><br></pre></td></tr></table></figure>

<ul>
<li>-H 代表 header 头</li>
<li>-X 是指定什么类型请求(POST&#x2F;GET&#x2F;HEAD&#x2F;DELETE&#x2F;PUT&#x2F;PATCH)</li>
<li>-d 代表传输什么数据</li>
</ul>
<blockquote>
<p>查看所有 curl 命令： man curl 或者 curl -h<br>请求头：H,A,e<br>响应头：I,i,D<br>cookie：b,c,j<br>传输：F(POST),G(GET),T(PUT),X<br>输出：o,O,w<br>断点续传：r<br>调试：v,–trace,–trace-ascii,–trace-time</p>
</blockquote>
<h2 id="测试端口"><a href="#测试端口" class="headerlink" title="测试端口"></a>测试端口</h2><p>可以用它来测试端口是否开启。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">curl -v ip:port</span><br></pre></td></tr></table></figure>

<ul>
<li>出现 Connection refused 表示端口关闭；</li>
<li>出现 Connected to ip(ip) port(#0)表示端口开启；</li>
<li>出现 No route to host 表示 IP 错误或者 iptables 限制。</li>
</ul>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>Web相关</category>
      </categories>
  </entry>
  <entry>
    <title>WireShark的安装</title>
    <url>/2023/05/25/3-%E8%BD%AF%E4%BB%B6-WireShark-WireShark%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h1><p>重点演示：</p>
<ol>
<li>如何选择网卡接口</li>
<li>如何设置过滤条件</li>
<li>如何查看抓取的报文</li>
</ol>
<h1 id="Linux-下安装和配置"><a href="#Linux-下安装和配置" class="headerlink" title="Linux 下安装和配置"></a>Linux 下安装和配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wireshark</span><br></pre></td></tr></table></figure>

<h2 id="设置运行权限"><a href="#设置运行权限" class="headerlink" title="设置运行权限"></a>设置运行权限</h2><p>如果您在此阶段以非 root 用户身份运行 wireshark，您将收到消息“没有接口可以用于在当前配置的系统中进行捕获。”</p>
<blockquote>
<p>缺省在非 root 账号下运行会发现看不见 interface 信息</p>
</blockquote>
<ol>
<li>Create the wiresharkgroup.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo groupadd wireshark</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Add your username to the wiresharkgroup</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G wiresharkYOUR_USER_NAME</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Change the group ownership of file dumpcap to wireshark</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chgrp wireshark/usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Change the mode of the file dumpcap to allow execution bythe group wireshark</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo chmod <span class="number">750</span> /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Grant capabilities with setcap, man capabilities(7), setcap(8), cap_from_text(3) for more info about what are “cap_net_raw”, “cap_net_admin” and “eip”. Anyway, after we grant the capabilities, the dump can perform various network-related operations, use RAW and PACKET sockets; bind to anyaddressfor transparent proxying.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo setcap cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Verifythe change</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo getcap /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<p>Outputshould be like below:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/usr/bin/dumpcap = cap_net_admin,cap_net_raw+eip</span><br></pre></td></tr></table></figure>

<p>At this point, you will need to log out, then backinto ubuntu</p>
<p>简单介绍下这个软件的一些常用按钮，简单的说下最常用的按钮，打开软件后，下面红框中的按钮从左到右依次是：</p>
<p>-1 列表显示所有网卡的网络包情况，一般用的很少；</p>
<p><strong>-2 显示抓包选项，一般都是点这个按钮开始抓包；</strong></p>
<p>-3 开始新的抓包，一般用的也很少；</p>
<p><strong>-4 停止抓包，当你抓完包之后，就是点这个停止了；</strong></p>
<p><strong>-5 清空当前已经抓到的数据包，可以防止抓包时间过长机器变卡；</strong></p>
<p>而实际上，一般我们只要知道上面加粗部分的按钮功能，就可以完成抓包了，剩下的就是如何抓你想要的数据包，如何分析的问题了。</p>
<p>接下来说下抓包选项界面，也就是点第二个按钮出来的界面，同样，这里也只介绍最常用的几个功能，首先下图中最上面的红框是选择需要抓的网卡，选择好网卡后会在下面显示这个网卡的 IP 地址。</p>
<p>然后 Capture Filter 中就是要写抓包规则的地方，也叫做“过滤规则”，我们下面要说的很多规则都是要写到这个框里的，规则写好后，点下</p>
<p>面的 Start 就开始抓包了。</p>
<p>当抓包结束之后，如果你需要把抓到的数据包找其他人分析，那么可以点菜单上的 file，然后点 Save As 保存抓到的数据包</p>
<p>使用 Wireshark 时最常见的问题，是当您使用默认设置时，会得到大量冗余信息，以至于很难找到自己需要的部分。这就是为什么过滤器会</p>
<p>如此重要。它们可以帮助我们在庞杂的结果中迅速找到我们需要的信息。</p>
<h1 id="三次握手-Three-way-Handshake"><a href="#三次握手-Three-way-Handshake" class="headerlink" title="三次握手 Three-way Handshake"></a>三次握手 Three-way Handshake</h1><p>一个虚拟连接的建立是通过三次握手来实现的</p>
<ol>
<li><p>(Client) –&gt; [SYN] –&gt; (Server)<br>假如 Client 和 Server 通讯. 当 Client 要和 Server 通信时，Client 首先向 Server 发一个 SYN (Synchronize) 标记的包，告诉 Server 请求建立连接.<br>注意: 一个 SYN 包就是仅 SYN 标记设为 1 的 TCP 包 (参见 TCP 包头 Resources). 认识到这点很重要，只有当 Server 收到 Client 发来的 SYN 包，才可建立连接，除此之外别无他法。因此，如果你的防火墙丢弃所有的发往外网接口的 SYN 包，那么你将不 能让外部任何主机主动建立连接。</p>
</li>
<li><p>(Client) &lt;– [SYN&#x2F;ACK] &lt;–(Server)<br>接着，Server 收到来自 Client 发来的 SYN 包后，会发一个对 SYN 包的确认包 (SYN&#x2F;ACK) 给 Client，表示对第一个 SYN 包的确认，并继续握手操作.<br>注意: SYN&#x2F;ACK 包是仅 SYN 和 ACK 标记为 1 的包.</p>
</li>
<li><p>(Client) –&gt; [ACK] –&gt; (Server)<br>Client 收到来自 Server 的 SYN&#x2F;ACK 包,Client 会再向 Server 发一个确认包 (ACK)，通知 Server 连接已建立。至此，三次握手完成，一个 TCP 连接完成。<br>Note: ACK 包就是仅 ACK 标记设为 1 的 TCP 包. 需要注意的是当三此握手完成、连接建立以后，TCP 连接的每个包都会设置 ACK 位。</p>
</li>
</ol>
<p>这就是为何连接跟踪很重要的原因了. 没有连接跟踪,防火墙将无法判断收到的 ACK 包是否属于一个已经建立的连接.一般的包过滤 (Ipchains) 收到 ACK 包时,会让它通过 (这绝对不是个 好主意). 而当状态型防火墙收到此种包时，它会先在连接表中查找是否属于哪个已建连接，否则丢弃该包。</p>
<h1 id="四次握手-Four-way-Handshake-四次握手用来关闭已建立的-TCP-连接"><a href="#四次握手-Four-way-Handshake-四次握手用来关闭已建立的-TCP-连接" class="headerlink" title="四次握手 Four-way Handshake 四次握手用来关闭已建立的 TCP 连接"></a>四次握手 Four-way Handshake 四次握手用来关闭已建立的 TCP 连接</h1><ol>
<li>(Client) –&gt; ACK&#x2F;FIN –&gt; (Server)</li>
<li>(Client) &lt;– ACK &lt;– (Server)</li>
<li>(Client) &lt;– ACK&#x2F;FIN &lt;– (Server)</li>
<li>(Client) –&gt; ACK –&gt; (Server)<br>注意: 由于 TCP 连接是双向连接, 因此关闭连接需要在两个方向上做。**ACK&#x2F;FIN 包 (ACK 和 FIN 标记设为 1) 通常被认为是 FIN(终结) 包.**然而, 由于连接还没有关闭, FIN 包总是打上 ACK 标记. 没有 ACK 标记而仅有 FIN 标记的包不是合法的包，并且通常被认为是恶意的。</li>
</ol>
<h1 id="连接复位-Resetting-a-connection"><a href="#连接复位-Resetting-a-connection" class="headerlink" title="连接复位 Resetting a connection"></a>连接复位 Resetting a connection</h1><p>四次握手不是关闭 TCP 连接的唯一方法. 有时,如果主机需要尽快关闭连接 (或连接超时,端口或主机不可达),RST(Reset) 包将被发送. 注意在，由于 RST 包不是 TCP 连接中的必须部分, 可以只发送 RST 包 (即不带 ACK 标记). 但在正常的 TCP 连接中 RST 包可以带 ACK 确认标记</p>
<p>请注意 RST 包是可以不要收到方确认的?</p>
<p>无效的 TCP 标记 Invalid TCP Flags</p>
<p>到目前为止，你已经看到了 SYN, ACK, FIN, 和 RST 标记. 另外，还有 PSH (Push) 和 URG (Urgent) 标记.</p>
<p>最常见的非法组合是 SYN&#x2F;FIN 包. 注意: 由于 SYN 包是用来初始化连接的, 它不可能和 FIN 和 RST 标记一起出现. 这也是一个恶意攻击.</p>
<p>由于现在大多数防火墙已知 SYN&#x2F;FIN 包, 别的一些组合,例如 SYN&#x2F;FIN&#x2F;PSH, SYN&#x2F;FIN&#x2F;RST, SYN&#x2F;FIN&#x2F;RST&#x2F;PSH。很明显，当网络中出现这种包时，很你的网络肯定受到攻击了。</p>
<p>别的已知的非法包有 FIN (无 ACK 标记) 和”NULL”包。如同早先讨论的，由于 ACK&#x2F;FIN 包的出现是为了关闭一个 TCP 连接，那么正常的 FIN 包总是带有 ACK 标记。”NULL”包就是没有任何 TCP 标记的包 (URG,ACK,PSH,RST,SYN,FIN 都为 0)。</p>
<p>到目前为止，正常的网络活动下，TCP 协议栈不可能产生带有上面提到的任何一种标记组合的 TCP 包。当你发现这些不正常的包时，肯定有人对你的网络不怀好意。</p>
<h1 id="UDP-用户数据包协议-User-DatagramProtocol"><a href="#UDP-用户数据包协议-User-DatagramProtocol" class="headerlink" title="UDP (用户数据包协议 User DatagramProtocol)"></a>UDP (用户数据包协议 User DatagramProtocol)</h1><p>TCP 是面向连接的，而 UDP 是非连接的协议。UDP 没有对接受进行确认的标记和确认机制。对丢包的处理是在应用层来完成的。(or accidentalarrival).此处需要重点注意的事情是：在正常情况下，当 UDP 包到达一个关闭的端口时，会返回一个 UDP 复位包。由于 UDP 是非面向连接的, 因此没有任何确认信息来确认包是否正确到达目的地。因此如果你的防火墙丢弃 UDP 包，它会开放所有的 UDP 端口 (?)。</p>
<p>由于 Internet 上正常情况下一些包将被丢弃，甚至某些发往已关闭端口 (非防火墙的) 的 UDP 包将不会到达目的，它们将返回一个复位 UDP 包。</p>
<p>因为这个原因，UDP 端口扫描总是不精确、不可靠的。</p>
<p>看起来大 UDP 包的碎片是常见的 DOS(Denial ofService) 攻击的常见形式 (这里有个 DOS 攻击的例子，<a href="http://grc.com/dos/grcdos.htm">http://grc.com/dos/grcdos.htm</a> ).</p>
<h1 id="ICMP-网间控制消息协议-Internet-ControlMessage-Protocol"><a href="#ICMP-网间控制消息协议-Internet-ControlMessage-Protocol" class="headerlink" title="ICMP (网间控制消息协议 Internet ControlMessage Protocol)"></a>ICMP (网间控制消息协议 Internet ControlMessage Protocol)</h1><p>如同名字一样， ICMP 用来在主机&#x2F;路由器之间传递控制信息的协议。 ICMP 包可以包含诊断信息 (ping, traceroute - 注意目前 unix 系统中的 traceroute 用 UDP 包而不是 ICMP)，错误信息 (网络&#x2F;主机&#x2F;端口 不可达 network&#x2F;host&#x2F;port unreachable), 信息 (时间戳 timestamp, 地址掩码 addressmaskrequest, etc.)，或控制信息 (source quench, redirect, etc.) 。</p>
<p>你可以在 <a href="http://www.iana.org/assignments/icmp-parameters">http://www.iana.org/assignments/icmp-parameters</a> 中找到 ICMP 包的类型。</p>
<p>尽管 ICMP 通常是无害的，还是有些类型的 ICMP 信息需要丢弃。</p>
<p>Redirect (5), Alternate Host Address(6), Router Advertisement (9) 能用来转发通讯。</p>
<p>Echo (8), Timestamp (13)and AddressMask Request (17) 能用来分别判断主机是否起来，本地时间 和地址掩码。注意它们是和返回的信息类别有关的。 它们自己本身是不能被利用的，但它们泄露出的信息对攻击者是有用的。</p>
<p>ICMP 消息有时也被用来作为 DOS 攻击的一部分 (例如：洪水 ping flood ping,死 ping ?呵呵，有趣 ping of death)?&#x2F;p&gt;</p>
<p>包碎片注意 A Note About Packet Fragmentation</p>
<p>如果一个包的大小超过了 TCP 的最大段长度 MSS(Maximum Segment Size) 或 MTU (Maximum Transmission Unit)，能够把此包发往目的的唯一</p>
<p>方法是把此包分片。由于包分片是正常的，它可以被利用来做恶意的攻击。</p>
<p>因为分片的包的第一个分片包含一个包头，若没有包分片的重组功能，包过滤器不可能检测附加的包分片。典型的攻击 Typicalattacks involve in overlapping the packet data in which packet header is 典型的攻击 Typicalattacksinvolve in overlapping the packet data in which packet header isnormal until isit overwritten with different destination IP (or port) thereby bypassing firewall rules。包分片能作为 DOS 攻击的一部分，它 可以 crash older IP stacks 或涨死 CPU 连接能力。</p>
<p>Netfilter&#x2F;Iptables 中的连接跟踪代码能自动做分片重组。它仍有弱点，可能受到饱和连接攻击，可以把 CPU 资源耗光。</p>
<p>OK，到此为止，关于 Wireshark 抓包工具的一些小教程已经写完了，而导致我想写这么一个纠结的教程的原因是，前几天通过这个抓包解决了梦幻西游在网维大师无盘上容易掉线的问题，当时捕捉到梦幻西游掉线时的数据包是这样的。</p>
<p>注意下图中的红色数据，123.58.184.241 是梦幻西游的服务器，而 192.168.1.41 是玩梦幻西游的客户机，在掉线时，发现是先有梦幻西游的服务器向客户机发送一个 [FIN,ACK] 数据包，根据上面的解释，FIN 标记的数据包是代表要断开连接的意思，而接着客户机又回给服务器一个确认断 开链接包。当看到这个抓包数据时，就意识到，大家说的在网维大师系统虚拟盘上梦幻爱掉线的问题，并非普通的网络问题，因为通过数据包的信息来看，是梦幻服 务器主动要求断开链接，产生这个情况无非是以下几个原因：</p>
<ol>
<li><p>服务器发现客户端非法，比如有外挂什么的，踢掉了客户机；</p>
</li>
<li><p>服务器压力大，踢掉了客户机；</p>
</li>
<li><p>总之不是客户端问题导致的掉线；</p>
</li>
</ol>
<p>那么既然结论是如此，为什么会有在网维大师系统虚拟盘上容易出现梦幻掉线问题呢？原因是由于网维大师系统虚拟盘是模拟真实硬盘方式来实现的，而在模拟过程 中，将硬盘的序列号设置为固定过的 OSDIY888 了，而梦幻西游刚好后识别客户机硬盘信息，发现大量客户端的硬盘序列号都是一样的，就认为是作弊或者使 用挂机外挂了，结果就导致随机被服务器踢下线的情况发生，后来我们将硬盘序列号设置为空，则没再出现该问题。这个问题在未来的新版本中会解决掉。</p>
<p>说这个案例的目的并不是为了说明抓包多有用，而是想说明一些解决问题的思路和方法，有些人是有思路，但是缺方法，比如不会用工具，而有些人收集了很多工具 却不会用，而我其实就属于后者，几年前就收集了 n 多工具，但是用到的没几个。慢慢的学会用这些工具后，发现思维 + 工具，解决问题是效率暴增，接下来的几天 里，会陆续介绍写小工具给大家，也希望大家有空学习下，有问题先百度，再自己摸索，而不是一味的求助，毕竟求人不如求己！自己能直接搞定，是皆大欢喜的事情</p>
<blockquote>
<p>注意：由于某些系统为了防止 ARP 攻击，都免疫掉了一个 Npptools.dll 文件，这会导致该软件无法正常安装，打下这个补丁就可以了</p>
</blockquote>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>WireShark</category>
      </categories>
  </entry>
  <entry>
    <title>WireShark过滤器</title>
    <url>/2023/05/22/3-%E8%BD%AF%E4%BB%B6-WireShark-WireShark%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="什么是-wireshark"><a href="#什么是-wireshark" class="headerlink" title="什么是 wireshark"></a>什么是 wireshark</h1><p>Wireshark 是一款开源的网络封包分析软件。它可以捕获、分析和展示计算机网络中的数据包。Wireshark 支持多种网络协议，包括以太网、无线网络、Internet 协议（IP）、传输控制协议（TCP）、用户数据报协议（UDP）等等。</p>
<p>使用 Wireshark，您可以通过连接到计算机网络上的一个接口来捕获网络数据包。捕获的数据包将被 Wireshark 以可视化的方式显示出来，您可以查看每个数据包的详细信息，例如源 IP 地址、目标 IP 地址、协议类型、数据长度等等。</p>
<p>Wireshark 提供了强大的过滤功能，使您能够根据特定的条件过滤数据包，以便更好地分析网络流量。它还提供了许多分析工具和统计功能，如流量图表、协议分层显示、数据包重组等，帮助用户深入了解网络通信并发现潜在的问题。</p>
<p>Wireshark 是一个广泛应用于网络管理、网络安全和网络协议开发的工具。它能够帮助网络管理员诊断和解决网络故障，分析网络性能问题，检测网络安全事件，以及进行协议开发和调试等任务。由于其功能强大且易于使用，Wireshark 成为了网络分析领域的标准工具之一。</p>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>在 Wireshark 中，过滤器（Filter）是一种机制，用于选择和筛选特定的网络数据包以供分析。过滤器允许您根据特定的条件仅显示感兴趣的数据包，从而减少分析的数据量并集中精力于关注的内容。</p>
<p>Wireshark 使用一种称为 “ 显示过滤器 “（Display Filter）的语法来定义过滤条件。您可以根据多个参数，如源&#x2F;目标 IP 地址、协议类型、端口号、数据包长度、特定字段的值等等，创建过滤器规则。当过滤器应用于数据包捕获或已保存的数据包时，只有符合过滤条件的数据包会被显示，而其他数据包将被隐藏。</p>
<p>通过使用过滤器，您可以根据您的需求来选择显示的数据包，使得分析更加高效和专注。例如，您可以创建一个过滤器来只显示特定源 IP 地址的数据包，或者只显示某个协议类型的数据包，以便更好地关注您感兴趣的通信流量。</p>
<p>Wireshark 提供了广泛的过滤器语法和功能，使您能够根据不同的需求创建复杂的过滤条件。您可以使用比较运算符、逻辑运算符、通配符等来构建更精确的过滤规则，并根据需要组合多个条件来定义更复杂的过滤器。</p>
<p>过滤器在网络分析和故障排除中非常有用，可以帮助您集中注意力于感兴趣的数据包，提供更清晰和有针对性的分析。</p>
<h1 id="过滤器的区别"><a href="#过滤器的区别" class="headerlink" title="过滤器的区别"></a>过滤器的区别</h1><p>捕捉过滤器（CaptureFilters）：用于决定将什么样的信息记录在捕捉结果中。需要在开始捕捉前设置。</p>
<p>显示过滤器（DisplayFilters）：在捕捉结果中进行详细查找。他们可以在得到捕捉结果后随意修改。</p>
<p>两种过滤器的目的是不同的。</p>
<p>捕捉过滤器是数据经过的第一层过滤器，它用于控制捕捉数据的数量，以避免产生过大的日志文件。</p>
<p>显示过滤器是一种更为强大（复杂）的过滤器。它允许您在日志文件中迅速准确地找到所需要的记录。</p>
<p>两种过滤器使用的语法是完全不同的。</p>
<h2 id="捕捉过滤器"><a href="#捕捉过滤器" class="headerlink" title="捕捉过滤器"></a>捕捉过滤器</h2><p>Protocol（协议）:</p>
<p>可能的值: ether, fddi, ip, arp, rarp, decnet, lat, sca, moprc, mopdl, tcp and udp.</p>
<p>如果没有特别指明是什么协议，则默认使用所有支持的协议。</p>
<p>Direction（方向）:</p>
<p>可能的值: src, dst, src and dst, src or dst</p>
<p>如果没有特别指明来源或目的地，则默认使用 “src or dst” 作为关键字。</p>
<p>例如，”host 10.2.2.2″与”src or dst host 10.2.2.2″是一样的。</p>
<p>Host(s):</p>
<p>可能的值： net, port, host, portrange.</p>
<p>如果没有指定此值，则默认使用”host”关键字。</p>
<p>例如，”src 10.1.1.1″与”src host 10.1.1.1″相同。</p>
<p>Logical Operations（逻辑运算）:</p>
<p>可能的值：not, and, or.</p>
<p>否 (“not”) 具有最高的优先级。或 (“or”) 和与 (“and”) 具有相同的优先级，运算时从左至右进行。</p>
<p>例如，</p>
<p>“not tcp port 3128 and tcp port 23″与”(not tcp port 3128) and tcp port 23″相同。</p>
<p>“not tcp port 3128 and tcp port 23″与”not (tcp port 3128 and tcp port 23)”不同。</p>
<p>例子：</p>
<p>tcp dst port 3128  	&#x2F;&#x2F;捕捉目的 TCP 端口为 3128 的封包。</p>
<p>ip src host 10.1.1.1  &#x2F;&#x2F;捕捉来源 IP 地址为 10.1.1.1 的封包。</p>
<p>host 10.1.2.3  &#x2F;&#x2F;捕捉目的或来源 IP 地址为 10.1.2.3 的封包。</p>
<p>ether host e0-05-c5-44-b1-3c &#x2F;&#x2F;捕捉目的或来源 MAC 地址为 e0-05-c5-44-b1-3c 的封包。如果你想抓本机与所有外网通讯的数据包时，可以将这里的 mac 地址换成路由的 mac 地址即可。</p>
<p>src portrange 2000-2500  &#x2F;&#x2F;捕捉来源为 UDP 或 TCP，并且端口号在 2000 至 2500 范围内的封包。</p>
<p>not imcp  &#x2F;&#x2F;显示除了 icmp 以外的所有封包。（icmp 通常被 ping 工具使用）</p>
<p>src host 10.7.2.12 and not dst net 10.200.0.0&#x2F;16 &#x2F;&#x2F;显示来源 IP 地址为 10.7.2.12，但目的地不是 10.200.0.0&#x2F;16 的封包。</p>
<p>(src host 10.4.1.12 or src net 10.6.0.0&#x2F;16) and tcp dst portrange 200-10000 and dst net 10.0.0.0&#x2F;8  &#x2F;&#x2F;捕捉来源 IP 为 10.4.1.12 或者来源网络为 10.6.0.0&#x2F;16，目的地 TCP 端口号在 200 至 10000 之间，并且目的位于网络 10.0.0.0&#x2F;8 内的所有封包。</p>
<p>src net 192.168.0.0&#x2F;24 </p>
<p>src net 192.168.0.0 mask 255.255.255.0  &#x2F;&#x2F;捕捉源地址为 192.168.0.0 网络内的所有封包。</p>
<p>注意事项：</p>
<ol>
<li><p>当使用关键字作为值时，需使用反斜杠“\”。<br>“ether proto \ip” (与关键字”ip”相同).  Ether proto 0x0800<br>这样写将会以 IP 协议作为目标。</p>
</li>
<li><p>“ip proto \icmp” (与关键字”icmp”相同).<br>这样写将会以 ping 工具常用的 icmp 作为目标。</p>
</li>
<li><p>可以在”ip”或”ether”后面使用”multicast”及”broadcast”关键字。<br>当您想排除广播请求时，”no broadcast”就会非常有用。</p>
</li>
<li><p>Protocol（协议）:<br>您可以使用大量位于 OSI 模型第 2 至 7 层的协议。点击”Expression…”按钮后，您可以看到它们。<br>比如：IP，TCP，DNS，SSH</p>
</li>
<li><p>String1, String2 (可选项):</p>
</li>
<li><p>协议的子类。<br>点击相关父类旁的”+”号，然后选择其子类。</p>
</li>
</ol>
<h2 id="显示过滤器"><a href="#显示过滤器" class="headerlink" title="显示过滤器"></a>显示过滤器</h2><p>例子：</p>
<p>snmp || dns || icmp &#x2F;&#x2F;显示 SNMP 或 DNS 或 ICMP 封包。 </p>
<p>ip.addr &#x3D;&#x3D; 10.1.1.1  &#x2F;&#x2F;显示来源或目的 IP 地址为 10.1.1.1 的封包。</p>
<p>ip.src !&#x3D; 10.1.2.3 or ip.dst !&#x3D; 10.4.5.6  &#x2F;&#x2F;显示来源不为 10.1.2.3 或者目的不为 10.4.5.6 的封包。</p>
<p>换句话说，显示的封包将会为：</p>
<p>来源 IP：除了 10.1.2.3 以外任意；目的 IP：任意</p>
<p>以及</p>
<p>来源 IP：任意；目的 IP：除了 10.4.5.6 以外任意</p>
<p>ip.src !&#x3D; 10.1.2.3 and ip.dst !&#x3D; 10.4.5.6  &#x2F;&#x2F;显示来源不为 10.1.2.3 并且目的 IP 不为 10.4.5.6 的封包。</p>
<p>换句话说，显示的封包将会为：</p>
<p>来源 IP：除了 10.1.2.3 以外任意；同时须满足，目的 IP：除了 10.4.5.6 以外任意</p>
<p>tcp.port &#x3D;&#x3D; 25  &#x2F;&#x2F;显示来源或目的 TCP 端口号为 25 的封包。 </p>
<p>tcp.dstport &#x3D;&#x3D; 25  &#x2F;&#x2F;显示目的 TCP 端口号为 25 的封包。 </p>
<p>tcp.flags  &#x2F;&#x2F;显示包含 TCP 标志的封包。 </p>
<p>tcp.flags.syn &#x3D;&#x3D; 0×02  &#x2F;&#x2F;显示包含 TCP SYN 标志的封包。 </p>
<p>如果过滤器的语法是正确的，表达式的背景呈绿色。如果呈红色，说明表达式有误。</p>
<p>更为详细的说明请见：<a href="http://openmaniak.com/cn/wireshark_filters.php">http://openmaniak.com/cn/wireshark_filters.php</a></p>
<p>以上只是抓包和简单的过滤，那么其实如果你要想达到能够分析这些网络包的要求时，还需要了解下一些数据包的标记，比如我们常说的 TCP 三次握手是怎么回事？</p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>WireShark</category>
      </categories>
  </entry>
  <entry>
    <title>内网穿透方案</title>
    <url>/2024/05/22/3-%E8%BD%AF%E4%BB%B6-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>内网穿透，也称为 NAT 穿透或端口转发，是一种技术手段，用于在没有公网 IP 的情况下，使外网用户能够访问内网中的设备和服务。其基本原理是通过中转服务器或特定的网络配置，将内网设备的 IP 地址和端口映射到外网，从而实现内外网之间的通信。</p>
<h1 id="具有公网-IP"><a href="#具有公网-IP" class="headerlink" title="具有公网 IP"></a>具有公网 IP</h1><h2 id="服务器端具有公网-IP"><a href="#服务器端具有公网-IP" class="headerlink" title="服务器端具有公网 IP"></a>服务器端具有公网 IP</h2><h3 id="获取公网-IP-DDNS-解析"><a href="#获取公网-IP-DDNS-解析" class="headerlink" title="获取公网 IP+DDNS 解析"></a>获取公网 IP+DDNS 解析</h3><p><strong>什么是 DDNS</strong><br>DDNS 的意思是动态域名解析。是解决有公网 IP ，但是公网 IP 不固定的问题，用固定的域名代替动态变化的公网 IP。</p>
<p>无公网 IP 网络环境用内网穿透方案，即类似如 nat123 内网映射方式，将内网 IP 映射成域名（自动生成二级域名或用自己域名）地址，然后通过域名来访问。</p>
<p>DDNS (Dynamic Domain Name System) 是一种可以动态更新域名解析的服务，它可以让您的域名指向一个动态 IP 地址，而不是一个固定的 IP 地址。它可以让您的域名跟随您的设备，而不需要您每次更改 IP 地址时都去更新域名解析。</p>
<p>适用情况：</p>
<p>路由器是公网 IP，但是公网 IP 不固定</p>
<p>检测方法：</p>
<p>用百度搜索 IP，百度会显示当前的 IP 地址，把这个 IP 地址和路由器的 IP 地址作比较，如果一致，说明是公网 IP，如果不一致，说明是运营商用一个 IP 然后经过多层 NAT 之后分配的内网 IP。</p>
<h2 id="具有公网-IP-云服务器"><a href="#具有公网-IP-云服务器" class="headerlink" title="具有公网 IP 云服务器"></a>具有公网 IP 云服务器</h2><h3 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h3><p>将内网端口映射到公网服务器，通过公网服务器 + 端口的形式访问内网端口。需要了解配置 frps 和 frpc 的配置文件如何配置，针对特定端口进行开放</p>
<p>下载 frp 文件，根据实际要部署的环境的架构利用 <code>wget</code> 下载相应版本</p>
<p>项目地址 <a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>
<p>安卓版本仓库地址 <a href="https://github.com/FrpcCluster/frpc-Android">https://github.com/FrpcCluster/frpc-Android</a></p>
<p>下载完成后 <code>tar -xvf</code> 解压，进入目录，修改 fps.toml 配置文件</p>
<p>文档地址 <a href="https://gofrp.org/zh-cn/docs/">https://gofrp.org/zh-cn/docs/</a></p>
<h4 id="frps-服务端配置"><a href="#frps-服务端配置" class="headerlink" title="frps 服务端配置"></a>frps 服务端配置</h4><p>安装前需 <code>uname -a</code> 查看云服务器的外网处理器架构,根据不同的架构下载不同 frp 版本，<code>x86_64</code> 的 下载 后缀带 <code>amd</code> 的即可</p>
<p><code>wget https://github.com/fatedier/frp/releases/download/v0.58.0/frp_0.58.0_linux_amd64.tar.gz</code></p>
<p>解压后编辑 frps.toml 文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#bindAddr = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">bindPort = <span class="number">9085</span>      <span class="comment">//内网设备绑定的端口</span></span><br><span class="line"><span class="meta"># auth token</span></span><br><span class="line">auth.token = <span class="string">&quot;******&quot;</span>    <span class="comment">//接入验证码，需要和设备端保持一致</span></span><br><span class="line"></span><br><span class="line"># Configure the web server to enable the dashboard <span class="keyword">for</span> frps.</span><br><span class="line"># 使能<span class="built_in">dashboard</span>(非必要)</span><br><span class="line"># 使能控制面板</span><br><span class="line"># 控制面板必须配置port</span><br><span class="line"><span class="meta"># dashboard is available only <span class="keyword">if</span> webServer.port is set.</span></span><br><span class="line">webServer.addr = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">webServer.port = <span class="number">9086</span></span><br><span class="line">webServer.user = <span class="string">&quot;lemonade&quot;</span></span><br><span class="line">webServer.password = <span class="string">&quot;lemonade&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># console or real logFile path like ./frps.log  </span></span><br><span class="line"># 使能<span class="built_in">log</span>(非必要)</span><br><span class="line"># 输入的日志文件</span><br><span class="line">log.to = <span class="string">&quot;./frps.log&quot;</span>      <span class="comment">//日志存储位置</span></span><br><span class="line"><span class="meta"># trace, debug, info, warn, <span class="keyword">error</span></span></span><br><span class="line">log.level = <span class="string">&quot;info&quot;</span>        <span class="comment">//存储等级</span></span><br><span class="line">log.maxDays = <span class="number">3</span>            <span class="comment">//时间</span></span><br></pre></td></tr></table></figure>

<p><code>netstat -ntlp</code> 查看端口占用情况</p>
<p>启动 frps 服务 <code>./frps -c ./frps.toml</code>，</p>
<p>需要注意服务器开通指定端口的防火墙</p>
<h4 id="frpc-客户端配置"><a href="#frpc-客户端配置" class="headerlink" title="frpc 客户端配置"></a>frpc 客户端配置</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//具有公网IP的服务器地址</span></span><br><span class="line">serverAddr = <span class="string">&quot;124.222.246.***&quot;</span>     </span><br><span class="line"><span class="comment">//接入端口</span></span><br><span class="line">serverPort = <span class="number">9085</span></span><br><span class="line"><span class="comment">//接入token</span></span><br><span class="line">auth.token=<span class="string">&quot;******&quot;</span></span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line"><span class="comment">//将本设备的5000端口映射到服务器的9087端口</span></span><br><span class="line">name = <span class="string">&quot;frp-nas&quot;</span></span><br><span class="line"><span class="comment">//类型</span></span><br><span class="line">type = <span class="string">&quot;tcp&quot;</span> </span><br><span class="line">localIP = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="comment">//本地端口</span></span><br><span class="line">localPort = <span class="number">5000</span></span><br><span class="line"><span class="comment">//公网端口</span></span><br><span class="line">remotePort = <span class="number">9087</span></span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = <span class="string">&quot;frp-nas-ssh&quot;</span></span><br><span class="line">type = <span class="string">&quot;tcp&quot;</span></span><br><span class="line">localIP = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">localPort = <span class="number">9090</span></span><br><span class="line">remotePort = <span class="number">9088</span></span><br></pre></td></tr></table></figure>

<h1 id="微软的-devtunnel"><a href="#微软的-devtunnel" class="headerlink" title="微软的 devtunnel"></a>微软的 devtunnel</h1><p>缺点是穿透的地址最长只能保持 30 天，执行安装命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Windows</span></span><br><span class="line">winget install Microsoft.devtunnel</span><br><span class="line"><span class="comment">#Linux </span></span><br><span class="line">curl -sL https://aka.ms/DevTunnelCliInstall | bash</span><br></pre></td></tr></table></figure>

<p>登录自己的账户</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">devtunnel user login [-g] <span class="comment">#-g代表github账户</span></span><br></pre></td></tr></table></figure>

<p>假定需要将本机的 9006 端口做为对外穿透的端口，则命令为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">devtunnel host -p <span class="number">9006</span> [--allow-anonymous] [--expiration <span class="number">2</span>d]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[--allow-anonymous]</code> 允许任何人都可以访问</li>
<li><code>[--expiration 2d]</code> 设置有效时间，过期自动删除，默认为 30 天，最大值为 30 天</li>
</ul>
<p>如果你需要创建多个端口，则可以改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">devtunnel host -p <span class="number">9006</span> <span class="number">9007</span> <span class="number">9008</span></span><br></pre></td></tr></table></figure>

<p>由于一个 powershell 窗口同一时间默认只能运行一个 devtunnel 进程，所以如果你需要创建并监听多个内网映射端口，则需要像上面那样同时填写多个端口</p>
<p>查看当前系统中隧道端口列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">devtunnel list</span><br></pre></td></tr></table></figure>

<p>查看某个隧道详细信息</p>
<p>假定隧道 id 为 “liuluhua”，列出 liuluhua 当前的一些配置或状态信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">devtunnel show liuluhua</span><br></pre></td></tr></table></figure>

<p>托管某个隧道</p>
<p>假定我们在其他 powershell 窗口里创建了一个隧道 “liuluhua”，我们现在当前 powershell 中托管监控它</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">devtunnel host liuluhua</span><br></pre></td></tr></table></figure>

<p>删除某个隧道：</p>
<p>假定要删除的某个 隧道 id 为 “liuluhua”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">devtunnel <span class="keyword">delete</span> liuluhua</span><br></pre></td></tr></table></figure>

<p>删除全部的隧道：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">devtunnel <span class="keyword">delete</span>-all</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#devtunnel port create lemonade -p 5245</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#devtunnel host lemonade</span></span><br><span class="line"></span><br><span class="line">devtunnel create [隧道名] -a</span><br><span class="line"><span class="comment">#-a 表示可以表示隧道可以匿名访问</span></span><br><span class="line"><span class="comment">#执行成功会输出隧道信息</span></span><br><span class="line"></span><br><span class="line">devtunnel port create [隧道名] -p 8080</span><br><span class="line"><span class="comment">#隧道名为可选，默认为刚才创建的隧道</span></span><br><span class="line"><span class="comment">#可以添加多个端口</span></span><br><span class="line"></span><br><span class="line">devtunnel host [隧道名]</span><br><span class="line"><span class="comment">#隧道名为可选，默认为刚才创建的隧道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#devtunnel delete [隧道名]</span></span><br><span class="line"><span class="comment">#可以删除隧道</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407301501433.png" alt="image.png"></p>
<h1 id="cloudflare"><a href="#cloudflare" class="headerlink" title="cloudflare"></a>cloudflare</h1><p>控制台页面 <a href="https://dash.cloudflare.com/">https://dash.cloudflare.com</a></p>
<h1 id="Tailscale"><a href="#Tailscale" class="headerlink" title="Tailscale"></a>Tailscale</h1><p>免费版</p>
<h1 id="构建虚拟局域网-—ZeroTier、Tailscale-以及蒲公英"><a href="#构建虚拟局域网-—ZeroTier、Tailscale-以及蒲公英" class="headerlink" title="构建虚拟局域网 —ZeroTier、Tailscale 以及蒲公英"></a>构建虚拟局域网 —ZeroTier、Tailscale 以及蒲公英</h1><p>  在 <a href="https://www.zerotier.com/">zerotier</a> 创建虚拟局域网，客户端安装后复制虚拟局域网 ID 加入即可实现访问，但是连接速度不稳定</p>
<p>  进阶方式可以自己搭建 moon 服务器和 planet 服务器，但是也需要公网服务器</p>
<p>  <a href="https://github.com/xubiaolin/docker-zerotier-planet">私有部署zerotier-planet服务</a></p>
<p>  <a href="https://github.com/Jonnyan404/zerotier-planet">一分钟自建zerotier-planet</a>  </p>
<h1 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h1><p><a href="https://www.mrdoc.fun/doc/254/">内网穿透 - Jonnyan的原创笔记 - 亖亖亖 (mrdoc.fun)</a></p>
<h1 id="cpolar-内网穿透"><a href="#cpolar-内网穿透" class="headerlink" title="cpolar 内网穿透"></a>cpolar 内网穿透</h1><p>cpolar 官网地址: <a href="https://www.cpolar.com/">https://www.cpolar.com</a></p>
<p>使用一键脚本安装命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">curl -L https:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span></span><br></pre></td></tr></table></figure>

<p>向系统添加服务</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure>

<p>启动 cpolar 服务</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure>

<p>cpolar 安装成功后，在外部浏览器上访问 Linux 的 9200 端口即:【http:&#x2F;&#x2F;服务器的局域网 ip:9200】，使用 cpolar 账号登录,登录后即可看到 cpolar web 配置界面,结下来在 web 管理界面配置即可。</p>
<p>登录后，点击左侧仪表盘的隧道管理——创建隧道，创建一个的公网 http 地址隧道</p>
<ul>
<li>隧道名称：可自定义命名，注意不要与已有的隧道名称重复</li>
<li>协议：选择 http</li>
<li>本地地址：8380(本地访问的地址)</li>
<li>域名类型：免费选择随机域名</li>
<li>地区：选择 China Top</li>
</ul>
<p>隧道创建成功后，点击左侧的状态——在线隧道列表,查看所生成的公网访问地址，有两种访问方式,一种是 http 和 https。使用上面的 Cpolar https 公网地址,在任意设备的浏览器进行访问,即可成功看到界面,这样一个公网地址且可以远程访问就创建好了,使用了 cpolar 的公网域名,无需自己购买云服务器,即可到公网进行远程访问了！</p>
<p>如果我们需要长期异地远程访问，由于刚才创建的是随机的地址，24 小时会发生变化。另外它的网址是由随机字符生成，不容易记忆。如果想把域名变成固定的二级子域名，并且不想每次都重新创建隧道来访问，我们可以选择创建一个固定的 http 地址来解决这个问题。</p>
<h2 id="固定公网地址"><a href="#固定公网地址" class="headerlink" title="固定公网地址"></a>固定公网地址</h2><p>我们接下来为其配置固定的 HTTP 端口地址，该地址不会变化，方便分享给别人长期查看你的博客，而无需每天重复修改服务器地址。配置固定 http 端口地址需要将 cpolar 升级到专业版套餐或以上。</p>
<p>登录 cpolar 官网，点击左侧的预留，选择保留二级子域名，设置一个二级子域名名称，点击保留,保留成功后复制保留的二级子域名名称。保留成功后复制保留成功的二级子域名的名称。返回登录 Cpolar web UI 管理界面，点击左侧仪表盘的隧道管理——隧道列表，找到所要配置的隧道，点击右侧的编辑。修改隧道信息，将保留成功的二级子域名配置到隧道中</p>
<ul>
<li>域名类型：选择二级子域名</li>
<li>Sub Domain：填写保留成功的二级子域名</li>
<li>点击更新(注意,点击一次更新即可,不需要重复提交)</li>
</ul>
<p>更新完成后,打开在线隧道列表,此时可以看到公网地址已经发生变化,地址名称也变成了固定的二级子域名名称的域名</p>
<p>最后,我们使用固定的公网 https 地址访问,可以看到访问成功,这样一个固定且永久不变的公网地址就设置好了，可以随时随地进行异地访问！</p>
<h1 id="freedns42"><a href="#freedns42" class="headerlink" title="freedns42"></a>freedns42</h1>]]></content>
      <categories>
        <category>3.软件</category>
        <category>内网穿透</category>
      </categories>
  </entry>
  <entry>
    <title>远程桌面</title>
    <url>/2024/07/30/3-%E8%BD%AF%E4%BB%B6-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="TeamViewer"><a href="#TeamViewer" class="headerlink" title="TeamViewer"></a>TeamViewer</h1><h1 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h1><p>选择 lightdm 作为 Display Manager。首先更新系统软件包列表并安装必要的软件包：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y xserver-xorg-video-dummy x11vnc xfce4</span><br></pre></td></tr></table></figure>

<p>接下来配置 X11 服务器以使用虚拟视频设备。编辑&#x2F;etc&#x2F;X11&#x2F;xorg.conf 文件并添加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Section <span class="string">&quot;Device&quot;</span></span><br><span class="line">    Identifier  <span class="string">&quot;Configured Video Device&quot;</span></span><br><span class="line">    Driver      <span class="string">&quot;dummy&quot;</span></span><br><span class="line">    VideoRam    <span class="number">256000</span></span><br><span class="line">EndSection</span><br><span class="line">Section <span class="string">&quot;Monitor&quot;</span></span><br><span class="line">    Identifier  <span class="string">&quot;Configured Monitor&quot;</span></span><br><span class="line">    HorizSync   <span class="number">5.0</span> - <span class="number">1000.0</span></span><br><span class="line">    VertRefresh <span class="number">5.0</span> - <span class="number">200.0</span></span><br><span class="line">    ModeLine    <span class="string">&quot;1920x1080&quot;</span> <span class="number">148.50</span> <span class="number">1920</span> <span class="number">2448</span> <span class="number">2492</span> <span class="number">2640</span> <span class="number">1080</span> <span class="number">1084</span> <span class="number">1089</span> <span class="number">1125</span> +Hsync +Vsync</span><br><span class="line">EndSection</span><br><span class="line">Section <span class="string">&quot;Screen&quot;</span></span><br><span class="line">    Identifier  <span class="string">&quot;Default Screen&quot;</span></span><br><span class="line">    Monitor     <span class="string">&quot;Configured Monitor&quot;</span></span><br><span class="line">    Device      <span class="string">&quot;Configured Video Device&quot;</span></span><br><span class="line">    DefaultDepth <span class="number">24</span></span><br><span class="line">    SubSection  <span class="string">&quot;Display&quot;</span></span><br><span class="line">        Depth  <span class="number">24</span></span><br><span class="line">        Modes  <span class="string">&quot;1920x1080&quot;</span></span><br><span class="line">    EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>

<p>完成配置后，重启设备以应用更改：<code>sudo reboot</code>，之后配置和启动 x11vnc 服务。</p>
<ol>
<li>查看设备 IP 地址：<code>ip addr</code></li>
<li>启动 x11vnc 服务：x 代表端口号</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo x11vnc -display :x -auth /var/lib/lightdm/.Xauthority &amp;</span><br></pre></td></tr></table></figure>

<p>然后就可以在 PC 机上使用 ip+5900+x 地址来 VNC 远程连接。</p>
<h2 id="安装必要的软件包"><a href="#安装必要的软件包" class="headerlink" title="安装必要的软件包"></a>安装必要的软件包</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install tigervnc-server <span class="comment">#tightvncserver</span></span><br></pre></td></tr></table></figure>

<h3 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h3><p>没有桌面环境的话，则需要安装相关的桌面环境</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vncserver -geometry <span class="number">1920</span>x1080 :<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-VNC-Server"><a href="#配置-VNC-Server" class="headerlink" title="配置 VNC Server"></a>配置 VNC Server</h2><p>运行 vncserver 命令来首次配置。它会提示您设置密码和查看连接所需的信息。</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo nano ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>

<p>将其中的内容修改为以下类似的内容，以确保有正确的桌面环境启动：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">unset SESSION_MANAGER</span><br><span class="line">unset DBUS_SESSION_BUS_ADDRESS</span><br><span class="line"></span><br><span class="line">gnome-session &amp;</span><br><span class="line"></span><br><span class="line"># #!/bin/sh</span><br><span class="line"><span class="meta">#export XKL_XMODMAP_DISABLE=1</span></span><br><span class="line"><span class="meta">#export XDG_CURRENT_DESKTOP=<span class="string">&quot;GNOME-Flashback:GNOME&quot;</span></span></span><br><span class="line"><span class="meta">#export XDG_MENU_PREFIX=<span class="string">&quot;gnome-flashback-&quot;</span></span></span><br><span class="line"><span class="meta">#gnome-session --session=gnome-flashback-metacity --disable-acceleration-#check &amp;</span></span><br></pre></td></tr></table></figure>

<h3 id="重启-VNC-Server"><a href="#重启-VNC-Server" class="headerlink" title="重启 VNC Server"></a>重启 VNC Server</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vncserver -kill :<span class="number">1</span>  # 假设您的 VNC 实例是 :<span class="number">1</span></span><br><span class="line">vncserver -geometry <span class="number">1920</span>x1080 :<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>VNCserver 的端口为 <code>5900+X</code>，如果我想要 VNC 端口在 9099 时，则设置 VNC 实例为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vncserver -geometry <span class="number">1920</span>x1080 :<span class="number">3199</span></span><br></pre></td></tr></table></figure>

<h2 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a>设置防火墙</h2><p>如果您启用了防火墙，需要允许 VNC 相关的端口通过。VNC 通常使用 5900 + 显示编号的端口，例如第一个实例是 5901。</p>
<p>例如，如果您使用 ufw 防火墙，可以运行以下命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo ufw allow <span class="number">5901</span></span><br></pre></td></tr></table></figure>

<p>这样，您就完成了 Ubuntu 20 上 VNC Server 的基本配置，可以通过 VNC 客户端使用设置的密码和服务器的 IP 地址及端口进行连接。</p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>内网穿透</category>
      </categories>
  </entry>
  <entry>
    <title>MYSQL安装</title>
    <url>/2024/08/17/3-%E8%BD%AF%E4%BB%B6-%E6%95%B0%E6%8D%AE%E5%BA%93-MYSQL%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Mysql-环境搭建"><a href="#Mysql-环境搭建" class="headerlink" title="Mysql 环境搭建"></a>Mysql 环境搭建</h1><p>安装 mysql</p>
<p><code>sudo apt install mysql-server -y</code></p>
<blockquote>
<p>sudo service mysql status # 查看服务状态<br>sudo service mysql start # 启动服务<br>sudo service mysql stop # 停止服务<br>sudo service mysql restart # 重启服务</p>
</blockquote>
<p>查看并更新密码</p>
<p><code>sudo cat /etc/mysql/debian.cnf</code></p>
<p>采用默认用户名密码登录</p>
<p><code>mysql -u *** -p</code></p>
<p>更新 root 用户密码</p>
<p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;newpasswd&#39;;</code></p>
<p>退出后，用 root 用户确认正常登录</p>
<p><code>mysql -u root -p newpasswd</code></p>
<p>创建 Qexo 要使用表</p>
<p><code>create database qexo;</code></p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Sqlie使用</title>
    <url>/2024/05/22/3-%E8%BD%AF%E4%BB%B6-%E6%95%B0%E6%8D%AE%E5%BA%93-Sqlie%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><p>安装数据库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo  apt-get install sqlite3</span><br></pre></td></tr></table></figure>

<h1 id="数据库指令操作"><a href="#数据库指令操作" class="headerlink" title="数据库指令操作"></a>数据库指令操作</h1><p>打开一个数据库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sqlite3 my.db</span><br></pre></td></tr></table></figure>

<p>常用查询:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.table   				<span class="comment">//查看数据库中的表</span></span><br><span class="line">.schema  tablename  	<span class="comment">//查看相应表的结构</span></span><br><span class="line">.database 			<span class="comment">//查看当前打开的数据库</span></span><br><span class="line">.quit 				<span class="comment">//退出当前数据库</span></span><br><span class="line">.help				<span class="comment">//列出帮助信息</span></span><br></pre></td></tr></table></figure>

<p><strong>创建表:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">create table <span class="title">movies</span> <span class="params">(id <span class="type">int</span>, name text,  time <span class="type">int</span>, auth text)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除表:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">drop   table  tablename;	</span><br></pre></td></tr></table></figure>

<p><strong>添加信息:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">insert into  movies <span class="title">values</span> <span class="params">(.....)</span></span>;</span><br><span class="line"><span class="function">insert into  movies <span class="title">values</span> <span class="params">(.....)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>查询信息:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">select * from movies ;</span><br></pre></td></tr></table></figure>

<p><strong>删除信息:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>  from movies  where id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>更新信息:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">update  tablename set name=<span class="string">&#x27;&#x27; where id=2;</span></span><br></pre></td></tr></table></figure>

<p><strong>添加字段:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alter table  tablename add column  sex <span class="type">char</span> ;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建名字为tong.db的数据库</span></span><br><span class="line">sqlite3 tong.db</span><br><span class="line"><span class="comment">//创建一个叫user的table,里面有name, age</span></span><br><span class="line"><span class="function">create table <span class="title">user</span><span class="params">(name, age integer)</span></span>;</span><br><span class="line"><span class="comment">//name的默认类型是字符串，用“taotao”</span></span><br><span class="line"><span class="comment">//age的类型相当于int</span></span><br><span class="line"><span class="comment">//删除一个table</span></span><br><span class="line">drop table user;</span><br><span class="line"><span class="comment">//向user中存储数据</span></span><br><span class="line">insert into user values（“taotao”, <span class="number">18</span>）;</span><br><span class="line"><span class="comment">//增加一个column叫num,类型是 integer</span></span><br><span class="line">alter table user add column num integer;</span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line">update user set name=<span class="string">&quot;taotao&quot;</span>,age=<span class="number">18</span> where num=<span class="number">110</span>;</span><br><span class="line"><span class="comment">//打印所有信息</span></span><br><span class="line">select * from user;</span><br><span class="line"><span class="comment">//打印某一个信息</span></span><br><span class="line">select * from user where name=<span class="string">&quot;taotao&quot;</span>;</span><br><span class="line"><span class="comment">//删除一个叫taotao的人</span></span><br><span class="line"><span class="keyword">delete</span> from user where name=<span class="string">&quot;taotao&quot;</span>;</span><br><span class="line"><span class="comment">//查看有哪几个表</span></span><br><span class="line">.tables</span><br><span class="line"><span class="comment">//查看某一个表的属性</span></span><br><span class="line">.schema user</span><br><span class="line"><span class="comment">//退出</span></span><br><span class="line">.q</span><br></pre></td></tr></table></figure>

<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQL_NAME <span class="string">&quot;./chen.db&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAB_NAME <span class="string">&quot;tb&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> num, <span class="type">char</span> **val, <span class="type">char</span> **name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s:%s\n&quot;</span>, name[i], val[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;========%d===\n&quot;</span>, num);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">	sqlite3 *db = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(SQLITE_OK != <span class="built_in">sqlite3_open</span>(SQL_NAME, &amp;db))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;OPEN SQLITE3 ERROR.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	char a = &#x27;A&#x27;;</span></span><br><span class="line"><span class="comment">	char buf[80];</span></span><br><span class="line"><span class="comment">	sprintf(buf, &quot;The ASCII code of a is %d.\n&quot;, a);</span></span><br><span class="line"><span class="comment">	printf(&quot;%s&quot;, buf);</span></span><br><span class="line"><span class="comment">	return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">输出ASCII 的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;create table if not exists %s (id, sex, score float);&quot;</span>, TAB_NAME);</span><br><span class="line">	<span class="keyword">if</span>(SQLITE_OK != <span class="built_in">sqlite3_exec</span>(db, buf, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;CREATE TABLE ERROR:%s\n&quot;</span>,</span><br><span class="line">		<span class="built_in">sqlite3_errmsg</span>(db));</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*	功 能: 将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值,</span></span><br><span class="line"><span class="comment"> *	块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span> , <span class="built_in">sizeof</span>(buf));</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;insert into %s values(&#x27;chen&#x27;, &#x27;B&#x27;, 90);&quot;</span>, TAB_NAME);</span><br><span class="line">	<span class="keyword">if</span>(SQLITE_OK != <span class="built_in">sqlite3_exec</span>(db, buf, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;CREATE TABLE ERROR:%s\n&quot;</span>, <span class="built_in">sqlite3_errmsg</span>(db));</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;select * from %s ;&quot;</span>, TAB_NAME);</span><br><span class="line">	<span class="keyword">if</span>(SQLITE_OK != <span class="built_in">sqlite3_exec</span>(db, buf, fun, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;CREATE TABLE ERROR:%s\n&quot;</span>, <span class="built_in">sqlite3_errmsg</span>(db));</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sqlite3_close</span>(db);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>相机参数</title>
    <url>/2024/09/11/3-%E8%BD%AF%E4%BB%B6-%E7%9B%B8%E6%9C%BA-%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>光圈、快门、ISO、景深</p>
<ul>
<li>光圈越大，代表光孔越大，单位时间内进来的光也就越多</li>
<li>快门太慢，放了长时间的光进来，但在物体运动时造成模糊</li>
<li>ISO 越高，进来的光越多。画面的噪点也就越多，画质越差</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1726018505000vyhn9o.png" alt="gh"></p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>相机</category>
      </categories>
  </entry>
  <entry>
    <title>接口功能</title>
    <url>/2024/08/12/3-%E8%BD%AF%E4%BB%B6-%E8%88%AA%E7%94%B5%E7%B3%BB%E7%BB%9F-%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="ARINC653-介绍"><a href="#ARINC653-介绍" class="headerlink" title="ARINC653 介绍"></a>ARINC653 介绍</h1><p>ARINC653 作为一个标准，主要阐述了模块化综合航空电子设备 IMA(Integrated Modular Avionics)使用的应用软件的基线操作环境。其定义了航空应用与下层操作环境之间的接口和数据交换的模式以及服务的行为，并描述了嵌入式航空电子软件的运行时环境。</p>
<p>在实际应用过程中，航空电子中的核心模块软件包括两类: 应用软件和核心软件。ARINC653 定义的就是位于应用软件和操作系统 OS 之间的 APEX(APplication EXecutive)接口，APEX 接口是操作系统为应用软件提供的一个功能集合。利用这个功能集合，应用软件可以控制系统的调度，通信和内部状态信息。</p>
<ul>
<li>APEX 接口相当于为应用提供的一种高层语言。</li>
<li>而对于 OS 来说，是关于参数和入口机制的定义。</li>
</ul>
<p>ARINC653 标准一个重要的标准就是将航空电子软件进行分时，分区管理。采用二级调度，<strong>分区内基于优先级进行调度</strong>，<strong>分区间通过时间窗口进行时间轮转调度</strong>。同时定义了分区内的进程接口，进程间通信接口，分区间通信的 Port 标准接口，并且为了增强系统的可靠性定义了<strong>系统级，分区级，进程级别的健康监控管理接口</strong>。</p>
<h1 id="分区和区间管理"><a href="#分区和区间管理" class="headerlink" title="分区和区间管理"></a>分区和区间管理</h1><p>分区（Partitioning）是 ARINC653 中一个核心概念。在 IMA(Integrated Modular Avionics)系统中，一个核心模块会包含一个或多个航空电子应用，并且这些应用要能够独立运行。<strong>分区</strong>就是航空电子应用中的一个功能划分。分区的单位称为区间，区间内的每一个执行单元称为<strong>进程</strong>。每一个区间具有自己独立的数据、上下文和运行环境，这样做的好处是能够防止一个区间的错误影响到其他区间。另外，它能使得整个系统容易验证、确认和认证。</p>
<p>区间化以及区间的管理和调度是由 OS 来实现的。ARINC653 为区间的调度规定了一种基于时间窗的循环调度算法。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408141033800.png" alt="image.png"></p>
<p>为了完成各区间的周期性调度，由 OS 维护一个固定时间长度的主时间框架，该时间框架在模块的运行期内周期性的重复。每个时间框架可以划分为若干个时间窗口。系统利用一个事先确定的配置表,在规定的时间窗口内激活对应区间的运行。这样就能够保证每个应用在分配给它的时间周期内访问公共资源不被打断。</p>
<p>ARINC supplement 1 对主时间框架的时间定义原则进行了补充。它规定主时间框架的大小应该是核心模块中所有区间周期的最小公倍数的正整数倍，并应考虑到每个区间每次执行的时间长度和执行频率。</p>
<p>在 ARINC653 Supplement 1 发布时又增加了系统区间属性和启动条件属性。区间的工作模式包括空闲，冷启动，热启动和正常四种，如图 3 所示。每个区间所需资源在系统构建时指定，在区间初始化完成时区间对象创建。OS 在进入运行模式时启动应用区间，然后区间进入正常运行模式。监测管理功能在响应致命错误时将重启区间或者停止区间的运行。</p>
<p>根据 ARINC653 标准的规定，需要模块操作系统提供时空隔离机制的支持，因此内核和分区应用在空间上和时间上应进行隔离保护。</p>
<p>下面分两部分论述系统空间时间分配，首先是基于整个模块操作系统的空间和时间分配情况，后面是基于 APEX 接口的实现上的空间和时间分配。</p>
<p>●空间隔离</p>
<p>在操作系统中，以分区为资源分配单位。采用复平面空间的方式，每个应用都有独立的 4G 空间，从而实现用户与操作系统，用户与用户之间在存储空间上进行隔离，达到互不影响的目的。</p>
<p>从 APEX 接口的设计实现上来讲，空间分配包含两部分的内容：</p>
<ol>
<li>APEX 分区上的资源分配<br> 即使用的是应用分区上的空间资源，包括了各个 APEX 对象管理控制块资源。<ul>
<li>分区管理</li>
<li>进程管理</li>
<li>分区健康监控</li>
<li>信号量</li>
<li>事件</li>
<li>黑板</li>
<li>缓冲</li>
<li>时间管理</li>
<li>采样端口</li>
<li>队列端口</li>
</ul>
</li>
<li>内核空间的资源分配<br> 主要是 APEX 接口调用过程中需要在内核分配的资源，列表如下：<ul>
<li>内核的域管理</li>
<li>内核的任务管理</li>
<li>内核的周期对象管理</li>
<li>内核信号量</li>
<li>内核黑板</li>
<li>内核消息队列<br>另外，在 APEX 内核支持层封装的对分区间通信的端口的支持，也是在内核空间分配的端口控制管理资源，包括了端口控制链和通道控制链。</li>
</ul>
</li>
</ol>
<p>●时间隔离</p>
<p>目前 OS 为基于 APEX 接口的应用分区提供了时间调度表调度策略。通过配置时间调度表，可以控制各个分区在时间点上的运行分配。由操作系统维护一个固定时间长度的主时间框架，该时间框架在模块的运行期内周期性的重复。每个时间框架可以划分为若干个时间窗口。系统利用一个事先确定的配置表，在规定的时间窗口内激活对应域的运行。这样就能够保证每个应用在分配给它的时间周期内访问公共资源不被打断。</p>
<h1 id="接口清单"><a href="#接口清单" class="headerlink" title="接口清单"></a>接口清单</h1><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408121646579.png" alt="image.png"></p>
<h1 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h1><p>分区是一个应用运行的资源单位。一个分区是一个独立的应用环境：它由数据、自己的上下文关系、配置属性和其它项组成。分区的运行要满足时间和空间的要求。</p>
<p>通过分区可以实现应用间的隔离和保护，分区也是应用隔离保护的单位，每个分区有独立的运行空间和堆空间，不同分区的运行空间不会重叠。当一个应用出现致命错误，出现的最坏情况就是应用被系统删除或者重启动。而这个应用的错误不会影响到其他分区，更不会影响到操作系统口。</p>
<p>分区具有独立的调度策略，每个分区在属于自己时间窗口内运行。</p>
<p>一个分区则由一个或多个并发执行的进程组成，分区内的所有进程将共享分区所占有的系统资源。分区管理要求系统中同时可以运行多个不同类型的应用，同时在时间上和空间上互不影响。分区管理主要包括：分区的属性定义、分区的工作状态转换、分区的控制和分区的调度。</p>
<h2 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h2><ul>
<li>分区状态的获取</li>
<li>设置分区模式</li>
</ul>
<h1 id="分区间通信"><a href="#分区间通信" class="headerlink" title="分区间通信"></a>分区间通信</h1><p>分区间通信是 ARINC 653 标准中使用的一种通用表达方式，其主要定义两个或多个分区间的通信，标准的分区间通信是一项基本需求以支持应用软件的可重用性和可移植性。所有的分区间通信都通过消息进行。消息被定义为有限长度的连续数据块。</p>
<p>消息从单个的源发出，到一个或多个目标。消息的目标是分区而不是分区内的进程。分区通过已定义的访问点访问通道，访问点称为端口(port)。通道由一个或多个端口以及相关的资源组成。端口提供所需的资源以允许特定的分区在特定的通道中发送或接收消息。分区可以通过各自的资源和目的端口使用多个通道交换消息。通道将一个发送端口通过中间端口和一个或多个接收端口连接起来。每个单独的通道都可以配置在专门的模式下运行。可以使用两种传送模式，采样模式(samplingmode)和队列模式(queuingmode)。因此提供了采样端口服务和队列端口服务。</p>
<p>分区间通信遵循以下原则：</p>
<ul>
<li>发送方和接受方并不关心对方的具体名字和物理位置，以避免系统的其他地方修改之后引起分区的变化。</li>
<li>消息只能有一个源，但可以有若干个目的；</li>
<li>来自不同端口的消息不需要按照它们发送的时间顺序到达它们的目的。</li>
</ul>
<h2 id="函数功能-1"><a href="#函数功能-1" class="headerlink" title="函数功能"></a>函数功能</h2><ul>
<li><p>采样端口服务<br>  根据采样端口的周期性数据特点，采用内核提供的黑板机制来实现。在分区之上<br>的 APEX 接口封装层提供配置初始化功能，提供标准的 APEX 调用接口。在 APEX 内<br>核支持层来实现具体的黑板写和读功能。需要注意的是源端口不用创建对应的黑板。<br>APEX 内核支持层只为目的端口创建对应的黑板。<br>  由于采样端口的数据具有周期性特点，因此存在数据有效性判断。对采样端口数<br>据有效性的定义如下：数据停留在端口的时间小于用户设置的数据刷新周期时间。<br>  数据停留时间&#x3D;从端口获取数据的系统时间一发送数据到端口的系统时间。</p>
</li>
<li><p>队列端口服务<br>  根据队列端口的消息队列数据特点，采用内核提供的消息队列机制来实现。在分区<br>之上的 APEX 接口封装层提供配置初始化功能，提供标准的 APEX 调用接口。在 APEX<br>内核支持层来实现具体的消息的发送和接收功能。需要注意的是源端口不用创建对应<br>的消息队列。APEX 内核支持层只为目的端口创建对应的消息队列。</p>
</li>
</ul>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>完成应用进程的管理，进程是操作系统运行的基本单位。</p>
<p>在分区内的执行体是由一个或多个进程组成，每个进程隶属于特定的分区，分区内的各进程之间并发执行。进程管理主要负责分区内进程的创建、调度和删除等管理工作。</p>
<p>进程分为按固定频率执行的周期进程和由事件触发的非周期进程两类，操作系统应具备对这两类进程的调度能力；进程在出现故障时应允许重新初始化或者终止；对于访问临界区的进程，为保证安全性，在访问时进程管理应禁止调度。</p>
<h2 id="函数功能-2"><a href="#函数功能-2" class="headerlink" title="函数功能"></a>函数功能</h2><ul>
<li>创建进程</li>
<li>停止进程</li>
<li>挂起进程</li>
<li>解挂进程</li>
<li>设置进程优先级</li>
</ul>
<h1 id="分区内通信"><a href="#分区内通信" class="headerlink" title="分区内通信"></a>分区内通信</h1><p>支持分区内的进程之间相互通信。按通信机制划分，分区内通信共有两种。一种是缓冲区和黑板，用于进程间通信。另一种是信号量和事件，用于进程间同步。</p>
<p>缓冲区和黑板的差别是：缓冲区允许消息以队列的形式存储，消息不允许覆盖，而黑板在任何时刻最多只保留一个消息，消息允许覆盖；信号量和事件的差别是：信号量用于对系统资源的访问，而事件用来完成进程之间的同步／异步操作。</p>
<p>提供了两种分区内通信机制：</p>
<h2 id="函数功能-3"><a href="#函数功能-3" class="headerlink" title="函数功能"></a>函数功能</h2><ul>
<li>允许分区内进程间通过缓冲区和黑板进行通信。</li>
<li>通过计数信号量或事件实现进程间的同步。</li>
</ul>
<h2 id="缓冲-Buffer-消息队列-MessageQueue"><a href="#缓冲-Buffer-消息队列-MessageQueue" class="headerlink" title="缓冲 Buffer&#x2F;消息队列 MessageQueue"></a>缓冲 Buffer&#x2F;消息队列 MessageQueue</h2><p>在缓冲区中，消息的每个新实例都携带唯一不同的数据，因此传送时不允许覆盖前一个。缓冲允许在消息队列中存储多个消息。发送进程发送的消息以 FIFO 顺序存储在消息队列中。这种排队模式下不应该丢失任何消息。缓冲中能够存储的消息数量是由缓冲大小确定并在创建时指定的。等待在缓冲上的进程以 FIFO 或者优先级排队。优先级排队的情况下，相同优先级的进程按照 FIFO 顺序排队。排队规则在创建缓冲时定义。如果有进程等待缓冲消息并且缓冲(变得)不为空，则按照应用排队规则算法(FIFO 或者优先级)来确定哪个排队的进程接收此消息。OS 将把该进程从进程队列上移出，将其置为就绪状态。OS 将把消息从缓冲消息队列中移出。</p>
<p>当进程试图从空缓冲接收消息，或者发送消息到满的缓冲，将发生进程重调度。调用进程将被放入队列一段指定的时间，如果在该段时间内没有消息被接收或者发送，OS 将自动从队列中移出该进程，将其置为就绪状态。</p>
<h2 id="黑板-Blackboard"><a href="#黑板-Blackboard" class="headerlink" title="黑板 Blackboard"></a>黑板 Blackboard</h2><p>黑板是分区内进程间的一种通信机制。它和消息队列一样支持在多个源和目的之间的传输。黑板与消息队列最大的不同点是消息队列允许消息排队，而黑板不允许消息排队。</p>
<p>只要预先分配的存储空间足够大，那么进程可以创建尽可能多的黑板。</p>
<p>当进程进入一个等待状态时，分区需要重新进行进程调度。超时机制限制或者避免了等待时间过长的现象出现。</p>
<p>黑板是不支持排队的，写到黑板上的任何消息可能被擦除或者被新写入的消息覆盖掉。任务可以从黑板上读取一条信息、显示一条信息或者擦除黑板。</p>
<p>试图从空的黑板上读取信息的操作将会导致进程重新调度，进行该操作的进程将会进入队列中等待一段指定时间，如果在该段时间内没有消息被写到黑板上，dOS 将会将该进程从等待队列上移出并将其状态变为就绪。</p>
<p>当有消息被写到黑板上时，所有等待在黑板队列上的进程将会从队列上被移出并设置为就绪状态，该消息会被保持在黑板上。当黑板被擦除时，它会变空。</p>
<h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>信号量服务提供了计数信号量。</p>
<p>计数信号量是一种同步对象，常用于对分区内资源访问的控制。计数信号量的计数值一般用于反映当前合法资源的数量。</p>
<p>为了使用信号量，必须在初始化阶段中对其进行创建。创建信号量时需要指定对象名字，这个名字仅局限于分区内。此外，这个名字也不是分区配置表的属性。</p>
<h2 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h2><p>事件是一种同步对象，用于通知进程等待条件的出现。同一分区内的进程可以设置和清除事件，还可以在本分区内创建的事件上等待。</p>
<p>分区内创建的事件能够被分区内的所有进程使用。事件创建时，被设置为 down 状态。为了通知事件条件的发生，可以设置指定的事件为 up 状态，所有等待该事件的进程的状态将从等待变为就绪，然后进行重调度。等待事件的进程的执行顺序应该只依赖于分区内进程调度规则。</p>
<p>为了使用事件，必须在初始化阶段中对其进行创建。创建事件时需要指定对象名字，这个名字仅局限于分区内。此外，这个名字也不是分区配置表的属性。</p>
<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><p>时间管理为分区提供了功能接口来控制周期和非周期进程。</p>
<p>周期进程就是以特定频率执行的进程。类似的，只在特定事件之后执行的进程为非周期进程或事件驱动进程。</p>
<p>对于周期进程，分区内每个进程都可以确定一段执行时间来作为进程周期执行的最大时间长度。这个时间长度可用以设定进程的 Deadline 时间。操作系统会通过周期性地评估 Deadline 时间来判断进程是否在分配的时间内完成了执行。在进程执行周期的最后，应该调用 PERIODIC W 舭 T 服务来获取新的 Deadline。新 Deadline 的计时将从进程的下一个周期开始。</p>
<p>对于所有进程，TIMED—WAIT 服务允许进程挂起自己一段时间。待挂起时间到达以后，进程又可以被重新调度。</p>
<h2 id="函数功能-4"><a href="#函数功能-4" class="headerlink" title="函数功能"></a>函数功能</h2><ul>
<li>使进程指定时间等待</li>
<li>使进程周期性等待</li>
<li>获取系统时间</li>
</ul>
<h1 id="健康监控"><a href="#健康监控" class="headerlink" title="健康监控"></a>健康监控</h1><p>健康监控用于监视硬件、应用程序和操作系统的状态，当发现故障时，记录故障并进行故障隔离，防止故障的蔓延，同时按故障级别(模块级、分区级和任务级)进行必要的恢复。健康监视的另一个功能是在系统配置时，用于检测系统配置的一致性和完整性。</p>
<p>ARINC 对健康监控处理的错误进行了分级，错误有可能发生在模块级、分区级和进程级。模块级错误仅影响模块内的所有分区。分区级错误仅影响该分区。进程级错误影响分区内的一个或者多个进程，或者是整个分区。如下给出各个级别的错误类型定义。</p>
<p>●模块级错误：</p>
<ul>
<li>模块初始化阶段出现模块配置错误；</li>
<li>模块初始化阶段出现其它错误：</li>
<li>系统功能执行期间的错误；</li>
<li>分区转换时发生的错误；</li>
<li>加电故障。</li>
</ul>
<p>●分区级错误：</p>
<ul>
<li>分区初始化阶段出现分区配置错误；</li>
<li>分区初始化错误；</li>
<li>进程管理中的错误；</li>
<li>故障处理过程的错误。</li>
</ul>
<p>●进程级错误：</p>
<ul>
<li>应用进程产生的应用错误；</li>
<li>非法的操作系统请求；</li>
<li>进程执行错误(溢出、存储区冲突…)。</li>
</ul>
<p>错误的级别是由系统人员在状态监控的配置表中定义的，并且与诊断的错误和系统状态相一致的。任何级别上发生的错误，根据其错误特性，将会扩散到其被处理的更高级别上。</p>
<p>故障响应机制依赖于错误级别。模块级和分区级的故障响应是由一张模块状态监控表和每个分区的单独分区状态监控表驱动的。进程级故障响应由应用程序员使用分区的专门(最高优先级)的进程一一错误处理进程决定。程序员可以通过状态监控服务确定错误和故障进程，然后在进程级(例如，停止，启动进程，replenish)或者分区级(例如，设置分区模式：空闲，冷启动，热启动)采取恢复措施。错误处理进程中发生的错误被视为分区级错误。</p>
<h2 id="函数功能-5"><a href="#函数功能-5" class="headerlink" title="函数功能"></a>函数功能</h2><ul>
<li>报告错误消息</li>
<li>创建错误处理进程</li>
<li>激活处理进程</li>
</ul>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>航电系统</category>
      </categories>
  </entry>
  <entry>
    <title>航电系统的平台说明</title>
    <url>/2024/09/02/3-%E8%BD%AF%E4%BB%B6-%E8%88%AA%E7%94%B5%E7%B3%BB%E7%BB%9F-%E8%88%AA%E7%94%B5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B9%B3%E5%8F%B0%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="航电系统"><a href="#航电系统" class="headerlink" title="航电系统"></a>航电系统</h1><p>航空电子系统是完成飞行任务相关功能的子系统，由无线电通信、导航、自动驾驶和显示管理等多个系统构成，包括机载计算机及在其之上运行的软件、通讯、传感器、控制器等。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725248196000sbixln.png" alt="gh"></p>
<p>航电系统先后经历了分立式，联合式，综合式和高度综合式四个阶段。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725248111000mo91mi.png" alt="gh"></p>
<p>综合模块化航空电子系统（Integrated Modular Avionics，IMA）是目前航电系统体系中的典型结构。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725248155000sujz2m.png" alt="gh"></p>
<p>综合模块化航空电子系统开发过程的指南文件 DO-297 中对 IMA 的定义是:“IMA 是一组灵活的、可重用的、可互操作的共享硬件和软件资源,当把这些资源综合在一起时可以构建一个平台,该平台按一组确定的安全和性能需求进行设计和验证,能提 供各种服务,并驻留执行飞机功能的应用”，通俗的来说，IMA 结构的主要功能是将多个功能独立的机载设备作为整体统一考虑，在模块级进行综合集成。IMA 平台适航审定的各适航标准之间的相互支撑关系如图。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725245836000dvvpa2.png" alt="gh"></p>
<p>在 IMA 结构中，以驻留在 IMA 系统的飞行管理系统为例，其飞机功能分配到 IMA 系统的功能&#x2F;性能需求层次结构如图。最顶层的任务描述与最底层的设计实现从不同的角度描述了同一个飞机功能。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725245325000bblku4.png" alt="gh"></p>
<ul>
<li>顶层是从飞机级任务的角度抽象地描述整个飞机的预期操作</li>
<li>底层的设计实现层则是从软硬件设计实现的角度,描述飞机级任务的最终实现</li>
<li>“设计实现层”描述的是具体的设计”需求”,可以逐级向上追溯到最顶层的”任务”描述,即最底层的需求是从最顶层的任务分解而捕获到的</li>
</ul>
<h2 id="行业标准"><a href="#行业标准" class="headerlink" title="行业标准"></a>行业标准</h2><p>针对 IMA 体系结构，常用行业标准和推荐实践包括:</p>
<ul>
<li><strong>RTCA (Radio Technical Commission for Aeronautics)</strong><ul>
<li>RTCA 是美国的标准组织，负责制定航空领域的最低操作性能标准（MOPS）和最低航空系统性能标准（MASPS）。RTCA 制定的标准用于 FAA 的技术标准命令（TSO），从而使设备符合 FAA 认证。</li>
<li><strong>DO-178C</strong>：软件认证标准，规定了航空软件的开发和验证过程，确保其安全性和可靠性。</li>
<li><strong>DO-254</strong>：硬件设计和开发标准，特别针对航空电子设备中的复杂电子硬件（如 FPGA 和 ASIC）。</li>
<li><strong>DO-297</strong>：由 RTCA 提出的指南，提供了 IMA 系统的开发、集成和认证的框架。该标准阐明了模块化航空电子系统的开发流程和认证要求。</li>
</ul>
</li>
<li><strong>EUROCAE (European Organisation for Civil Aviation Equipment)</strong><ul>
<li>EUROCAE 是欧洲的标准制定组织，类似于 RTCA，主要服务于欧洲民航局（EASA）的认证需求。</li>
<li><strong>ED-12C</strong>：与 RTCA DO-178C 相同，是航空软件开发的欧洲标准。</li>
<li><strong>ED-80&#x2F;DO-254</strong>：航空电子设备中的硬件开发标准。</li>
</ul>
</li>
<li><strong>SAE (Society of Automotive Engineers)</strong><ul>
<li>SAE 是汽车和航空领域的标准组织，覆盖从汽车到航空航天等多领域的技术和安全标准。SAE 的标准在航空电子、自动驾驶汽车等领域有广泛应用。</li>
<li><strong>ARP4754A</strong>：航空系统开发标准，规定了复杂航空系统的开发流程。</li>
<li><strong>ARP4761</strong>：航空系统安全性评估标准，结合失效模式与影响分析（FMEA）和故障树分析（FTA）来评估系统的安全性。</li>
</ul>
</li>
<li><strong>ARINC (Aeronautical Radio, Inc.)</strong><ul>
<li>ARINC 是一个航空标准组织，制定航空电子设备的互联互通和规范标准，广泛用于航空公司和航空制造商之间的设备兼容性。</li>
<li><strong>ARINC 429</strong>：航空电子设备之间的数字数据通信协议，广泛用于商业航空系统中的航电通信。</li>
<li><strong>ARINC 653</strong>：实时操作系统（RTOS）的标准接口，广泛应用于航空嵌入式系统，特别是分区多任务操作系统。</li>
<li><strong>ARINC 661</strong>：航空座舱显示系统的标准接口，规定了用户界面和座舱显示器的设计标准。</li>
<li><strong>ARINC 664</strong>：与以太网兼容的航空网络标准，适用于现代航空网络通信，特别是 AFDX（Avionics Full-Duplex Switched Ethernet）网络。</li>
<li><strong>ARINC 818</strong>：用于航空系统视频传输的协议。</li>
</ul>
</li>
</ul>
<p>IMA 系统作为体系结构定义了应用分区概念，ARINC 653 是为 IMA 设计的一个关键标准，定义了分区操作系统的接口标准。规定了在航空电子系统中如何实现时间和空间分区，以确保不同应用程序之间的隔离，防止它们相互干扰。符合 ARINC653 规范的 IMA 架构从上而下划分为应用软件、实时操作系统(Real-Time Operating Systems, RTOS)、硬件三个层级，层级之间通过虚拟的接口层进行交互。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725247954000uq9m0f.png" alt="gh"></p>
<p><strong>空间分区</strong>：当某一个分区的应用软件发生错误或故障时不会影响其他分区内应用软件的正常运行</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/172524775600050db4y.png" alt="gh"></p>
<p><strong>时间分区</strong>：系统会提供相对完整独立的时间窗口给系统中的各个分区进行调度，每一个分区都有自己对应的一个或多个时间片，只有当轮到该分区的时间片时，才会激活并被操作系统调用并运行，以确保时间维度上的确定性</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/172524770100089615o.png" alt="gh"></p>
<h1 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h1><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725247503000sbqtxx.png" alt="gh"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725249656000yvj1ib.png" alt="gh"></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="ARINC653-标准"><a href="#ARINC653-标准" class="headerlink" title="ARINC653 标准"></a>ARINC653 标准</h2><p>航 电 应 用 软 件 标 准 接 口 653（AvionicsApplication Software Standard Interface 653，ARINC653）是一种嵌入式操作系统应用程序接口标准，目前是国际上在飞行器软件方面比较通行的软件运行标准。</p>
<p>在 ARINC653 标准中定义了一个主时间帧，再将主时间帧中分成多个小时间段，每个时间段分配给一个应用程序进程执行。随着航空软件系统的执行，主时间帧周而复始运行，使各个应用程序进程都能有效获得硬件资源。同时，由于每个进程只会在分配的小时间段中执行，从而避免了在时间上多个进程同时执行造成的相互影响。与小时间段相对应，利用处理器存储器管理单元（Memory Management Unit，MMU）、存储器控制器分区（bank）控制等硬件技术，每个应用程序进程运行时使用相互独立的一段存储器，从而避免了在存储器空间上多个进程同时执行造成的相互影响。</p>
<p>ARINC653 通过使应用软件中的各进程在时间和空间上同时分开获得了较高的软件运行安全性，有效控制了进程发生错误的影响范围，避免了因为某一进程发生错误时威胁到整个航空软件系统运行，进而威胁到飞行器安全飞行的情况发生。</p>
<p>ARINC653 的详细接口实现见 <a href="source/_posts/3.%E8%BD%AF%E4%BB%B6/%E8%88%AA%E7%94%B5%E7%B3%BB%E7%BB%9F/%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD.md">接口功能</a></p>
<h2 id="FACE-标准"><a href="#FACE-标准" class="headerlink" title="FACE 标准"></a>FACE 标准</h2><p>未来机载能力环境（Future Airborne Capability Environment，FACE）在 2010 年由美国海军航空系统司令部发起、开源组织（OpenGroup）提出，其策略是在己安装好硬件的军用航电平台上建立软件通用操作环境，使 FACE 组件应用在不同平台上时可被重新部署，从而实现跨平台的可移植性和重用性。</p>
<p>FACE 采用“分段式”架构，自顶向下分为操作系统段、I&#x2F;O 服务段、平台特定服务段、传输服务段和可移植组件段，每个段间的接口都进行了标准化定义，使得基于 FACE 标准的应用系统可以从任意一个段间接口开始设计具有自身特色功能段。相比 ARINC653 中只定义了应用程序分时分区使用硬件的软件接口，FACE 标准包含了应用程序从顶层通用服务到底层 IO 的全部内容，制定了应用程序各组件的标准化接口，为应用程序赋予了可移植性、开放性和灵活性，大幅提高了电子系统设计的便利性，为航电设备即插即用等应用场景提供了有效技术支撑。</p>
<h2 id="系统架构简介"><a href="#系统架构简介" class="headerlink" title="系统架构简介"></a>系统架构简介</h2><p>嵌入式操作系统（Embedded Operating System）是一种运行在嵌入式系统硬件上的基础软件，其基本功能是对硬件进行有效管理并对硬件进行一定程度的抽象以便应用软件调用。在军工领域，嵌入式操作系统在具备基本功能的基础上，还需要具有实时性（Real-time）、安全性（Security &amp;Safety）等特点。</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/17252476050004gd4jy.png" alt="gh"></p>
<h2 id="主流使用的嵌入式操作系统"><a href="#主流使用的嵌入式操作系统" class="headerlink" title="主流使用的嵌入式操作系统"></a>主流使用的嵌入式操作系统</h2><h3 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408141025920.png" alt="image.png"></p>
<h3 id="欧洲"><a href="#欧洲" class="headerlink" title="欧洲"></a>欧洲</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408141025794.png" alt="image.png"></p>
<h3 id="日本"><a href="#日本" class="headerlink" title="日本"></a>日本</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408141026221.png" alt="image.png"></p>
<h3 id="国内自研且有军工应用"><a href="#国内自研且有军工应用" class="headerlink" title="国内自研且有军工应用"></a>国内自研且有军工应用</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408141039489.png" alt="image.png"></p>
<h3 id="国内自研"><a href="#国内自研" class="headerlink" title="国内自研"></a>国内自研</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408141039623.png" alt="image.png"></p>
<h3 id="符合-ARINC653-的-OS"><a href="#符合-ARINC653-的-OS" class="headerlink" title="符合 ARINC653 的 OS"></a>符合 ARINC653 的 OS</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725249743000945vpa.png" alt="gh"></p>
<h3 id="国内外-OS-安全认证"><a href="#国内外-OS-安全认证" class="headerlink" title="国内外 OS 安全认证"></a>国内外 OS 安全认证</h3><p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408151701228.png" alt="image.png"></p>
<h2 id="操作系统调度"><a href="#操作系统调度" class="headerlink" title="操作系统调度"></a>操作系统调度</h2><h3 id="单核处理器"><a href="#单核处理器" class="headerlink" title="单核处理器"></a>单核处理器</h3><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p>在单核处理器中，每次调度只有一个任务在运行，只有等待当前任务结束或该任务的时间片结束后才能切换到下一任务运行，追求 CPU 利用率和吞吐率的最大化，关于 CPU 利用率等参数见 <a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/Linux/%E5%85%B6%E4%BB%96/CPU%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E.md">CPU参数说明</a></p>
<ul>
<li>先到先服务（First-Come, First-Served，FCFS）<br>  FCFS 是一种广泛使用而又相对简单的调度算法，其采用的是先进先出（First-Input,First-Output，FIFO）队列。任务从 FIFO 队列头部开始顺次分配给处理器执行，任务执行完成后便从队首删除，并从队首取出新的任务执行。而当某一任务准备就绪后便将该任务链接到 FIFO 队列的队尾，如此循环往复的执行。FCFS 是一种非抢占式的任务调度算法，其优点是简单易懂，缺点则是缺乏灵活性，任务执行效率低下。</li>
<li>最短作业时间（Shortest-Job-First，SJF）<br>  SJF 是指对处理时间短的任务优先进行调度运行，其拥有可抢占与非抢占两种调度模式。这是种可以极大缩短调度的平均等待时间的调度方案，但遗憾的是这仅仅只是一种理想的方案，因为计算机是很难预先知道随机任务运行所需要占用处理器的时间。</li>
<li>优先权调度（Priority）<br>  优先权调度指的是系统会按照某种权值分配策略来给每个任务分配一个对应的权值，以此来衡量任务的优先级别，优先级别最高的任务最先分配给处理器进行执行，对于具有相同优先级别的任务，将其按照 FCFS 的顺序来进行执行。以上讲到的 SJF 调度算法便是优先权调度的一个特例，其权值分配策略为任务运行时间的倒数。</li>
<li>轮转法调度（Round Robin，RR）<br>  RR 算法是在 FCFS 算法中加入时间片抢占策略而形成的，是对 FCFS 算法的优化。在任务调度过程中，如果任务 A 的运行时间小于设定的时间片，则会自动释放处理器；反之，如果任务 A 的运行时间大于时间片，则系统会产生定时器中断，先保存任务 A 的执行状态文件，然后将其添加到 FIFO 队列的尾部；与此同时，系统会从 FIFO 队列的队首调出任务 B 来进行执行。RR 调度算法的性能与时间片大小有着直接的关系，当时间片选取过小时，单位时间里进行任务切换的次数就会变多，从而增加系统的内存消耗，影响系统任务调度的效率；与之相反，当时间片选取无限大时，对于大量使用 RR 调度算法的任务来说，其调度效率趋同与 FCFS 算法，容易造成任务的阻塞。因此使用 RR 算法进行任务调度时，选择适当长度的时间片非常重要。</li>
<li>多队列调度（Multilevel Queue）<br>  多队列调度是一种两层的调度模型，其将所有的任务划分为多个任务队列，先以任务队列为调度单元，队列之间采用某种合适的调度算法。再以队列中的任务为调度单元，在每一个队列内部采用某种合适的调度算法。</li>
<li>多级反馈队列（Multilevel Feedback Queue）<br>  多级反馈队列调度是一种广泛使用却异常复杂的调度算法，它是对多队列调度算法的优化。在多队列调度中，任务分配到某队列后便固定不能进行移动，导致任务调度过程缺乏灵活性。而在多级反馈队列调度中，优化了这种固定的设计，允许任务在队列中进行移动，提高了调度的灵活性与高效性。</li>
</ul>
<h4 id="ARINC653-调度"><a href="#ARINC653-调度" class="headerlink" title="ARINC653 调度"></a>ARINC653 调度</h4><p>在 ARINC653 标准的实现中，分为分区调度和分区内的进程调度：</p>
<ul>
<li>分区间调度： 采用 轮转法调度（Round Robin，RR），通过固定长度的时间片按循环顺序分配处理器时间，实现了各分区的公平和隔离。</li>
<li>分区内进程调度： 采用 优先权调度（Priority Scheduling），根据进程的优先级分配执行顺序，确保关键任务的实时性和响应速度。</li>
</ul>
<p>关于分区调度的实现和流程见 <a href="source/_posts/3.%E8%BD%AF%E4%BB%B6/%E8%88%AA%E7%94%B5%E7%B3%BB%E7%BB%9F/%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.md">运行流程</a></p>
<h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h3><h4 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法"></a>调度算法</h4><p>多核任务调度典型应用模式：</p>
<ul>
<li>对称多处理（Symmetric Multi-Processing，SMP）<br>  SMP 模式是指同一个核心操作系统映像负责协调所有处理器核上的任务调度工作，在这种模式下，所有的分区任务允许动态分配到任何空闲的处理器核上进行执行，可以更好的实现负载均衡性。</li>
<li>非对称多处理（Asymmetric Multi-Processing，AMP）<br>  AMP 模式是指某一任务与某个处理器核绑定之后，就不允许在此处理器核之外的其他处理器核上运行。相比较于 SMP 模式下所有处理器核共享一个全局的核心操作系统映像，AMP 模式下各个处理器核都有自己独立的操作系统映像，且每个处理器核都可以根据实际调度需求选择加载合适的操作系统映像，如加载 Windows 映像、Linux 映像、VxWorks 映像等等，以形成该处理器核独立的调度域，对调度域内的任务资源进行管理。</li>
<li>绑定多处理（Bound Multi-Processing，BMP）<br>  BMP 模式是一种比 SMP 更加灵活的多核处理器调度模式。相比较 SMP 模式，BMP 模式在保证 SMP 模式下任务全局动态调度的同时，允许对一些有特殊需求的任务绑定到指定的处理器核上进行调度，增加了灵活性。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725248929000zi0492.png" alt="gh"></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/17252499220002jhb7q.png" alt="gh"></p>
<p><a href="source/_posts/0.%E5%B9%B3%E5%8F%B0/Linux/%E5%86%85%E6%A0%B8/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.md">多核处理器的负载均衡</a></p>
<h1 id="硬件平台"><a href="#硬件平台" class="headerlink" title="硬件平台"></a>硬件平台</h1><h2 id="能力指标"><a href="#能力指标" class="headerlink" title="能力指标"></a>能力指标</h2><p>综合计算能力指标</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725248993000sli0jl.png" alt="gh"></p>
<p>网络互联能力指标</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725249033000t6sgge.png" alt="gh"></p>
<p>嵌入式平台的优点</p>
<p>平台</p>
<ul>
<li>CPU 为 AMD PPC440</li>
<li>GPU 为 ATI Tech M7500E</li>
<li>操作系统 LynxOS-178，POSIX，多处理器多线程，实时，分区 ARINC653</li>
</ul>
<p>目前平台的限制点</p>
<ul>
<li>功耗</li>
<li>发热</li>
<li>GPU</li>
</ul>
<p>采用的 RISC 的指令集</p>
<p>PPC 平台</p>
<p>ARM 平台</p>
<ul>
<li>RK</li>
<li>NXP</li>
<li>TI</li>
</ul>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>航电系统</category>
      </categories>
  </entry>
  <entry>
    <title>运行流程</title>
    <url>/2024/08/12/3-%E8%BD%AF%E4%BB%B6-%E8%88%AA%E7%94%B5%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="启动分区"><a href="#启动分区" class="headerlink" title="启动分区"></a><strong>启动分区</strong></h1><ul>
<li><strong>分区启动</strong>：<ul>
<li>分区启动后，操作系统内核会为该分区创建一个初始任务。</li>
<li><strong>初始任务的作用</strong>：主要用于初始化 APEX 接口，执行分区配置表中的初始化步骤。</li>
<li><strong>初始任务的参数</strong>：例如优先级和任务栈大小，这些参数通常由 APEX 接口的具体实现决定，对于使用 APEX 接口的用户来说，这些参数是透明的，即用户不需要手动设置这些参数。</li>
</ul>
</li>
</ul>
<p>APEX 配置信息的入口参数的结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* processInfo； <span class="comment">/*进程整体配置信息*/</span></span><br><span class="line"><span class="type">void</span>* bufferInfo； <span class="comment">/*缓冲区整体配置信息*/</span></span><br><span class="line"><span class="type">void</span>* bbInfo； <span class="comment">/*黑板整体配置*/</span></span><br><span class="line"><span class="type">void</span>* semInfo； <span class="comment">/*信号量整体配置信息*/</span></span><br><span class="line"><span class="type">void</span>* eventInfo； <span class="comment">/*事件整体配置信息*/</span></span><br><span class="line"><span class="type">void</span>* queuingInfo；<span class="comment">/*队列端口配置信息*/</span></span><br><span class="line"><span class="type">void</span>* samplingInfo； <span class="comment">/*采样端口配置信息*/</span></span><br><span class="line"><span class="type">void</span>* hmInfo； <span class="comment">/*分区健康监控配置信息*/</span></span><br><span class="line">)T_APEX_CONFIG_INFO；</span><br></pre></td></tr></table></figure>

<h1 id="初始化-APEX-接口"><a href="#初始化-APEX-接口" class="headerlink" title="初始化 APEX 接口"></a><strong>初始化 APEX 接口</strong></h1><ul>
<li><strong>APEX INIT 调用</strong>：<ul>
<li>初始任务会以分区配置表为参数，调用 APEX 接口的初始化入口函数 <code>APEX INIT</code>。</li>
<li><strong>系统对象的初始化</strong>：APEX 接口根据分区配置表中的各项参数，初始化系统对象。系统对象包括各种系统资源，如队列、缓冲区、信号量等。</li>
<li><strong>创建系统进程</strong>：APEX 接口接着会创建一些关键的系统进程，比如初始进程和 IDLE 进程。这些进程对于分区的基本操作和管理至关重要。</li>
<li><strong>初始任务的结束</strong>：在完成上述初始化步骤后，初始任务的生命周期就结束了，系统进程开始接管分区的运行。</li>
</ul>
</li>
</ul>
<p>值得注意的是， APEX 接口的初始化是一个分界线，从此之后创建的任何进程或对象都必须在分区配置表中有对应的配置，否则创建将会失败，IDLE 等系统进程也不例外。而在初始化 APEX 接口之前创建的系统对象的生命周期必须到此结束，不能延续到 APEX 接口初始化之后，以初始任务为例，在 APEX 接口初始化过程就会被终止。以保证 APEX 接口之上应用程序的可移植性不受具体 OS 的影响。</p>
<h1 id="设置分区为-NORMAL-模式"><a href="#设置分区为-NORMAL-模式" class="headerlink" title="设置分区为 NORMAL 模式"></a><strong>设置分区为 NORMAL 模式</strong></h1><ul>
<li><strong>USERMAIN 的调用</strong>：<ul>
<li>由系统进程之一的初始进程调用用户程序的入口函数 <code>USERMAIN</code>。</li>
<li><strong>分区应用程序的执行</strong>：用户可以在 <code>USERMAIN</code> 函数中创建自己的用户进程和其他系统对象（例如信号量、事件、任务等）。</li>
<li><strong>设置分区模式为 NORMAL</strong>：在用户程序的初始化步骤完成后，系统将分区的模式设置为 NORMAL。这意味着分区已经准备好并开始执行用户定义的进程。</li>
<li><strong>初始进程的结束</strong>：一旦所有用户进程创建完成并开始运行，初始进程的生命周期也结束。</li>
</ul>
</li>
</ul>
<h1 id="分区间切换"><a href="#分区间切换" class="headerlink" title="分区间切换"></a><strong>分区间切换</strong></h1><ul>
<li><p><strong>分区切换概述</strong>：</p>
<ul>
<li>分区间切换是指在一个多分区系统中，操作系统从一个分区切换到另一个分区。切换通常是由系统调度器在时间片到期或者根据特定条件触发的。</li>
<li><strong>时间分片</strong>：系统通常会以固定的时间片进行分区切换，即每个分区在其时间片内独占 CPU 资源。</li>
</ul>
</li>
<li><p><strong>切换过程</strong>：</p>
<ol>
<li><strong>时间片到期或切换请求</strong>：当分配给当前分区的时间片到期，或者有其他条件触发了分区切换请求，系统调度器将会进行分区切换。</li>
<li><strong>保存当前分区状态</strong>：在切换之前，操作系统会保存当前分区的状态，包括寄存器、任务栈和其他重要数据。</li>
<li><strong>加载新分区状态</strong>：系统调度器加载下一个分区的状态，并将处理器控制权转移到新分区。</li>
<li><strong>切换完成</strong>：新分区开始执行其任务，并在其时间片内独占 CPU 资源。</li>
</ol>
</li>
<li><p><strong>分区间切换的关键点</strong>：</p>
<ul>
<li><strong>隔离性</strong>：确保不同分区的资源和状态相互隔离，以防干扰。</li>
<li><strong>实时性</strong>：需要保证分区切换的延迟在可接受的范围内，以满足系统的实时性要求。</li>
</ul>
</li>
</ul>
<h1 id="分区内进程切换"><a href="#分区内进程切换" class="headerlink" title="分区内进程切换"></a><strong>分区内进程切换</strong></h1><ul>
<li><p><strong>进程切换概述</strong>：</p>
<ul>
<li>分区内进程切换是指在同一个分区内，从一个进程切换到另一个进程。通常由分区内的调度器管理。</li>
</ul>
</li>
<li><p><strong>切换过程</strong>：</p>
<ol>
<li><strong>进程调度</strong>：分区内的调度器根据调度算法（如优先权调度）决定下一个要执行的进程。</li>
<li><strong>保存当前进程状态</strong>：保存当前进程的寄存器值、堆栈指针和其他状态信息。</li>
<li><strong>恢复新进程状态</strong>：加载新进程的寄存器值和堆栈指针，恢复新进程的执行上下文。</li>
<li><strong>切换完成</strong>：新进程开始执行。</li>
</ol>
</li>
<li><p><strong>进程间切换的关键点</strong>：</p>
<ul>
<li><strong>优先级</strong>：进程调度通常依赖于优先级，确保高优先级的进程能够得到及时处理。</li>
<li><strong>上下文切换</strong>：需要有效地管理进程的上下文切换，减少上下文切换的开销，以提高系统性能。</li>
</ul>
</li>
</ul>
<h1 id="APEX-时间调度（ApexTime-Scheduling）"><a href="#APEX-时间调度（ApexTime-Scheduling）" class="headerlink" title="APEX 时间调度（ApexTime Scheduling）"></a><strong>APEX 时间调度（ApexTime Scheduling）</strong></h1><ul>
<li><p><strong>APEX 时间调度概述</strong>：</p>
<ul>
<li><strong>ApexTime</strong> 是 ARINC 653 规范的一部分，用于管理系统中的时间分片和时间资源。它保证了任务在预定的时间段内能够得到执行，满足实时任务的需求。</li>
</ul>
</li>
<li><p><strong>时间调度的关键功能</strong>：</p>
<ol>
<li><strong>时间分片</strong>：系统将时间划分为固定长度的时间片，分配给不同的任务或分区。这确保了每个任务都有公平的执行机会。</li>
<li><strong>时间分区</strong>：APEX 接口通过时间分区机制管理任务执行的时间，确保任务在预定的时间内运行，满足实时系统的要求。</li>
<li><strong>定时器管理</strong>：APEX 提供了定时器服务，用于管理任务的超时和周期性调度，支持任务在特定时间点或间隔内执行。</li>
</ol>
</li>
<li><p><strong>时间调度的实现</strong>：</p>
<ul>
<li><strong>调度算法</strong>：APEX 接口可能会使用轮转法、优先级调度或其他调度算法来管理任务的时间片和优先级。</li>
<li><strong>系统调用</strong>：用户任务可以通过 APEX 提供的系统调用来请求时间服务，例如设置定时器、请求时间片等。</li>
<li><strong>实时保障</strong>：通过精确的时间管理和调度算法，APEX 确保了系统能够满足严格的实时性要求。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>航电系统</category>
      </categories>
  </entry>
  <entry>
    <title>部分名词解释</title>
    <url>/2024/08/22/3-%E8%BD%AF%E4%BB%B6-%E8%88%AA%E7%94%B5%E7%B3%BB%E7%BB%9F-%E9%83%A8%E5%88%86%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h1 id="AHRS"><a href="#AHRS" class="headerlink" title="AHRS"></a>AHRS</h1><p>AHRS (Attitude and Heading Reference System) 是一种姿态和航向参考系统,用于测量和计算飞机的姿态和航向。它由以下部分组成:</p>
<ul>
<li>三轴陀螺仪 - 测量角速率</li>
<li>三轴加速度计 - 测量重力加速度</li>
<li>三轴磁力计 - 测量地磁场</li>
</ul>
<p>AHRS 使用这些传感器数据,通过数据融合算法(如扩展卡尔曼滤波)计算出飞机的滚转角、俯仰角和航向角。它提供了一种比传统机械式仪表更可靠和精确的姿态参考。</p>
<h1 id="ADAHRS"><a href="#ADAHRS" class="headerlink" title="ADAHRS"></a>ADAHRS</h1><p>ADAHRS (Air Data and Attitude Heading Reference System)是一种集成的空速数据和姿态航向参考系统。它在 AHRS 的基础上,增加了以下功能:</p>
<ul>
<li>测量静压和动压,计算空速、高度等空速数据</li>
<li>测量外界温度</li>
<li>集成 GPS 数据</li>
<li>提供冗余的姿态和航向参考</li>
</ul>
<p>ADAHRS 将 AHRS 的姿态数据与空速数据、温度数据、GPS 数据等融合,为飞机提供更加完整和冗余的导航参考。它广泛应用于商用航空飞机、军用飞机和无人机等。</p>
<h1 id="AHRRATE"><a href="#AHRRATE" class="headerlink" title="AHRRATE"></a>AHRRATE</h1><p>AHRRATE(Attitude and Heading Reference System Rate)指的是姿态和航向参考系统(AHRS)测量的角速率。具体来说:</p>
<ul>
<li>AHRRATE 包括滚转角速率、俯仰角速率和偏航角速率,单位通常为 deg&#x2F;s（度每秒）。</li>
<li>AHRS 使用陀螺仪传感器测量飞机在三个轴上的角速率变化。</li>
<li>AHRRATE 数据用于计算飞机的姿态角,并提供给飞行控制系统和显示系统。<br>监测 AHRRATE 可以检测飞机的旋转运动,有助于监测飞机状态和预防失速。</li>
</ul>
<h1 id="ADCRATE"><a href="#ADCRATE" class="headerlink" title="ADCRATE"></a>ADCRATE</h1><p>ADCRATE (Air Data Computer Rate)指的是空速数据计算机(ADC)测量的数据更新率。具体来说:</p>
<ul>
<li>ADCRATE 表示 ADC 每秒钟更新静压、动压、温度等空速数据的频率,单位为 Hz（赫兹）。</li>
<li>ADC 使用压力传感器和温度传感器测量飞机的空速相关参数。</li>
<li>较高的 ADCRATE 可以提供更平滑和实时的空速数据,有利于飞行控制系统的精确控制。<br>典型的 ADCRATE 范围为 4-16 Hz。较高的更新率可以提高系统响应性,但也会增加处理开销。</li>
</ul>
<h1 id="空速"><a href="#空速" class="headerlink" title="空速"></a>空速</h1><p>IAS 是最基本的指示空速，CAS 是校正后的空速，EAS 考虑了空气密度的影响，TAS 是真实的空速，GS 是相对于地面的飞行速度。</p>
<h2 id="IAS"><a href="#IAS" class="headerlink" title="IAS"></a>IAS</h2><p>IAS (Indicated Airspeed)是指示空速,是飞机上的空速表直接显示的数值,不考虑任何误差和环境因素的影响。IAS 是最基本的空速概念。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS(Calibrated Airspeed)是校正空速,是对 IAS 进行校正后的值。由于静压孔和皮托管的安装位置误差,以及仪表本身的误差,IAS 会与实际的空速存在偏差。CAS 就是将这些误差校正后的空速值。</p>
<h2 id="EAS"><a href="#EAS" class="headerlink" title="EAS"></a>EAS</h2><p>EAS (Equivalent Airspeed)是当量空速,是在标准海平面大气条件下,具有与当前高度和 TAS 相同动压的空速。EAS 考虑了空气密度的影响。在高速高空飞行时,需要将 CAS 转换为 EAS。</p>
<h2 id="TAS"><a href="#TAS" class="headerlink" title="TAS"></a>TAS</h2><p>TAS(True Airspeed)是真空速,是飞机相对于周围空气的实际飞行速度。TAS 考虑了空气密度的影响,是最能反映飞机性能的空速。在飞行计划和性能比较中,通常使用 TAS。</p>
<h2 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h2><p>GS (Ground Speed)是地速,是飞机相对于地面的实际飞行速度。GS 等于 TAS 加上顺风分量,减去逆风分量。在无风条件下,GS 等于 TAS。</p>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>航电系统</category>
      </categories>
  </entry>
  <entry>
    <title>TV BOX</title>
    <url>/2024/05/22/3-%E8%BD%AF%E4%BB%B6-%E9%9F%B3%E8%A7%86%E9%A2%91-TV-BOX/</url>
    <content><![CDATA[<h1 id="应用端"><a href="#应用端" class="headerlink" title="应用端"></a>应用端</h1><h2 id="TVBOX"><a href="#TVBOX" class="headerlink" title="TVBOX"></a>TVBOX</h2><p><del>Github 开源了一个名为 <a href="https://github.com/CatVodTVOfficial/TVBoxOSC">TVBox</a> 的项目</del></p>
<p>o0HalfLife0o APK <a href="https://github.com/o0HalfLife0o/TVBoxOSC/releases/">https://github.com/o0HalfLife0o/TVBoxOSC/releases/</a></p>
<p>APP 设置 » 配置地址，我们需要在这里给 APP 添加视频源之后才能使用</p>
<h2 id="ZY-Player"><a href="#ZY-Player" class="headerlink" title="ZY-Player"></a>ZY-Player</h2><p><a href="https://github.com/cuiocean/ZY-Player-APP">https://github.com/cuiocean/ZY-Player-APP</a></p>
<h1 id="视频源"><a href="#视频源" class="headerlink" title="视频源"></a>视频源</h1><p>部分视频源由于网站地址原因无法直连，加速方式见 <a href="source/_posts/3.%E8%BD%AF%E4%BB%B6/Git/GitHub%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE.md">GitHub加速访问</a>。例如：</p>
<ul>
<li>jsDelivr 加速地址：<ul>
<li><a href="https://gcore.jsdelivr.net/gh/YuanHsing/freed@master/ZY-Player/ZY-Player-PC.json">https://gcore.jsdelivr.net/gh/YuanHsing/freed@master/ZY-Player/ZY-Player-PC.json</a></li>
</ul>
</li>
<li>Statically 加速地址：<ul>
<li><a href="https://cdn.staticaly.com/gh/YuanHsing/freed/master/ZY-Player/ZY-Player-PC.json">https://cdn.staticaly.com/gh/YuanHsing/freed/master/ZY-Player/ZY-Player-PC.json</a></li>
</ul>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>YuanHsing 维护的 <a href="https://github.com/YuanHsing/freed/tree/master/TVBox/">TVBOX接口项目</a></li>
<li><a href="https://github.com/hl128k/tvbox">https://github.com/hl128k/tvbox</a></li>
<li><a href="https://github.com/2hacc/TVBox">https://github.com/2hacc/TVBox</a></li>
</ul>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table>
<thead>
<tr>
<th align="center">网站</th>
<th align="center">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FongMi</td>
<td align="center"><a href="https://ghproxy.com/raw.githubusercontent.com/FongMi/CatVodSpider/main/json/config.json">https://ghproxy.com/raw.githubusercontent.com/FongMi/CatVodSpider/main/json/config.json</a></td>
</tr>
<tr>
<td align="center">巧技</td>
<td align="center"><a href="http://pandown.pro/tvbox/tvbox.json">http://pandown.pro/tvbox/tvbox.json</a></td>
</tr>
<tr>
<td align="center">俊于</td>
<td align="center"><a href="http://home.jundie.top:81/top98.json">http://home.jundie.top:81/top98.json</a><br></td>
</tr>
<tr>
<td align="center">霜辉月明</td>
<td align="center"><a href="https://ghproxy.com/raw.githubusercontent.com/lm317379829/PyramidStore/pyramid/py.json">https://ghproxy.com/raw.githubusercontent.com/lm317379829/PyramidStore/pyramid/py.json</a></td>
</tr>
<tr>
<td align="center">小雅</td>
<td align="center"><a href="http://drpy.site/js1">http://drpy.site/js1</a></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><a href="https://tvbox.cainisi.cf/">https://tvbox.cainisi.cf</a></td>
</tr>
<tr>
<td align="center">神器</td>
<td align="center">https:&#x2F;&#x2F;神器每日推送.tk&#x2F;pz.json</td>
</tr>
<tr>
<td align="center">饭太硬</td>
<td align="center">http:&#x2F;&#x2F;饭太硬.ga&#x2F;x&#x2F;o.json</td>
</tr>
<tr>
<td align="center">云星日记</td>
<td align="center"><a href="https://maoyingshi.cc/tvbox/%E4%BA%91%E6%98%9F%E6%97%A5%E8%AE%B0/1.m3u8">https://maoyingshi.cc/tvbox/云星日记/1.m3u8</a></td>
</tr>
<tr>
<td align="center">肥猫</td>
<td align="center">http:&#x2F;&#x2F;肥猫.love</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>ffmpeg-m3u8转mp4</title>
    <url>/2024/05/16/3-%E8%BD%AF%E4%BB%B6-%E9%9F%B3%E8%A7%86%E9%A2%91-ffmpeg-m3u8%E8%BD%ACmp4/</url>
    <content><![CDATA[<h1 id="FFmpeg-命令行工具"><a href="#FFmpeg-命令行工具" class="headerlink" title="FFmpeg 命令行工具"></a>FFmpeg 命令行工具</h1><p>将 m3u8 文件转换为 mp4 格式</p>
<p><strong>下载并安装 FFmpeg</strong><br>您可以从 <a href="https://ffmpeg.org/download.html">官方网站</a> 下载适合您操作系统的版本。</p>
<p><strong>打开命令行工具</strong></p>
<ul>
<li>在 Windows 上，您可以按下 Win + R 键，然后输入 cmd 并按 Enter 键打开命令提示符。</li>
<li>在 Mac OS 或 Linux 上，您可以打开终端应用程序。</li>
</ul>
<p><strong>转换 m3u8 文件</strong><br>在命令行中，导航到包含 m3u8 文件的目录，然后运行以下命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.m3u8 -c copy output.mp4</span><br></pre></td></tr></table></figure>

<p><code>input.m3u8</code> 是要转换的 m3u8 文件的名称，<code>output.mp4</code> 是转换后的 mp4 文件的名称。</p>
<p>该命令将使用 FFmpeg 将 m3u8 文件转换为 mp4 格式，并将其保存在相同的目录中。</p>
<p>请注意，此命令只能将 m3u8 文件转换为 mp4 格式，而不能将其中的视频文件下载到本地计算机。</p>
<p>如果您需要下载 m3u8 文件中的视频文件，请使用其他工具或软件。</p>
<h2 id="将分段式-m3u8-文件转换为-MP4-文件"><a href="#将分段式-m3u8-文件转换为-MP4-文件" class="headerlink" title="将分段式 m3u8 文件转换为 MP4 文件"></a>将分段式 m3u8 文件转换为 MP4 文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cd ./m3u8Movie  #分段式m3u8文件所在文件夹</span><br><span class="line"><span class="keyword">for</span> i in &#123;<span class="number">1.</span><span class="number">.2473</span>&#125;  #轮询所有分段式文件数量</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;$i&quot;</span> ]; then    #检测文件存在</span><br><span class="line">        mv <span class="string">&quot;$i&quot;</span> <span class="string">&quot;$i.mp4&quot;</span>    #重命名</span><br><span class="line">    fi</span><br><span class="line">    echo <span class="string">&quot;file &#x27;./$i.mp4&#x27;&quot;</span> &gt;&gt; list.txt  #添加到列表中去</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#调用ffmpeg进行视频连接操作</span><br><span class="line">ffmpeg -f concat -safe <span class="number">0</span> -i list.txt -c copy ../movie.mp4</span><br><span class="line">#-f 指定输入格式为concat，表示要进行视频文件的连接操作</span><br><span class="line">#-safe <span class="number">0</span> 设置安全模式为<span class="number">0</span>，允许使用不安全的文件名</span><br><span class="line">#-i 指定文本文件包含了要连接的视频文件的列表及其路径</span><br><span class="line">#-c 直接复制输入视频文件的音视频流，而不进行重新编码。这样可以加快处理速度而不损失质量。</span><br><span class="line">#指定输出文件路径和名称</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>3.软件</category>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>DRM+EGL 执行错误分析</title>
    <url>/2024/05/17/0-%E5%B9%B3%E5%8F%B0-Linux-Graphics-DRM-EGL-%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>mesa 运行 DRM+EGL 执行错误分析：</p>
<p><code>src\egl\main\egldefines.h</code> 中定义了 <code>EGL_VENDOR</code></p>
<p><code>#define _EGL_VENDOR_STRING &quot;Mesa Project&quot;</code></p>
<p>输出结果为 Mesa Project，确认输出无误</p>
<p><a href="https://askubuntu.com/questions/1027168/why-is-opengl-vendor-mesa-project">https://askubuntu.com/questions/1027168/why-is-opengl-vendor-mesa-project</a></p>
<p>以上问题项中，该选项显卡为 Nvidia</p>
<blockquote>
<p><code>glxinfo</code> tells you what the X11 server you’re running under is using for GL. It doesn’t tell you what an arbitrary program not using X11 might use.</p>
</blockquote>
<p>故分析如下：</p>
<ol>
<li>未正确启用显卡，EGL 采用的是 Mesa 软件渲染，故无法提供正确的 config</li>
</ol>
<blockquote>
<p>证明：</p>
</blockquote>
<ol start="2">
<li>是否有 GLX 或 Wayland 等方案解决该问题</li>
</ol>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>DRM+GBM+EGL显示</title>
    <url>/2024/05/17/0-%E5%B9%B3%E5%8F%B0-Linux-Graphics-DRM-GBM-EGL%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>DRM (Direct Rendering Manager)、GBM (Generic Buffer Manager) 和 EGL (Embedded-System Graphics Library) 组合在一起，是在 Linux 平台上进行图形渲染和硬件加速的常见方式。这些组件一起提供了一个完整的图形渲染栈，允许应用程序直接与图形硬件进行交互。</p>
<ul>
<li><p><strong>DRM（Direct Rendering Manager）</strong>：DRM 是 Linux 内核中的一个子系统，用于管理图形硬件的驱动程序。它提供了一种通用的接口，允许用户空间程序直接与硬件交互，通过设备文件 <code>/dev/dri/cardX</code> 访问。DRM 提供了诸如模式设置、显示控制、渲染加速等功能。</p>
</li>
<li><p><strong>GBM（Generic Buffer Manager）</strong>：GBM 是一个用于管理图形缓冲区的库，通常与 DRM 配合使用。它提供了一种标准的接口，用于分配、管理和操作图形内存。GBM 还提供了与 EGL 和 OpenGL ES 兼容的接口，使应用程序能够使用硬件加速进行渲染。</p>
</li>
<li><p><strong>EGL（Embedded-System Graphics Library）</strong>：EGL 是一个用于管理图形资源的库，提供了一个通用的接口，用于创建和管理 OpenGL 和 OpenGL ES 上下文、表面和其他相关对象。EGL 通常与 GBM 和 DRM 一起使用，通过 GBM 提供的接口来创建图形表面，并将其与 OpenGL 或 OpenGL ES 上下文关联起来，实现硬件加速的图形渲染。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Mesa</title>
    <url>/2024/05/17/0-%E5%B9%B3%E5%8F%B0-Linux-Graphics-Mesa/</url>
    <content><![CDATA[<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134513.png" alt="20240506123633.png"></p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>OpenGL显示</title>
    <url>/2024/05/17/0-%E5%B9%B3%E5%8F%B0-Linux-Graphics-OpenGL%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="GLU"><a href="#GLU" class="headerlink" title="GLU"></a>GLU</h1><p>GLU（OpenGL Utility Library）是 OpenGL 的一个辅助库，提供了一些更高级的几何计算和对象构造函数，如曲面和体的生成、平移、旋转等，这些函数在处理复杂的几何操作时非常有用。</p>
<h1 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h1><p>GLFW 是一个流行的开源库，主要用于创建和管理图形应用程序中的窗口、OpenGL 或 Vulkan 上下文，以及处理用户输入、定时器等功能。适用于各种图形应用程序的开发，提供了窗口管理、上下文管理、输入处理等功能，使开发者能够专注于图形渲染和应用逻辑的实现。</p>
<p>主要功能：</p>
<ol>
<li><strong>窗口管理：</strong> GLFW 允许开发者创建窗口并对其进行管理，包括调整大小、最小化、最大化、关闭等操作。</li>
<li><strong>上下文管理：</strong> 它提供了创建 OpenGL 或 Vulkan 上下文的功能，使得图形渲染程序可以在窗口中绘制图形。</li>
<li><strong>输入处理：</strong> GLFW 支持处理用户输入，包括键盘输入、鼠标移动和点击、游戏手柄等。</li>
<li><strong>事件处理：</strong> 它允许开发者监听和响应各种事件，如窗口大小改变、键盘按键、鼠标移动等。</li>
<li><strong>监视器管理：</strong> GLFW 支持多个显示器的管理，可以获取显示器的分辨率、刷新率等信息。</li>
</ol>
<p>使用步骤：</p>
<ol>
<li><strong>初始化：</strong> 在程序启动时，调用 GLFW 的初始化函数来初始化库。</li>
<li><strong>创建窗口：</strong> 使用 GLFW 的窗口创建函数来创建一个窗口并指定其属性，如大小、标题等。</li>
<li><strong>创建上下文：</strong> 使用 GLFW 的上下文创建函数来创建一个 OpenGL 或 Vulkan 上下文。</li>
<li><strong>主循环：</strong> 在主循环中轮询事件，并根据事件类型做出相应的处理。</li>
<li><strong>渲染：</strong> 在渲染阶段，使用 OpenGL 或 Vulkan 等图形 API 绘制场景。</li>
<li><strong>清理：</strong> 在程序结束时，调用 GLFW 的清理函数来释放资源并关闭库。</li>
</ol>
<p>利用 glfw 监视器 Demo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="comment">// 初始化 GLFW </span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>()) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125; </span><br><span class="line">	<span class="comment">// 获取监视器（显示器）列表 </span></span><br><span class="line">	<span class="type">int</span> count; GLFWmonitor** monitors = <span class="built_in">glfwGetMonitors</span>(&amp;count); </span><br><span class="line">	<span class="comment">// 指定要使用的显示设备索引 </span></span><br><span class="line">	<span class="type">int</span> monitor_index = <span class="number">0</span>; </span><br><span class="line">	<span class="comment">// 设置为你想要的显示设备索引 </span></span><br><span class="line">	<span class="comment">// 获取指定索引的显示设备 </span></span><br><span class="line">	GLFWmonitor* monitor = (monitor_index &lt; count) ? monitors[monitor_index] : <span class="literal">NULL</span>; </span><br><span class="line">	<span class="comment">// 获取显示设备的视频模式 </span></span><br><span class="line">	<span class="type">const</span> GLFWvidmode* mode = <span class="built_in">glfwGetVideoMode</span>(monitor); </span><br><span class="line">	<span class="comment">// 创建窗口并指定显示设备 </span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(mode-&gt;width, mode-&gt;height, <span class="string">&quot;OpenGL Window&quot;</span>, monitor, <span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">if</span> (!window) &#123; <span class="built_in">glfwTerminate</span>(); <span class="keyword">return</span> <span class="number">-1</span>; &#125; </span><br><span class="line">	<span class="comment">// 进入主循环 </span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123; </span><br><span class="line">		<span class="comment">// 渲染代码 </span></span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT); </span><br><span class="line">		<span class="comment">// ... </span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window); </span><br><span class="line">		<span class="built_in">glfwPollEvents</span>(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 清理资源 </span></span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window); </span><br><span class="line">	<span class="built_in">glfwTerminate</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GLUT（OpenGL-Utility-Toolkit）"><a href="#GLUT（OpenGL-Utility-Toolkit）" class="headerlink" title="GLUT（OpenGL Utility Toolkit）"></a>GLUT（OpenGL Utility Toolkit）</h1><p> GLUT 是一个跨平台的工具包，用于创建和管理 OpenGL 窗口、处理用户输入等。它提供了一组简单的 API，使得编写基本的 OpenGL 程序变得更加容易。</p>
<pre><code>- GLUT 支持多种操作系统，包括 Windows、Linux 和 macOS。

- 使用 GLUT，你可以很快地编写出一个可以在不同平台上运行的简单 OpenGL 程序，而不必担心平台特定的细节。

- 但是，GLUT 对于创建复杂的图形用户界面（GUI）可能不够灵活，因为它的功能相对有限。
</code></pre>
<ul>
<li><p><strong>GLUT</strong> 是一个跨平台的工具包，用于简化 OpenGL 应用程序的开发。它提供了一组函数，用于创建窗口、处理输入事件、进行基本的图形绘制等，使开发者可以更轻松地编写 OpenGL 应用程序，而无需处理底层的窗口系统的细节。</p>
</li>
<li><p>GLUT 提供了一个相对简单的接口，适用于快速原型设计和简单的图形应用程序。它通常用于学习 OpenGL、编写小型游戏、演示程序等。</p>
</li>
</ul>
<h1 id="GLX（OpenGL-Extension-to-the-X-Window-System）"><a href="#GLX（OpenGL-Extension-to-the-X-Window-System）" class="headerlink" title="GLX（OpenGL Extension to the X Window System）"></a>GLX（OpenGL Extension to the X Window System）</h1><ul>
<li><p><strong>GLX</strong> 是 OpenGL 在 X Window System 上的扩展，它允许 OpenGL 应用程序与 X 服务器通信，并在 X 窗口系统中创建 OpenGL 上下文。GLX 提供了一组函数，用于在 X 窗口系统中创建 OpenGL 渲染上下文、管理 OpenGL 窗口和图形渲染等。</p>
</li>
<li><p>GLX 允许 OpenGL 应用程序直接与 X 服务器通信，而不需要借助其他库或工具。它提供了对 OpenGL 的完整支持，可以实现高性能的图形渲染和交互。</p>
</li>
</ul>
<p>GLX 则是 OpenGL 在 X 窗口系统上的扩展，提供了与 X 服务器通信和在 X 窗口系统中创建 OpenGL 渲染上下文的功能。</p>
<h1 id="EGL（Embedded-Graphics-Library）"><a href="#EGL（Embedded-Graphics-Library）" class="headerlink" title="EGL（Embedded Graphics Library）"></a>EGL（Embedded Graphics Library）</h1><p>EGL 是一个用于管理图形渲染上下文的接口，通常用于嵌入式系统和移动设备上。</p>
<pre><code>- EGL 是 OpenGL ES 和 OpenVG 的标准的本地显示系统接口，它提供了与底层窗口系统交互的能力。

- 在 Linux 上，EGL 通常与 GBM（Generic Buffer Manager）或其他图形系统配合使用，如 Wayland。

- 使用 EGL，你可以在嵌入式系统上更好地控制 OpenGL 上下文的创建和管理，以及与窗口系统的交互。
</code></pre>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>一些关于Linux显示的说明</title>
    <url>/2024/05/17/0-%E5%B9%B3%E5%8F%B0-Linux-Graphics-%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8ELinux%E6%98%BE%E7%A4%BA%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>modetest 命令</p>
<p>利用 xrandr 在命令行指定输出</p>
<p><code>xrandr --output HDMI-1 --mode 1920x1080 | ./a.out</code></p>
<p>Mesa 是一个开源的实现了 OpenGL 规范的图形库，它提供了一个 OpenGL 兼容的渲染器和工具库。在 Mesa 生成的头文件中可能不包含 GLU，因为 GLU（OpenGL Utility Library）通常被视为 OpenGL 的一个独立组件，而不是 OpenGL 的核心部分。</p>
<p>GLU 提供了一些 OpenGL 的辅助功能，比如进行复杂几何运算和对象构造等。虽然 GLU 在许多 OpenGL 实现中都有支持，但它并不是 OpenGL 规范的一部分，因此在某些情况下，OpenGL 实现可能不包括 GLU 或将其作为一个可选组件。</p>
<p>Mesa 是一个开源的图形库，提供了 OpenGL 兼容的渲染器和工具库。在 Mesa 生成的头文件中可能不包含 GLU，因为 GLU 不是 OpenGL 规范的一部分。如果需要在使用 Mesa 的项目中使用 GLU，可以通过其他途径获取 GLU 的头文件和库文件，然后将其包含到项目中并链接以使用 GLU 提供的功能。</p>
<p>如果你需要在使用 Mesa 的项目中使用 GLU，可以通过其他途径获取 GLU 的头文件和库文件，例如从系统的 OpenGL 安装中获取，或者从其他地方下载 GLU 的实现。然后将 GLU 的头文件包含到你的项目中，并链接 GLU 库以使用 GLU 提供的功能。</p>
<p>Mesa 是一个开源的图形库，提供了 OpenGL 兼容的渲染器和工具库。在 Mesa 生成的头文件中可能不包含 GLU，因为 GLU 不是 OpenGL 规范的一部分。如果需要在使用 Mesa 的项目中使用 GLU，可以通过其他途径获取 GLU 的头文件和库文件，然后将其包含到项目中并链接以使用 GLU 提供的功能。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134548.png" alt="20240506131239.png"></p>
<h1 id="DRM"><a href="#DRM" class="headerlink" title="DRM"></a>DRM</h1><p>利用 DRM+GBM+EGL 指定显卡运行代码分析</p>
<p>Mesa GBM（Generic Buffer Management）是一个开源图形缓冲区管理库，用于管理图形内存缓冲区。它是 Mesa 3D 图形库的一部分。GBM 主要用于 Linux 平台，为 Direct Rendering Manager (DRM) 内核子系统提供了一个用户空间 API。它提供了一种统一的接口，用于在 Linux 系统中管理图形缓冲区和设备之间的交互。</p>
<p>在 DRM（Direct Rendering Manager）中，CRTC（Cathode Ray Tube Controller）是一个显示管控制器，负责控制显示管的扫描、同步和刷新操作。它与 Encoder（编码器）和 Connector（连接器）之间存在着一定的联系。</p>
<ol>
<li><p><strong>CRTC（Cathode Ray Tube Controller）</strong>：CRTC 控制着实际显示设备的扫描和刷新操作。每个 CRTC 都与一个显示管（如液晶显示器或投影仪）相关联，负责生成该显示设备的图像信号。一个显卡可能有多个 CRTC，每个 CRTC 控制一个显示输出。</p>
</li>
<li><p><strong>Encoder（编码器）</strong>：Encoder 是 CRTC 输出信号的编码器，将图像数据转换为特定格式的信号以便发送到显示设备。Encoder 通常与特定类型的连接器（如 HDMI、DVI、VGA 等）相关联，以便将图像数据转换为对应的视频信号格式。一个 CRTC 可能与多个 Encoder 相关联，这意味着它可以同时支持多种连接器类型。</p>
</li>
<li><p><strong>Connector（连接器）</strong>：Connector 表示与显卡相连的物理显示端口，如 HDMI 接口、DVI 接口等。每个 Connector 对应一个实际的显示输出接口，比如连接显示器或投影仪的端口。每个 Connector 都与一个 Encoder 相关联，该 Encoder 负责将图像数据编码成连接器所需的信号格式。</p>
</li>
</ol>
<p>在 DRM 中，通常的工作流程是：</p>
<ul>
<li>用户空间（如图形驱动程序）通过 DRM 接口选择一个 Connector，然后创建一个 CRTC 并将其与所选 Connector 关联起来。</li>
<li>然后，用户空间会创建一个 Encoder，并将其与所选的 Connector 关联起来，以便将图像数据编码成正确的视频信号格式。</li>
<li>最后，用户空间会将帧缓冲区（Framebuffer）的内容提交给 CRTC 进行显示。CRTC 接收到帧缓冲区的内容后，会将其发送给相关联的 Encoder，最终显示到连接器所代表的显示设备上。</li>
</ul>
<p>总之，CRTC 负责控制实际的显示设备，Encoder 负责将图像数据转换为视频信号格式，而 Connector 则表示实际的物理显示端口，它们之间相互关联，共同完成图像显示的任务。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134315.png" alt="20240509162919.png"></p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134326.png" alt="20240509162636.png"></p>
<p>EGL 是 Khronos 渲染 API（如 OpenGL、OpenGL ES 或 OpenVG）与底层本地平台 (窗口) 系统之间的接口。</p>
<p>EGL 主要功能：处理图形上下文管理、Buffer 管理和渲染同步</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134402.png" alt="20240513100358.png"></p>
<ul>
<li>Display (EGLDisplay): 对实际显示设备&#x2F;窗口系统的抽象；</li>
<li>Surface (EGLSurface): 存储图像的内存区域；</li>
<li>Context (EGLContext): 存储渲染 API 的状态信息；<br>一套标准的 EGL 绘制流程简介:<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134413.png" alt="20240513151231.png"></li>
</ul>
<ol>
<li><p>获取 EGL Display 对象：eglGetDisplay</p>
</li>
<li><p>初始化与 EGLDisplay 之间的连接：eglInitialize</p>
</li>
<li><p>获取 EGLConfig 对象：eglChooseConfig &#x2F; eglGetconfigs</p>
</li>
<li><p>创建 EGLContext 实例：eglCreateContext</p>
</li>
<li><p>创建 EGLSurface 实例：eglCreatewindowSurface &#x2F; eglCratePbufferSurface</p>
</li>
<li><p>连接 EGLContext 和 EGLSurface 上下文: eglMakeCurrent<br><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/22/20240522134421.png" alt="20240513151344.png"></p>
</li>
<li><p>使用 OpenGL ES API 绘制图形：gl_*</p>
</li>
<li><p>切换 front buffer 和 back buffer 显示：eglSwapBuffer</p>
</li>
<li><p>断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease</p>
</li>
<li><p>删除 EGLSurface 对象</p>
</li>
<li><p>删除 EGLContext 对象</p>
</li>
<li><p>终止与 EGLDisplay 之间的连接</p>
</li>
</ol>
<h2 id="EGL-Display-的获取"><a href="#EGL-Display-的获取" class="headerlink" title="EGL Display 的获取"></a>EGL Display 的获取</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">EGLDisplay <span class="title">eglGetDisplay</span><span class="params">(NativeDisplayType native_display)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">EGLDisplay <span class="title">eglGetPlatformDisplay</span><span class="params">( EGLenum platform, <span class="type">void</span> * native_display, <span class="type">const</span> EGLAttrib * attrib_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">EGLDisplay <span class="title">eglGetPlatformDisplayEXT</span><span class="params">( EGLenum platform, <span class="type">void</span> *native_display, <span class="type">const</span> EGLint *attrib_list)</span></span>;</span><br></pre></td></tr></table></figure>

<p>eglGetDisplay</p>
<p>会根据现在的环境来决定默认的原生窗口系统，其他两个需要手动指定平台；</p>
<p>compositor 运行相当于是裸机运行没有窗口环境，首先必须通过 GBM 或者 EGL_PLATFORM_DEVICE_EXT 扩展这两种方式来获取 EGLDisplay;</p>
<p>GBM 概念:</p>
<p>基于 GEM&#x2F;TTM 的驱动对外是没有提供统一的内存管理接口的，至少 Buffer Object 创建销毁等操作是需要自行提供设备相关的即口进行实现的。</p>
<p>用户态没有统一的接口对缓冲区进行管理，这导致某些特定用户态程序的开发的困难，如 wayland compositor。</p>
<p>简单的说 GBM 就是为了实现 DRM(gbm_device) 作为 EGL 的本地平台，创建的句柄可以用来初始化 EGL 和创建渲染目标缓冲区</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get gdm_device</span></span><br><span class="line"><span class="comment">// path = &quot;/dev/dri/renderD128&quot; / &quot;dev/dri/card0&quot;</span></span><br><span class="line">egl_gbm.render_fd = <span class="built_in">open</span>(path, O_RDWR|O_CLOEXEC);</span><br><span class="line"><span class="built_in">assert</span>(<span class="number">-1</span> != egl_gbm.render_fd);</span><br><span class="line">egl_gbm.gbm_device = <span class="built_in">gbm_create_device</span>(egl_gbm.render_fd);</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">NULL</span> != egl_gbm.gbm_device);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get display</span></span><br><span class="line"><span class="number">1.</span> egl_gbm.display = <span class="built_in">eglGetDisplay</span>((EGLNativeDisplayType)egl_gbm.gbm_device);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> egl_gbm.display = <span class="built_in">eglGetPlatformDisplay</span>(EGL_PLATFORM_GBM_KHR, egl_gbm.gbm_device, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> egl_gbm.display = <span class="built_in">eglGetPlatformDisplayEXT</span>(EGL_PLATFORM_GBM_MESA, egl_gbm.gbm_device, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// wlroots里面从严谨性来说，通过GBM获取EGL Display的时候，eglGetPlatformDisplayEXT后面的参数应该是EGL_PLATFORM_GBM_MESA而不是EGL_PLATFORM_GBM_KHR；</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>Wayland</strong>：Wayland 是一种图形显示服务器协议，而 DRM 是 Linux 内核中的 Direct Rendering Manager 子系统，用于管理图形硬件驱动程序。在 Wayland 中，客户端应用程序通过 Wayland 协议与显示服务器通信，而 Wayland 服务器通过 DRM 接口与底层的图形硬件交互。</p>
</li>
<li><p>** GBM**：直接的关系是 DRM 和 GBM，其中 DRM（Direct Rendering Manager）是 Linux 内核中的子系统，用于管理图形硬件的驱动程序，而 GBM（Generic Buffer Manager）是一个用户态库，提供了一个标准接口，用于分配、管理和操作图形内存，通常与 DRM 配合使用。GBM 通常与 DRM（Direct Rendering Manager）配合使用，用于与底层的图形硬件进行交互。应用程序可以使用 GBM 接口来分配和管理图形缓冲区，以便进行硬件加速的图形渲染。GBM 与 Wayland 无直接关联，但在一些特定的场景下，它们可能会一起使用。</p>
</li>
<li><p><strong>GBM 控制 EGL</strong>：GBM 通常与 EGL 结合使用，以在硬件加速的图形渲染中创建和管理图形表面（buffers）。EGL（Embedded-System Graphics Library）是一个用于管理图形资源的库，提供了一个通用的接口，用于创建和管理 OpenGL 和 OpenGL ES 上下文、表面和其他相关对象。</p>
</li>
<li><p><strong>EGL 操作 OpenGL API 进行操作</strong>：EGL 用于管理 OpenGL 或 OpenGL ES 的上下文和表面，以便应用程序可以使用 OpenGL API 进行图形操作。EGL 提供了一个标准的接口，用于在不同的图形系统中创建和管理 OpenGL 上下文和表面，以便实现跨平台的图形渲染。</p>
</li>
</ol>
<h1 id="确定显卡"><a href="#确定显卡" class="headerlink" title="确定显卡"></a>确定显卡</h1><p>linux 内核检测到机器上的显卡时，会加载正确的设备驱动程序（位于内核树中的 <code>./drivers/gpu/drm/&lt;xy&gt;</code>），并提供两个字符设备来控制显卡。</p>
<p>Udev （或您使用的任何热插拔应用程序）将把它们创建为</p>
<p><code>/dev/dri/card0</code></p>
<p><code>/dev/dri/controlID64</code></p>
<p>我们只需要第一个。</p>
<p>你可以像我们在这里做的那样，在应用程序中硬编码这个路径，但建议使用真正支持热插拔和多座的 libudev。不过，这超出了本文的讨论范围。</p>
<p>如果有多块显卡，可能还会有 <code>/dev/dri/card1</code>、<code>/dev/dri/card2</code>、……</p>
<p><code>modeset_open(out,node)</code>： 辅助函数用于打开作为 @node 给定的 DRM 设备。</p>
<p>成功时，新的 fd 将存储在 @out 中。如果失败，则返回负错误代码。</p>
<p>打开文件后，我们还要检查 DRM_CAP_DUMB_BUFFER 功能。</p>
<p>如果驱动程序支持该功能，我们就可以创建简单的内存映射缓冲区，而无需任何依赖于驱动程序的代码。</p>
<p>由于我们希望避免使用任何 radeon、nvidia、intel 等驱动程序的特定代码，因此我们在此依赖于 DUMB_BUFFER。</p>
<h1 id="确认显示设备"><a href="#确认显示设备" class="headerlink" title="确认显示设备"></a>确认显示设备</h1><p>我们需要找到可用的显示设备。</p>
<p>libdrm 提供了 drmModeRes 结构，其中包含所有需要的信息。</p>
<p>通过 drmModeGetResources(fd) 获取，</p>
<p>通过 drmModeFreeResources(res) 释放。</p>
<p>显卡上的物理连接器称为 “connector”。您可以将显示器插入其中并控制显示内容。</p>
<p>我们肯定会对当前使用的 connector 感兴趣，因此，我们需遍历连接器列表，并尝试在每个可用的显示器上显示测试图片。</p>
<p>然而，这并不像听起来那么容易。首先，我们需要检查连接器是否被实际使用（显示器已插入并打开）。</p>
<p>然后，我们需要找到一个能控制该连接器的 CRTC，CRTC 稍后介绍。</p>
<p>然后，我们创建一个帧缓冲器对象 framebuffer object。</p>
<p>准备完成后我们就可以对帧缓冲区进行 mmap()，并在其中绘制测试图片。</p>
<p>然后，我们就可以告诉 DRM 设备在给定的 CRTC 上用选定的连接器显示帧缓冲。</p>
<p>由于我们要在帧缓存上绘制动态图像，因此必须记住所有这些设置。</p>
<p>因此，我们要为成功初始化的每对连接器 +crtc+ 帧缓冲器创建一个 “struct modeset_dev “ 对象，并将其推入全局设备列表。</p>
<p>因此，下一步我们需要实际准备好找到的所有连接器。</p>
<p>这段文字主要讲述了在 Linux 系统中确定显卡和显示设备的过程。以下是关键点的概括：</p>
<ol>
<li><p><strong>内核检测与驱动加载</strong>：Linux 内核会自动检测并加载适合的显卡驱动程序。</p>
</li>
<li><p><strong>创建字符设备</strong>：显卡驱动程序会创建两个字符设备，用于控制显卡。</p>
</li>
<li><p><strong>确认显示设备和 CRTC</strong>：通过遍历连接器列表，并尝试在每个可用显示器上显示测试图片，来确定合适的显示设备（CRTC）。</p>
</li>
<li><p><strong>避免完整模式集的设置</strong>：在使用 CRTC 之前，需要确保其他设备没有占用该 CRTC。</p>
</li>
<li><p><strong>创建并维护设备列表</strong>：为成功初始化的每一对连接器 +CRTC+ 帧缓冲器创建一个 <code>struct modeset_dev</code> 对象，并将其添加到全局设备列表中。<br><code>modeset_prepare(fd)</code>：该辅助函数将 DRM fd 作为参数，然后简单地从设备中获取资源信息。</p>
</li>
</ol>
<p>如果初始化成功，我们只需将此对象作为新设备添加到全局模式集设备列表中。</p>
<p>资源结构包含所有连接器 ID 的列表。</p>
<p>我们使用辅助函数 drmModeGetConnector() 获取每个连接器的更多信息。</p>
<p>如果连接器当前未使用，也未插入监视器，我们的辅助函数 modeset_setup_dev() 将返回 -ENOENT。</p>
<p>因此，我们可以忽略该连接器。</p>
<p>modeset_find_crtc(fd, res, conn, dev)： 这个小助手试图为给定的连接器找到合适的 CRTC。</p>
<p>实际上，我们必须再引入一个 DRM 对象，以便更清楚地说明这一点：编码器（Encoders）。</p>
<p>编码器可以帮助 CRTC 将帧缓冲器中的数据转换成正确的格式，以便用于所选的连接器。</p>
<p>我们不需要了解更多的转换信息就能使用它。</p>
<p>不过，您必须知道，每个连接器可以使用的编码器都是有限的。</p>
<p>而每个编码器只能与有限的 CRTC 配合使用。</p>
<p>因此，我们要做的就是尝试每一个可用的编码器，并寻找该编码器可以配合使用的 CRTC。</p>
<p>如果我们找到了第一个工作组合，我们就会很高兴，并将其写入 @dev 结构。</p>
<p>但在遍历所有可用编码器之前，我们首先要在一个连接器上尝试当前激活的编码器 +CRTC，以避免出现完整的模式集。</p>
<p>不过，在使用 CRTC 之前，我们必须确保之前设置的其他设备都没有使用该 CRTC。</p>
<p>请记住，每个 CRTC 只能驱动一个连接器！因此，我们只需遍历之前设置的设备的 “modeset_list”，并检查该 CRTC 之前是否未被使用。</p>
<p>否则，我们将继续使用下一个 CRTC&#x2F;编码器组合。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>信号量</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-Linux-IO-%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Linux 的信号量是一种<strong>进程间通信机制</strong>，用于控制进程对共享资源的访问。信号量是一个计数器，用于表示某个共享资源的可用数量。进程可以使用信号量来申请共享资源的访问权限，也可以使用信号量来释放已经申请到的资源。</p>
<p>Linux 中的信号量包括两种类型：二进制信号量和计数信号量。二进制信号量只有两个取值，分别表示资源的空闲和占用状态。计数信号量的取值可以是任意正整数，表示可用资源的数量。</p>
<p>进程可以使用 semget() 函数创建一个信号量集，使用 semop() 函数对信号量进行操作。semop() 函数可以对信号量进行加锁和解锁操作，还可以等待信号量的值达到某个条件。当某个进程占用了一个资源时，它需要对相应的信号量进行加锁操作，以防止其他进程同时访问该资源。当进程释放资源时，需要对相应的信号量进行解锁操作，以便其他进程可以访问该资源。</p>
<h1 id="SIG-簇函数"><a href="#SIG-簇函数" class="headerlink" title="SIG 簇函数"></a>SIG 簇函数</h1><p>在 Linux 中，信号量通常用于进程间的同步和互斥操作。例如，多个进程需要访问同一个共享文件时，可以使用信号量来控制对该文件的访问。</p>
<p>在 Linux 中，SIG 簇函数是一组用于处理信号的系统调用函数，可以用来注册信号处理函数、发送信号、阻塞信号等操作。这些函数的名称都以 “sig” 开头，例如 sigaction、sigprocmask、sigqueue 等。</p>
<p>下面是一些常用的 SIG 簇函数：</p>
<ul>
<li>sigaction 函数：用于注册信号处理函数。该函数可以指定一个函数指针作为信号处理函数，当接收到指定信号时，系统会自动调用该函数进行处理。sigaction 函数还可以设置信号的处理方式，例如忽略信号、执行默认操作、执行指定的处理函数等。</li>
<li>sigprocmask 函数：用于设置进程的信号屏蔽字。进程可以使用该函数屏蔽某些信号，以免在处理某个信号时被其他信号中断。当某个信号被屏蔽后，它将被暂时忽略，直到该信号被解除屏蔽。</li>
<li>sigpending 函数：用于获取当前进程的未决信号集。未决信号是指已经发送给进程但尚未处理的信号。sigpending 函数可以获取当前进程的未决信号集，并将其保存在一个 sigset_t 类型的变量中。</li>
<li>sigsuspend 函数：用于挂起当前进程，直到收到指定信号为止。该函数可以用于等待某个信号的到来，并阻塞当前进程，直到收到指定信号后才会继续执行。</li>
<li>sigqueue 函数：用于向指定进程发送信号，并可以携带一个整数值作为附加数据。该函数可以用于进程间的通信，例如向另一个进程发送通知消息等。</li>
</ul>
<p>这些 SIG 簇函数可以帮助我们更好地处理信号，实现进程间的通信和同步操作。在使用这些函数时，需要注意信号的处理顺序和优先级，以免出现意外的结果。</p>
<h1 id="信号量用作定时器"><a href="#信号量用作定时器" class="headerlink" title="信号量用作定时器"></a>信号量用作定时器</h1><p>信号量可以用作定时器的一种实现方式。具体来说，可以使用 setitimer 函数设置一个定时器，当定时器到期时，系统会自动向当前进程发送一个指定的信号，进程可以通过信号处理函数来处理该信号。</p>
<p>以下是一个使用信号量实现定时器的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_KEY 0x12345678</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sem_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">semid_ds</span> *buf;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> *array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Timer expired.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_timer</span><span class="params">(<span class="type">int</span> sec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">itimerval</span> timer;</span><br><span class="line">	timer.it_value.tv_sec = sec;</span><br><span class="line">	timer.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	timer.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">	timer.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">setitimer</span>(ITIMER_REAL, &amp;timer, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_sem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">semun</span> arg;</span><br><span class="line">	arg.val = <span class="number">0</span>;</span><br><span class="line">	sem_id = <span class="built_in">semget</span>(SEM_KEY, <span class="number">1</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">	<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_sem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sembuf</span> sb;</span><br><span class="line">	sb.sem_num = <span class="number">0</span>;</span><br><span class="line">	sb.sem_op = <span class="number">-1</span>;</span><br><span class="line">	sb.sem_flg = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">semop</span>(sem_id, &amp;sb, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_sem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sembuf</span> sb;</span><br><span class="line">	sb.sem_num = <span class="number">0</span>;</span><br><span class="line">	sb.sem_op = <span class="number">1</span>;</span><br><span class="line">	sb.sem_flg = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">semop</span>(sem_id, &amp;sb, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">signal</span>(SIGALRM, handler);</span><br><span class="line">	<span class="built_in">init_sem</span>();</span><br><span class="line">	<span class="built_in">set_timer</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">wait_sem</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Exiting...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，我们使用了 setitimer 函数来设置一个 5 秒的定时器，当定时器到期时，系统会向当前进程发送 SIGALRM 信号。我们在程序中注册了 SIGALRM 信号的处理函数 handler，当收到该信号时，会输出一条消息。</p>
<p>为了实现等待定时器到期的功能，我们使用了信号量。在程序开始时，我们调用了 init_sem 函数来初始化信号量。在程序中，我们使用了 wait_sem 函数来等待信号量的值变为 0，这个函数会阻塞当前进程直到收到信号量为止。在信号处理函数中，我们调用了 post_sem 函数来将信号量的值加 1，这样就可以让等待信号量的进程继续执行了。</p>
<p>当程序运行时，它会等待 5 秒钟，然后输出一条消息并退出。如果需要更长或更短的定时器，可以修改 set_timer 函数中的参数。</p>
<h1 id="Linux-中的信号量和-Qt-的信号槽机制"><a href="#Linux-中的信号量和-Qt-的信号槽机制" class="headerlink" title="Linux 中的信号量和 Qt 的信号槽机制"></a>Linux 中的信号量和 Qt 的信号槽机制</h1><p>Linux 中的信号量和 Qt 中的信号槽都是用于<strong>实现进程间通信和事件处理</strong>的机制，但实现方式和应用场景有所不同。</p>
<p>Linux 中的信号量是一种进程间通信机制，用于控制进程<strong>对共享资源的访问</strong>。信号量是一个计数器，用于表示某个共享资源的可用数量。进程可以使用信号量来申请共享资源的访问权限，也可以使用信号量来释放已经申请到的资源。Linux 中的信号量通常用于<strong>进程间的同步和互斥操作</strong>，例如多个进程需要访问同一个共享文件时，可以使用信号量来控制对该文件的访问。</p>
<p>Qt 中的信号槽是一种<strong>事件处理</strong>机制，用于在对象之间<strong>传递消息和处理事件</strong>。当一个对象发生某个事件时，它会发送一个信号，其他对象可以连接到该信号并定义一个槽函数来处理该事件。Qt 中的信号槽机制可以用于实现对象之间的通信和协作，例如在一个窗口中点击一个按钮时，可以发送一个信号来通知其他对象执行相应的操作。</p>
<p>虽然 Linux 中的信号量和 Qt 中的信号槽机制都可以用于进程间通信和事件处理，但它们的实现方式和应用场景有所不同。在 Linux 中，信号量通常用于控制对共享资源的访问，而在 Qt 中，信号槽机制通常用于处理事件和实现对象之间的通信。</p>
<h2 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h2><p>sigaction 和 Qt 的信号槽机制都是用于处理信号的机制，sigaction 主要用于实现进程间通信和事件处理，而 Qt 的信号槽机制主要用于处理 GUI 事件和实现对象之间的通信。</p>
<p>sigaction 是 Linux 中用于处理信号的函数，可以设置信号处理函数、信号屏蔽字等。当进程接收到某个信号时，会自动调用对应的信号处理函数来处理该信号。sigaction 主要用于实现<strong>进程间通信和事件处理</strong>，例如在多进程编程中，可以使用 sigaction 实现进程间的同步和互斥操作。</p>
<p>Qt 中的信号槽机制是一种事件处理机制，用于在对象之间传递消息和处理事件。当一个对象发生某个事件时，它会发送一个信号，其他对象可以连接到该信号并定义一个槽函数来处理该事件。Qt 中的信号槽机制可以用于实现<strong>对象之间的通信和协作</strong>，例如在一个窗口中点击一个按钮时，可以发送一个信号来通知其他对象执行相应的操作。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>IO</category>
      </categories>
  </entry>
  <entry>
    <title>文件IO</title>
    <url>/2024/06/07/0-%E5%B9%B3%E5%8F%B0-Linux-IO-%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<p>文件 IO</p>
<pre><code>文件描述符

    进程的概念 从硬盘到内存到cpu的的动态过程

    进程内唯一，每个打开的文件都对应内核中的一块区域，被内核管理

    内核给用户一个整型值用来通知内核要操作的文件

    缺省默认当前可用的最小值

012

    缺省文件描述符

    分别映射一个硬件设备

    由系统默认打开
</code></pre>
<p>文件 IO API 编程接口,就是函数名</p>
<pre><code>fp = open(pathname,  flag);

fp = open(pathname,  flag, mode);


ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);

close(fd); 

lseek();
    空洞文件。
</code></pre>
<p>文件和目录</p>
<pre><code>文件属性:

    stat(&quot;pathname&quot;, struct stat p);

    fstat(int fd, ....);

    lstat(&quot;..&quot;,  ....);

    getpwuid(); //根据uid获取用户信息

    getgrgid(); //	  gid    组信息

    localtime();

    
    struct stat &#123;&#125;; 文件信息结构体
    struct passwd &#123;&#125;; 用户信息结构体 pw = getpwuid(sb.st_uid);
    struct group &#123;&#125;; 组信息结构体
    struct tm&#123;&#125;; 时间结构体

文件夹:
    DIR *opendir();
    struct dirent * readdir();
    closedir();
    
    struct dirent &#123;&#125;;
    
    
</code></pre>
<p>拓展:</p>
<pre><code>getopt(); 获取短参函数 ls -la

access(); 检查文件文件是否存在和文件权限函数

chdir();	
</code></pre>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>IO</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu更换国内源</title>
    <url>/2024/05/17/0-%E5%B9%B3%E5%8F%B0-Linux-Ubuntu-Ubuntu%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<h1 id="Ubuntu-更换国内源"><a href="#Ubuntu-更换国内源" class="headerlink" title="Ubuntu 更换国内源"></a>Ubuntu 更换国内源</h1><p>Ubuntu 本身的源使用的是国内的源，下载速度比较慢。</p>
<p>清华源地址 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu-ports/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu-ports/</a></p>
<p><code>bionic</code> 代表 ubuntu18</p>
<h3 id="备份-etc-apt-sources-list-文件"><a href="#备份-etc-apt-sources-list-文件" class="headerlink" title="备份&#x2F;etc&#x2F;apt&#x2F;sources.list 文件"></a>备份&#x2F;etc&#x2F;apt&#x2F;sources.list 文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sourses.list.backup</span><br></pre></td></tr></table></figure>

<h3 id="新建-etc-apt-sources-list-文件并添加以下内容"><a href="#新建-etc-apt-sources-list-文件并添加以下内容" class="headerlink" title="新建&#x2F;etc&#x2F;apt&#x2F;sources.list 文件并添加以下内容"></a>新建&#x2F;etc&#x2F;apt&#x2F;sources.list 文件并添加以下内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#163源</span></span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>更改完成之后执行一下 <code>apt update</code> 命令</p>
<h3 id="其他的一些-apt-命令"><a href="#其他的一些-apt-命令" class="headerlink" title="其他的一些 apt 命令"></a>其他的一些 apt 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  更新源</span><br><span class="line">sudo apt-get install package 安装包</span><br><span class="line">sudo apt-get remove package 删除包</span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line">sudo apt-get install package --reinstall  重新安装包</span><br><span class="line">sudo apt-get -f install  修复安装</span><br><span class="line">sudo apt-get remove package --purge 删除包，包括配置文件等</span><br><span class="line">sudo apt-get build-dep package 安装相关的编译环境</span><br><span class="line">sudo apt-get upgrade 更新已安装的包</span><br><span class="line">sudo apt-get dist-upgrade 升级系统</span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line">sudo apt-get <span class="built_in">source</span> package  下载该包的源代码</span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</span><br><span class="line">sudo apt-get check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure>

<h3 id="其他几个国内的源："><a href="#其他几个国内的源：" class="headerlink" title="其他几个国内的源："></a>其他几个国内的源：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#中科大源</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#阿里云源</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#清华源</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>CPU参数说明</title>
    <url>/2024/09/02/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%85%B6%E4%BB%96-CPU%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>在 Linux 系统中使用 top 命令查看 CPU 相关参数时有以下内容</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/obsidian/1725256239000gjd0h6.png" alt="gh"></p>
<ul>
<li>us: “user CPU time” 用户空间占用 CPU 百分比</li>
<li>sy: “system CPU time” 内核空间占用 CPU 百分比</li>
<li>ni: is meaning of” nice CPU time” 用户进程空间内改变过优先级的进程占用 CPU 百分比</li>
<li>id: “idle” 空闲 CPU 百分比</li>
<li>wa: “iowait”  等待输入输出的 CPU 时间百分比即等待磁盘写入完成时间</li>
<li>hi：”hardware irq” 硬件中断消耗时间</li>
<li>si : “software irq” 软件中断消耗时间</li>
<li>st : “steal time” 分配给其他虚拟机的时间</li>
</ul>
<h1 id="使用率"><a href="#使用率" class="headerlink" title="使用率"></a>使用率</h1><p> CPU 在处理任务时所花费的时间占总时间的比例。可以通过以下公式计算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CPU 使用率 = us + sy + ni + hi + si</span><br></pre></td></tr></table></figure>

<p>这表示了 CPU 忙于实际处理任务的时间，不包括空闲时间（id）和 I&#x2F;O 等待时间（wa）。</p>
<h1 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h1><p>负载通常指的是系统的任务排队情况，也就是在等待 CPU 处理的进程数。它通常由操作系统的负载均衡器来计算，考虑到运行队列中的任务数量和平均等待时间。</p>
<p>CPU 负载需要结合任务队列长度、等待时间以及 CPU 调度情况来衡量，可以通过 uptime、w 命令查看 CPU 平均负载，使用 top 命令还能看到 CPU 负载总体使用率以及各个进程占用 CPU 的比例。</p>
<p>如果单核 CPU 的话，负载达到 1 就代表 CPU 已经达到满负荷的状态了，超过 1，后面的进行就需要排队等待处理了。如果是多核多 CPU，假设现在服务器是 2 个 CPU，每个 CPU 有 2 个核，那么总负载不超过 4 都没什么问题。</p>
<h1 id="参数查看"><a href="#参数查看" class="headerlink" title="参数查看"></a>参数查看</h1><p>查看物理 CPU 个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep “physical id”| sort | uniq| wc -l</span><br></pre></td></tr></table></figure>

<p>查看每个物理 CPU 中 core 的个数(即核数)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep “cpu cores” | uniq</span><br></pre></td></tr></table></figure>

<p>查看逻辑 CPU 的个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep “processor”| wc -l</span><br></pre></td></tr></table></figure>

<h1 id="负载高利用率低"><a href="#负载高利用率低" class="headerlink" title="负载高利用率低"></a>负载高利用率低</h1><p>CPU 负载很高，利用率却很低，说明处于等待状态的任务很多，负载越高，代表可能很多僵死的进程。通常这种情况是 IO 密集型的任务，大量任务在请求相同的 IO，导致任务队列堆积。</p>
<h1 id="负载低利用率高"><a href="#负载低利用率高" class="headerlink" title="负载低利用率高"></a>负载低利用率高</h1><p>这表示 CPU 的任务并不多，但是任务执行的时间很长，大概率就是你写的代码本身有问题，通常是计算密集型任务，生成了大量耗时短的计算任务。</p>
<ul>
<li>通过 top 找到 CPU 占用率高的进程</li>
<li>通过 top -Hp pid 命令查看 CPU 占比靠前的线程 ID</li>
<li>再把线程 ID 转化为 16 进制，printf “0x%x\n” 74317，得到 0x1224d</li>
<li>在比对程序中的线程 ID 找到有问题的部分</li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%85%B6%E4%BB%96-Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>嵌入式开发中常常需要确认开发板的系统版本，CPU，各种外部设备，内寸占用情况等数据。</p>
<h1 id="管理员口令丢失解决办法"><a href="#管理员口令丢失解决办法" class="headerlink" title="管理员口令丢失解决办法"></a>管理员口令丢失解决办法</h1><ul>
<li>开机从 LILO 或 GRUB 中选择进入单用户模式（运行级别 1）</li>
<li>使用 passwd 命令修改 root 口令</li>
<li>重新切换为运行级别 3 或 5</li>
</ul>
<p><code>sudo –s # 切换到 root 用户，但是不切换用户环境</code></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><code>uname -a #查看内核</code></p>
<p><code>head -n 1 /etc/issue #查看操作系统版本</code></p>
<p><code>cat /proc/cpuinfo #查看CPU信息</code></p>
<p><code>hostname #查看计算机名</code></p>
<p><code>lspci -tv #列出所有PCI设备</code></p>
<p><code>lsusb -tv #列出所有USB设备</code></p>
<p><code>lsmod #列出加载的内核模块</code></p>
<p><code>env #查看环境变量</code></p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p><code>free -m #查看内存使用量和交换区使用量</code></p>
<p><code>df -h #查看各分区使用情况</code></p>
<p><code>du -sh &lt;目录名&gt; #查看指定目录的大小</code></p>
<p><code>grep MemTotal /proc/meminfo #查看内存总量</code></p>
<p><code>grep MemFree /proc/meminfo #查看空闲内存量</code></p>
<p><code>uptime #查看系统运行时间、用户数、负载</code></p>
<p><code>cat /proc/loadavg #查看系统负载</code></p>
<h1 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h1><p><code>mount | column -t #查看挂接的分区状态</code></p>
<p><code>fdisk -l #查看所有分区</code></p>
<p><code>swapon -s #查看所有交换分区</code></p>
<p><code>hdparm -i /dev/hda #查看磁盘参数(仅适用于IDE设备)</code></p>
<p><code>dmesg | grep IDE #查看启动时IDE设备检测状况</code></p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p><code>ifconfig #查看所有网络接口的属性</code></p>
<p><code>iptables -L #查看防火墙设置</code></p>
<p><code>route -n #查看路由表</code></p>
<p><code>netstat -nltp #查看所有监听端口</code></p>
<p><code>netstat -antp #查看所有已经建立的连接</code></p>
<p><code>netstat -s #查看网络统计信息</code></p>
<p><code>tcpdump</code></p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><code>ps -aux # 显示瞬间行程 (process) 的动态</code></p>
<p><code>ps -ef #查看所有进程</code></p>
<p><code>top #实时显示进程状态</code></p>
<p><code>nice -n 1 ls # 将 ls 的优先序加 1 并执行</code></p>
<p><code>renice +1 987 -u daemon root -p 32 # 将行程 id 为 987 及 32 的行程与行程拥有者为 daemon 及 root 的优先序号码加 1</code></p>
<p><code>kill # 送出一个特定的信号 (signal) 给行程 id 为 pid 的行程根据该信号而做特定的动作, 若没有指定, 预设是送出终止 (TERM) 的信号 </code></p>
<p><code>killall proc</code></p>
<p><code>bg</code></p>
<p><code>fg</code></p>
<p><code>fg n</code></p>
<p><code>pstree # 将所有行程 (process) 以树状图显示</code></p>
<p><code>skill # 送个讯号给正在执行的程序,预设的讯息为 TERM (中断) </code></p>
<h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><p><code>w #查看活动用户</code></p>
<p><code>id &lt;用户名&gt; #查看指定用户信息</code></p>
<p><code>last #查看用户登录日志</code></p>
<p><code>cut -d: -f1 /etc/passwd #查看系统所有用户</code></p>
<p><code>cut -d: -f1 /etc/group #查看系统所有组</code></p>
<p><code>crontab -l #查看当前用户的计划任务</code></p>
<p><code>crontab 0 6-12/3 * 12 * /usr/bin/backup # 在 12 月内, 每天的早上 6 点到 12 点中,每隔 20 分钟执行一次 /usr/bin/backup</code></p>
<p><code>at 5pm + 3 days /bin/ls # 三天后的下午 5 点执行 /bin/ls:</code></p>
<p><code>login</code></p>
<p><code>passwd</code></p>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p><code>chkconfig --list #列出所有系统服务</code></p>
<p><code>chkconfig --list | grep on #列出所有启动的系统服务</code></p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><code>rpm -qa #查看所有安装的软件包</code></p>
<h1 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h1><p><code>ls -alrtFR filename </code></p>
<p><code>cut</code></p>
<p><code>pwd</code></p>
<p><code>mkdir/rmdir dir</code></p>
<p><code>rm -rf dir</code></p>
<p><code>cp -r dest source # 将目录下之档案亦皆依序拷贝至目的地</code></p>
<p><code>mv file1 file2</code></p>
<p><code>ln -s yy zz # 将档案 yy 产生一个 symbolic link:zz ,不加s为硬链接</code></p>
<p><code>touch filename #将档案的时候记录改为现在的时间。若档案不存在,系统会建立新的档案。</code></p>
<p><code>cat &gt; file</code></p>
<p><code>more -s testfile # 逐页显示 testfile 之档案内容,如有连续两行以上空白行则以一行空白行显示。 </code></p>
<p><code>more +20 testfile # 从第 20 行开始显示 testfile 之档案内容。</code></p>
<p><code>less filename # 浏览文字档案的内容</code></p>
<p><code>head file</code></p>
<p><code>tail file</code></p>
<p><code>tail -f file</code></p>
<p><code>cat # 把档案串连接后传到基本输出（萤幕或加 &gt; fileName 到另一个档案） </code></p>
<p><code>diff -u a.patch oldfile newfile # 可以完成比较功能，生成补丁文件</code></p>
<p><code>patch -i a.patch filname # 命令用于打补丁，补丁文件是使用diff产生的</code></p>
<p><code>split -b 1m filename filename.dump. # 将filename分割为1M大小，分割后的文件名为filename.dump.aa，filename.dump.ab...</code></p>
<p><code>tr #指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</code></p>
<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p><code>ssh user@host</code></p>
<p><code>ssh -p port user@host</code></p>
<p><code>ssh-copy-id user@host</code></p>
<h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><p><code>tar cf file.tar files</code></p>
<p><code>tar xf file.tar</code></p>
<p><code>tar czf file.tar.gz  files</code></p>
<p><code>tar xzf file.tar.gz </code></p>
<p><code>tar cjf file.tar.bz2</code></p>
<p><code>tar xjf file.tar.bz2</code></p>
<p><code>gzip file</code></p>
<p><code>gzip -d file.gz</code></p>
<p><code>compress -f source.dat # 将 source.dat 压缩成 source.dat.Z，解压-d</code></p>
<p><code>tar cjf - logs/ | split -b 1m - logs.tar.bz2 # 将目录logs打包压缩并分割成多个1M的文件，可以用下面的命令</code></p>
<p><code>cat logs.tar.bz2.a* | tar xj # 分包解压</code></p>
<h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p><code>chmod a+x filename # 对文件增加权限</code></p>
<p><code>chown -R dirname # 对目前目录下的所有档案与子目录进行相同的拥有者变更</code></p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p><code>grep pattern files</code></p>
<p><code>grep -r pattern dir</code></p>
<p><code>command | grep pattern</code></p>
<p><code>find path -name &quot;filename*&quot; # 在 path 路径下查找所有以 filename 开头的文件</code></p>
<p><code>locate chdrv # 寻找所有叫 chdrv 的档案</code></p>
<p><code>expr #字串长度/从位置处抓取字串/出现次数</code></p>
<h1 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h1><p><code>ping host</code></p>
<p><code>whois domain</code></p>
<p><code>dig domian</code></p>
<p><code>dig -x host</code></p>
<p><code>wget file</code></p>
<p><code>wget -c file</code></p>
<p><code>scp test.c root@192.168.7.1:/home/root	# SCP 拷贝数据</code></p>
<h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h1><p><code>date # 显示或设定系统的日期与时间</code></p>
<p><code>cal # 显示本月的月历</code></p>
<p><code>uptime # 显示开机时间等信息</code></p>
<p><code>who # 显示系统中有那些使用者正在上面</code></p>
<p><code>whoami</code></p>
<p><code>finger user</code></p>
<p><code>cat /proc/cpuinfo</code></p>
<p><code>cat /proc/meminfo</code></p>
<p><code>man command</code></p>
<p><code>free</code></p>
<p><code>file [filename]	# 可查看可执行文件是 ARM 架构还是 X86 架构</code></p>
<p><code>uname -a	# 显示电脑以及操作系统的相关信息</code></p>
<p><code>df	# 查看磁盘</code></p>
<p><code>mount	# 挂载</code></p>
<p><code>umount	# 卸载</code></p>
<p><code>sync	# 卸载之前同步数据</code></p>
<p><code>cat /sys/kernel/debug/usb/devices	# 查看 USB 类型</code></p>
<h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><p><strong>使用方式</strong>： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">time [options] COMMAND [arguments] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>time 指令的用途,在于等等。需要特别注意的是,部分资讯在 Linux 上显示不出来。这是因为在 Linux 上部分资源的分配函式与 time </p>
<p>指令所预设的方式并不相同,以致于 time 指令无法取得这些资料。 </p>
<ul>
<li>-o or –output&#x3D;FILE 设定结果输出档。这个选项会将 time 的输出写入 所指定的档案中。如果档案已经存在,系统将覆写其内容。 </li>
<li>-a or –append 配合 -o 使用,会将结果写到档案的末端,而不会覆盖掉原来的内容。 </li>
<li>-f FORMAT or –format&#x3D;FORMAT 以 FORMAT 字串设定显示方式。当这个选项没有被设定的时候,会用系统预设的格式。不过你可以用环境变数 time 来设定这个格式,如此一来就不必每次登入系统都要设定一次。</li>
</ul>
<p>一般设定上,你可以用 \t 表示跳栏,或者是用 \n 表示换行。</p>
<p>每一项资料要用 % 做为前导。如果要在字串中使用百分比符号,就用.（学过 C 语言的人大概会觉得很熟悉） </p>
<p>time 指令可以显示的资源有四大项,分别是： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time resources </span><br><span class="line">Memory resources </span><br><span class="line">IO resources </span><br><span class="line">Command info </span><br></pre></td></tr></table></figure>

<p>详细的内容如下： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time Resources </span><br><span class="line">E 执行指令所花费的时间,格式是：[hour]:minute:second。请注意这个数字并不代表实际的 CPU 时间。 </span><br><span class="line">e 执行指令所花费的时间,单位是秒。请注意这个数字并不代表实际的 CPU 时间。 </span><br><span class="line">S 指令执行时在核心模式（kernel mode）所花费的时间,单位是秒。 </span><br><span class="line">U 指令执行时在使用者模式（user mode）所花费的时间,单位是秒。 </span><br><span class="line">P 执行指令时 CPU 的占用比例。其实这个数字就是核心模式加上使用者模式的 CPU 时间除以总时间。 </span><br><span class="line"></span><br><span class="line">Memory Resources </span><br><span class="line">M 执行时所占用的实体记忆体的最大值。单位是 KB </span><br><span class="line">t 执行时所占用的实体记忆体的平均值,单位是 KB </span><br><span class="line">K 执行程序所占用的记忆体总量（stack+data+text）的平均大小,单位是 KB </span><br><span class="line">D 执行程序的自有资料区（unshared data area）的平均大小,单位是 KB </span><br><span class="line">p 执行程序的自有堆叠（unshared stack）的平均大小,单位是 KB </span><br><span class="line">X 执行程序间共享内容（shared text）的平均值,单位是 KB </span><br><span class="line">Z 系统记忆体页的大小,单位是 byte。对同一个系统来说这是个常数 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IO Resources </span><br><span class="line">F 此程序的主要记忆体页错误发生次数。所谓的主要记忆体页错误是指某一记忆体页已经置换到置换档（swap file)中,而且已经分配给其他程序。此时该页的内容必须从置换档里再读出来。 </span><br><span class="line">R 此程序的次要记忆体页错误发生次数。所谓的次要记忆体页错误是指某一记忆体页虽然已经置换到置换档中,但尚未分配给其他程序。此时该页的内容并未被破坏,不必从置换档里读出来 </span><br><span class="line">W 此程序被交换到置换档的次数 </span><br><span class="line">c 此程序被强迫中断（像是分配到的 CPU 时间耗尽）的次数 </span><br><span class="line">w 此程序自愿中断（像是在等待某一个 I/O 执行完毕,像是磁碟读取等等）的次数 </span><br><span class="line">I 此程序所输入的档案数 </span><br><span class="line">O 此程序所输出的档案数 </span><br><span class="line">r 此程序所收到的 Socket Message </span><br><span class="line">s 此程序所送出的 Socket Message </span><br><span class="line">k 此程序所收到的信号 ( Signal )数量 </span><br><span class="line"></span><br><span class="line">Command Info </span><br><span class="line">C 执行时的参数以及指令名称 </span><br><span class="line">x 指令的结束代码 ( Exit Status ) </span><br></pre></td></tr></table></figure>

<p>-p or –portability 这个选项会自动把显示格式设定成为： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">real %e </span><br><span class="line">user %U </span><br><span class="line">sys %S</span><br></pre></td></tr></table></figure>

<p>这么做的目的是为了与 POSIX 规格相容。 </p>
<p>-v or –verbose 这个选项会把所有程式中用到的资源通通列出来,不但如一般英文语句,还有说明。对不想花时间去熟习格式设定或是刚刚开始接触这个指令的人相当有用。 </p>
<p><strong>范例</strong>： </p>
<p>利用下面的指令 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">time -v ps -aux </span><br></pre></td></tr></table></figure>

<p>我们可以获得执行 ps -aux 的结果和所花费的系统资源。如下面所列的资料： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND </span><br><span class="line">root <span class="number">1</span> <span class="number">0.0</span> <span class="number">0.4</span> <span class="number">1096</span> <span class="number">472</span> ? S Apr19 <span class="number">0</span>:<span class="number">04</span> init </span><br><span class="line">root <span class="number">2</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0</span> <span class="number">0</span> ? SW Apr19 <span class="number">0</span>:<span class="number">00</span> [kflushd] </span><br><span class="line">root <span class="number">3</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0</span> <span class="number">0</span> ? SW Apr19 <span class="number">0</span>:<span class="number">00</span> [kpiod] </span><br><span class="line">...... </span><br><span class="line">root <span class="number">24269</span> <span class="number">0.0</span> <span class="number">1.0</span> <span class="number">2692</span> <span class="number">996</span> pts/<span class="number">3</span> R <span class="number">12</span>:<span class="number">16</span> <span class="number">0</span>:<span class="number">00</span> ps -aux </span><br><span class="line"></span><br><span class="line">Command being timed: <span class="string">&quot;ps -aux&quot;</span> </span><br><span class="line"><span class="function">User <span class="title">time</span> <span class="params">(seconds)</span>: <span class="number">0.05</span> </span></span><br><span class="line"><span class="function">System time (seconds): <span class="number">0.06</span> </span></span><br><span class="line"><span class="function">Percent of CPU this job got: <span class="number">68</span>% </span></span><br><span class="line"><span class="function">Elapsed (wall clock) time (h:mm:ss or m:ss): <span class="number">0</span>:<span class="number">00.16</span> </span></span><br><span class="line"><span class="function">Average shared text size (kbytes): <span class="number">0</span> </span></span><br><span class="line"><span class="function">Average unshared data size (kbytes): <span class="number">0</span> </span></span><br><span class="line"><span class="function">Average stack size (kbytes): <span class="number">0</span> </span></span><br><span class="line"><span class="function">Average total size (kbytes): <span class="number">0</span> </span></span><br><span class="line"><span class="function">Maximum resident set size (kbytes): <span class="number">0</span> </span></span><br><span class="line"><span class="function">Average resident set size (kbytes): <span class="number">0</span> </span></span><br><span class="line"><span class="function">Major (requiring I/O) page faults: <span class="number">238</span> </span></span><br><span class="line"><span class="function">Minor (reclaiming a frame) page faults: <span class="number">46</span> </span></span><br><span class="line"><span class="function">Voluntary context switches: <span class="number">0</span> </span></span><br><span class="line"><span class="function">Involuntary context switches: <span class="number">0</span> </span></span><br><span class="line"><span class="function">Swaps: <span class="number">0</span> </span></span><br><span class="line"><span class="function">File system inputs: <span class="number">0</span> </span></span><br><span class="line"><span class="function">File system outputs: <span class="number">0</span> </span></span><br><span class="line"><span class="function">Socket messages sent: <span class="number">0</span> </span></span><br><span class="line"><span class="function">Socket messages received: <span class="number">0</span> </span></span><br><span class="line"><span class="function">Signals delivered: <span class="number">0</span> </span></span><br><span class="line"><span class="function">Page size (bytes): <span class="number">4096</span> </span></span><br><span class="line"><span class="function">Exit status: <span class="number">0</span> </span></span><br></pre></td></tr></table></figure>

<h1 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h1><p><strong>使用方式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mail [-iInv] [-s subject] [-c cc-addr] [-b bcc-addr] user1 [user <span class="number">2</span> ...] </span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong>：</p>
<p>mail 不仅只是一个指令, mail 还是一个电子邮件程式,不过利用 mail 来读信的人应该很少吧！对于系统管理者来说 mail 就很有用,因为管理者可以用 mail 写成 script ,定期寄一些备忘录提醒系统的使用者。 </p>
<ul>
<li>i 忽略 tty 的中断讯号。 (interrupt) </li>
<li>I 强迫设成互动模式。 (Interactive) </li>
<li>v 列印出讯息,例如送信的地点,状态等等。 (verbose) </li>
<li>n 不读入 mail.rc 设定档。 </li>
<li>s 邮件标题。 </li>
<li>c cc 邮件地址。 </li>
<li>b bcc 邮件地址。</li>
</ul>
<p><strong>范例</strong>： </p>
<p>将信件送给一个或以上的电子邮件地址,由于没有加入其他的选项,使用者必须输入标题与信件的内容等。而 user2 没有主机位置,就会送给邮件伺服器的 user2 使用者。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mail user1@email.address </span><br><span class="line">mail user1@email.address user2 </span><br></pre></td></tr></table></figure>

<p>将 mail.txt 的内容寄给 user2 同时 cc 给 user1 。如果将这一行指令设成 cronjob 就可以定时将备忘录寄给系统使用者。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mail -s 标题 -c user1 user2 &lt; mail.txt </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>时间编程</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%85%B6%E4%BB%96-%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h1><p><strong>Coordinated Unicersal Time（UTC）</strong>：世界标准时间，也就是大家所熟知的格林威治标准时间（Greenwich Mean Time 吗 GMT）</p>
<p><strong>Calendar Time</strong>：日历时间，是用“从一个标准时间点（如：1970 年 1 月 1 日 0 点）到此时经过的秒数”来表示时间</p>
<h1 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h1><p><strong>获取日历时间，即从 1970 年 1 月 1 日 0 点到现在所经历的秒数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">time</span><span class="params">(<span class="type">time_t</span>*tloc)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>将日历时间转化为格林威治标准时间，并保存至 TM 结构</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *<span class="built_in">gmtime</span>(<span class="type">const</span> <span class="type">time_t</span>*timep);</span><br></pre></td></tr></table></figure>

<p><strong>将日历时间转化为本地时间，并保存至 TM 结构</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *<span class="built_in">localtime</span>(<span class="type">const</span> <span class="type">time_t</span>*timep);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line"><span class="type">int</span> tm_sec; <span class="comment">/* Seconds(0-60) */</span></span><br><span class="line"><span class="type">int</span> tm_min; <span class="comment">/* Minutes(0-59) */</span></span><br><span class="line"><span class="type">int</span> tm_hour; <span class="comment">/* Hours(0-23) */</span></span><br><span class="line"><span class="type">int</span> tm_mday; <span class="comment">/* Day of the month (1-31) */</span></span><br><span class="line"><span class="type">int</span> tm_mon; <span class="comment">/* Month (0-11) */</span></span><br><span class="line"><span class="type">int</span> tm_year; <span class="comment">/* Year - 1900 */</span></span><br><span class="line"><span class="type">int</span> tm_wday; <span class="comment">/* Day of the week (0-6, Sunday = 0) */</span></span><br><span class="line"><span class="type">int</span> tm_yday; <span class="comment">/* Dayin the year (0-365, 1 Jan = 0) */</span></span><br><span class="line"><span class="type">int</span> tm_isdst; <span class="comment">/* Daylightsaving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>将 tm 格式的时间转化为字符串，如：Sat Jul 30 08：43：03：2005</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>*<span class="title">asctime</span><span class="params">(conststruct tm *tm)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>将日历时间转化为本地时间的字符串形式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>*<span class="title">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span>*timep)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>获取从今日凌晨到现在的时间差，常用于计算事件耗时</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv,<span class="keyword">struct</span> timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line"><span class="type">time_t</span> tv_sec; <span class="comment">/*seconds*/</span> 秒数</span><br><span class="line"><span class="type">suseconds_t</span> tv_usec; <span class="comment">/* microseconds*/</span> 微秒</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h1><p><strong>使程序睡眠 seconds</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">intsleep</span><span class="params">(<span class="type">unsigned</span> intseconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>使程序睡眠 usec 微秒</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">usleep</span><span class="params">(<span class="type">useconds_t</span> usec)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>机器大小端校验</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%85%B6%E4%BB%96-%E6%9C%BA%E5%99%A8%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="大小端字节序"><a href="#大小端字节序" class="headerlink" title="大小端字节序"></a>大小端字节序</h1><p>大端字节序（Big-Endian）和小端字节序（Little-Endian）是两种不同的字节存储顺序方式，用于在多字节数据类型（如整数、浮点数）在内存中的表示。</p>
<p>在大端字节序中，较高字节（最高有效字节）保存在较低的存储地址，而较低字节（最低有效字节）保存在较高的存储地址。</p>
<p>换句话说，数据的高位字节存储在低地址位置，低位字节存储在高地址位置。</p>
<p>例如，整数值 0x12345678 在大端字节序中的存储顺序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">地址： <span class="number">0x1000</span>   <span class="number">0x1001</span>   <span class="number">0x1002</span>   <span class="number">0x1003</span></span><br><span class="line">数据：  <span class="number">0x12</span>     <span class="number">0x34</span>     <span class="number">0x56</span>     <span class="number">0x78</span></span><br></pre></td></tr></table></figure>

<p>相比之下，在小端字节序中，较低字节保存在较低的存储地址，而较高字节保存在较高的存储地址。数据的低位字节存储在低地址位置，高位字节存储在高地址位置。</p>
<p>使用同样的示例值 0x12345678，小端字节序的存储顺序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">地址： <span class="number">0x1000</span>   <span class="number">0x1001</span>   <span class="number">0x1002</span>   <span class="number">0x1003</span></span><br><span class="line">数据：  <span class="number">0x78</span>     <span class="number">0x56</span>     <span class="number">0x34</span>     <span class="number">0x12</span></span><br></pre></td></tr></table></figure>

<h1 id="64-位和-32-位的不同"><a href="#64-位和-32-位的不同" class="headerlink" title="64 位和 32 位的不同"></a>64 位和 32 位的不同</h1><p>64 位和 32 位的大小端情况是类似的，但存在一些细微差异。</p>
<p>在 64 位系统中，数据被划分为 8 字节（64 位），而在 32 位系统中，数据被划分为 4 字节（32 位）。因此，字节的顺序和对齐方式在这两种情况下可能会有所不同。</p>
<p>例如，考虑一个 64 位整数值 0x1122334455667788。</p>
<p>在大端字节序中，存储顺序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">地址： <span class="number">0x1000</span>   <span class="number">0x1001</span>   <span class="number">0x1002</span>   <span class="number">0x1003</span>   <span class="number">0x1004</span>   <span class="number">0x1005</span>   <span class="number">0x1006</span>   <span class="number">0x1007</span></span><br><span class="line">数据：  <span class="number">0x11</span>     <span class="number">0x22</span>     <span class="number">0x33</span>     <span class="number">0x44</span>     <span class="number">0x55</span>     <span class="number">0x66</span>     <span class="number">0x77</span>     <span class="number">0x88</span></span><br></pre></td></tr></table></figure>

<p>而在小端字节序中，存储顺序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">地址： <span class="number">0x1000</span>   <span class="number">0x1001</span>   <span class="number">0x1002</span>   <span class="number">0x1003</span>   <span class="number">0x1004</span>   <span class="number">0x1005</span>   <span class="number">0x1006</span>   <span class="number">0x1007</span></span><br><span class="line">数据：  <span class="number">0x88</span>     <span class="number">0x77</span>     <span class="number">0x66</span>     <span class="number">0x55</span>     <span class="number">0x44</span>     <span class="number">0x33</span>     <span class="number">0x22</span>     <span class="number">0x11</span></span><br></pre></td></tr></table></figure>

<p>尽管在 64 位和 32 位系统上字节顺序的原理相同，但具体的存储布局和访问方式可能有所不同。因此，在跨平台开发或数据交换中，需要注意字节序的差异，并采取适当的转换方法以确保数据的正确解释和传输。</p>
<h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>字节序的选择对于不同的计算机体系结构和通信协议至关重要。它主要影响以下方面：</p>
<p>数据传输：在网络通信和数据交换中，如果通信双方使用不同的字节序，就需要进行字节序的转换，以确保正确解释和传输数据。</p>
<p>文件格式：某些文件格式（如图像、音频、视频）可能使用特定的字节序来存储数据，因此读取和解析这些文件时需要考虑字节序。</p>
<p>处理器架构：不同的处理器架构可能采用不同的字节序。例如，x86 架构使用小端字节序，而 PowerPC 架构使用大端字节序。在开发软件时，需要根据目标处理器架构的字节序选择适当的数据处理方式。</p>
<p>正确地处理字节序是确保跨平台兼容性和数据一致性的重要方面，特别是在网络通信和数据交换的情况下。</p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>整数值 0x12345678 在 64 位和 32 位系统上，以大端字节序和小端字节序存储的示例：</p>
<p>64 位系统大端字节序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">地址： <span class="number">0x1000</span>   <span class="number">0x1001</span>   <span class="number">0x1002</span>   <span class="number">0x1003</span>   <span class="number">0x1004</span>   <span class="number">0x1005</span>   <span class="number">0x1006</span>   <span class="number">0x1007</span></span><br><span class="line">数据：  <span class="number">0x12</span>     <span class="number">0x34</span>     <span class="number">0x56</span>     <span class="number">0x78</span>     <span class="number">0x00</span>     <span class="number">0x00</span>     <span class="number">0x00</span>     <span class="number">0x00</span></span><br></pre></td></tr></table></figure>

<p>64 位系统小端字节序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">地址： <span class="number">0x1000</span>   <span class="number">0x1001</span>   <span class="number">0x1002</span>   <span class="number">0x1003</span>   <span class="number">0x1004</span>   <span class="number">0x1005</span>   <span class="number">0x1006</span>   <span class="number">0x1007</span></span><br><span class="line">数据：  <span class="number">0x00</span>     <span class="number">0x00</span>     <span class="number">0x00</span>     <span class="number">0x00</span>     <span class="number">0x78</span>     <span class="number">0x56</span>     <span class="number">0x34</span>     <span class="number">0x12</span></span><br></pre></td></tr></table></figure>

<p>32 位系统大端字节序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">地址： <span class="number">0x1000</span>   <span class="number">0x1001</span>   <span class="number">0x1002</span>   <span class="number">0x1003</span></span><br><span class="line">数据：  <span class="number">0x12</span>     <span class="number">0x34</span>     <span class="number">0x56</span>     <span class="number">0x78</span></span><br></pre></td></tr></table></figure>

<p>32 位系统小端字节序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">地址： <span class="number">0x1000</span>   <span class="number">0x1001</span>   <span class="number">0x1002</span>   <span class="number">0x1003</span></span><br><span class="line">数据：  <span class="number">0x78</span>     <span class="number">0x56</span>     <span class="number">0x34</span>     <span class="number">0x12</span></span><br></pre></td></tr></table></figure>

<h1 id="校验方法"><a href="#校验方法" class="headerlink" title="校验方法"></a>校验方法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0x01020304</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *ptr = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*ptr == <span class="number">0x01</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">short</span> <span class="type">int</span> x;</span><br><span class="line">	<span class="type">char</span> x1,x2;</span><br><span class="line">	x= <span class="number">0x1122</span>;</span><br><span class="line">	</span><br><span class="line">	x1=((<span class="type">char</span> *)&amp;x)[<span class="number">0</span>];<span class="comment">//低地址</span></span><br><span class="line">	x2=((<span class="type">char</span> *)&amp;x)[<span class="number">1</span>];<span class="comment">//高地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x1=%x\n&quot;</span>,x1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x2=%x\n&quot;</span>,x2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">checkCPU</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">w</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		<span class="type">char</span> b;</span><br><span class="line">	&#125;c;</span><br><span class="line">	c.a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>(c.b==<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>终端</title>
    <url>/2024/05/17/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%85%B6%E4%BB%96-%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p>一个基于文本的交互界面</p>
<blockquote>
<p><strong>快捷键</strong></p>
<p>打开命令行终端 <code>Ctrl+Alt+t</code></p>
<p>放大终端 <code>Ctrl Shirft +</code></p>
<p>缩小终端 <code>Ctrl -</code></p>
</blockquote>
<p><strong>终端提示符含义</strong><br><code>lemonade@ubuntu:~$</code> 对应<br>用户名 (lemonade)@主机名 (ubuntu): 工作目录 (~) 提示符 ($)</p>
<blockquote>
<p>~：家目录</p>
</blockquote>
<blockquote>
<p>$: 普通用户<br>#: 超级用户 (root)</p>
</blockquote>
<p><strong>命令</strong>— 在终端中用于告诉计算机去执行一个动作</p>
<p><strong>参数</strong>—</p>
<p><strong>选项</strong>— 选项通常用一个连接号（<code>-</code>）或两个连接号（<code>--</code>）来划分</p>
<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><ul>
<li><code>ls</code>: 列出当前目录内容</li>
<li><code>cd ~</code>: 进入当前用户的家目录</li>
<li><code>./</code> 当前目录 (可省略)</li>
<li><code>../</code> 上一层目录</li>
<li><code>../../ </code> 上一层的上一层</li>
</ul>
<p><strong>文件操作指令</strong></p>
<ul>
<li><code>mkdir</code> 创建文件夹 <code>mkdir  mydir</code></li>
<li><code>touch</code> 创建空文件 <code>touch myfile</code></li>
<li><code>rmdir</code> 删除一个空文件夹</li>
<li><code>rm</code> 删除一个文件或文件夹,默认删除文件</li>
<li><code>rm -r</code> 	删除文件夹</li>
</ul>
<p><strong>打印定向指令</strong></p>
<ul>
<li><code>echo</code> 打印一串字符 <code>echo  hello world</code></li>
<li>&gt; 输出重定向&#x2F;指定输出的目标文件</li>
<li>&gt;&gt; 向指定文件中追加内容</li>
<li><code>cat</code> 读文件内容并打印 <code>cat readme</code></li>
</ul>
<p><strong>root&amp;sudo</strong></p>
<ul>
<li><code>sudo passwd</code> 通过普通用户修改超级用户 (root) 的密码.</li>
<li><code>su  root</code> 切换用户为 root 用户 (超级用户)</li>
<li><code>su  lemonade</code> 切换为 lemonade 用户.</li>
<li><code>sudo</code> 用普通用户权限执行 root 的功能</li>
</ul>
<blockquote>
<p>普通用户权限执行 root 的功能需注意用户环境下的环境变量和 root 用户环境的下环境变量是否一致</p>
</blockquote>
<p><strong>移动拷贝指令</strong></p>
<ul>
<li><code>mv</code> 移动命令 <code>mv   source  dest``mv   source  dir</code></li>
<li><code>cp</code> 拷贝命令</li>
</ul>
<p><strong>man 用户帮助手册</strong></p>
<p><code>man ls </code></p>
<blockquote>
<p><code>ls  [options]...    [file]... </code></p>
<p><code>options</code> 选项或参数</p>
<p><code>file</code> 目标文件或文件夹</p>
<p><code>[]</code> 可选标志</p>
<p><code>...</code> 多参机制</p>
</blockquote>
<p><strong>改变权值的命令</strong></p>
<ul>
<li><code>chmod  777 readme.sh </code> 所有用户可读可写可执行</li>
</ul>
<blockquote>
<p>文件类型:</p>
<p>- ：普通文件<br>d : 文件夹&#x2F;目录<br>l : 链接 (快捷方式)<br>s : 网络套接字<br>p: 管道<br>b : 块设备, 磁盘 c : 字符设备, 键盘</p>
</blockquote>
<p><strong>关机</strong></p>
<ul>
<li><code>halt</code> 关机</li>
<li><code>reboot</code> 重启</li>
<li><code>sudo shutdown  -h  now</code> 加上关机时间</li>
<li><code>sudo shutdown  -h  +1 &quot;See You la la&quot;</code> 加上关机备注</li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>自启动</title>
    <url>/2024/05/21/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%85%B6%E4%BB%96-%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="设置脚本"><a href="#设置脚本" class="headerlink" title="设置脚本"></a>设置脚本</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.local</span><br><span class="line"></span><br><span class="line"># 添加内容</span><br><span class="line">/usr/bin/nginx start</span><br><span class="line"></span><br><span class="line">chmod +x /etc/rc.d/rc.local</span><br><span class="line"># /etc/rc.d/rc.local是/etc/rc.local的软连接</span><br></pre></td></tr></table></figure>

<h1 id="自启动服务"><a href="#自启动服务" class="headerlink" title="自启动服务"></a>自启动服务</h1><p>在 <code>/etc/systemd/system/my_startup.service</code> 或 <code>/usr/lib/systemd/system/startmyapp.service</code> 编辑或创建一个服务文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=API Server for Klipper SV1</span><br><span class="line"><span class="attr">Documentation</span>=https://moonraker.readthedocs.io/</span><br><span class="line"><span class="attr">Requires</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">User</span>=forlinx</span><br><span class="line"><span class="attr">SupplementaryGroups</span>=moonraker-admin</span><br><span class="line"><span class="attr">RemainAfterExit</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">WorkingDirectory</span>=/home/forlinx/moonraker</span><br><span class="line"><span class="attr">EnvironmentFile</span>=/home/forlinx/printer_data/systemd/moonraker.env</span><br><span class="line"><span class="attr">ExecStart</span>=/home/forlinx/moonraker-env/bin/python <span class="variable">$MOONRAKER_ARGS</span></span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加载服务到自启动中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> my_startup</span><br></pre></td></tr></table></figure>

<p><strong>操作服务</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 设置开机自启动</span><br><span class="line">systemctl enable startmyapp.service</span><br><span class="line"># 停止开机自启动</span><br><span class="line">systemctl disable startmyapp.service</span><br><span class="line"># 启动服务</span><br><span class="line">systemctl start startmyapp.service</span><br><span class="line"># 关闭服务</span><br><span class="line">systemctl stop startmyapp.service</span><br><span class="line"># 重新启动服务</span><br><span class="line">systemctl restart startmyapp.service</span><br><span class="line"># 重新加载服务配置文件</span><br><span class="line">systemctl reload startmyapp.service</span><br><span class="line"># 查看服务当前状态</span><br><span class="line">systemctl status startmyapp.service</span><br><span class="line"># 查看所有已启动的服务</span><br><span class="line">systemctl list-units --type=services</span><br><span class="line"># 查询服务是否开机启动</span><br><span class="line">systemctl is-enabled startmyapp.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h2><p><code>journalctl</code> 是 <code>Systemd</code> 日志收集服务 <code>journal</code> 的一个命令行界面。它允许用户查询和操作 <code>systemd journal</code> 中的日志条目。这对于诊断系统服务问题、追踪错误或者监控系统事件非常有用。下面是几个使用 <code>journalctl</code> 的基本命令示例：</p>
<p>查看所有日志，这个命令会显示系统中所有服务的日志。</p>
<p><code>journalctl</code></p>
<p>查看特定服务的日志，将&lt;服务名&gt;替换为你想查看服务的日志名称，例如查看 nginx 服务日志：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">journalctl -u &lt;服务名&gt;.service</span><br><span class="line">journalctl -u nginx.service</span><br></pre></td></tr></table></figure>

<p>实时查看日志，这个命令会像 tail -f 一样实时显示新的日志条目。</p>
<p><code>journalctl -f</code></p>
<p>查看特定时间范围内的日志，这个例子会显示从 2023 年 4 月 1 日 0 点到 23 点 59 分 59 秒之间的日志。</p>
<p><code>journalctl --since &quot;2023-04-01 00:00:00&quot; --until &quot;2023-04-01 23:59:59&quot;</code></p>
<p>查看包含特定关键词的日志，使用 grep 结合 journalctl 来过滤特定关键词，例如查找包含”error”的日志，或者直接使用 journalctl 的 grep 参数（-g 或–grep）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">journalctl | grep error</span><br><span class="line"></span><br><span class="line">journalctl -u &lt;服务名&gt;.service --grep <span class="string">&quot;关键字&quot;</span></span><br></pre></td></tr></table></figure>

<p>清空日志，这个命令会删除所有超过 1 天的日志条目。请注意，这将永久删除日志数据。</p>
<p><code>journalctl --vacuum-time=1d</code></p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>进程脱离终端后台运行</title>
    <url>/2024/07/12/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%85%B6%E4%BB%96-%E8%BF%9B%E7%A8%8B%E8%84%B1%E7%A6%BB%E7%BB%88%E7%AB%AF%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p>运行一个连接到控制终端的进程，作为用户你将会在你的终端上看到这个进程数据的许多行的输出，也包含错误信息。同样，当你关闭一个控制终端，你的进程和子进程都将会终止。为了解决上面两个问题，你需要从一个控制终端完全脱离一个进程。</p>
<h1 id="如何在后台运行一个进程"><a href="#如何在后台运行一个进程" class="headerlink" title="如何在后台运行一个进程"></a>如何在后台运行一个进程</h1><p>如果一个进程已经运行，按下 Ctrl+Z 就可以暂停它，然后输入命令 bg 就可以继续以一个任务在后台运行了。但是，标准输入（STDIN）、标准输出（STDOUT）和标准错误（STDERR）依旧掺杂到控制台中。你可以通过输入 jobs 查看所有的后台任务。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ tar -czf home.tar.gz .</span><br><span class="line">$ bg</span><br><span class="line">$ jobs</span><br></pre></td></tr></table></figure>

<p>也可以直接使用符号 &amp; 在后台运行一个进程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ tar-czf home.tar.gz . &amp;</span><br><span class="line">$ jobs</span><br></pre></td></tr></table></figure>

<p>虽然是作为一个后台任务开始的，但是错误信息依旧发送到终端，这表示，进程依旧和控制终端关联在一起。</p>
<h1 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h1><p>我们将使用 disown 命令，它在一个进程已经运行并且被放在后台之后使用，它的作用是从 shell 的活动任务列表中移走一个 shell 任务，因此，对于该任务，你将再也不能使用 fg 、 bg 命令了。而且，当你关闭控制控制终端，这个任务将不会挂起（暂停）或者向任何一个子任务发送 SIGHUP 信号。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo rsync Templates/* /var/www/html/files/ &amp;</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">$ <span class="built_in">disown</span> -h %1</span><br><span class="line">$ <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>

<h1 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h1><p>你也可以使用 nohup 命令，这个命令也可以在用户退出 shell 之后保证进程在后台继续运行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> tar -czf iso.tar.gz Templates/* &amp;</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>

<h1 id="dev-null"><a href="#dev-null" class="headerlink" title="&#x2F;dev&#x2F;null"></a>&#x2F;dev&#x2F;null</h1><p>对于图形用户界面 (GUI) 的程序例如 firefox 来说，使用下面的命令行格式会更有效：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ firefox /dev/null &amp;</span><br></pre></td></tr></table></figure>

<p>在 Linux 上，&#x2F;dev&#x2F;null 是一个特殊的文件设备，它会忽略所有的写在它上面的数据，上述命令，输入来源和输出发送目标都是 &#x2F;dev&#x2F;null。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>内核模块</title>
    <url>/2024/07/22/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>内核模块是一段可以动态加载到内核中的代码，这使得开发人员可以扩展内核的功能而无需重启系统或重编译整个内核。</p>
<h1 id="内核模块的编译"><a href="#内核模块的编译" class="headerlink" title="内核模块的编译"></a>内核模块的编译</h1><h2 id="编写内核模块代码"><a href="#编写内核模块代码" class="headerlink" title="编写内核模块代码"></a>编写内核模块代码</h2><p>一个简单的内核模块通常包括初始化和清理函数。以下是一个基本的“Hello, World”内核模块示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_AUTHOR</span>(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_DESCRIPTION</span>(<span class="string">&quot;A Simple Hello World Module&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Goodbye, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure>

<h2 id="创建-Makefile"><a href="#创建-Makefile" class="headerlink" title="创建 Makefile"></a>创建 Makefile</h2><p>要编译内核模块，需要一个 Makefile。以下是一个简单的 Makefile 示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span><br></pre></td></tr></table></figure>

<ul>
<li>obj-m：定义需要编译的模块对象文件。</li>
<li>-C &#x2F;lib&#x2F;modules&#x2F;$(shell uname -r)&#x2F;build：指定内核源代码树的路径。</li>
<li>M&#x3D;$(PWD)：指定当前目录。</li>
</ul>
<h2 id="编译模块"><a href="#编译模块" class="headerlink" title="编译模块"></a>编译模块</h2><p>在模块源代码所在目录中运行以下命令进行编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>这个命令会在当前目录下生成一个 .ko 文件，这是编译后的内核模块。</p>
<h1 id="内核模块的安装"><a href="#内核模块的安装" class="headerlink" title="内核模块的安装"></a>内核模块的安装</h1><h2 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h2><p>编译完成后，可以使用 insmod 命令将模块加载到内核中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo insmod hello.ko</span><br></pre></td></tr></table></figure>

<ul>
<li>insmod：加载指定的内核模块。</li>
<li>hello.ko：编译生成的内核模块文件。</li>
</ul>
<h2 id="验证模块是否加载"><a href="#验证模块是否加载" class="headerlink" title="验证模块是否加载"></a>验证模块是否加载</h2><p>可以通过 lsmod 命令检查模块是否已成功加载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lsmod | grep hello</span><br></pre></td></tr></table></figure>

<p>也可以通过 dmesg 查看内核日志，检查模块的输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dmesg | tail</span><br></pre></td></tr></table></figure>

<h2 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h2><p>如果需要卸载模块，可以使用 rmmod 命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo rmmod hello</span><br></pre></td></tr></table></figure>

<h1 id="内核模块的调试"><a href="#内核模块的调试" class="headerlink" title="内核模块的调试"></a>内核模块的调试</h1><h2 id="使用-printk-调试"><a href="#使用-printk-调试" class="headerlink" title="使用 printk 调试"></a>使用 printk 调试</h2><p>在开发内核模块时，最常用的调试方法是使用 printk 函数输出调试信息。这些信息会被记录在内核日志中，可以通过 dmesg 查看。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;This is a debug message with value: %d\n&quot;</span>, value);</span><br></pre></td></tr></table></figure>

<ul>
<li>KERN_INFO 是一个日志级别，表示信息性消息。还有其他日志级别，如 KERN_DEBUG、KERN_ERR 等。</li>
<li>使用 dmesg 命令可以查看内核输出的调试信息。</li>
</ul>
<h2 id="使用调试器"><a href="#使用调试器" class="headerlink" title="使用调试器"></a>使用调试器</h2><p>使用调试器（如 gdb）调试内核模块是可能的，但需要一些额外的设置。典型的步骤包括：</p>
<ul>
<li>启动一个虚拟机或使用内核调试器（KGDB）来远程调试运行中的内核。</li>
<li>在内核配置中启用 CONFIG_DEBUG_INFO 以生成调试符号。</li>
<li>使用 gdb 连接到内核，加载符号文件，然后进行调试。</li>
</ul>
<h2 id="使用内核日志和跟踪工具"><a href="#使用内核日志和跟踪工具" class="headerlink" title="使用内核日志和跟踪工具"></a>使用内核日志和跟踪工具</h2><p>除了 printk，还可以使用以下工具进行调试：</p>
<ul>
<li>ftrace：Linux 内核的内建跟踪工具，用于跟踪函数调用和性能分析。</li>
<li>perf：强大的性能监视和分析工具，适用于分析内核模块的性能问题。</li>
<li>Kprobes&#x2F;eBPF：用于动态插入调试探针，以监视内核行为。</li>
</ul>
<h1 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h1><h2 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h2><p>确保<strong>内核头文件与运行的内核版本</strong>匹配。</p>
<p>检查 Makefile 中的路径是否正确，尤其是内核源代码目录。</p>
<h2 id="模块加载失败"><a href="#模块加载失败" class="headerlink" title="模块加载失败"></a>模块加载失败</h2><p>检查 dmesg 输出是否有错误信息。</p>
<p>确保模块使用的符号在内核中可用。</p>
<p>检查模块的许可证是否与内核兼容（如 GPL）。</p>
<h2 id="调试信息不足"><a href="#调试信息不足" class="headerlink" title="调试信息不足"></a>调试信息不足</h2><p>使用更高的 printk 日志级别（如 KERN_DEBUG）来捕获更多详细信息。</p>
<p>使用 dmesg -n 调整 printk 的日志级别过滤器。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>内核</category>
      </categories>
  </entry>
  <entry>
    <title>内核补丁</title>
    <url>/2024/08/24/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E8%A1%A5%E4%B8%81/</url>
    <content><![CDATA[<p>内核补丁（.patch 文件）是用于对 Linux 内核源代码进行修改的文件。补丁通常用于修复漏洞、引入新功能、优化性能或修正错误。</p>
<h1 id="什么是内核补丁"><a href="#什么是内核补丁" class="headerlink" title="什么是内核补丁"></a>什么是内核补丁</h1><p>内核补丁是一个包含源代码更改的文本文件，通常由 diff 或 git diff 生成。它描述了如何从当前版本的源代码生成一个新版本，包括添加、删除或修改的代码行。</p>
<p>补丁文件通常包含以下部分：</p>
<ul>
<li>文件头：指示补丁适用于哪个文件。</li>
<li>上下文信息：显示修改的代码周围的几行代码，以帮助理解更改的位置。</li>
<li>更改信息：实际的代码差异，标记为添加（+）、删除（-）或修改。</li>
</ul>
<h1 id="内核补丁的作用"><a href="#内核补丁的作用" class="headerlink" title="内核补丁的作用"></a>内核补丁的作用</h1><ol>
<li>修复漏洞和错误<br> 内核是操作系统的核心部分，任何漏洞或错误可能都会导致系统不稳定或受到攻击。通过应用补丁，开发人员可以修复这些问题，而不需要等待完整的新内核版本发布。</li>
<li>添加新功能<br> Linux 内核是一个快速发展的项目，新的硬件支持、新的文件系统、新的安全功能等，都是通过补丁引入的。开发人员通过提交补丁来贡献新功能，其他开发者可以在自己的内核中应用这些补丁进行测试和使用。</li>
<li>性能优化<br> 补丁还可以用于性能优化，尤其是在高性能计算或嵌入式系统中。开发人员可以通过调整内核代码，优化资源使用和响应时间，从而提高系统整体性能。</li>
<li>自定义内核<br> 有些用户和开发人员需要定制内核以满足特定需求，如在特定硬件上运行、启用特定功能或优化某些工作负载。通过应用特定的补丁，内核可以被调整和定制。</li>
</ol>
<h1 id="如何使用内核补丁"><a href="#如何使用内核补丁" class="headerlink" title="如何使用内核补丁"></a>如何使用内核补丁</h1><p>以下我们使用一个 linux4.19 的内核在 ubuntu24 中编译时出现报错的示例来说明如何使用一个内核补丁。</p>
<ol>
<li>编译内核源码，在编译内核源码时出现以下错误：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> In file included from /usr/include/signal.h:<span class="number">328</span>,</span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> from ./signal.h:<span class="number">52</span>,</span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> from c-stack.c:<span class="number">49</span>:</span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> c-stack.c:<span class="number">55</span>:<span class="number">26</span>: error: missing binary <span class="keyword">operator</span> before token <span class="string">&quot;(&quot;</span></span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> <span class="number">55</span> | <span class="meta">#<span class="keyword">elif</span> HAVE_LIBSIGSEGV &amp;&amp; SIGSTKSZ &lt; 16384</span></span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> |                          ^~~~~~~~</span><br><span class="line">......</span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> make[<span class="number">4</span>]: *** [Makefile:<span class="number">1674</span>: all] Error <span class="number">2</span></span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> make[<span class="number">3</span>]: *** [Makefile:<span class="number">1572</span>: all-recursive] Error <span class="number">1</span></span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> make[<span class="number">2</span>]: *** [Makefile:<span class="number">1528</span>: all] Error <span class="number">2</span></span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> make[<span class="number">1</span>]: *** [package/pkg-generic.mk:<span class="number">231</span>: /mnt/c/Users/Administrator/Desktop/<span class="number">12.</span>GitHub/CodeWork/<span class="number">00.</span>HoldDev/OK3568-linux-source/buildroot/output/OK3568/build/host-m4<span class="number">-1.4</span><span class="number">.18</span>/.stamp_built] Error <span class="number">2</span></span><br><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-24</span>T13:<span class="number">51</span>:<span class="number">26</span> make: *** [/mnt/c/Users/Administrator/Desktop/<span class="number">12.</span>GitHub/CodeWork/<span class="number">00.</span>HoldDev/OK3568-linux-source/buildroot/output/OK3568/Makefile:<span class="number">16</span>: _all] Error <span class="number">2</span></span><br><span class="line">Command exited with non-zero status <span class="number">1</span></span><br><span class="line">you take <span class="number">7</span>:<span class="number">43.42</span> to build builroot</span><br><span class="line">ERROR: Running build_buildroot failed!</span><br><span class="line">ERROR: exit code <span class="number">1</span> from line <span class="number">565</span>:</span><br><span class="line">    /usr/bin/time -f <span class="string">&quot;you take %E to build builroot&quot;</span> $COMMON_DIR/mk-buildroot.sh $BOARD_CONFIG</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>下载我们需要的补丁文件</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd OK3568-linux-source</span><br><span class="line">wget https:<span class="comment">//toolchains.bootlin.com/downloads/releases/sources/m4-1.4.18/0003-c-stack-stop-using-SIGSTKSZ.patch</span></span><br></pre></td></tr></table></figure>

<p>具体补丁文件内容如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c-stack: stop <span class="keyword">using</span> SIGSTKSZ</span><br><span class="line"></span><br><span class="line">It’s been proposed to stop making SIGSTKSZ an integer constant:</span><br><span class="line">https:<span class="comment">//sourceware.org/pipermail/libc-alpha/2020-September/118028.html</span></span><br><span class="line">Also, <span class="keyword">using</span> SIGSTKSZ in <span class="meta">#<span class="keyword">if</span> did not conform to current POSIX.</span></span><br><span class="line">Also, avoiding SIGSTKSZ makes the code simpler <span class="keyword">and</span> easier to grok.</span><br><span class="line">* lib/c-stack.<span class="built_in">c</span> (SIGSTKSZ): Remove.</span><br><span class="line">(alternate_signal_stack): Now a <span class="number">64</span> KiB array, <span class="keyword">for</span> simplicity.</span><br><span class="line">All uses changed.</span><br><span class="line"></span><br><span class="line">[<span class="built_in">Retrieved</span> (<span class="keyword">and</span> backported) from:</span><br><span class="line">https:<span class="comment">//git.savannah.gnu.org/cgit/gnulib.git/patch/?id=f9e2b20a12a230efa30f1d479563ae07d276a94b]</span></span><br><span class="line">Signed-off-by: Fabrice Fontaine &lt;fontaine.fabrice@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">diff -Nura m4<span class="number">-1.4</span><span class="number">.18</span>.orig/lib/c-stack.c m4<span class="number">-1.4</span><span class="number">.18</span>/lib/c-stack.c</span><br><span class="line">--- m4<span class="number">-1.4</span><span class="number">.18</span>.orig/lib/c-stack.c        <span class="number">2021</span><span class="number">-04</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">12</span>:<span class="number">14.086494029</span> +<span class="number">0200</span></span><br><span class="line">+++ m4<span class="number">-1.4</span><span class="number">.18</span>/lib/c-stack.c     <span class="number">2021</span><span class="number">-04</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">48</span>:<span class="number">46.316862760</span> +<span class="number">0200</span></span><br><span class="line">@@ <span class="number">-50</span>,<span class="number">15</span> +<span class="number">50</span>,<span class="number">16</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> ! HAVE_STACK_T &amp;&amp; ! defined stack_t</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">sigaltstack</span> <span class="type">stack_t</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">-<span class="meta">#<span class="keyword">ifndef</span> SIGSTKSZ</span></span><br><span class="line">-<span class="meta"># <span class="keyword">define</span> SIGSTKSZ 16384</span></span><br><span class="line">-<span class="meta">#<span class="keyword">elif</span> HAVE_LIBSIGSEGV &amp;&amp; SIGSTKSZ &lt; 16384</span></span><br><span class="line">-<span class="comment">/* libsigsegv 2.6 through 2.8 have a bug where some architectures use</span></span><br><span class="line"><span class="comment">-   more than the Linux default of an 8k alternate stack when deciding</span></span><br><span class="line"><span class="comment">-   if a fault was caused by stack overflow.  */</span></span><br><span class="line">-<span class="meta"># <span class="keyword">undef</span> SIGSTKSZ</span></span><br><span class="line">-<span class="meta"># <span class="keyword">define</span> SIGSTKSZ 16384</span></span><br><span class="line">-<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* Storage for the alternate signal stack.</span></span><br><span class="line"><span class="comment">+   64 KiB is not too large for Gnulib-using apps, and is large enough</span></span><br><span class="line"><span class="comment">+   for all known platforms.  Smaller sizes may run into trouble.</span></span><br><span class="line"><span class="comment">+   For example, libsigsegv 2.6 through 2.8 have a bug where some</span></span><br><span class="line"><span class="comment">+   architectures use more than the Linux default of an 8 KiB alternate</span></span><br><span class="line"><span class="comment">+   stack when deciding if a fault was caused by stack overflow.  */</span></span><br><span class="line">+<span class="type">static</span> <span class="type">max_align_t</span> alternate_signal_stack[(<span class="number">64</span> * <span class="number">1024</span></span><br><span class="line">+                                           + <span class="built_in">sizeof</span> (<span class="type">max_align_t</span>) - <span class="number">1</span>)</span><br><span class="line">+                                          / <span class="built_in">sizeof</span> (<span class="type">max_align_t</span>)];</span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">@@ <span class="number">-128</span>,<span class="number">19</span> +<span class="number">129</span>,<span class="number">6</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> (HAVE_SIGALTSTACK &amp;&amp; HAVE_DECL_SIGALTSTACK \</span></span><br><span class="line"><span class="meta">      &amp;&amp; HAVE_STACK_OVERFLOW_HANDLING) || HAVE_LIBSIGSEGV</span></span><br><span class="line"></span><br><span class="line">-<span class="comment">/* Storage for the alternate signal stack.  */</span></span><br><span class="line">-<span class="type">static</span> <span class="keyword">union</span></span><br><span class="line">-&#123;</span><br><span class="line">-  <span class="type">char</span> buffer[SIGSTKSZ];</span><br><span class="line">-</span><br><span class="line">-  <span class="comment">/* These other members are for proper alignment.  There&#x27;s no</span></span><br><span class="line"><span class="comment">-     standard way to guarantee stack alignment, but this seems enough</span></span><br><span class="line"><span class="comment">-     in practice.  */</span></span><br><span class="line">-  <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line">-  <span class="type">long</span> l;</span><br><span class="line">-  <span class="type">void</span> *p;</span><br><span class="line">-&#125; alternate_signal_stack;</span><br><span class="line">-</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"> <span class="title">null_action</span> <span class="params">(<span class="type">int</span> signo __attribute__ ((unused)))</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">@@ <span class="number">-205</span>,<span class="number">8</span> +<span class="number">193</span>,<span class="number">8</span> @@</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Always install the overflow handler.  */</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">stackoverflow_install_handler</span> (overflow_handler,</span><br><span class="line">-                                     alternate_signal_stack.buffer,</span><br><span class="line">-                                     <span class="keyword">sizeof</span> alternate_signal_stack.buffer))</span><br><span class="line">+                                     alternate_signal_stack,</span><br><span class="line">+                                     <span class="keyword">sizeof</span> alternate_signal_stack))</span><br><span class="line">     &#123;</span><br><span class="line">       errno = ENOTSUP;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">@@ <span class="number">-279</span>,<span class="number">14</span> +<span class="number">267</span>,<span class="number">14</span> @@</span><br><span class="line">   <span class="type">stack_t</span> st;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">   st.ss_flags = <span class="number">0</span>;</span><br><span class="line">+  st.ss_sp = alternate_signal_stack;</span><br><span class="line">+  st.ss_size = <span class="keyword">sizeof</span> alternate_signal_stack;</span><br><span class="line"> <span class="meta"># <span class="keyword">if</span> SIGALTSTACK_SS_REVERSED</span></span><br><span class="line">   <span class="comment">/* Irix mistakenly treats ss_sp as the upper bound, rather than</span></span><br><span class="line"><span class="comment">      lower bound, of the alternate stack.  */</span></span><br><span class="line">-  st.ss_sp = alternate_signal_stack.buffer + SIGSTKSZ - <span class="built_in">sizeof</span> (<span class="type">void</span> *);</span><br><span class="line">-  st.ss_size = <span class="keyword">sizeof</span> alternate_signal_stack.buffer - <span class="built_in">sizeof</span> (<span class="type">void</span> *);</span><br><span class="line">-<span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">-  st.ss_sp = alternate_signal_stack.buffer;</span><br><span class="line">-  st.ss_size = <span class="keyword">sizeof</span> alternate_signal_stack.buffer;</span><br><span class="line">+  st.ss_size -= <span class="built_in">sizeof</span> (<span class="type">void</span> *);</span><br><span class="line">+  <span class="type">char</span> *ss_sp = st.ss_sp;</span><br><span class="line">+  st.ss_sp = ss_sp + st.ss_size;</span><br><span class="line"> <span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">   r = <span class="built_in">sigaltstack</span> (&amp;st, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (r != <span class="number">0</span>)</span><br><span class="line">diff -Nura m4<span class="number">-1.4</span><span class="number">.18</span>.orig/lib/c-stack.h m4<span class="number">-1.4</span><span class="number">.18</span>/lib/c-stack.h</span><br><span class="line">--- m4<span class="number">-1.4</span><span class="number">.18</span>.orig/lib/c-stack.h        <span class="number">2021</span><span class="number">-04</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">12</span>:<span class="number">14.098494042</span> +<span class="number">0200</span></span><br><span class="line">+++ m4<span class="number">-1.4</span><span class="number">.18</span>/lib/c-stack.h     <span class="number">2021</span><span class="number">-04</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">17</span>:<span class="number">42.138848378</span> +<span class="number">0200</span></span><br><span class="line">@@ <span class="number">-34</span>,<span class="number">7</span> +<span class="number">34</span>,<span class="number">7</span> @@</span><br><span class="line">    A null ACTION acts like an action that does nothing.</span><br><span class="line"></span><br><span class="line">    ACTION must be async-signal-safe.  ACTION together with its callees</span><br><span class="line">-   must <span class="keyword">not</span> require more than SIGSTKSZ bytes of stack space.  Also,</span><br><span class="line">+   must <span class="keyword">not</span> require more than <span class="number">64</span> KiB bytes of stack space.  Also,</span><br><span class="line">    ACTION should <span class="keyword">not</span> call longjmp, because <span class="keyword">this</span> implementation does</span><br><span class="line">    <span class="keyword">not</span> guarantee that it is safe to <span class="keyword">return</span> to the original stack.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在合适的位置使用内核补丁（.patch 文件）来修改 Linux 内核的源代码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">patch -p1 &lt; /path/to/my_patch.patch</span><br></pre></td></tr></table></figure>

<ul>
<li>-p1 是一个常用选项，它告诉 patch 命令忽略路径前的一个目录部分。如果补丁文件的路径与源代码目录结构不一致，你可能需要调整 -p 选项的值。</li>
<li>&lt; 用来将补丁文件的内容传递给 patch 命令。</li>
</ul>
<p>在这里，实际应用时，我们在编译源码目录下 wget 下载补丁文件，之后进入指定位置应用补丁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OK3568-linux-source$ cd ./buildroot/output/OK3568/build/host-m4<span class="number">-1.4</span><span class="number">.18</span>/</span><br><span class="line">OK3568-linux-source/buildroot/output/OK3568/build/host-m4<span class="number">-1.4</span><span class="number">.18</span>$ patch -p1 &lt; ../../../../../<span class="number">0003</span>-c-stack-stop-<span class="keyword">using</span>-SIGSTKSZ.patch</span><br><span class="line">patching file lib/c-stack.c</span><br><span class="line">patching file lib/c-stack.h</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>检查应用结果，你可以检查应用补丁后的文件，确保补丁已正确应用。</p>
</li>
<li><p>回滚补丁，如果补丁引入了问题或不需要了，可以回滚补丁：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">patch -p1 -R &lt; /path/to/patch.patch</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>内核</category>
      </categories>
  </entry>
  <entry>
    <title>多核处理器的负载均衡</title>
    <url>/2024/07/25/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%86%85%E6%A0%B8-%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>现阶段多核处理器的应用范围越来越广泛，在通常情况下应用程序的调度都是交由操作系统进行管理，操作系统对应用程序进行调度，使其在不同的核上轮番运行。</p>
<p>多核操作系统的关注点在于进程的分配和调度。进程的分配将进程分配到合理的物理核上，因为不同的核在共享性和历史运行情况都是不同的。有的物理核能够共享二级 cache，而有的却是独立的。如果将有数据共享的进程分配给有共享二级 cache 的核上，将大大提升性能；反之，就有可能影响性能。</p>
<p>在一般情况下，操作系统的默认调度机制可以应付大部分的情况，但是针对于需要高运行效率的进程来说，就有必要考虑将其固定在一个核上运行，避免在不同的核上调度造成的额外开销。</p>
<p>对于绑定的进程来说，该进程将会一直在指定的核上运行，不会在被调度到其他的核上，但是被绑定的核上仍然有可能运行其他进程。</p>
<p>在多核处理器的 Linux 系统中,可以通过几种方法实现应用程序线程在指定 CPU 核上运行,从而提高性能并减少不同核心间切换的开销. 需要注意的是,手动绑核应谨慎使用,因为它可能会影响系统的整体负载均衡. 在大多数情况下,操作系统的默认调度策略已经能够很好地管理线程分配.</p>
<h1 id="查看-cpu-有几个核"><a href="#查看-cpu-有几个核" class="headerlink" title="查看 cpu 有几个核"></a>查看 cpu 有几个核</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p>使用系统调用 sysconf 获取 cpu 核心数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sysconf</span><span class="params">(_SC_NPROCESSORS_CONF)</span></span>;<span class="comment">/* 返回系统可以使用的核数，但是其值会包括系统中禁用的核的数目，因 此该值并不代表当前系统中可用的核数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sysconf</span><span class="params">(_SC_NPROCESSORS_ONLN)</span></span>;<span class="comment">/* 返回值真正的代表了系统当前可用的核数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下两个函数与上述类似 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_nprocs_conf</span> <span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">/* 可用核数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_nprocs</span> <span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">/* 真正的反映了当前可用核数 */</span></span><br></pre></td></tr></table></figure>

<h1 id="taskset-命令"><a href="#taskset-命令" class="headerlink" title="taskset 命令"></a>taskset 命令</h1><p>taskset 可以在命令行中将进程或线程绑定到特定的 CPU 核心.</p>
<p>查看进程绑定情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">taskset -p [pid]</span><br></pre></td></tr></table></figure>

<p>绑定进程到指定 CPU 核（cpuid 的标号是从 0 开始的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">taskset -cp [cpuid] [pid]</span><br></pre></td></tr></table></figure>

<p>例如:（将进程 9865 绑定到 1,2,5-11 号核）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">taskset -cp <span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span><span class="number">-11</span> <span class="number">9865</span></span><br></pre></td></tr></table></figure>

<h2 id="在启动时绑定"><a href="#在启动时绑定" class="headerlink" title="在启动时绑定"></a>在启动时绑定</h2><p>可以在启动应用程序时使用 taskset 命令直接绑定:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">taskset -c <span class="number">0</span>,<span class="number">1</span> ./your_program</span><br></pre></td></tr></table></figure>

<h1 id="sched-setaffinity-系统调用"><a href="#sched-setaffinity-系统调用" class="headerlink" title="sched_setaffinity 系统调用"></a>sched_setaffinity 系统调用</h1><p>在程序代码中可以使用 sched_setaffinity 函数来设置线程的 CPU 亲和性:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置进程号为pid的进程运行在mask所设定的CPU上</span></span><br><span class="line"><span class="comment"> * 第二个参数cpusetsize是mask所指定的数的长度</span></span><br><span class="line"><span class="comment"> * 通常设定为sizeof(cpu_set_t)</span></span><br><span class="line"><span class="comment"> * 如果pid的值为0,则表示指定的是当前进程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize, <span class="type">cpu_set_t</span> *mask)</span></span>;</span><br><span class="line"><span class="comment">/* 获得pid所指示的进程的CPU位掩码,并将该掩码返回到mask所指向的结构中 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sched_getaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize, <span class="type">cpu_set_t</span> *mask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">cpu_set_t</span> mask;</span><br><span class="line"><span class="built_in">CPU_ZERO</span>(&amp;mask);</span><br><span class="line"><span class="built_in">CPU_SET</span>(<span class="number">0</span>, &amp;mask);  <span class="comment">// 设置亲和性为 CPU 0</span></span><br><span class="line"><span class="built_in">sched_setaffinity</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(mask), &amp;mask);</span><br></pre></td></tr></table></figure>

<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USE_GNU</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_MAX_NUM 200  <span class="comment">//1个CPU内的最多进程数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;  <span class="comment">//cpu中核数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFun</span><span class="params">(<span class="type">void</span>* arg)</span>  <span class="comment">//arg  传递线程标号（自己定义）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         <span class="type">cpu_set_t</span> mask;  <span class="comment">//CPU核的集合</span></span><br><span class="line">         <span class="type">cpu_set_t</span> get;   <span class="comment">//获取在集合中的CPU</span></span><br><span class="line">         <span class="type">int</span> *a = (<span class="type">int</span> *)arg; </span><br><span class="line">         <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;the thread is:%d\n&quot;</span>,*a);  <span class="comment">//显示是第几个线程</span></span><br><span class="line">         <span class="built_in">CPU_ZERO</span>(&amp;mask);    <span class="comment">//置空</span></span><br><span class="line">         <span class="built_in">CPU_SET</span>(*a,&amp;mask);   <span class="comment">//设置亲和力值</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">sched_setaffinity</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(mask), &amp;mask) == <span class="number">-1</span>)<span class="comment">//设置线程CPU亲和力</span></span><br><span class="line">         &#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;warning: could not set CPU affinity, continuing...\n&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">CPU_ZERO</span>(&amp;get);</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">sched_getaffinity</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(get), &amp;get) == <span class="number">-1</span>)<span class="comment">//获取线程CPU亲和力</span></span><br><span class="line">           &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;warning: cound not get thread affinity, continuing...\n&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">           &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">CPU_ISSET</span>(i, &amp;get))<span class="comment">//判断线程与哪个CPU有亲和力</span></span><br><span class="line">                    &#123;</span><br><span class="line">                             <span class="built_in">printf</span>(<span class="string">&quot;this thread %d is running processor : %d\n&quot;</span>, i,i);</span><br><span class="line">                    &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         <span class="type">int</span> tid[THREAD_MAX_NUM];</span><br><span class="line">         <span class="type">int</span> i;</span><br><span class="line">         <span class="type">pthread_t</span> thread[THREAD_MAX_NUM];</span><br><span class="line"></span><br><span class="line">         num = <span class="built_in">sysconf</span>(_SC_NPROCESSORS_CONF);  <span class="comment">//获取核数</span></span><br><span class="line">         <span class="keyword">if</span> (num &gt; THREAD_MAX_NUM) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;num of cores[%d] is bigger than THREAD_MAX_NUM[%d]!\n&quot;</span>, num, THREAD_MAX_NUM);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;system has %i processor(s). \n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">         &#123;</span><br><span class="line">                   tid[i] = i;  <span class="comment">//每个线程必须有个tid[i]</span></span><br><span class="line">                   <span class="built_in">pthread_create</span>(&amp;thread[i],<span class="literal">NULL</span>,threadFun,(<span class="type">void</span>*)&amp;tid[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; num; i++)</span><br><span class="line">         &#123;</span><br><span class="line">                   <span class="built_in">pthread_join</span>(thread[i],<span class="literal">NULL</span>);<span class="comment">//等待所有的线程结束，线程为死循环所以CTRL+C结束</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="pthread-setaffinity-np-函数"><a href="#pthread-setaffinity-np-函数" class="headerlink" title="pthread_setaffinity_np 函数"></a>pthread_setaffinity_np 函数</h1><p>对于 POSIX 线程,可以使用 pthread_setaffinity_np 函数来设置线程亲和性:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize, <span class="type">const</span> <span class="type">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_getaffinity_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">size_t</span> cpusetsize, <span class="type">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">cpu_set_t</span> cpuset;</span><br><span class="line"><span class="built_in">CPU_ZERO</span>(&amp;cpuset);</span><br><span class="line"><span class="built_in">CPU_SET</span>(<span class="number">2</span>, &amp;cpuset);</span><br><span class="line"><span class="built_in">pthread_setaffinity_np</span>(<span class="built_in">pthread_self</span>(), <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset);</span><br></pre></td></tr></table></figure>

<h2 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">gettid</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">syscall</span>(SYS_gettid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief print_running_cpu</span></span><br><span class="line"><span class="comment"> * pthread_setaffinity_np函数用于设置线程的CPU亲和度。</span></span><br><span class="line"><span class="comment"> * CPU_SET和CPU_ZERO用于设置和清除CPU掩码。</span></span><br><span class="line"><span class="comment"> * print_running_cpu函数通过系统命令查询线程当前运行的CPU核，并打印出来。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_running_cpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> qry_cmd[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(qry_cmd, <span class="string">&quot;ps -o pid,spid,psr -T -p %d | grep %d | tail -n 1 | awk &#123;&#x27;print $3&#x27;&#125;&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">gettid</span>());</span><br><span class="line">    FILE *fp = <span class="built_in">popen</span>(qry_cmd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span> cpu_id_str[<span class="number">200</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">fgets</span>(cpu_id_str, <span class="number">80</span>, fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d] : current thread(%d@%d) is running on cpu(%d)\n&quot;</span>, <span class="built_in">gettid</span>(), <span class="built_in">gettid</span>(), <span class="built_in">getpid</span>(), <span class="built_in">atoi</span>(cpu_id_str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bind_thread_to_cpu</span><span class="params">(<span class="type">int</span> cpu_id)</span> </span>&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_mask;</span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;cpu_mask);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(cpu_id, &amp;cpu_mask);</span><br><span class="line">    <span class="built_in">pthread_setaffinity_np</span>(<span class="built_in">pthread_self</span>(), <span class="built_in">sizeof</span>(cpu_mask), &amp;cpu_mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_func</span><span class="params">(<span class="type">void</span>* p_arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> bind_cpu_id = *(<span class="type">int</span> *)p_arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d] : setting cpu affinity for thread(%d@%d) to cpu(%d)\n&quot;</span>, <span class="built_in">gettid</span>(), <span class="built_in">gettid</span>(), <span class="built_in">getpid</span>(), bind_cpu_id);</span><br><span class="line">    <span class="built_in">bind_thread_to_cpu</span>(bind_cpu_id);</span><br><span class="line">    <span class="built_in">print_running_cpu</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟工作负载</span></span><br><span class="line">        <span class="type">long</span> loop = <span class="number">4000000000</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop--) &#123;&#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">print_running_cpu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cpu_id_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cpu_id_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">pthread_t</span> thr_id_1, thr_id_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并绑定线程1到CPU 1</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thr_id_1, <span class="literal">NULL</span>, thread_func, &amp;cpu_id_1);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 确保线程1已经绑定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并绑定线程2到CPU 2</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thr_id_2, <span class="literal">NULL</span>, thread_func, &amp;cpu_id_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thr_id_1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(thr_id_2, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>内核</category>
      </categories>
  </entry>
  <entry>
    <title>keyring库</title>
    <url>/2024/08/24/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%8A%A0%E5%AF%86-keyring%E5%BA%93/</url>
    <content><![CDATA[<p>使用 keyring 库安全地存储和检索敏感信息（如密码）。</p>
<p>keyring 提供了一个安全的方式来管理这些信息，而不是将明文存储在代码或配置文件中。但是 keyring 库不是 Linux 内核的密钥保留服务，而是一个独立的 C++ 库，提供了跨平台的密码管理功能。它通常会使用操作系统提供的安全存储机制（如 Linux 的 Secret Service API 或 Windows 的 Credential Manager）来实现其功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyring/keyring.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string service_name = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">  std::string account = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">  std::string password_input = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">  std::string password_output = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  keyring::<span class="built_in">set_password</span>(service_name, account, password_input);</span><br><span class="line"></span><br><span class="line">  keyring::<span class="built_in">get_password</span>(service_name, account, password_output);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; password_output &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title>内核密钥保留服务</title>
    <url>/2024/08/24/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%8A%A0%E5%AF%86-%E5%86%85%E6%A0%B8%E5%AF%86%E9%92%A5%E4%BF%9D%E7%95%99%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>Linux 内核提供了密钥保留服务(Key Retention Service),可以用于应用程序加密。Linux 密钥保留服务（Linux key retention service 是在 Linux 2.6 中引入的，它的主要意图是在 Linux 内核中缓存身份验证数据。远程文件系统和其他内核服务可以使用这个服务来管理密码学、身份验证标记、跨域用户映射和其他安全问题。它还使 Linux 内核能够快速访问所需的密钥，并可以用来将密钥操作（比如添加、更新和删除）委托给用户空间。</p>
<h2 id="启用密钥保留服务"><a href="#启用密钥保留服务" class="headerlink" title="启用密钥保留服务"></a>启用密钥保留服务</h2><ol>
<li>在内核配置中启用密钥服务选项:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Security options</span><br><span class="line">#</span><br><span class="line">CONFIG_KEYS=y</span><br><span class="line">CONFIG_KEYS_DEBUG_PROC_KEYS=y</span><br><span class="line">CONFIG_SECURITY=y</span><br><span class="line">CONFIG_SECURITY_NETWORK=y</span><br><span class="line">CONFIG_SECURITY_CAPABILITIES=y</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 keyutils 包,提供密钥管理工具:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install keyutils</span><br></pre></td></tr></table></figure>

<h2 id="内核层-API"><a href="#内核层-API" class="headerlink" title="内核层 API"></a>内核层 API</h2><ul>
<li>register_key_type 定义新的密钥类型。如果存在名称相同的密钥类型，返回 EEXIT。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_key_type</span><span class="params">(<span class="keyword">struct</span> key_type *type)</span> </span></span><br></pre></td></tr></table></figure>

<ul>
<li>unregister_key_type 用来取消密钥类型的注册</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unregister_key_type</span><span class="params">(<span class="keyword">struct</span> key_type *type)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>key_alloc 分配指定类型的密钥</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">key</span> *<span class="built_in">key_alloc</span>(<span class="keyword">struct</span> key_type *type, <span class="type">const</span> <span class="type">char</span> *desc, <span class="type">uid_t</span> uid, <span class="type">gid_t</span> gid, <span class="keyword">struct</span> task_struct *ctx, <span class="type">key_perm_t</span> perm, <span class="type">unsigned</span> <span class="type">long</span> flags);</span><br></pre></td></tr></table></figure>

<ul>
<li>key_instantiate_and_link 对密钥进行实例化并将它链接到目标 keyring</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">key_instantiate_and_link</span><span class="params">(<span class="keyword">struct</span> key *key, <span class="type">const</span> <span class="type">void</span> *data,<span class="type">size_t</span> datalen, <span class="keyword">struct</span> key *keyring,<span class="keyword">struct</span> key *instkey)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>request_key 搜索与给定的描述匹配的密钥</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">key</span> *<span class="built_in">request_key</span>(<span class="type">const</span> <span class="keyword">struct</span> key_type *type,<span class="type">const</span> <span class="type">char</span> *description,<span class="type">const</span> <span class="type">char</span> *callout_string);</span><br></pre></td></tr></table></figure>

<ul>
<li>lookup_user_key 用于在内核中查找指定 ID 的密钥</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">key_ref_t</span> <span class="title">lookup_user_key</span><span class="params">(<span class="type">key_serial_t</span> id, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">key_perm_t</span> perm)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>key_put 发布一个密钥</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">key_put</span><span class="params">(<span class="keyword">struct</span> key *key)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="应用层-API"><a href="#应用层-API" class="headerlink" title="应用层 API"></a>应用层 API</h2><p>Linux 内核提供了密钥保留服务(Key Retention Service)服务提供三个新的系统调用，用来在用户空间中操作密钥。</p>
<ol>
<li>add_key()用于用户空间程序向指定的密钥环中添加新密钥或更新现有密钥。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">key_serial_t</span> keyring)</span></span>;</span><br></pre></td></tr></table></figure>

<p>add_key 系统调用用来创建类型为 type、长度为 plen 的密钥。密钥描述由 desc 定义，它的有效内容由 payload 指定。密钥链接到 keyring ring。密钥类型可以是 user 或 keyring。其他任何密钥类型必须已经通过内核服务向内核注册，然后才能使用。如果密钥是 keyring 类型的，有效内容就应该是 NULL，plen 应该是零。</p>
<ol start="2">
<li>request_key()用于请求访问一个密钥。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">key_serial_t</span> <span class="title">request_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> <span class="type">char</span> *callout_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">key_serial_t</span> dest_keyring)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它允许程序请求访问一个已存在的密钥，如果密钥不存在，还可以触发创建密钥的过程。</p>
<ol start="3">
<li>keyctl()多功能系统调用,用于执行各种密钥管理操作。其基本用法如下:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">keyctl</span><span class="params">(<span class="type">int</span> operation, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>keyctl()支持多种操作,包括但不限于:</p>
<ul>
<li>KEYCTL_DESCRIBE 描述一个密钥。</li>
<li>KEYCTL_READ 从一个密钥读取有效内容数据。</li>
<li>KEYCTL_UPDATE 更新指定的密钥。</li>
<li>KEYCTL_LINK 将一个密钥链接到一个 keyring。</li>
<li>KEYCTL_UNLINK 将密钥或 keyring 与另一个 keyring 的链接取消。</li>
<li>KEYCTL_JOIN_SESSION_KEYRING 将一个会话 keyring 替换为新的会话 keyring。</li>
<li>KEYCTL_REVOKE 取消一个密钥。</li>
<li>KEYCTL_CHOWN 修改密钥的所有者。</li>
<li>KEYCTL_SETPERM 修改密钥的权限掩码。</li>
<li>KEYCTL_CLEAR 清除一个 keyring。</li>
<li>KEYCTL_SEARCH 在一个 keyring 树中搜索密钥。</li>
<li>KEYCTL_INSTANTIATE 对部分构造好的密钥进行实例化。</li>
<li>KEYCTL_NEGATE 取消对部分构造好的密钥的实例化。</li>
</ul>
<p>查看内核中是否支持以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取密钥内容</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">keyctl_read</span><span class="params">(<span class="type">key_serial_t</span> key, <span class="type">char</span> *buffer, <span class="type">size_t</span> buflen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 更新密钥内容  </span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">keyctl_update</span><span class="params">(<span class="type">key_serial_t</span> key, <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 撤销密钥</span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">keyctl_revoke</span><span class="params">(<span class="type">key_serial_t</span> key)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="使用密钥保留服务"><a href="#使用密钥保留服务" class="headerlink" title="使用密钥保留服务"></a>使用密钥保留服务</h2><h3 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h3><p>通过密钥保留服务密钥会被存储在内核中,而不是应用程序的内存空间,提高了安全性</p>
<h4 id="内核层"><a href="#内核层" class="headerlink" title="内核层"></a>内核层</h4><p>模块在它的 init 函数中调用 register_key_type() 来注册这个新密钥类型（名为 mykey）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/key-type.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">key_type</span> my_key_type = &#123;</span><br><span class="line">	.name = <span class="string">&quot;mykey&quot;</span>,</span><br><span class="line">	.instantiate = my_instantiate_key,</span><br><span class="line">	.describe = my_key_describe,</span><br><span class="line">	.match = my_key_match,</span><br><span class="line">	.destroy = my_key_destroy,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">my_module_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">register_key_type</span>(&amp;my_key_type);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;Failed to register key type\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pr_info</span>(<span class="string">&quot;My key type registered\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">my_module_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">unregister_key_type</span>(&amp;my_key_type);</span><br><span class="line">	<span class="built_in">pr_info</span>(<span class="string">&quot;My key type unregistered\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(my_module_init);</span><br><span class="line"><span class="built_in">module_exit</span>(my_module_exit);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当内核模块收到 ioctl 请求时，它首先调用 key_alloc() 来分配一个新的密钥，从而创建一个会话 keyring。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">key</span> *key;</span><br><span class="line">key = <span class="built_in">key_alloc</span>(&amp;my_key_type, <span class="string">&quot;my_key&quot;</span>, <span class="built_in">current_uid</span>(), <span class="built_in">current_gid</span>(), <span class="built_in">current_cred</span>(), KEY_POS_ALL, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IS_ERR</span>(key)) &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;secret_data&quot;</span>;</span><br><span class="line">	<span class="built_in">key_instantiate_and_link</span>(key, data, <span class="built_in">strlen</span>(data), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在成功调用 key_alloc() 之后，调用 key_instantiate_and_link() 对密钥进行实例化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="built_in">key_instantiate_and_link</span>(key, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">key_put</span>(key);</span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建并实例化会话 keyring 之后，为用户的会话创建密钥。</p>
<p>同样，依次调用 key_alloc() 和 key_instantiate_and_link()。</p>
<p>成功完成这些调用之后，用户空间会话就有了一个新密钥。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">keyctl add user mykey <span class="string">&quot;mysecretvalue&quot;</span> @u</span><br></pre></td></tr></table></figure>

<h3 id="使用密钥"><a href="#使用密钥" class="headerlink" title="使用密钥"></a>使用密钥</h3><p>在应用程序中使用密钥:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_serial_t</span> key;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="type">long</span> buflen;</span><br><span class="line"></span><br><span class="line">    key = request_key(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;mykey&quot;</span>, <span class="literal">NULL</span>, KEY_SPEC_SESSION_KEYRING);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;request_key&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buflen = keyctl_read(key, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (buflen == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;keyctl_read&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Key data: %.*s\n&quot;</span>, (<span class="type">int</span>)buflen, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>需要内核支持(2.6 及以上版本)</li>
<li><code>libkeyutils.so</code> 是 C 库，在 C++工程中会出现 <code>undefined reference add_key</code> 等错误，头文件 <code>&lt;keyutils.h&gt;</code> 需要 <code>extern</code> 包含，且需要注意链接时需要添加 <code>LIB += -lkeyutils</code></li>
<li>一定要初始化 keyutils 库,具体方法如下:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line">rc = <span class="built_in">keyctl</span>(KEYCTL_LINK,KEY_SPEC_USER_KEYRING,KEY_SPEC_SESSION_KERING);</span><br></pre></td></tr></table></figure>

<p>只有此处调用成功后,才能调用 add_key(“user”,…);否则,即使 add_key 成功,最后调用 request_key 也会失败，找不到才加入到 keyring 中的 KEY.在内核中调用 request_key 也会失败,返回 NOKEY.</p>
<h2 id="状态查看"><a href="#状态查看" class="headerlink" title="状态查看"></a>状态查看</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@phoenix set<span class="number">.5</span>]<span class="meta"># keyctl show</span></span><br><span class="line">Session Keyring</span><br><span class="line"><span class="number">-3</span> --alswrv <span class="number">0</span> <span class="number">0</span> keyring: session<span class="number">.2621</span></span><br><span class="line"><span class="number">39044642</span> --alswrv <span class="number">0</span> <span class="number">0</span> \_ mykey: New key type</span><br><span class="line"></span><br><span class="line">[root@phoenix set<span class="number">.5</span>]<span class="meta"># cat /proc/keys</span></span><br><span class="line"><span class="number">00000001</span> I----- <span class="number">1</span> perm <span class="number">1f</span>3f0000 <span class="number">0</span> <span class="number">0</span> keyring _uid_ses<span class="number">.0</span>: <span class="number">1</span>/<span class="number">4</span></span><br><span class="line"><span class="number">00000002</span> I----- <span class="number">5</span> perm <span class="number">1f</span>3f0000 <span class="number">0</span> <span class="number">0</span> keyring _uid<span class="number">.0</span>: empty</span><br><span class="line"><span class="number">0253</span>c622 I--Q-- <span class="number">1</span> perm <span class="number">3f</span>3f0000 <span class="number">0</span> <span class="number">0</span> mykey New key type: <span class="number">0</span></span><br><span class="line"><span class="number">11</span>a490da I--Q-- <span class="number">2</span> perm <span class="number">3f</span>3f0000 <span class="number">0</span> <span class="number">0</span> keyring session<span class="number">.2621</span>: <span class="number">1</span>/<span class="number">4</span></span><br><span class="line"><span class="number">13670439</span> I--Q-- <span class="number">2</span> perm <span class="number">1f</span>3f0000 <span class="number">0</span> <span class="number">0</span> keyring _ses<span class="number">.1977</span>: <span class="number">1</span>/<span class="number">4</span></span><br><span class="line"><span class="number">159</span>d39b8 I--Q-- <span class="number">5</span> perm <span class="number">1f</span>3f0000 <span class="number">0</span> <span class="number">0</span> keyring _ses<span class="number">.1976</span>: <span class="number">1</span>/<span class="number">4</span></span><br><span class="line"><span class="number">3</span>a14f259 I--Q-- <span class="number">3</span> perm <span class="number">1f</span>3f0000 <span class="number">0</span> <span class="number">0</span> keyring _ses<span class="number">.1978</span>: <span class="number">1</span>/<span class="number">4</span></span><br><span class="line"></span><br><span class="line">[root@phoenix set<span class="number">.5</span>]<span class="meta"># cat /proc/key-users</span></span><br><span class="line"><span class="number">0</span>: <span class="number">8</span> <span class="number">7</span>/<span class="number">7</span> <span class="number">5</span>/<span class="number">100</span> <span class="number">136</span>/<span class="number">10000</span></span><br><span class="line"><span class="number">43</span>: <span class="number">2</span> <span class="number">2</span>/<span class="number">2</span> <span class="number">2</span>/<span class="number">100</span> <span class="number">56</span>/<span class="number">10000</span></span><br><span class="line"><span class="number">48</span>: <span class="number">2</span> <span class="number">2</span>/<span class="number">2</span> <span class="number">2</span>/<span class="number">100</span> <span class="number">56</span>/<span class="number">10000</span></span><br><span class="line"><span class="number">81</span>: <span class="number">2</span> <span class="number">2</span>/<span class="number">2</span> <span class="number">2</span>/<span class="number">100</span> <span class="number">56</span>/<span class="number">10000</span></span><br><span class="line"><span class="number">786</span>: <span class="number">4</span> <span class="number">4</span>/<span class="number">4</span> <span class="number">4</span>/<span class="number">100</span> <span class="number">113</span>/<span class="number">10000</span></span><br><span class="line"><span class="string">&quot;keyctl describe &lt;``Key``&gt;&quot;</span> command gives the description of key.</span><br><span class="line"></span><br><span class="line">[root@phoenix set<span class="number">.5</span>]<span class="meta"># keyctl describe -3</span></span><br><span class="line"><span class="number">-3</span>: alswrvalswrv------------ <span class="number">0</span> <span class="number">0</span> keyring: session<span class="number">.2621</span></span><br><span class="line"></span><br><span class="line">[root@phoenix set<span class="number">.5</span>]<span class="meta"># keyctl describe 39044642</span></span><br><span class="line"><span class="number">39044642</span>: alswrvalswrv------------ <span class="number">0</span> <span class="number">0</span> mykey: New key type</span><br><span class="line">[avinesh@phoenix set<span class="number">.5</span>]$ keyctl search <span class="number">-3</span> mykey <span class="string">&quot;New key type&quot;</span></span><br><span class="line"><span class="number">39044642</span></span><br><span class="line"></span><br><span class="line">[root@phoenix set<span class="number">.5</span>]<span class="meta"># exit</span></span><br><span class="line">exit</span><br><span class="line">Now back to our previous state</span><br><span class="line"></span><br><span class="line">[root@phoenix set<span class="number">.5</span>]<span class="meta"># keyctl show</span></span><br><span class="line">Session Keyring</span><br><span class="line"><span class="number">-3</span> --alswrv <span class="number">0</span> <span class="number">0</span> keyring: _ses<span class="number">.1976</span></span><br><span class="line"><span class="number">2</span> --alswrv <span class="number">0</span> <span class="number">0</span> \_ keyring: _uid<span class="number">.0</span></span><br><span class="line"></span><br><span class="line">[root@phoenix set<span class="number">.5</span>]<span class="meta"># rmmod ./kernel.land/newkey.ko</span></span><br><span class="line">Unloading the <span class="keyword">module</span>.</span><br><span class="line">Unregistered <span class="string">&quot;learning_key&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="内核中的密钥管理"><a href="#内核中的密钥管理" class="headerlink" title="内核中的密钥管理"></a>内核中的密钥管理</h2><p>内核密钥管理在 proc 文件系统中创建了两个只读文件：&#x2F;proc&#x2F;keys 和&#x2F;proc&#x2F;key-users。它们没有被创建在&#x2F;proc&#x2F;pid 目录下，而是被直接创建在了 proc 文件系统的根目录下。这就造成了进程根本无法查看到别的进程的密钥。</p>
<ul>
<li>&#x2F;proc&#x2F;keys 文件列出当前进程可查看的密钥，所以不同的进程读出的内容会不同。如果一个进程希望了解它可以查看哪些密钥，它可以通过读取 &#x2F;proc&#x2F;keys 获得这些信息。列出的内容包括序列号、过期时间、访问允许位、uid、gid、类型、描述等。在配置内核时，必须启用这个文件，因为它允许任何用户列出密钥数据库。</li>
<li>&#x2F;proc&#x2F;key-users 列出密钥的统计信息，包括 uid、使用计数、密钥总数量和实例化数量、密钥数量的配额信息、密钥占用内存的配额信息。</li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title>加密方式介绍</title>
    <url>/2024/07/12/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%8A%A0%E5%AF%86-%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>加密技术通常分为两大类“对称式”和“非对称式”</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407121500527.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title>加密方案</title>
    <url>/2024/05/17/0-%E5%B9%B3%E5%8F%B0-Linux-%E5%8A%A0%E5%AF%86-%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="3568-应用程序及主板可执行文件加密"><a href="#3568-应用程序及主板可执行文件加密" class="headerlink" title="3568 应用程序及主板可执行文件加密"></a>3568 应用程序及主板可执行文件加密</h1><p>在针对可执行文件的加壳加密和解密中，通常会使用以下步骤：</p>
<p><strong>加壳加密</strong>：</p>
<ol>
<li><strong>选择壳程序：</strong> 选择一个用于加壳的程序，通常是一个小型的程序，它可以将原始的 ELF 文件嵌入到自身中，并添加解密逻辑。</li>
<li><strong>嵌入并加密原始 ELF 文件：</strong> 将原始的 ELF 可执行文件嵌入到壳程序中，并对嵌入的原始 ELF 文件进行加密处理，使用加密算法对文件内容进行加密，确保只有正确的解密密钥可以解密文件。</li>
<li><strong>生成加密后的文件：</strong> 将加密后的 ELF 文件保存为一个新的可执行文件，这个文件是经过加密处理的。</li>
</ol>
<p><strong>解密</strong>：</p>
<ol>
<li><strong>执行加密后的文件：</strong> 执行加密后的 ELF 文件，这个文件是壳程序，它包含了解密逻辑。</li>
<li><strong>解密逻辑：</strong> 壳程序在运行时会对自身进行解密，并将嵌入的原始 ELF 文件解密出来。</li>
<li><strong>还原原始 ELF 文件：</strong> 解密后的原始 ELF 文件会被还原到内存中，然后壳程序会将控制权转移到原始 ELF 文件，使得原始程序可以正常执行。</li>
</ol>
<p>本文档实现的加密方式主要分为以下两个模块：</p>
<ol>
<li>内核空间下，基于内核密钥保留服务的 ELF 文件解密并交付内核正常运行模块</li>
<li>用户空间下，基于非对称加密算法的 ELF 文件内容加密，主要针对 ELF Header 模块【可选加密 program header 和 section header】</li>
</ol>
<h1 id="1-应用程序加壳"><a href="#1-应用程序加壳" class="headerlink" title="1. 应用程序加壳"></a>1. 应用程序加壳</h1><h2 id="1-1-ELF-文件格式介绍"><a href="#1-1-ELF-文件格式介绍" class="headerlink" title="1.1 ELF 文件格式介绍"></a>1.1 ELF 文件格式介绍</h2><p>应用程序加壳模块对应用程序进行加密操作，主要针对以下模块进行加密操作</p>
<ol>
<li>ELF header</li>
<li>Program header table 【可选】</li>
<li>Section header table 【可选】</li>
</ol>
<p>其中 ELF header 指明了 ELF 文件的整体信息，如 ELF 文件的 magic value、类型、版本、目标机器等。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line"> Elf_Half		e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line"> Elf_Half		e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line"> Elf_Word	    e_version;		<span class="comment">/* Object file version 文件版本,目前常见的ELF文件版本均为EV_CURRENT(1)*/</span></span><br><span class="line"> Elf_Addr		e_entry;		<span class="comment">/* Entry point virtual address 入口虚拟地址。*/</span></span><br><span class="line"> Elf_Off		    e_phoff;		<span class="comment">/* Program header table file offset 段表文件偏移。*/</span></span><br><span class="line"> Elf_Off		    e_shoff;		<span class="comment">/* Section header table file offset 节表文件偏移。*/</span></span><br><span class="line"> Elf_Word	    e_flags;		<span class="comment">/* Processor-specific flags 处理器特定的标志，一般为0。*/</span></span><br><span class="line"> Elf_Half		e_ehsize;		<span class="comment">/* ELF header size in bytes  Elf_Header的大小（字节）*/</span></span><br><span class="line"> Elf_Half		e_phentsize;	<span class="comment">/* Program header table entry size 段头的大小（字节）。*/</span></span><br><span class="line"> Elf_Half		e_phnum;		<span class="comment">/* Program header table entry count 段的数量。*/</span></span><br><span class="line"> Elf_Half		e_shentsize;	<span class="comment">/* Section header table entry size   节头的大小（字节）。*/</span></span><br><span class="line"> Elf_Half		e_shnum;		<span class="comment">/* Section header table entry count 字的数量。*/</span></span><br><span class="line"> Elf_Half		e_shstrndx;		<span class="comment">/* Section header string table index 节字符串表的节索引*/</span></span><br><span class="line">&#125; Elf_Ehdr;</span><br><span class="line"></span><br><span class="line">[e_ident]</span><br><span class="line">包含了Maigc Number和其它信息，共<span class="number">16</span>字节。	</span><br><span class="line"><span class="number">0</span>~<span class="number">3</span>：前<span class="number">4</span>字节为Magic Number，固定为ELFMAG。</span><br><span class="line"><span class="number">4</span>（EI_CLASS）：ELFCLASS32代表是<span class="number">32</span>位ELF，ELFCLASS64 代表<span class="number">64</span>位ELF。</span><br><span class="line"><span class="number">5</span>（EI_DATA）：ELFDATA2LSB代表小端，ELFDATA2MSB代表大端。</span><br><span class="line"><span class="number">6</span>（EI_VERSION）：固定为EV_CURRENT（<span class="number">1</span>）。</span><br><span class="line"><span class="number">7</span>（EI_OSABI）：操作系统ABI标识（实际未使用）。</span><br><span class="line"><span class="number">8</span>（EI_ABIVERSION）：ABI版本（实际 未使用）。</span><br><span class="line"><span class="number">9</span>~<span class="number">15</span>：对齐填充，无实际意义。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[e_type]</span><br><span class="line">ELF的文件类型，定义如下：</span><br><span class="line">ET_REL		可重定位文 件（如目标文件）</span><br><span class="line">ET_EXEC	        可执行文件（可直接执行的文件）</span><br><span class="line">DT_DYN	        共享目标文件（如SO库）</span><br><span class="line">DT_CORE	        Core文件（吐核文件）</span><br><span class="line">注：GCC使用编译选项 -pie 编译的可执行文件实际 也是DT_DYN类型。</span><br><span class="line"></span><br><span class="line">[e_machine]</span><br><span class="line">处理器架构类型，常见的定义如下：</span><br><span class="line">EM_386		Intel <span class="number">386</span>架构（实际上就是<span class="number">32</span>位的x86架构）</span><br><span class="line">EM_X86_64	Amd x86<span class="number">-64</span>架构</span><br><span class="line">EM_ARM		ARM架构（包括thumb,thumb2）</span><br><span class="line">EM_AARCH64	ARM64架构</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另外，ELF header 还指明了 program header table 与 section header table 两个表在文件中的偏移位置、条目个数、条目大小。</p>
<p>这两个表的位置和长度随着 section&#x2F;segment 的个数而变化，而 ELF header 总是位于文件最开头，且长度固定。</p>
<p>如果想要访问 program header table 和 section header table 中的信息，必须通过 ELF header 来找到它们在文件中的确切位置。</p>
<p>Program header table 主要描述了将哪一个或哪几个 section 组织为一个 segment，以及各个 segment 的描述信息。</p>
<blockquote>
<p>ELF 程序头是对二进制文件中段的描述，是程序装载必需的一部分。段（segment）是在内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。可以通过引用原始 ELF 头中名为 e_phoff（程序头表偏移量）的偏移量来得到程序头表，</p>
</blockquote>
<p>Section header table 描述了 ELF 文件中所有的 section，以及每个 section 的类型、长度等描述信息。</p>
<blockquote>
<p>节，不是段。段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。节头对于程序的执行来说不是必需的，没有节头表，程序仍可以正常执行，因为节头表没有对程序的内存布局进行描述，对程序内存布局的描述是程序头表的任务。节头是对程序头的补充。readelf –l 命令可以显示一个段对应有哪些节，可以很直观地看到节和段之间的关系。</p>
<p>Section header table 中并不存储每个 section 的名称。所有 section 的名称全部存储在一个名为 section header string table 的 section 中，名称之间用 <code>\0</code> 分隔。在 ELF header 中，记录了该 section 在 section header table 中的索引。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/liuluhua/GitHubImageBed/main/PicGo/2024/05/06/20240506115137.png?token=AFPOA6C6WKPDTVD27EK6ZDLGHBKAO" alt="image"></p>
<h2 id="1-2-功能模块"><a href="#1-2-功能模块" class="headerlink" title="1.2 功能模块"></a>1.2 功能模块</h2><p>针对以上理解，加壳程序的功能有以下：</p>
<ul>
<li>针对 ELF 文件，通过字段异或&#x2F;【RSA 加密(可选)】的方式进行覆写 ELF header&#x2F;【Program&#x2F;Section header table(可选)】</li>
<li>ELF 开头修改为 HMAVIC【加密方式字段】【加密内容字段】ELF</li>
<li>【可选】单独进行末尾追加签名，确认为 HMAVIC 程序</li>
</ul>
<h2 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN_OFFSET 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN_CONTENT <span class="string">&quot;HMAVIC&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN_LENGTH 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">xxd -l <span class="number">100</span> a.run</span><br><span class="line"></span><br><span class="line">readelf -h a.run</span><br></pre></td></tr></table></figure>

<h1 id="2-内核密钥保留服务"><a href="#2-内核密钥保留服务" class="headerlink" title="2. 内核密钥保留服务"></a>2. 内核密钥保留服务</h1><h2 id="2-1-密钥配置文件"><a href="#2-1-密钥配置文件" class="headerlink" title="2.1 密钥配置文件"></a>2.1 密钥配置文件</h2><p><strong>配置文件内容</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表示这个配置文件包含一系列的请求信息，用于生成证书请求</span></span><br><span class="line">[ req ]</span><br><span class="line"><span class="comment"># 指定生成的 RSA 密钥长度为 2048 位</span></span><br><span class="line">default_bits = 2048</span><br><span class="line"><span class="comment"># 指定用于请求的分辨名 (DN)，在 [ req_distinguished_name ] 部分中定义</span></span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line"><span class="comment"># 禁用交互式提示，生成证书时不会要求用户输入</span></span><br><span class="line">prompt = no</span><br><span class="line"><span class="comment"># 指定字符编码为 UTF-8</span></span><br><span class="line">string_mask = utf8only</span><br><span class="line"><span class="comment"># 指定用于 X.509 扩展的配置，定义在 [ myexts ] 部分</span></span><br><span class="line">x509_extensions = myexts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了请求的分辨名信息，包括组织 (O)、通用名 (CN) 和电子邮件地址 (emailAddress)</span></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line"><span class="comment"># 指定组织名为hmavic</span></span><br><span class="line">O = hmavic</span><br><span class="line"><span class="comment"># 指定通用名为 verification for hmavic</span></span><br><span class="line">CN = verification <span class="keyword">for</span> hmavic</span><br><span class="line"><span class="comment"># 指定电子邮件地址</span></span><br><span class="line">emailAddress = liuluhua7@gmail.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了 X.509 扩展信息，包括基本约束 (basicConstraints)、密钥用途 (keyUsage)、主题密钥标识符 (subjectKeyIdentifier) 和颁发者密钥标识符 (authorityKeyIdentifier)</span></span><br><span class="line">[ myexts ]</span><br><span class="line"><span class="comment"># 指定证书不是 CA 证书，即不具有颁发其他证书的权限</span></span><br><span class="line">basicConstraints=critical,CA:FALSE</span><br><span class="line"><span class="comment"># 指定密钥用途为数字签名</span></span><br><span class="line">keyUsage=digitalSignature</span><br><span class="line"><span class="comment"># 指定使用 SHA-1 哈希算法生成主题密钥标识符</span></span><br><span class="line">subjectKeyIdentifier=<span class="built_in">hash</span></span><br><span class="line"><span class="comment"># 指定使用密钥标识符生成颁发者密钥标识符</span></span><br><span class="line">authorityKeyIdentifier=keyid</span><br></pre></td></tr></table></figure>

<p><strong>生成密钥并导入证书</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">openssl req -<span class="keyword">new</span> -nodes -utf8 -sha256 -days <span class="number">36500</span> -batch -x509 -config x509.hm.genkey -outform PEM -out kernel_key.pem -keyout kernel_key.pem</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 OpenSSL 工具生成一个配置信息由 x509.hm.genkey 指定的自签名的 X.509 格式证书。</p>
<p>以下是命令中每个选项的解释：</p>
<p><strong>openssl req</strong>：使用 OpenSSL 工具中的 req 子命令，用于处理证书请求和生成证书。<br><strong>-new</strong>：指定创建一个新的证书请求。<br><strong>-nodes</strong>：不加密生成的私钥，即不设置私钥密码。<br><strong>-utf8</strong>：指定使用 UTF-8 编码。<br><strong>-sha256</strong>：指定使用 SHA-256 哈希算法生成证书签名。<br><strong>-days 36500</strong>：指定证书的有效期为 36500 天<br><strong>-batch</strong>：在生成证书请求时不会提示用户输入任何信息，而是使用配置文件中指定的默认值。<br><strong>-x509</strong>：指定生成自签名的 X.509 格式证书，而不是生成证书请求。<br><strong>-config x509.genkey</strong>：指定使用配置文件 x509.genkey 中的配置信息来生成证书。<br><strong>-outform PEM</strong>：指定输出的证书格式为 PEM 格式。<br><strong>-out kernel_key.pem</strong>：指定输出的证书文件名为 kernel_key.pem。<br><strong>-keyout kernel_key.pem</strong>：指定输出的私钥文件名为 kernel_key.pem，因为在本例中私钥和证书是一对的。</p>
</blockquote>
<h2 id="2-2-编译内核"><a href="#2-2-编译内核" class="headerlink" title="2.2 编译内核"></a>2.2 编译内核</h2><p>修改 <code>kernel/arch/arm64/configs/OK3568-C-linux_defconfig</code></p>
<p>在文件最后增加以下内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Certificates <span class="keyword">for</span> signature checking</span><br><span class="line">#</span><br><span class="line">CONFIG_SYSTEM_TRUSTED_KEYRING=y</span><br><span class="line">CONFIG_SYSTEM_TRUSTED_KEYS=<span class="string">&quot;certs/kernel_key.pem&quot;</span></span><br></pre></td></tr></table></figure>

<p>进入顶层目录执行 <code>./build.sh kernel</code></p>
<p><img src="https://raw.githubusercontent.com/liuluhua/GitHubImageBed/main/PicGo/2024/05/06/20240506115155.png?token=AFPOA6GHV6TWQIBHPSK54HTGHBKBS" alt="image-20240425140707918"></p>
<p>在编译过程中，应该可以看到如下信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">EXTRACT_CERTS   &lt;PATH_TO_CERT&gt;/kernel_key.pem</span><br><span class="line">AS      certs/system_certificates.o</span><br><span class="line">AR      certs/built-in.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>待内核编译完成，烧录内核至开发板，查看 proc 文件系统中的 <code>/proc/keys</code>。如果能够看到自行生成的密钥，那么说明该密钥已经被放置于内核的系统密钥环中。</p>
<h1 id="3-内核模块脱壳并运行"><a href="#3-内核模块脱壳并运行" class="headerlink" title="3. 内核模块脱壳并运行"></a>3. 内核模块脱壳并运行</h1><h2 id="3-1-功能模块"><a href="#3-1-功能模块" class="headerlink" title="3.1 功能模块"></a>3.1 功能模块</h2><p>针对加壳进行编写脱壳模块功能如下：</p>
<ul>
<li>内核模块安装时进行 RSA 核验，核验通过则安装模块，否则卸载模块</li>
<li>注入到内核 ELF 运行之前，对 HMAVIC 开头的 ELF 进行拦截</li>
<li>根据加密方式和内容进行解密处理，解密完成后覆写内容交由 Linux 内核处理</li>
<li>【可选】针对未签名程序，拒绝执行</li>
</ul>
<h2 id="3-2-将解密模块嵌入内核中"><a href="#3-2-将解密模块嵌入内核中" class="headerlink" title="3.2 将解密模块嵌入内核中"></a>3.2 将解密模块嵌入内核中</h2><p>我们为 ELF 的签名与验证生成了一对 <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> 公私钥，将公私钥以符合 X.509 标准的方式导入到一个 PEM 编码的文件中。通过上述机制，可以将文件中的公钥证书编译到内核的系统密钥环上。这样，在 <a href="https://mrdrivingduck.gitbook.io/linux-elf-sv/group-1-kernel-signature-verification/chapter-1-binary-execution-procedure#15-dui-elf-wen-jian-jin-hang-qian-ming-yan-zheng-de-si-lu">ELF 签名验证模块</a> 中，可以通过使用系统密钥环中的公钥证书，对 ELF 文件中的签名信息进行验证。</p>
<p>首先，我们对 Linux 内核中已有的 <a href="https://www.kernel.org/doc/html/v4.15/admin-guide/module-signing.html">内核模块签名</a> 验证机制的代码进行了分析。在内核源代码目录 <code>certs/system_keyring.c</code> 中，定义了内核内置的受信密钥：</p>
<p>certs&#x2F;system_keyring.c</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">key</span> *builtin_trusted_keys;</span><br></pre></td></tr></table></figure>

<p>但由于这个变量没有被声明为 <code>extern</code>，因此无法在其它内核代码中直接引用这个变量。但是在这个源文件中，开放了 <code>verify_pkcs7_signature()</code> 函数，使得其它内核代码能够通过这个函数，间接使用内置密钥环的签名验证功能：</p>
<p>certs&#x2F;system_keyring.c</p>
<p>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * verify_pkcs7_signature - Verify a PKCS#7-based signature on system data.</span></span><br><span class="line"><span class="comment"> * @data: The data to be verified (NULL if expecting internal data).</span></span><br><span class="line"><span class="comment"> * @len: Size of @data.</span></span><br><span class="line"><span class="comment"> * @raw_pkcs7: The PKCS#7 message that is the signature.</span></span><br><span class="line"><span class="comment"> * @pkcs7_len: The size of @raw_pkcs7.</span></span><br><span class="line"><span class="comment"> * @trusted_keys: Trusted keys to use (NULL for builtin trusted keys only,</span></span><br><span class="line"><span class="comment"> *					(void *)1UL for all trusted keys).</span></span><br><span class="line"><span class="comment"> * @usage: The use to which the key is being put.</span></span><br><span class="line"><span class="comment"> * @view_content: Callback to gain access to content.</span></span><br><span class="line"><span class="comment"> * @ctx: Context for callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">verify_pkcs7_signature</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">const</span> <span class="type">void</span> *raw_pkcs7, <span class="type">size_t</span> pkcs7_len,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="keyword">struct</span> key *trusted_keys,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="keyword">enum</span> key_being_used_for usage,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">int</span> (*view_content)(<span class="type">void</span> *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">					       <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">					       <span class="type">size_t</span> asn1hdrlen),</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在内核代码中，通过 <code>#include &lt;linux/verification.h&gt;</code> 使用该函数时，输入 <strong>签名数据</strong> 与 <strong>被签名数据</strong> 的 <strong>缓冲区内存地址</strong> 和 <strong>缓冲区长度</strong>，就能够使用内置密钥完成签名认证。因此，<a href="https://mrdrivingduck.gitbook.io/linux-elf-sv/group-1-kernel-signature-verification/chapter-1-binary-execution-procedure#15-dui-elf-wen-jian-jin-hang-qian-ming-yan-zheng-de-si-lu">ELF 签名验证模块</a> 只要能够从 ELF 文件中正确提取 <a href="https://tools.ietf.org/html/rfc2315">PKCS #7</a> 格式的签名数据，以及签名保护的目标数据，就可以通过这个函数验证数字签名是否正确。</p>
<p>模块代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">编译 Makefile</span><br><span class="line"></span><br><span class="line">```<span class="function">makefile</span></span><br><span class="line"><span class="function"><span class="title">ifneq</span> <span class="params">($(KERNELRELEASE),)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">obj-m :=</span> binfmt_elf_signature_verification.o</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"># KDIR := ../</span><br><span class="line">#KDIR := /lib/modules/$(shell uname -r)/build</span><br><span class="line">KDIR := /home/forlinx/Desktop/OK3568-linux-source/kernel</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        $(MAKE) -C $(KDIR) M=$(PWD) modules</span><br><span class="line">clean:</span><br><span class="line">        $(RM) *.ko</span><br><span class="line">        $(RM) *.o</span><br><span class="line">        $(RM) *.mod*</span><br><span class="line">        $(RM) *.symvers</span><br><span class="line">        $(RM) *.order</span><br><span class="line">        $(RM) .*.mk</span><br><span class="line">        $(RM) .*.cmd</span><br><span class="line">        $(RM) -r .tmp_versions</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make ARCH=arm64 CROSS_COMPILE=/home/forlinx/Desktop/OK3568-linux-source/buildroot/output/OK3568/host/bin/aarch64-buildroot-linux-gnu-</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mrdrivingduck.gitbook.io/linux-elf-sv">Linux ELF 文件数据完整性保护系统</a></p>
<h1 id="附录-A-OpenSSL-进行密钥生成验证"><a href="#附录-A-OpenSSL-进行密钥生成验证" class="headerlink" title="附录 A OpenSSL 进行密钥生成验证"></a>附录 A OpenSSL 进行密钥生成验证</h1><h2 id="A1-私钥"><a href="#A1-私钥" class="headerlink" title="A1 私钥"></a>A1 私钥</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genpkey -algorithm RSA -out private_key.pem -aes256</span><br></pre></td></tr></table></figure>

<p>将生成一个 AES256 加密的 RSA 私钥，并将其保存到名为 <code>private_key.pem</code> 的文件中。</p>
<p>生成时需要密码，密码为 HmAvic@123</p>
<h2 id="A2-公钥"><a href="#A2-公钥" class="headerlink" title="A2 公钥"></a>A2 公钥</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">openssl rsa -in private_key.pem -pubout -out public_key.pem</span><br></pre></td></tr></table></figure>

<p>将从私钥文件 <code>private_key.pem</code> 中提取公钥，并将其保存到名为 <code>public_key.pem</code> 的文件中。</p>
<h2 id="A3-签名"><a href="#A3-签名" class="headerlink" title="A3 签名"></a>A3 签名</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 -sign private_key.pem -out signature.bin your_elf_file</span><br></pre></td></tr></table></figure>

<p>使用 SHA-256 算法对 <code>your_elf_file</code> 进行签名，并将签名结果保存到 <code>signature.bin</code> 文件中。</p>
<h2 id="A4-签名认证"><a href="#A4-签名认证" class="headerlink" title="A4 签名认证"></a>A4 签名认证</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 -verify public_key.pem -signature signature.bin your_elf_file</span><br></pre></td></tr></table></figure>

<p>使用公钥 <code>public_key.pem</code> 验证 <code>signature.bin</code> 文件中的签名是否与 <code>your_elf_file</code> 匹配。</p>
<h2 id="A5-签名和认证代码实现"><a href="#A5-签名和认证代码实现" class="headerlink" title="A5 签名和认证代码实现"></a>A5 签名和认证代码实现</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/sha.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 函数声明</span></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">sign_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file_path, <span class="type">const</span> <span class="type">char</span>* private_key_path, <span class="type">const</span> <span class="type">char</span>* signature_path)</span></span>;</span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">verify_signature</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file_path, <span class="type">const</span> <span class="type">char</span>* signature_path, <span class="type">const</span> <span class="type">char</span>* public_key_path)</span></span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* file_path = <span class="string">&quot;your_elf_file&quot;</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* private_key_path = <span class="string">&quot;private_key.pem&quot;</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* public_key_path = <span class="string">&quot;public_key.pem&quot;</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* signature_path = <span class="string">&quot;signature.bin&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 签名文件</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">sign_file</span>(file_path, private_key_path, signature_path) != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to sign file.\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;File signed successfully.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 验证签名</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">verify_signature</span>(file_path, signature_path, public_key_path) != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Signature verification failed.\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Signature verified successfully.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">sign_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file_path, <span class="type">const</span> <span class="type">char</span>* private_key_path, <span class="type">const</span> <span class="type">char</span>* signature_path)</span> </span>&#123;</span><br><span class="line">   FILE* file = <span class="built_in">fopen</span>(file_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to open file.\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 读取 ELF 文件内容</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">   <span class="type">size_t</span> bytes_read;</span><br><span class="line">   SHA256_CTX sha256;</span><br><span class="line">   <span class="built_in">SHA256_Init</span>(&amp;sha256);</span><br><span class="line">   <span class="keyword">while</span> ((bytes_read = <span class="built_in">fread</span>(buffer, <span class="number">1</span>, BUF_SIZE, file)) != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">SHA256_Update</span>(&amp;sha256, buffer, bytes_read);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> hash[SHA256_DIGEST_LENGTH];</span><br><span class="line">   <span class="built_in">SHA256_Final</span>(hash, &amp;sha256);</span><br><span class="line">   <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 加载私钥</span></span><br><span class="line">   FILE* private_key_file = <span class="built_in">fopen</span>(private_key_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!private_key_file) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to open private key file.\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   RSA* rsa = <span class="built_in">PEM_read_RSAPrivateKey</span>(private_key_file, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="built_in">fclose</span>(private_key_file);</span><br><span class="line">   <span class="keyword">if</span> (!rsa) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to load private key.\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对 ELF 文件哈希进行签名</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> signature[BUF_SIZE];</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> signature_length;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">RSA_sign</span>(NID_sha256, hash, SHA256_DIGEST_LENGTH, signature, &amp;signature_length, rsa)) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to sign hash.\n&quot;</span>);</span><br><span class="line">       <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将签名写入文件</span></span><br><span class="line">   FILE* signature_file = <span class="built_in">fopen</span>(signature_path, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!signature_file) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to create signature file.\n&quot;</span>);</span><br><span class="line">       <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">fwrite</span>(signature, <span class="number">1</span>, signature_length, signature_file);</span><br><span class="line">   <span class="built_in">fclose</span>(signature_file);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">verify_signature</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file_path, <span class="type">const</span> <span class="type">char</span>* signature_path, <span class="type">const</span> <span class="type">char</span>* public_key_path)</span> </span>&#123;</span><br><span class="line">   FILE* file = <span class="built_in">fopen</span>(file_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to open file.\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 读取 ELF 文件内容</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">   <span class="type">size_t</span> bytes_read;</span><br><span class="line">   SHA256_CTX sha256;</span><br><span class="line">   <span class="built_in">SHA256_Init</span>(&amp;sha256);</span><br><span class="line">   <span class="keyword">while</span> ((bytes_read = <span class="built_in">fread</span>(buffer, <span class="number">1</span>, BUF_SIZE, file)) != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">SHA256_Update</span>(&amp;sha256, buffer, bytes_read);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> hash[SHA256_DIGEST_LENGTH];</span><br><span class="line">   <span class="built_in">SHA256_Final</span>(hash, &amp;sha256);</span><br><span class="line">   <span class="built_in">fclose</span>(file);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 加载公钥</span></span><br><span class="line">   FILE* public_key_file = <span class="built_in">fopen</span>(public_key_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!public_key_file) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to open public key file.\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   RSA* rsa = <span class="built_in">PEM_read_RSA_PUBKEY</span>(public_key_file, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="built_in">fclose</span>(public_key_file);</span><br><span class="line">   <span class="keyword">if</span> (!rsa) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to load public key.\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 读取签名文件</span></span><br><span class="line">   FILE* signature_file = <span class="built_in">fopen</span>(signature_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!signature_file) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to open signature file.\n&quot;</span>);</span><br><span class="line">       <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> signature[BUF_SIZE];</span><br><span class="line">   <span class="type">size_t</span> signature_length = <span class="built_in">fread</span>(signature, <span class="number">1</span>, BUF_SIZE, signature_file);</span><br><span class="line">   <span class="built_in">fclose</span>(signature_file);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 验证签名</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">RSA_verify</span>(NID_sha256, hash, SHA256_DIGEST_LENGTH, signature, signature_length, rsa) != <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Signature verification failed.\n&quot;</span>);</span><br><span class="line">       <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="附录-B-如何实现对程序的加解密"><a href="#附录-B-如何实现对程序的加解密" class="headerlink" title="附录 B 如何实现对程序的加解密"></a>附录 B 如何实现对程序的加解密</h1><p>公钥加密，私钥解密</p>
<ul>
<li>方式一：不同设备内核烧录不同的私钥进行解密</li>
<li>方式二：不同设备内核烧录相同的私钥进行解密</li>
</ul>
<h2 id="B1-生成-RSA-密钥对"><a href="#B1-生成-RSA-密钥对" class="headerlink" title="B1 生成 RSA 密钥对"></a>B1 生成 RSA 密钥对</h2><p>首先，你需要生成 RSA 密钥对，包括私钥和公钥。下面是一个示例命令来生成 RSA 密钥对：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">openssl genpkey -algorithm RSA -out private_key.pem -aes256</span><br><span class="line">openssl rsa -pubout -in private_key.pem -out public_key.pem</span><br></pre></td></tr></table></figure>

<p>这个命令会生成一个 RSA 私钥文件 private_key.pem，并在生成的同时使用 AES256 算法对私钥进行加密保护。然后从私钥中提取公钥，并保存到 public_key.pem 文件中。</p>
<h2 id="B2-使用-RSA-加密文件"><a href="#B2-使用-RSA-加密文件" class="headerlink" title="B2 使用 RSA 加密文件"></a>B2 使用 RSA 加密文件</h2><p>要使用 RSA 公钥加密文件，你可以执行以下命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">openssl rsautl -encrypt -pubin -inkey public_key.pem -in plaintext.txt -out encrypted.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会使用公钥文件 public_key.pem 对明文文件 plaintext.txt 进行加密，并将加密后的结果输出到 encrypted.txt 文件中。</p>
<h2 id="B3-使用-RSA-解密文件"><a href="#B3-使用-RSA-解密文件" class="headerlink" title="B3 使用 RSA 解密文件"></a>B3 使用 RSA 解密文件</h2><p>要使用 RSA 私钥解密文件，你可以执行以下命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">openssl rsautl -decrypt -inkey private_key.pem -in encrypted.txt -out decrypted.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会使用私钥文件 private_key.pem 对加密文件 encrypted.txt 进行解密，并将解密后的结果输出到 decrypted.txt 文件中。</p>
<ol>
<li><p>   如何向内核中添加密钥</p>
</li>
<li><p>   如何在程序中读取密钥</p>
</li>
</ol>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title>最大打开文件数量</title>
    <url>/2024/08/12/0-%E5%B9%B3%E5%8F%B0-Linux-%E6%96%87%E4%BB%B6-%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p>报错：Can’t open so many files 或者 too many open files</p>
<p>涉及参数</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
<th align="center">默认值</th>
<th align="center">查询语句</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nofile</td>
<td align="center">单个进程的最大打开文件数</td>
<td align="center">1024</td>
<td align="center">ulimit -n 或者 cat &#x2F;proc&#x2F;pid&#x2F;limits</td>
</tr>
<tr>
<td align="center">nr_open</td>
<td align="center">单个进程可分配的最大文件数</td>
<td align="center">1024*1024&#x3D;1048576</td>
<td align="center">cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open</td>
</tr>
<tr>
<td align="center">file-max</td>
<td align="center">系统内核一共可以打开的最大值</td>
<td align="center">199708</td>
<td align="center">cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</td>
</tr>
</tbody></table>
<p>nofile 是 linux 操作系统对一个进程打开的文件句柄数量的限制（也包含打开的套接字数量）</p>
<p>file-max 是设置系统所有进程一共可以打开的文件数量 。同时一些程序可以通过 setrlimit 调用，设置每个进程的限制。</p>
<h1 id="nofile"><a href="#nofile" class="headerlink" title="nofile"></a>nofile</h1><h2 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ulimit -SHn <span class="number">1024000</span></span><br></pre></td></tr></table></figure>

<p>分软限制和硬限制，加-H 就是硬限制，加-S 就是软限制。默认显示的是软限制，如果运行 ulimit 命令修改时没有加上-H 或-S，就是两个参数一起改变。</p>
<p>硬限制就是实际的限制，而软限制是警告限制，它只会给出警告。</p>
<h2 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408120927471.png"></p>
<p><code>* 表示所用的用户</code></p>
<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>修改 <code>/etc/profile</code> 增加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ulimit -SHn <span class="number">128000</span></span><br></pre></td></tr></table></figure>

<p>&#x2F;etc&#x2F;profile 是 Linux 系统中的一个重要配置文件，主要用于设置系统级的环境变量和启动程序。该文件在用户登录时被执行，适用于所有用户。</p>
<h1 id="系统总限制"><a href="#系统总限制" class="headerlink" title="系统总限制"></a>系统总限制</h1><h2 id="临时修改-1"><a href="#临时修改-1" class="headerlink" title="临时修改"></a>临时修改</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1200000</span> &gt; /proc/sys/fs/nr_open</span><br><span class="line">echo <span class="number">200000</span> &gt; /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure>

<h2 id="永久修改-1"><a href="#永久修改-1" class="headerlink" title="永久修改"></a>永久修改</h2><h3 id="一-1"><a href="#一-1" class="headerlink" title="一"></a>一</h3><p>在文件&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open 中加入如下代码：（1200000 为修改的参数值）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fs.nr_open=<span class="number">1200000</span></span><br></pre></td></tr></table></figure>

<p>在文件 &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 中插入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fs.file-max=<span class="number">200000</span></span><br></pre></td></tr></table></figure>

<p>保存并执行 reboot 重启服务器。</p>
<h3 id="二-1"><a href="#二-1" class="headerlink" title="二"></a>二</h3><p>在&#x2F;etc&#x2F;sysctl.conf 中设置 fs.nr_open&#x3D; 1200000 fs.file-max&#x3D;200000，然后执行 sysctl -p，使配置生效。无需重启。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202408120938209.png" alt="image.png"></p>
<h1 id="查看系统下各个进程打开的文件描述符数量"><a href="#查看系统下各个进程打开的文件描述符数量" class="headerlink" title="查看系统下各个进程打开的文件描述符数量"></a>查看系统下各个进程打开的文件描述符数量</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lsof -n |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|sort|uniq -c |sort -nr</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#匹配PID为<span class="number">696</span>的进程</span><br><span class="line">lsof -fp | grep <span class="number">696</span> | wc -l</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>文件</category>
      </categories>
  </entry>
  <entry>
    <title>ELF文件分析</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-Linux-%E7%A8%8B%E5%BA%8F-ELF%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>ELF 全称 “Executable and Linkable Format”，即可执行可链接文件格式，目前常见的 Linux、 Android 可执行文件、共享库（.so）、目标文件（ .o）以及 Core 文件（吐核）均为此格式。</p>
<h1 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a><strong>文件布局</strong></h1><p>常见的 ELF 文件大致结构如下：</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407121503687.png" alt="image.png"></p>
<p>常见的 ELF 格式如上图所示，左边为链接视图，右边为执行视图。从大局上看，ELF 文件主要分为 3 个部分:</p>
<ul>
<li>ELF Header</li>
<li>Section Header Table</li>
<li>Program Header Table</li>
</ul>
<p>其中，ELF Header 是文件头，包含了固定长度的文件信息；Section Header Table 则包含了链接时所需要用到的信息；Program Header Table 中包含了运行时加载程序所需要的信息。</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407121511149.png" alt="pic.1714466896000tz0d56.png"></p>
<h2 id="链接视图"><a href="#链接视图" class="headerlink" title="链接视图"></a>链接视图</h2><p>静态链接器（即编译后参与生成最终 ELF 过程的链接器，如 ld ）会以链接视图解析 ELF。编译时生成的 .o（目标文件）以及链接后的 .so （共享库）均可通过链接视图解析，链接视图可以没有段表（如目标文件不会有段表）。</p>
<h2 id="执行视图"><a href="#执行视图" class="headerlink" title="执行视图"></a>执行视图</h2><p>动态链接器（即加载器，如 x86 架构 linux 下的 &#x2F;lib&#x2F;ld-linux.so.2 或者安卓系统下的 &#x2F;system&#x2F;linker 均为动态链接器）会以执行视图解析 ELF 并动态链接，执行视图可以没有节表。</p>
<h1 id="文件头-ELF-Header"><a href="#文件头-ELF-Header" class="headerlink" title="文件头 ELF Header"></a><strong>文件头 ELF Header</strong></h1><p>ELF 的结构声明位于系统头文件 elf.h 中，ELF 格式分为 32 位与 64 位两种，除了重定位类型稍有区别，其它大致相同，为了简化描述，后续说明将省略 32&#x2F;64 字样。</p>
<p>ELF Header 的声明如下 :</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">    Elf_Half		e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">    Elf_Half		e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">    Elf_Word	        e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">    Elf_Addr		e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">    Elf_Off		e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">    Elf_Off		e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">    Elf_Word	        e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">    Elf_Half		e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">    Elf_Half		e_phentsize;		<span class="comment">/* Program header table entry size */</span></span><br><span class="line">    Elf_Half		e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">    Elf_Half		e_shentsize;		<span class="comment">/* Section header table entry size */</span></span><br><span class="line">    Elf_Half		e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">    Elf_Half		e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf_Ehdr;</span><br></pre></td></tr></table></figure>

<p>注释都很清楚了，挑一些比较重要的来说。其中 e_type 表示 ELF 文件的类型，有以下几种:</p>
<ul>
<li>ET_NONE: 未知类型</li>
<li>ET_REL: 可重定向类型(relocatable)，通常是我们编译的 <code>*.o</code> 文件</li>
<li>ET_EXEC: 可执行类型(executable)，静态编译的可执行文件</li>
<li>ET_DYN: 共享对象(shared object)，动态编译的可执行文件或者动态库 <code>*.so</code></li>
<li>ET_CORE: coredump 文件</li>
</ul>
<p>e_entry 是程序的入口虚拟地址，注意不是 main 函数的地址，而是.text 段的首地址 <code>_start</code>。当然这也要求程序本身非 PIE(-no-pie)编译的且 ASLR 关闭的情况下，对于非 ET_EXEC 类型通常并不是实际的虚拟地址值。</p>
<p>其他的字段大多数是指定 Section Header(e_sh)和 Program Header(e_ph)的信息。Section&#x2F;Program Header Table 本身可以看做是数组结构，ELF 头中的信息指定对应 Table 数组的位置、长度、元素大小信息。最后一个 e_shstrndx 表示的是 section table 中的第 e_shstrndx 项元素，保存了所有 section table 名称的字符串信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e_ident</span><br><span class="line"></span><br><span class="line">包含了Maigc Number和其它信息，共<span class="number">16</span>字节。</span><br><span class="line"><span class="number">0</span>~<span class="number">3</span>：前<span class="number">4</span>字节为Magic Number，固定为ELFMAG。</span><br><span class="line"><span class="number">4</span>（EI_CLASS）：ELFCLASS32代表是<span class="number">32</span>位ELF，ELFCLASS64 代表<span class="number">64</span>位ELF。</span><br><span class="line"><span class="number">5</span>（EI_DATA）：ELFDATA2LSB代表小端，ELFDATA2MSB代表大端。</span><br><span class="line"><span class="number">6</span>（EI_VERSION）：固定为EV_CURRENT（<span class="number">1</span>）。</span><br><span class="line"><span class="number">7</span>（EI_OSABI）：操作系统ABI标识（实际未使用）。</span><br><span class="line"><span class="number">8</span>（EI_ABIVERSION）：ABI版本（实际 未使用）。</span><br><span class="line"><span class="number">9</span>~<span class="number">15</span>：对齐填充，无实际意义。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e_type</span><br><span class="line"></span><br><span class="line">ELF的文件类型，定义如下：</span><br><span class="line">ET_REL		可重定位文 件（如目标文件）</span><br><span class="line">ET_EXEC	        可执行文件（可直接执行的文件）</span><br><span class="line">DT_DYN	        共享目标文件（如SO库）</span><br><span class="line">DT_CORE	        Core文件（吐核文件）</span><br><span class="line">注：GCC使用编译选项 -pie 编译的可执行文件实际 也是DT_DYN类型。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e_machine</span><br><span class="line"></span><br><span class="line">处理器架构类型，常见的定义如下：</span><br><span class="line">EM_386		Intel <span class="number">386</span>架构（实际上就是<span class="number">32</span>位的x86架构）</span><br><span class="line">EM_X86_64	Amd x86<span class="number">-64</span>架构</span><br><span class="line">EM_ARM		ARM架构（包括thumb,thumb2）</span><br><span class="line">EM_AARCH64	ARM64架构</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>e_verison: 文件版本，目前常见的 ELF 文件版本均为 EV_CURRENT（1）。</p>
<p>e_entry: 入口虚拟地址。</p>
<p>e_phoff: 段表文件偏移。</p>
<p>e_shoff: 节表文件偏移。</p>
<p>e_flags: 处理器特定的标志，一般为 0。</p>
<p>e_ehsize: Elf_Header 的大小（字节）</p>
<p>e_phentsize: 段头（Program Header）的大小（字节）。</p>
<p>e_phnum: 段的数量。</p>
<p>e_shentsize: 节头（Section Header）的大小（字节）。</p>
<p>e_shnum: 字的数量。</p>
<p>e_shstrndx: 节字符串表的节索引。</p>
<h1 id="Section-Header"><a href="#Section-Header" class="headerlink" title="Section Header"></a>Section Header</h1><p>section header table 是一个数组结构，这个数组的位置在 e_shoff 处，共有 e_shnum 个元素(即 section)，每个元素的大小为 e_shentsize 字节。每个元素的结构如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word	sh_name;		<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf32_Word	sh_type;		<span class="comment">/* Section type */</span></span><br><span class="line">  Elf32_Word	sh_flags;		<span class="comment">/* Section flags */</span></span><br><span class="line">  Elf32_Addr	sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf32_Off	sh_offset;		<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf32_Word	sh_size;		<span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf32_Word	sh_link;		<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf32_Word	sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf32_Word	sh_addralign;		<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf32_Word	sh_entsize;		<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<p>其中 sh_name 是该 section 的名称，用一个 word 表示其在字符表中的偏移，字符串表(.shstrtab)就是上面说到的第 e_shstrndx 个元素。ELF 文件中经常使用这种偏移表示方式，可以方便组织不同区段之间的引用。</p>
<p>sh_type 表示本 section 的类型，SPEC 中定义了几十个类型，列举其中一些如下:</p>
<ul>
<li>SHT_NULL: 表示该 section 无效，通常第 0 个 section 为该类型</li>
<li>SHT_PROGBITS: 表示该 section 包含由程序决定的内容，如.text、.data、.plt、.go</li>
<li>SHT_SYMTAB&#x2F;SHT_DYNSYM: 表示该 section 中包含符号表，如.symtab、.dynsym</li>
<li>SHT_DYNAMIC: 表示该 section 中包含动态链接阶段所需要的信息</li>
<li>SHT_STRTAB: 表示该 section 中包含字符串信息，如.strtab、.shstrtab</li>
<li>SHT_REL&#x2F;SHT_RELA: 包含重定向项信息</li>
</ul>
<p>虽然每个 section header 的大小一样(e_shentsize 字节)，但不同类型的 section 有不同的内容，内容部分由这几个字段表示:</p>
<ul>
<li>sh_offset: 内容起始地址相对于文件开头的偏移</li>
<li>sh_size: 内容的大小</li>
<li>sh_entsize: 有的内容是也是一个数组，这个字段就表示数组的元素大小</li>
</ul>
<p>与运行时信息相关的字段为:</p>
<ul>
<li>sh_addr: 如果该 section 需要在运行时加载到虚拟内存中，该字段就是对应 section 内容(第一个字节)的虚拟地址</li>
<li>sh_addralign: 内容地址的对齐，如果有的话需要满足 sh_addr % sh_addralign &#x3D; 0</li>
<li>sh_flags: 表示所映射内容的权限，可根据 SHF_WRITE&#x2F;ALLOC&#x2F;EXECINSTR 进行组合</li>
</ul>
<p>另外两个字段 sh_link 和 sh_info 的含义根据 section 类型的不同而不同，如下表所示:</p>
<p><img src="https://raw.staticdn.net/liuluhua/liuluhua.github.io/ImageBed/PicGo/202407121518093.png" alt="image.png"></p>
<p>至于不同类型的 section，有的是保存符号表，有的是保存字符串，这也是 ELF 表现出拓展性和复杂性的地方，因此需要在遇到具体问题的时候查看文档去进行具体分析。</p>
<h1 id="Program-Header"><a href="#Program-Header" class="headerlink" title="Program Header"></a>Program Header</h1><p>program header table 用来保存程序加载到内存中所需要的信息，使用段(segment)来表示。与 section header table 类似，同样是数组结构。数组的位置在偏移 e_phoff 处，每个元素(segment header)的大小为 e_phentsize，共有 e_phnum 个元素。单个 segment header 的结构如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word	p_type;			<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf32_Off	p_offset;		  <span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf32_Addr	p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf32_Addr	p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf32_Word	p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf32_Word	p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf32_Word	p_flags;		<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf32_Word	p_align;		<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>

<p>既然 program header 的作用是提供用于初始化程序进程的段信息，那么下面这些字段就是很直观的:</p>
<ul>
<li>p_offset: 该 segment 的数据在文件中的偏移地址(相对文件头)</li>
<li>p_vaddr: segment 数据应该加载到进程的虚拟地址</li>
<li>p_paddr: segment 数据应该加载到进程的物理地址(如果对应系统使用的是物理地址)</li>
<li>p_filesz: 该 segment 数据在文件中的大小</li>
<li>p_memsz: 该 segment 数据在进程内存中的大小。注意需要满足 p_memsz&gt;&#x3D;p_filesz，多出的部分初始化为 0，通常作为.bss 段内容</li>
<li>p_flags: 进程中该 segment 的权限(R&#x2F;W&#x2F;X)</li>
<li>p_align: 该 segment 数据的对齐，2 的整数次幂。即要求 p_offset % p_align &#x3D; p_vaddr。</li>
</ul>
<p>剩下的 p_type 字段，表示该 program segment 的类型，主要有以下几种:</p>
<ul>
<li>PT_NULL: 表示该段未使用</li>
<li>PT_LOAD: Loadable Segment，将文件中的 segment 内容映射到进程内存中对应的地址上。值得一提的是 SPEC 中说在 program header 中的多个 PT_LOAD 地址是按照虚拟地址递增排序的。</li>
<li>PT_DYNAMIC: 动态链接中用到的段，通常是 RW 映射，因为需要由 interpreter(ld.so)修复对应的的入口</li>
<li>PT_INTERP: 包含 interpreter 的路径，见下文</li>
<li>PT_HDR: 表示 program header table 本身。如果有这个 segment 的话，必须要在所有可加载的 segment 之前，并且在文件中不能出现超过一次。</li>
</ul>
<p>在不同的操作系统中还可能有一些拓展的类型，比如 PT_GNU_STACK、PT_GNU_RELRO 等，不一而足。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://refspecs.linuxfoundation.org/" target="_blank" rel="noopener noreferrer">Linux Foundation Referenced Specifications</a></li>
<li><a href="http://www.cs.yale.edu/homes/aspnes/pinewiki/attachments/ELF%2820%29format/ELF_format.pdf" target="_blank" rel="noopener noreferrer">Executable and Linkable Format (ELF)</a></li>
<li><a href="https://refspecs.linuxfoundation.org/elf/elf.pdf" target="_blank" rel="noopener noreferrer">Tool Interface Standard (TIS) Executable and Linking Format (ELF) Specification Version 1.2</a></li>
<li><a href="https://man7.org/linux/man-pages/man5/elf.5.html" target="_blank" rel="noopener noreferrer">elf(5) - format of Executable and Linking Format (ELF) files</a></li>
<li><a href="https://lwn.net/Articles/631631/" target="_blank" rel="noopener noreferrer">How programs get run: ELF binaries</a></li>
<li><a href="https://evilpan.com/2018/04/09/about-got-plt/" target="_blank" rel="noopener noreferrer">深入了解GOT,PLT和动态链接</a></li>
</ul>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>内存分布</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-Linux-%E7%A8%8B%E5%BA%8F-%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<h1 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h1><p>在 32 位操作系统中，地址空间的最大理论限制是 4GB&#x3D;2 的 32 次方。然而，这个地址空间并不完全可用给用户应用程序，因为操作系统自身也需要地址空间。在 32bit 的 OS 中，可执行文件 4G 内存分布分为: </p>
<ul>
<li>用户空间 app+C 库	3G</li>
<li>内核空间 驱动		1G</li>
</ul>
<h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p>通常，内核空间和硬件设备及驱动占用了高位的 1GB 地址空间，即从 0xC0000000 到 0xFFFFFFFF。这部分空间是操作系统用来管理系统资源和硬件设备的，用户态程序不能直接访问。</p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p>剩下的 3GB 地址空间，即从 0x00000000 到 0xBFFFFFFF，被分配给用户态应用程序。用户态应用程序的代码段、数据段、堆、栈和动态链接库（DLL）都在这部分地址空间内。</p>
<p>在这个 3GB 的用户空间中，内存分布通常如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">低地址</span><br><span class="line">+-----------------+</span><br><span class="line">|   .text 段      |    代码段:包含应用程序的可执行代码。一般从较低地址开始分配。</span><br><span class="line">+-----------------+</span><br><span class="line">|   .data 段      |    数据段:包含已初始化的全局变量和静态变量。</span><br><span class="line">+-----------------+</span><br><span class="line">|   .bss 段       |    包含未初始化的全局变量和静态变量。</span><br><span class="line">+-----------------+</span><br><span class="line">|   堆 (heap)     |    堆: 用户自定义空间，用于动态内存分配（如 malloc、<span class="keyword">new</span>）。 |                 |    堆一般从数据段之后的地址开始，向高地址方向增长。</span><br><span class="line">|(向高地址方向增长) |    用完手动释放</span><br><span class="line">+-----------------+</span><br><span class="line">|                 |</span><br><span class="line">|     空闲区域     |    共享库（DLLs）会被映射到进程的地址空间中，</span><br><span class="line">|                 |    通常在堆和栈之间的某个位置。</span><br><span class="line">+-----------------+</span><br><span class="line">|   栈 (stack)    |    栈: 局部变量，函数参数，函数结束自动释放</span><br><span class="line">|                 |    用于存储局部变量和函数调用信息。</span><br><span class="line">| (向低地址方向增长)|    栈一般从高地址开始，向低地址方向增长。</span><br><span class="line">+-----------------+</span><br><span class="line">高地址</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*C语言中数据的内存分配*/</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *p1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b;						<span class="comment">/*b在栈 */</span></span><br><span class="line">	<span class="type">char</span> s[] =<span class="string">&quot;abc&quot;</span>;			<span class="comment">/*s在栈，&quot;abc&quot;在常量区*/</span></span><br><span class="line">	<span class="type">char</span> *p2;					<span class="comment">/*p2在栈*/</span></span><br><span class="line">	<span class="type">char</span> *p3=<span class="string">&quot;123456&quot;</span>;			<span class="comment">/* 123456在常量区，p3 在栈 */</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> c=<span class="number">0</span>;				<span class="comment">/*可读可写数据段*/</span></span><br><span class="line">	p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);	<span class="comment">/*分配得来的 10个字节的区域在堆区*/</span></span><br><span class="line">	p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);	<span class="comment">/*分配得来的 20个字节的区域在堆区*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 从常量区的“Hello world”字符串复制到刚分配到的堆区 */</span></span><br><span class="line">	<span class="built_in">strcpy</span>(p1，“Hello World<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>程序加载</title>
    <url>/2024/07/12/0-%E5%B9%B3%E5%8F%B0-Linux-%E7%A8%8B%E5%BA%8F-%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>Linux 中分为用户态和内核态，执行 ELF 文件在用户态的表现就是执行 execve 系统调用，随后陷入内核进行处理。</p>
<h1 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h1><p>内核空间对 execve 的处理其实可以单独用一篇文章去介绍，其中涉及到进程的创建、文件资源的处理以及进程权限的设置等等。我们这里主要关注其中 ELF 处理相关的部分即可，实际上内核可以识别多种类型的可执行文件，ELF 的处理代码主要在 fs&#x2F;binfmt_elf.c 中的 load_elf_binary 函数中。</p>
<p>对于 ELF 而言，Linux 内核所关心的只有 Program Header 部分，甚至大部分情况下只关心三种类型的 Header，即 PT_LOAD、PT_INTERP 和 PT_GNU_STACK。以 3.18 内核为例，load_elf_binary 主要有下面操作:</p>
<ol>
<li>对 ELF 文件做一些基本检查，保证 e_phentsize &#x3D; sizeof(struct elf_phdr)并且 e_phnum 的个数在一定范围内；</li>
<li>循环查看每一项 program header，如果有 PT_INTERP 则使用 open_exec 加载进来，并替换原程序的 bprm-&gt;buf;</li>
<li>根据 PT_GNU_STACK 段中的 flag 设置栈是否可执行；</li>
<li>使用 flush_old_exec 来更新当前可执行文件的所有引用；</li>
<li>使用 setup_new_exec 设置新的可执行文件在内核中的状态；</li>
<li>setup_arg_pages 在栈上设置程序调用参数的内存页；</li>
<li>循环每一项 PT_LOAD 类型的段，elf_map 映射到对应内存页中，初始化 BSS；</li>
<li>如果存在 interpreter，将入口(elf_entry)设置为 interpreter 的函数入口，否则设置为原 ELF 的入口地址；</li>
<li>install_exec_creds(bprm)设置进程权限等信息；</li>
<li>create_elf_tables 添加需要的信息到程序的栈中，比如 ELF auxiliary vector；</li>
<li>设置 current-&gt;mm 对应的字段；</li>
</ol>
<p>从内核的处理流程上来看，如果是静态链接的程序，实际上内核返回用户空间执行的就是该程序的入口地址代码；如果是动态链接的程序，内核返回用户空间执行的则是 interpreter 的代码，并由其加载实际的 ELF 程序去执行。</p>
<p>为什么要这么做呢？如果把动态链接相关的代码也放到内核中，就会导致内核执行功能过多，内核的理念一直是能不在内核中执行的就不在内核中处理，以避免出现问题时难以更新而且影响系统整体的稳定性。事实上内核中对 ELF 文件结构的支持是相当有限的，只能读取并理解部分的字段。</p>
<h1 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h1><p>内核返回用户空间后，对于静态链接的程序是直接执行，没什么好说的。而对于动态链接的程序，实际是执行 interpreter 的代码。ELF 的 interpreter 作为一个段，自然是编译链接的时候加进去的，因此和编译使用的工具链有关。对于 Linux 系统而言，使用的一般是 GCC 工具链，而 interpreter 的实现，代码就在 glibc 的 elf&#x2F;rtld.c 中。</p>
<p>interpreter 又称为 dynamic linker，以 glibc2.27 为例，它的大致功能如下:</p>
<ol>
<li>将实际要执行的 ELF 程序中的内存段加载到当前进程空间中；</li>
<li>将动态库的内存段加载到当前进程空间中；</li>
<li>对 ELF 程序和动态库进行重定向操作(relocation)；</li>
<li>调用动态库的初始化函数(如 <em>.preinit_array, .init, .init_array</em>)；</li>
<li>将控制流传递给目标 ELF 程序，让其看起来自己是直接启动的；</li>
</ol>
<p>其中参与动态加载和重定向所需要的重要部分就是 Program Header Table 中 PT_DYNAMIC 类型的 Segment。前面我们提到在 Section Header 中也有一部分参与动态链接的 section，即.dynamic。我在自己解析动态链接文件的时候发现，实际上 .dynamic section 中的数据，和 PT_DYNAMIC 中的数据指向的是文件中的同一个地方，即这两个 entry 的 s_offset 和 p_offset 是相同。每个元素的类型如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Sword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">      Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<p>d_tag 表示实际类型，并且 d_un 和 d_tag 相关。同样的，标准中定义了几十个 d_tag 类型，比较常用的几个如下:</p>
<ul>
<li>DT_NULL: 表示 <code>_DYNAMIC </code> 的结尾</li>
<li>DT_NEEDED: d_val 保存了一个到字符串表头的偏移，指定的字符串表示该 ELF 所依赖的动态库名称</li>
<li>DT_STRTAB: d_ptr 指定了地址保存了符号、动态库名称以及其他用到的字符串</li>
<li>DT_STRSZ: 字符串表的大小</li>
<li>DT_SYMTAB: 指定地址保存了符号表</li>
<li>DT_INIT&#x2F;DT_FINI: 指定初始化函数和结束函数的地址</li>
<li>DT_RPATH: 指定动态库搜索目录</li>
<li>DT_SONAME: Shared Object Name，指定当前动态库的名字(logical name)</li>
</ul>
<p>其中有部分的类型可以和 Section 中的 SHT_xxx 类型进行类比，完整的列表可以参考 ELF 标准中的 Book III: Operating System Specific 一节。</p>
<p>在 interpreter 根据 DT_NEEDED 加载完所有需要的动态库后，就实现了完整进程虚拟内存映像的布局。在寻找某个动态符号时，interpreter 会使用广度优先的方式去进行搜索，即先在当前 ELF 符号表中找，然后再从当前 ELF 的 DT_NEEDED 动态库中找，再然后从动态库中的 DT_NEEDED 里查找。</p>
<p>因为动态库本身是位置无关的(PIE)，支持被加载到内存中的随机位置，因此为了程序中用到的符号可以被正确引用，需要对其进行重定向操作，指向对应符号的真实地址。</p>
<h1 id="Interpreter-Hack"><a href="#Interpreter-Hack" class="headerlink" title="Interpreter Hack"></a>Interpreter Hack</h1><p>假设现在面对两种场景:</p>
<ul>
<li>目标环境的可写磁盘直接 mount 为 noexec，无法执行代码</li>
<li>目标环境内核监控任何非系统路径的程序的执行都会直接告警</li>
</ul>
<p>运用上面学到的 ELF 知识，利用 interpreter 进行执行。示例如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ cat hello.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">$ gcc hello.c -o hello</span><br><span class="line">$ ./hello</span><br><span class="line">hello!</span><br><span class="line">$ chmod -x hello</span><br><span class="line">$ ./hello</span><br><span class="line">bash: ./hello: Permission denied</span><br><span class="line">$ /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> ./hello</span><br><span class="line">hello!</span><br><span class="line">$ strace /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> ./hello <span class="number">2</span>&gt;&amp;<span class="number">1</span> | <span class="function">grep exec</span></span><br><span class="line"><span class="function"><span class="title">execve</span><span class="params">(<span class="string">&quot;/lib64/ld-linux-x86-64.so.2&quot;</span>, [<span class="string">&quot;/lib64/ld-linux-x86-64.so.2&quot;</span>, <span class="string">&quot;./hello&quot;</span>], <span class="number">0x7fff1206f208</span> <span class="comment">/* 9 vars */</span>)</span> </span>= <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>/lib64/ld-linux-x86-64.so.2 </code> 本身应该是内核调用执行的，但我们这里可以直接进行调用。这样一方面可以在没有执行权限的情况下执行任意代码，另一方面也可以在一定程度上避免内核对 execve 的异常监控。</p>
<p>利用(滥用)interpreter 我们还可以做其他有趣的事情，比如通过修改指定 ELF 文件的 interpreter 为我们自己的可执行文件，可让内核在处理目标 ELF 时将控制器交给我们的 interpreter，这可以通过直接修改字符串表或者使用一些工具如 patchelf 来轻松实现。</p>
<p>对于恶意软件分析的场景，很多安全研究人员看到 ELF 就喜欢用 ldd 去看看有什么依赖库，一般 ldd 脚本实际上是调用系统默认的 ld.so 并通过环境变量来打印信息，不过对于某些 glibc 实现(如 glibc2.27 之前的 ld.so)，会调用 ELF 指定的 interpreter 运行，从而存在非预期命令执行的风险。</p>
<h1 id="加固-脱壳"><a href="#加固-脱壳" class="headerlink" title="加固&#x2F;脱壳"></a>加固&#x2F;脱壳</h1><p>与逆向分析比较相关的就是符号表，一个有符号的程序在逆向时基本上和读源码差不多。因此对于想保护应用程序的开发者而言，最简单的防护方法就是去除符号表，一个简单的 strip 命令就可实现。strip 删除的主要是 Section 中的信息，因为这不影响程序的执行。去除前后进行 diff 对比可看到删除的 section 主要有下面这些:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ diff <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>c1</span><br><span class="line">&lt; There are <span class="number">35</span> section headers, starting at offset <span class="number">0x1fdc</span>:</span><br><span class="line">---</span><br><span class="line">&gt; There are <span class="number">28</span> section headers, starting at offset <span class="number">0x1144</span>:</span><br><span class="line"><span class="number">32</span>,<span class="number">39</span>c32</span><br><span class="line">&lt;   [<span class="number">27</span>] .debug_aranges    PROGBITS        <span class="number">00000000</span> <span class="number">00104</span>d <span class="number">000020</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">&lt;   [<span class="number">28</span>] .debug_info       PROGBITS        <span class="number">00000000</span> <span class="number">00106</span>d <span class="number">000350</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">&lt;   [<span class="number">29</span>] .debug_abbrev     PROGBITS        <span class="number">00000000</span> <span class="number">0013b</span>d <span class="number">000100</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">&lt;   [<span class="number">30</span>] .debug_line       PROGBITS        <span class="number">00000000</span> <span class="number">0014b</span>d <span class="number">0000</span>cd <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">&lt;   [<span class="number">31</span>] .debug_str        PROGBITS        <span class="number">00000000</span> <span class="number">00158</span>a <span class="number">000293</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">&lt;   [<span class="number">32</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">001820</span> <span class="number">000480</span> <span class="number">10</span>     <span class="number">33</span>  <span class="number">49</span>  <span class="number">4</span></span><br><span class="line">&lt;   [<span class="number">33</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">001</span>ca0 <span class="number">0001f</span>4 <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">&lt;   [<span class="number">34</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">001e94</span> <span class="number">000145</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&gt;   [<span class="number">27</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">00104</span>d <span class="number">0000f</span>5 <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>.symtab</code> 是符号表，<code>.strtab</code> 是符号表中用到的字符串。</p>
<p>仅仅去掉符号感觉还不够，熟悉汇编的人放到反编译工具中还是可以慢慢还原程序逻辑。通过前面的分析我们知道，ELF 执行需要的只是 Program Header 中的几个段，Section Header 实际上是不需要的，只不过在运行时动态链接过程会引用到部分关联的区域。大部分反编译工具，如 IDA、Ghidra 等，处理 ELF 是需要某些 section 信息来构建程序视图的，所以我们可以通过构造一个损坏 Section Table 或者 ELF Header 令这些反编译工具出错，从而干扰逆向人员。</p>
<p>当然，这个方法并不总是奏效，逆向人员可以通过动态调试把程序 dump 出来并对运行视图进行还原。一个典型的例子是 Android 中的 JNI 动态库，有的安全人员对这些 so 文件进行了加密处理，并且在.init&#x2F;.initarray 这些动态库初始化函数中进行动态解密。破解这种加固方法的策略就是将其从内存中复制出来并进行重建，重建的过程可根据 segment 对 section 进行还原，因为 segment 和 section 之间共享了许多内存空间，例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ readelf -l main1</span><br><span class="line">...</span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   <span class="number">00</span></span><br><span class="line">   <span class="number">01</span>     .interp</span><br><span class="line">   <span class="number">02</span>     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame</span><br><span class="line">   <span class="number">03</span>     .init_array .fini_array .dynamic .got .got.plt .data .bss</span><br><span class="line">   <span class="number">04</span>     .dynamic</span><br><span class="line">   <span class="number">05</span>     .note.ABI-tag .note.gnu.build-id</span><br><span class="line">   <span class="number">06</span>     .eh_frame_hdr</span><br><span class="line">   <span class="number">07</span></span><br><span class="line">   <span class="number">08</span>     .init_array .fini_array .dynamic .got</span><br></pre></td></tr></table></figure>

<p>在 Section to Segment mapping 中可以看到这些段的内容是跟对应 section 的内容重叠的，一个 segment 可以包含多个 section，但是依然可以根据内存的读写属性、内存特征以及对应段的一般顺序进行区分。</p>
<p>如果程序中有比较详细的日志函数，我们还可以通过反编译工具的脚本拓展去修改.symtab&#x2F;.strtab 段来批量还原 ELF 文件的符号，从而高效地辅助动态调试。</p>
<h1 id="Binary-Fuzzing"><a href="#Binary-Fuzzing" class="headerlink" title="Binary Fuzzing"></a>Binary Fuzzing</h1><p>考虑这么一种场景，我们在分析某个 IoT 设备时发现了一个定制的 ELF 网络程序，类似于 httpd，其中有个静态函数负责处理输入数据。现在想要单独对这个函数进行 fuzz 应该怎么做？直接从网络请求中进行变异是一种方法，但是网络请求的效率太低，而且触达该函数的程序逻辑也可能太长。</p>
<p>既然我们已经了解了 ELF，那就可以有更好的办法将该函数抽取出来进行独立调用。在介绍 ELF 类型的时候其实有提到，可执行文件可以有两种类型，即可执行类型(ET_EXEC)和共享对象(ET_DYN)，一个动态链接的可执行程序默认是共享对象类型的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ gcc hello.c -o hello</span><br><span class="line">$ readelf -h hello | grep Type</span><br><span class="line">  Type:  <span class="built_in">DYN</span> (Shared object file)</span><br></pre></td></tr></table></figure>

<p>而动态库(.so)本身也是共享对象类型，他们之间的本质区别在于前者链接了 libc 并且定义了 main 函数。对于动态库，我们可以通过 dlopen&#x2F;dlsym 获取对应的符号进行调用，因此对于上面的场景，一个解决方式就是修改目标 ELF 文件，并且将对应的静态函数导出添加到 dynamic section 中，并修复对应的 ELF 头。</p>
<p>这个思想其实很早就已经有人实现了，比如 lief 的 bin2lib。通过该方法，我们就能将目标程序任意的函数抽取出来执行，比如 hugsy 就用这个方式复现了 Exim 中的溢出漏洞(CVE-2018-6789)。</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>网络超时检测的三种方法</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-Linux-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E8%B6%85%E6%97%B6%E6%A3%80%E6%B5%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>网络超时检测的三种方法</p>
<p>网络通信中，很多操作会使得进程阻塞，这时我们要设定时间，到时间后强制返回，避免进程在没有数据的情况下无限阻塞</p>
<p>这里我们总结一下网络超时检测的三种方法：</p>
<p>一、通过 <code>setsockopt</code> 设置套接字属性 <code>SO_RCVTIMEO</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> t = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_RCVTIMEO, &amp;t, <span class="built_in">sizeof</span>(t)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;peeraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(peeraddr));</span><br><span class="line">len = <span class="built_in">sizeof</span>(peeraddr);</span><br><span class="line"><span class="keyword">if</span> ((connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;peeraddr, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;errno=%d: %s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">	<span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、设定 <code>select</code> 函数的一个参数实现超时处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> t= &#123;<span class="number">3</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	t.tv_sec = <span class="number">3</span>;</span><br><span class="line">	t.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((ret = <span class="built_in">select</span>(maxfd+<span class="number">1</span>, &amp;rdfs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;t)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三、设定一个定时器捕捉 <code>SIGALRM</code> 信号做超时控制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line"><span class="built_in">sigaction</span>(SIGALRM, <span class="literal">NULL</span>, &amp;act); <span class="comment">//获取SIGALRM信号的属性</span></span><br><span class="line">act.sa_handler = handler; <span class="comment">// 设置SIGALRM信号的处理函数</span></span><br><span class="line"><span class="built_in">sigaction</span>(SIGALRM, &amp;act, <span class="literal">NULL</span>); <span class="comment">// 设置SIGALRM信号的属性</span></span><br><span class="line"><span class="built_in">alarm</span>(<span class="number">3</span>); <span class="comment">// 定时器设置3秒钟</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;peeraddr, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时器 3 秒钟内没有数据到来，内核产生 <code>SIGALRM</code> 信号中断当前操作。我们知道设置信号捕捉函数可以用 <code>signal</code> 函数或是 <code>sigaction</code> 函数。但这里只能使用 <code>sigaction</code> 函数，因为 <code>signal</code> 设置的信号处理函数执行完后会重新执行被中断的操作</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>网络配置</title>
    <url>/2024/05/22/0-%E5%B9%B3%E5%8F%B0-Linux-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<ul>
<li>TCP&#x2F;IP 网络相关概念</li>
<li>配置以太网络接口</li>
<li>配置 ppp 网络接口</li>
<li>Linux 环境下的网络配置</li>
<li>检测网络配置</li>
</ul>
<p>TCP&#x2F;IP 网络相关概念</p>
<ul>
<li>TCP&#x2F;IP 协议</li>
<li>IP 地址、子网掩码和域名</li>
<li>路由选择和网关地址</li>
<li>端到端连接</li>
<li>Linux 的网络应用</li>
</ul>
<h1 id="Linux-的网络接口设备"><a href="#Linux-的网络接口设备" class="headerlink" title="Linux 的网络接口设备"></a>Linux 的网络接口设备</h1><ul>
<li>在网络中使用的每一个外围设备的网络接口，在 Linux 的核心（kernel）中都有相应的名字。</li>
<li>网络接口设备和相关的设备接口名：<br>lo 本地回送接口。用于网络软件测试以及本地机进程间通信，无论什么程序一旦使用回送地址发送数据，协议软件立即将其返回，不进行任何网络传输。在 Linux 系统中，回送设备是默认设置好的。<br>ethn 第 n 个以太网卡接口 (n 为 0 表示第一块，以此类推)，eth 是大多数网卡的接口设备名。<br>pppn 第 n 个 ppp 接口。PPP 接口按照与它们有关的 PPP 配置顺序连接在串口上。</li>
</ul>
<h1 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h1><ul>
<li>hostnameLinux<br>– 查看或配置计算机的主机名</li>
<li>ifconfig<br>– 查看或配置网络接口</li>
<li>ifup<br>– 启用指定的网络接口</li>
<li>ifdown<br>– 禁用指定的网络接口</li>
<li>route<br>– 查看或配置内核路由表的配置情况</li>
</ul>
<h1 id="配置以太网络－使用命令"><a href="#配置以太网络－使用命令" class="headerlink" title="配置以太网络－使用命令"></a>配置以太网络－使用命令</h1><ul>
<li>配置 IP 地址</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">– <span class="meta"># ifconfig [interface] [ip-address] [netmask …] </span></span><br><span class="line">[broadcast … ] [up] [down]</span><br><span class="line">- 配置默认网关</span><br><span class="line">– <span class="meta"># route add default gw IP 地址</span></span><br><span class="line">– <span class="meta">#route add 0.0.0.0 netmask 0.0.0.0 eth0</span></span><br><span class="line">- 配置 DNS 客户</span><br><span class="line">– <span class="meta"># vi /etc/resolv.conf</span></span><br></pre></td></tr></table></figure>

<h1 id="TCP-IP-配置文件"><a href="#TCP-IP-配置文件" class="headerlink" title="TCP&#x2F;IP 配置文件"></a>TCP&#x2F;IP 配置文件</h1><p>&#x2F;etc&#x2F;sysconfig&#x2F;network 主机最基本网络信息，用于系统启动</p>
<p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts 系统启动初始化网络信息</p>
<p>&#x2F;etc&#x2F;xinetd.conf 定义由超级进程 xinetd 启动的网络服务</p>
<p>&#x2F;etc&#x2F;hosts 主机和 ip 映射</p>
<p>&#x2F;etc&#x2F;host.conf DNS 客户端搜索顺序</p>
<p>&#x2F;etc&#x2F;resoly.conf 指定 DNS 地址</p>
<p>&#x2F;etc&#x2F;serveices </p>
<p>编辑&#x2F;etc&#x2F;sysconfig&#x2F;entwork-script&#x2F;ifcfg-eth0 文件</p>
<p>Linux 支持一块网卡绑定多 IP，编辑子接口配置文件 ifcfg-eth0:1</p>
<p>Netconfig 调用菜单</p>
<h1 id="配置-ADSL-网络接口"><a href="#配置-ADSL-网络接口" class="headerlink" title="配置 ADSL 网络接口"></a>配置 ADSL 网络接口</h1><ul>
<li>安装 pppoe<br>rpm –qa |grep pppoe</li>
<li>配置 pppoe<br>adsl-setup<br>&#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;ifcfg-ppp0<br>adsl-status</li>
<li>启用和挂断 ADSL 网络连接<br>adsl-start (或 ifup ppp0)<br>adsl-stop (或 ifdown ppp0)</li>
</ul>
<h1 id="网络测试一般方法"><a href="#网络测试一般方法" class="headerlink" title="网络测试一般方法"></a>网络测试一般方法</h1><ul>
<li>排除非自身因素</li>
<li>查看本机 IP 地址</li>
<li>检测与网关的连接</li>
<li>监测与互联网的连接</li>
<li>测试域名解析</li>
<li>测试与特定站点的连接</li>
</ul>
<h1 id="检测网络状态"><a href="#检测网络状态" class="headerlink" title="检测网络状态"></a>检测网络状态</h1><ul>
<li>Ifconfig<br>– 检测网络接口</li>
<li>ping<br>– 检测网络连通性</li>
<li>netstat<br>– 查看网络状态</li>
<li>traceroute<br>– 检测到目的主机所经过的路由器</li>
<li>tcpdump<br>– 显示本机网络流量的状态</li>
</ul>
<h1 id="配置网卡信息"><a href="#配置网卡信息" class="headerlink" title="配置网卡信息"></a>配置网卡信息</h1><p>IP、网关、掩码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/etc/network/interfaces</span><br></pre></td></tr></table></figure>

<p>DNS</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;》重启网卡 sudo service networking restart</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/etc/sysconfig/network-scripts/ifcfg-eno16777736</span><br><span class="line">TYPE=<span class="built_in">Ethernet</span>(设备类型） BOOTPROTO=<span class="type">static</span>（地址分配模式） NAME=eno16777736 ONBOOT=yes（是否启用）</span><br><span class="line">IPADDR=<span class="number">192.168</span><span class="number">.10</span><span class="number">.10</span> NETMASK=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> GATEWAY=<span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> DNS1=<span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;》重启网卡 systemctl restart network</p>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>网络设备驱动的中断处理</title>
    <url>/2024/07/18/0-%E5%B9%B3%E5%8F%B0-Linux-%E9%A9%B1%E5%8A%A8-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>devm_request_irq 和 request_threaded_irq 都是用于注册中断处理程序的函数，但它们的用途和管理机制有所不同。以下是这两个函数的详细说明及如何使用它们。</p>
<h2 id="devm-request-irq"><a href="#devm-request-irq" class="headerlink" title="devm_request_irq"></a>devm_request_irq</h2><p>devm_request_irq 是用于注册中断处理程序的设备管理函数，它的主要优点是自动管理资源。当设备驱动程序被卸载时，系统会自动释放中断资源，避免资源泄漏。</p>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">devm_request_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：<br>dev：指向设备结构体的指针。<br>irq：要申请的中断号。<br>handler：中断处理程序的函数指针。<br>irqflags：中断标志，如 IRQF_SHARED 等。<br>devname：设备名称，用于显示和调试。<br>dev_id：设备标识，一般为设备结构体的指针，用于区分共享中断。</p>
</blockquote>
<h2 id="request-threaded-irq"><a href="#request-threaded-irq" class="headerlink" title="request_threaded_irq"></a>request_threaded_irq</h2><p>request_threaded_irq 是用于注册中断处理程序和线程化中断处理程序的函数。线程化中断处理程序运行在中断上下文之外，因此可以执行更复杂的操作而不会阻塞中断处理。</p>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：<br>    irq：要申请的中断号。<br>    handler：顶半部中断处理程序的函数指针。可以为 NULL。<br>    thread_fn：线程化中断处理程序的函数指针。不能为 NULL。<br>    irqflags：中断标志，如 IRQF_SHARED 等。<br>    devname：设备名称，用于显示和调试。<br>    dev_id：设备标识，一般为设备结构体的指针，用于区分共享中断。</p>
</blockquote>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>Linux</category>
        <category>驱动</category>
      </categories>
  </entry>
  <entry>
    <title>Sqlite3</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E7%A7%BB%E6%A4%8D-Sqlite3/</url>
    <content><![CDATA[<h1 id="Qt-交叉编译"><a href="#Qt-交叉编译" class="headerlink" title="Qt 交叉编译"></a>Qt 交叉编译</h1><p>Qt 使用数据库时提示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSqlDatabase: QSQLITE driver <span class="keyword">not</span> loaded</span><br></pre></td></tr></table></figure>

<p>问题原因是交叉编译的 qt 中可能是裁剪过的版本，其中没有 sqlite 的驱动，需要交叉编译 qsqlite 驱动</p>
<ol>
<li>下载 qt 源码: <a href="http://download.qt.io/">http://download.qt.io/</a> 找到 qt-everywhere-opensource-src-5.3.2.tar.gz，要求 qt-everywhere-opensource-src 版本需与编译器版本一致。</li>
<li>解压源码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tar -xvf qt-everywhere-opensource-src<span class="number">-5.3</span><span class="number">.2</span>.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入目录</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd qt-everywhere-opensource-src<span class="number">-5.3</span><span class="number">.2</span>/qtbase/src/plugins/sqldrivers/sqlite</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行编译</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">qmake</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>拷贝生成的库到开发板上，库的路径在生成在 <code>qt-everywhere-opensource-src-5.3.2/qtbase/plugins/sqldrivers/libqsqlite.so</code>，拷贝 <code>libqsqlite.so</code> 到开发板 <code>/usr/lib/qt5/plugins/sqldrivers/</code>，如果没有，则执行创建 <code>mkdir /usr/lib/qt5/plugins/sqldrivers</code></li>
</ol>
<h1 id="Sqlite-使用"><a href="#Sqlite-使用" class="headerlink" title="Sqlite 使用"></a>Sqlite 使用</h1><p><a href="source/_posts/3.%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/Sqlie%E4%BD%BF%E7%94%A8.md">Sqlie使用</a></p>
<h1 id="C-代码编写"><a href="#C-代码编写" class="headerlink" title="C 代码编写"></a>C 代码编写</h1><p>源码下载地址 <a href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a></p>
<p>以下两个对象和八个方法构成了 SQLite 接口的基本元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库连接对象。通过创建 sqlite3_open,并通过破坏sqlite3_close</span></span><br><span class="line">sqlite3</span><br><span class="line"><span class="comment">//准备好的语句对象。通过创建 sqlite3_prepare,并通过破坏sqlite3_finalize</span></span><br><span class="line">sqlite3_stmt</span><br><span class="line"><span class="comment">//打开与新的或现有的SQLite数据库的连接。sqlite3的构造函数。</span></span><br><span class="line"><span class="built_in">sqlite3_open</span>()</span><br><span class="line"><span class="comment">//将SQL文本编译为字节代码，它将完成查询或更新数据库的工作。sqlite3_stmt的构造函数。</span></span><br><span class="line"><span class="built_in">sqlite3_prepare</span>()</span><br><span class="line"><span class="comment">//将应用程序数据存储到 原始SQL的参数中。</span></span><br><span class="line"><span class="built_in">sqlite3_bind</span>()</span><br><span class="line"><span class="comment">//将sqlite3_stmt前进到下一个结果行或完成。</span></span><br><span class="line"><span class="built_in">sqlite3_step</span>()</span><br><span class="line"><span class="comment">//当前结果行用于在→列值sqlite3_stmt。</span></span><br><span class="line"><span class="built_in">sqlite3_column</span>()</span><br><span class="line"><span class="comment">// sqlite3_stmt的析构函数。</span></span><br><span class="line"><span class="built_in">sqlite3_finalize</span>()</span><br><span class="line"><span class="comment">// sqlite3的析构函数。</span></span><br><span class="line"><span class="built_in">sqlite3_close</span>()</span><br><span class="line"><span class="comment">//一个包装函数，对一个或多个SQL语句字符串执行sqlite3_prepare()，sqlite3_step()， sqlite3_column()和sqlite3_finalize()。</span></span><br><span class="line"><span class="built_in">sqlite3_exec</span>() </span><br></pre></td></tr></table></figure>

<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">mkdir</span> sqlite3 <span class="comment">#在主机（如Ubuntu）创建工作目录</span></span><br><span class="line"><span class="built_in">cd</span> sqlite3 <span class="comment">#进入工作目录中</span></span><br><span class="line">tar zxvf sqlite-autoconf3080500.tar.gz <span class="comment">#解压</span></span><br><span class="line"><span class="built_in">cd</span> sqlite-autoconf3080500 <span class="comment">#进入解压后的目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span>../install <span class="comment">#创建安装目录</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/arm-2010q1/bin <span class="comment">#交叉编译工具路径加入系统环境变量</span></span><br><span class="line">./configure--host=arm-none-linux-gnueabi --prefix=/home/gary/sqlite3/install</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<ul>
<li>–host： 指定交叉编译工具，一般为 arm-linux、arm-linux-gnueabihf 等，根据板子用的交叉编译工具来。</li>
<li>–prefix： 指定安装目录，编译后的文件会全部放在安装目录中。必须是绝对路径</li>
</ul>
<p>之后拷贝编译完成的镜像到开发板上即可。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;sqlite3.h&quot;</span></span></span><br><span class="line"><span class="comment">//exec传入    </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">callback</span><span class="params">(<span class="type">void</span>*arg ,<span class="type">int</span> num, <span class="type">char</span>**rowdata , <span class="type">char</span>** title)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">		<span class="keyword">for</span>(; i&lt;num; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s  &quot;</span>, title[i]);</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s  &quot;</span>, rowdata[i]);</span><br><span class="line">	&#125;		</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> SQLITE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.打开数据</span></span><br><span class="line">	sqlite3 *ppdb;</span><br><span class="line">	<span class="type">int</span> empty=<span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> *err=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">sqlite3_open</span>(<span class="string">&quot;./test.db&quot;</span>, &amp;ppdb);</span><br><span class="line">	<span class="keyword">if</span>(ret != SQLITE_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;open sqlite3 fail&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.执行</span></span><br><span class="line">	<span class="comment">//char *sql = &quot;insert into gec_94(name, age) values (&#x27;amao&#x27;, 100);&quot;; //（插入数据）</span></span><br><span class="line">	<span class="comment">//char *sql = &quot;delete from gec_94 where name like &#x27;amao&#x27;;&quot;; //删除</span></span><br><span class="line">	<span class="comment">//char *sql = &quot;select * from gec_94;&quot;;  //查询</span></span><br><span class="line">	<span class="type">char</span> *sql = <span class="string">&quot;create table gec_94(id int primary key,msg varchar(128))&quot;</span>;<span class="comment">//创建表</span></span><br><span class="line">	ret = <span class="built_in">sqlite3_exec</span>(ppdb, sql, callback, &amp;empty, &amp;err);</span><br><span class="line">	<span class="keyword">if</span>(ret != SQLITE_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;exec sqlite3 create table  fail&quot;</span>);</span><br><span class="line">		<span class="built_in">sqlite3_close</span>(ppdb);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">sqlite3_exec</span>(ppdb, <span class="string">&quot;select * from gec_94;&quot;</span>, callback, &amp;empty, &amp;err);</span><br><span class="line">	<span class="keyword">if</span>(ret != SQLITE_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;exec sqlite3 fail&quot;</span>);</span><br><span class="line">		<span class="built_in">sqlite3_close</span>(ppdb);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3.关闭</span></span><br><span class="line">	<span class="built_in">sqlite3_close</span>(ppdb);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#gcc sqlit3.c sqlite3.c sqlite3.h -o main -lpthread -ldl</span></span><br><span class="line">TARGET=queue</span><br><span class="line">#CC=arm-linux-gcc</span><br><span class="line">SRCS=sqlit3.c sqlite3.c</span><br><span class="line">OBJS=$(patsubst %.c,%, $(SRCS))</span><br><span class="line">#SRCS=$(wildcard *.cpp)</span><br><span class="line">#OBJS=$(patsubst %.cpp, %, $(SRCS))</span><br><span class="line"></span><br><span class="line">LIB=-lpthread -ldl</span><br><span class="line">INCLUDE=</span><br><span class="line"></span><br><span class="line">ADD=-Wno-psabi </span><br><span class="line">ADD1=-enable-<span class="type">static</span> </span><br><span class="line"></span><br><span class="line">main:$(SRCS)</span><br><span class="line">	$(CC) $^ -o $@ $(LIB)</span><br><span class="line">clean:</span><br><span class="line">	rm -f  $(OBJS) main</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
        <category>应用软件移植</category>
      </categories>
  </entry>
  <entry>
    <title>嵌入式中的gsnap截屏</title>
    <url>/2024/08/28/0-%E5%B9%B3%E5%8F%B0-%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E7%A7%BB%E6%A4%8D-%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E7%9A%84gsnap%E6%88%AA%E5%B1%8F/</url>
    <content><![CDATA[<p>Linux 系统的 <strong>FrameBuffer 机制</strong>，会把屏幕上的每个点映射成一段线性内存空间，程序就可以通过改变这段内存的值来改变屏幕上某一点的颜色。屏幕色彩的原始数据保存在&#x2F;dev&#x2F;fb0 文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/fb0 &gt; fb.raw        <span class="comment">#读取该文件获得数据</span></span><br><span class="line"><span class="built_in">cat</span> fb_data.raw &gt; /dev/fb0   <span class="comment">#数据回显到 framebuffer </span></span><br></pre></td></tr></table></figure>

<p>这种原始数据无法通过简单的工具直接查看，特别是在精简的嵌入式 Linux 系统上。因此，通过工具 gsnap。这个工具可以将 framebuffer 中的数据直接保存为 png 或者 jpeg 格式的图片。</p>
<p>打开 gsnap 的 Makefile 文件，该源码依赖 libpng、libjpeg、zlib、libmath 四种库。</p>
<h2 id="交叉编译-libjpeg"><a href="#交叉编译-libjpeg" class="headerlink" title="交叉编译 libjpeg"></a>交叉编译 libjpeg</h2><p>进入到源码目录，执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">./configure --host=arm-linux --prefix=./jpeg_install/</span><br></pre></td></tr></table></figure>

<p>然后执行 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install </span><br></pre></td></tr></table></figure>

<p>在安装目录 <code>./jpeg_install/</code> 得到交叉编译过的库。</p>
<h2 id="交叉编译-zlib"><a href="#交叉编译-zlib" class="headerlink" title="交叉编译 zlib"></a>交叉编译 zlib</h2><p>由于 zlib 中的 configure 并未提供–host 参数，因此需要为它手动指明交叉编译器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> CC=arm-fsl-linux-gnueabi-gcc</span><br><span class="line">./configure --prefix=./z_install/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="交叉编译-libpng"><a href="#交叉编译-libpng" class="headerlink" title="交叉编译 libpng"></a>交叉编译 libpng</h2><p><em>zlib 是 libpng 的依赖，因此在交叉编译 libpng 之前，必须首先编译 zlib</em><br>libpng 中提供有 Linux 平台下的 Makefile 例程，可以直接修改使用。进入到 libpng 的源码目录，执行拷贝 <code> cp scripts/makefile.linux Makefile</code>，打开 Makefile 修改，修改交叉编译器名称和依赖的 zlib 的路径。执行 <code>make</code>、<code>makeinstall</code> 得到头文件和库文件。</p>
<h2 id="交叉编译-gsnap"><a href="#交叉编译-gsnap" class="headerlink" title="交叉编译 gsnap"></a>交叉编译 gsnap</h2><p>将上述得到的库文件和头文件分别集中拷贝到自行建立的 lib 和 includes 目录下，并修改 gsnap 的 Makefile。执行 make 后就能得到可执行文件 gsnap。</p>
<p>将得到的 gsnap 可执行文件拷贝到目标板的&#x2F;usr&#x2F;bin 目录下，执行截屏命令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gsnap fb.jpg /dev/fb0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>0.平台</category>
        <category>嵌入式</category>
        <category>应用软件移植</category>
      </categories>
  </entry>
  <entry>
    <title>QComboBox样式表</title>
    <url>/2024/08/27/1-%E8%AF%AD%E8%A8%80-Qt-%E6%A0%B7%E5%BC%8F%E8%A1%A8-QComboBox%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    color: #<span class="number">000000</span>;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>font-family 为设置字体类型，标准形式需要加双引号，不加也可能会生效，具体看系统是否支持，中英文都支持，但要保证字体编码支持，一般程序编码为”utf-8”时没问题。</li>
<li>font-size 为设置字体大小，单位一般使用 px 像素</li>
<li>font-style 为设置字体斜体，italic 为斜体， normal 为不斜体</li>
<li>font-weight 为设置字体加粗，bold 为加粗， normal 为不加粗</li>
<li>color 为设置字体颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为 0~255，如果想不显示颜色可以设置值为透明 transparent</li>
<li>字体颜色用的是 color 属性，没有 font-color 这个属性的</li>
</ul>
<p>对于字体样式，可以把 family size style weight 统一设置在 font 属性中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">font: bold italic <span class="number">18</span>px <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里出现的顺序要求是 style 和 weight 必须出现在开头，size 和 family 在后面，而且 size 必须在 family 之前，否则样式将不生效，font 中不能设置颜色，可以单独设置 style weight 和 size，不能单独设置 family</p>
<h1 id="文字位置"><a href="#文字位置" class="headerlink" title="文字位置"></a>文字位置</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">padding-left: <span class="number">10</span>px;</span><br><span class="line">padding-top: <span class="number">8</span>px;</span><br><span class="line">padding-right: <span class="number">7</span>px;</span><br><span class="line">padding-bottom: <span class="number">9</span>px;</span><br></pre></td></tr></table></figure>

<ul>
<li>padding-left 为设置按钮(包括选择框和文字)距离左边边界的距离</li>
<li>padding-top 为设置按钮(包括选择框和文字)距离顶边边界的距离</li>
<li>padding-right 为设置按钮(包括选择框和文字)距离右边边界的距离</li>
<li>padding-bottom 为设置按钮(包括选择框和文字)距离底边边界的距离</li>
<li>在 qss 中，属性 text-align 对 QComboBox 是不起作用的，一般 padding-left 相当于 x 坐标，padding-top 相当于 y 坐标，设置这两个就可以精确地调节文字的显示位置</li>
</ul>
<p>下面我们调节字体左间距为 30px</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    color: #<span class="number">000000</span>;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    padding-left: <span class="number">30</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们设置的 padding-left 只对按钮框文字起作用，对下拉列表不起作用，后面我们会单独讨论下拉框样式</p>
<h1 id="边框样式"><a href="#边框样式" class="headerlink" title="边框样式"></a>边框样式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-style: solid;</span><br><span class="line">border-width: <span class="number">2</span>px;</span><br><span class="line">border-color: aqua;</span><br></pre></td></tr></table></figure>

<ul>
<li>border-style 为设置边框样式，solid 为实线， dashed 为虚线， dotted 为点线， none 为不显示（如果不设置 border-style 的话，默认会设置为 none）</li>
<li>border-width 为设置边框宽度，单位为 px 像素</li>
<li>border-color 为设置边框颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为 0~255，如果想不显示颜色可以设置值为透明 transparent</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    color: #<span class="number">000000</span>;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    padding-left: <span class="number">30</span>px;</span><br><span class="line">    border-width: <span class="number">2</span>px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-color: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以把 border 的 width style color 一起设置在 border 属性中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border: <span class="number">2</span>px solid aqua;</span><br></pre></td></tr></table></figure>

<p>但必须注意的是，值的顺序必须是按照 width style color 来写，不然不会生效！如果不想显示边框可以直接设置 border 属性值为 none</p>
<p>也可以单独设置某一条边框的样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-top-style: solid;</span><br><span class="line">border-top-width: <span class="number">2</span>px;</span><br><span class="line">border-top-color: red;</span><br><span class="line">border-top: <span class="number">2</span>px solid red;</span><br></pre></td></tr></table></figure>

<ul>
<li>border-top-style 为设置顶部边框样式</li>
<li>border-top-width 为设置顶部边框宽度</li>
<li>border-top-color 为设置顶部边框颜色</li>
<li>border-top 为设置顶部边框 width style color 的属性，原理和 border 一致<br>其它三个边框：right bottom left 边框的设置都相同</li>
</ul>
<h2 id="设置边框半径"><a href="#设置边框半径" class="headerlink" title="设置边框半径"></a>设置边框半径</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-top-left-radius: <span class="number">20</span>px;</span><br><span class="line">border-top-right-radius: <span class="number">20</span>px;</span><br><span class="line">border-bottom-left-radius: <span class="number">20</span>px;</span><br><span class="line">border-bottom-right-radius: <span class="number">20</span>px;</span><br><span class="line">border-radius: <span class="number">20</span>px;</span><br></pre></td></tr></table></figure>

<ul>
<li>border-top-left-radius 为设置左上角圆角半径，单位 px 像素</li>
<li>border-top-right-radius 为设置右上角圆角半径，单位 px 像素</li>
<li>border-bottom-left-radius 为设置左下角圆角半径，单位 px 像素</li>
<li>border-bottom-right-radius 为设置右上角圆角半径，单位 px 像素</li>
<li>border-radius 为设置所有边框圆角半径，单位为 px 像素，通过圆角半径可以实现圆形的 QComboBox</li>
</ul>
<p>下面我们来设置左上角和左下角半径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    color: #<span class="number">000000</span>;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    padding-left: <span class="number">30</span>px;</span><br><span class="line">    border-width: <span class="number">2</span>px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-color: aqua;</span><br><span class="line">    border-top-left-radius: <span class="number">13</span>px;</span><br><span class="line">    border-bottom-left-radius: <span class="number">13</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">background-color: #<span class="number">2E3648</span>;</span><br><span class="line">background-image: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>);</span><br><span class="line">background-repeat: no-repeat; </span><br><span class="line">background-position: left center;</span><br><span class="line">background: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>) no-repeat left center #<span class="number">2E3648</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>background-color 为设置背景颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为 0~255，如果想不显示颜色可以设置值为透明 transparent</li>
<li>background-image 为设置背景图片，图片路径为 url(image-path)</li>
<li>background-repeat 为设置背景图是否重复填充背景，如果背景图片尺寸小于背景实际大小的话，默认会自动重复填充图片，可以设置为 no-repeat 不重复，repeat-x 在 x 轴重复，repeat-y 在 y 轴重复</li>
<li>background-position 为设置背景图片显示位置，只支持 left right top bottom center；值 left right center 为设置水平位置，值 top bottom center 为设置垂直位置</li>
</ul>
<p>比如我们给 QComboBox 左边添加一个背景图片</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    color: #BDC8E2;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    padding-left: <span class="number">30</span>px;</span><br><span class="line">    border-width: <span class="number">1</span>px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-color: aqua;</span><br><span class="line">    background-color: #<span class="number">2E3648</span>;</span><br><span class="line">    background-image: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-position: left center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 background，可以把 color image repeat position 一起设置在 background 属性中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">background: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>) no-repeat left center #<span class="number">2E3648</span>;</span><br></pre></td></tr></table></figure>

<p>color image repeat position 这些属性值出现的顺序可以任意</p>
<h1 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h1><p>可以设置鼠标悬浮时的样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox:hover &#123;</span><br><span class="line">    color: green;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当下拉列表显示出来时的样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox:on &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当下拉框按钮可编辑输入文字时的样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox:editable &#123;</span><br><span class="line">    color: white;</span><br><span class="line">    background-color: #<span class="number">2E3648</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要可编辑样式生效需要设置下拉框按钮为可编辑，比如调用 setEditable() 方法，值得注意的是，一旦可编辑样式生效，其它类似于 hover、on 所设置的样式都会被覆盖掉，除非再次设置为不可编辑</p>
<h1 id="下拉图标"><a href="#下拉图标" class="headerlink" title="下拉图标"></a>下拉图标</h1><p>下拉图标属于下拉框按钮的一个子控件 drop-down，而 drop-down 中又包含 down-arrow 子控件，我们用样式表把这两个控件显示出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    color: #<span class="number">000000</span>;</span><br><span class="line">    font-style: normal;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QComboBox::drop-down &#123;</span><br><span class="line">    border: <span class="number">1</span>px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QComboBox::down-arrow &#123;</span><br><span class="line">    border: <span class="number">1</span>px solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在样式表中，我们设置 drop-down 边框颜色为红色，down-arrow 边框为绿色。我们也可以自定义 drop-down 控件的大小和位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QComboBox &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    color: #<span class="number">000000</span>;</span><br><span class="line">    font-style: normal;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    padding-left: <span class="number">6</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QComboBox::drop-down &#123;</span><br><span class="line">    width:<span class="number">28</span>px;</span><br><span class="line">    height:<span class="number">22</span>px;</span><br><span class="line">    border: <span class="number">1</span>px solid red;</span><br><span class="line">    subcontrol-position: center top;</span><br><span class="line">    subcontrol-origin: padding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QComboBox::down-arrow &#123;</span><br><span class="line">    border: <span class="number">1</span>px solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>width 和 height 设置 drop-down 的宽高</li>
<li>subcontrol-position 设置 drop-down 的位置，只支持 left right top bottom center；值 left right center 为设置水平位置，值 top bottom center 为设置垂直位置</li>
<li>subcontrol-origin 设置 drop-down 的对齐方式，一般设置为 padding</li>
<li>如果想要自定义的 width、height、subcontrol-position 生效，必须在 QComboBox 按钮中设置 padding 的值，哪怕设置值为 0，否则无法生效！</li>
</ul>
<p>当然，我们也可以设置 drop-down 的圆角半径 border-radius，属性值和其它控件样式的设置方式一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-top-left-radius: <span class="number">6</span>px;</span><br><span class="line">border-top-right-radius: <span class="number">6</span>px;</span><br><span class="line">border-bottom-left-radius: <span class="number">6</span>px;</span><br><span class="line">border-bottom-right-radius: <span class="number">6</span>px;</span><br><span class="line">border-radius: <span class="number">6</span>px;</span><br></pre></td></tr></table></figure>

<p>同时，我们还可以往 drop-down 添加图片，方式有两种：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">image: <span class="built_in">url</span>(<span class="string">&quot;./arrow_down.png&quot;</span>);</span><br><span class="line">background-image: <span class="built_in">url</span>(<span class="string">&quot;./arrow_down.png&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>image 设置唯一的自动适应不重复的图片，而 background-image 则需要手动调节它的 repeat, position 属性值。这里，我们不推荐在 drop-down 中设置图片，因为它有一个更好放图片的控件 down-arrow</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Qt</category>
        <category>样式表</category>
      </categories>
  </entry>
  <entry>
    <title>QLabel样式表</title>
    <url>/2024/08/27/1-%E8%AF%AD%E8%A8%80-Qt-%E6%A0%B7%E5%BC%8F%E8%A1%A8-QLabel%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">    color: #BDC8E2;</span><br><span class="line">    background-color: #<span class="number">2E3648</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">font-size: <span class="number">14</span>px;</span><br><span class="line">font-style: italic;</span><br><span class="line">font-weight: bold;</span><br><span class="line">color: #BDC8E2;</span><br><span class="line">font: bold italic <span class="number">18</span>px <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>font-family 为设置字体类型，标准形式需要加双引号，不加也可能会生效，具体看系统是否支持，中英文都支持，但要保证字体编码支持，一般程序编码为”utf-8”时没问题。</li>
<li>font-size 为设置字体大小，单位一般使用 px 像素</li>
<li>font-style 为设置字体斜体样式，italic 为斜体， normal 为不斜体</li>
<li>font-weight 为设置字体加粗样式，bold 为加粗， normal 为不加粗</li>
<li>font 为同时设置字体 style weight size family 的样式，但是 style 和 weight 必须出现在开头，size 和 family 在后面，而且 size 必须在 family 之前，否则样式将不生效，font 中不能设置颜色，可以单独设置 style weight 和 size，不能单独设置 family</li>
<li>color 为设置字体颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为 0~255，如果想不显示颜色可以设置值为透明 transparent</li>
<li>字体颜色用的是 color 属性，没有 font-color 这个属性的</li>
</ul>
<h1 id="文字位置"><a href="#文字位置" class="headerlink" title="文字位置"></a>文字位置</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">padding-left: <span class="number">10</span>px;</span><br><span class="line">padding-top: <span class="number">8</span>px;</span><br><span class="line">padding-right: <span class="number">7</span>px;</span><br><span class="line">padding-bottom: <span class="number">9</span>px;</span><br></pre></td></tr></table></figure>

<ul>
<li>padding-left 为设置文字距离左边边界的距离</li>
<li>padding-top 为设置文字距离顶边边界的距离</li>
<li>padding-right 为设置文字距离右边边界的距离</li>
<li>padding-bottom 为设置文字距离底边边界的距离</li>
<li>在 qss 中，属性 text-align 对 Label 是不起作用的，只能通过设置 padding 来实现文字的显示位置；一般 padding-left 相当于 x 坐标，padding-top 相当于 y 坐标，设置这两个就可以在任意位置显示了（默认情况下文字是上下左右都居中显示的）</li>
</ul>
<h1 id="边框样式"><a href="#边框样式" class="headerlink" title="边框样式"></a>边框样式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-style: solid;</span><br><span class="line">border-width: <span class="number">2</span>px;</span><br><span class="line">border-color: red;</span><br><span class="line">border: <span class="number">2</span>px solid red;</span><br></pre></td></tr></table></figure>

<ul>
<li>border-style 为设置边框样式，solid 为实线， dashed 为虚线， dotted 为点线， none 为不显示（如果不设置 border-style 的话，默认会设置为 none）</li>
<li>border-width 为设置边框宽度，单位为 px 像素</li>
<li>border-color 为设置边框颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为 0~255，如果想不显示颜色可以设置值为透明 transparent</li>
<li>border 为同时设置 border 的 width style color 属性，但值的顺序必须是按照 width style color 来写，不然不会生效！<br>也可以单独设置某一条边框的样式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-top-style: solid;</span><br><span class="line">border-top-width: <span class="number">2</span>px;</span><br><span class="line">border-top-color: red;</span><br><span class="line">border-top: <span class="number">2</span>px solid red;</span><br></pre></td></tr></table></figure>

<ul>
<li>border-top-style 为设置顶部边框样式</li>
<li>border-top-width 为设置顶部边框宽度</li>
<li>border-top-color 为设置顶部边框颜色</li>
<li>border-top 为设置顶部边框 width style color 的属性，原理和 border 一致<br>其它三个边框：right bottom left 边框的设置都相同</li>
</ul>
<h2 id="设置边框半径"><a href="#设置边框半径" class="headerlink" title="设置边框半径"></a>设置边框半径</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-top-left-radius: <span class="number">20</span>px;</span><br><span class="line">border-top-right-radius: <span class="number">20</span>px;</span><br><span class="line">border-bottom-left-radius: <span class="number">20</span>px;</span><br><span class="line">border-bottom-right-radius: <span class="number">20</span>px;</span><br><span class="line">border-radius: <span class="number">20</span>px;</span><br></pre></td></tr></table></figure>

<ul>
<li>border-top-left-radius 为设置左上角圆角半径，单位 px 像素</li>
<li>border-top-right-radius 为设置右上角圆角半径，单位 px 像素</li>
<li>border-bottom-left-radius 为设置左下角圆角半径，单位 px 像素</li>
<li>border-bottom-right-radius 为设置右上角圆角半径，单位 px 像素</li>
<li>border-radius 为设置所有边框圆角半径，单位为 px 像素，通过圆角半径可以实现圆形的 Label</li>
</ul>
<h1 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">background-color: #<span class="number">2E3648</span>;</span><br><span class="line">background-image: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>);</span><br><span class="line">background-repeat: no-repeat; </span><br><span class="line">background-position: left center;</span><br><span class="line">background: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>) no-repeat left center #<span class="number">2E3648</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>background-color 为设置背景颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为 0~255，如果想不显示颜色可以设置值为透明 transparent</li>
<li>background-image 为设置背景图片，图片路径为 url(image-path)</li>
<li>background-repeat 为设置背景图是否重复填充背景，如果背景图片尺寸小于背景实际大小的话，默认会自动重复填充图片，可以设置为 no-repeat 不重复，repeat-x 在 x 轴重复，repeat-y 在 y 轴重复</li>
<li>background-position 为设置背景图片显示位置，只支持 left right top bottom center；值 left right center 为设置水平位置，值 top bottom center 为设置垂直位置</li>
<li>background 为设置背景的所有属性，color image repeat position 这些属性值出现的顺序可以任意</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">18</span>px;</span><br><span class="line">    color: #BDC8E2;</span><br><span class="line">    font-style: normal;</span><br><span class="line">    font-weight: normal;</span><br><span class="line"></span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-width: <span class="number">2</span>px;</span><br><span class="line">    border-color: aqua;</span><br><span class="line">    border-radius: <span class="number">20</span>px;</span><br><span class="line"></span><br><span class="line">    padding-left: <span class="number">20</span>px;</span><br><span class="line">    padding-top: <span class="number">0</span>px;</span><br><span class="line"></span><br><span class="line">    background-color: #<span class="number">2E3648</span>;</span><br><span class="line">    background-image: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-position: left center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h1><p>鼠标悬浮时的样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel:hover&#123;</span><br><span class="line">color: red;</span><br><span class="line">border-color: green;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签禁止时的样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel:disabled&#123;</span><br><span class="line">color: blue;</span><br><span class="line">border-color: brown;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，遗憾的是，标签并没有点击 pressed 这种样式的</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Qt</category>
        <category>样式表</category>
      </categories>
  </entry>
  <entry>
    <title>QPushButton样式表</title>
    <url>/2024/08/27/1-%E8%AF%AD%E8%A8%80-Qt-%E6%A0%B7%E5%BC%8F%E8%A1%A8-QPushButton%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">16</span>px;</span><br><span class="line">    color: #BDC8E2;</span><br><span class="line">    background-color: #<span class="number">2E3648</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">font-size: <span class="number">14</span>px;</span><br><span class="line">font-style: italic;</span><br><span class="line">font-weight: bold;</span><br><span class="line">color: #BDC8E2;</span><br><span class="line">font: bold italic <span class="number">18</span>px <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>font-family 为设置字体类型，标准形式需要加双引号，不加也可能会生效，具体看系统是否支持，中英文都支持，但要保证字体编码支持，一般程序编码为”utf-8”时没问题。</li>
<li>font-size 为设置字体大小，单位一般使用 px 像素</li>
<li>font-style 为设置字体斜体，italic 为斜体， normal 为不斜体</li>
<li>font-weight 为设置字体加粗，bold 为加粗， normal 为不加粗</li>
<li>font 为同时设置字体 style weight size family 的样式，但是 style 和 weight 必须出现在开头，size 和 family 在后面，而且 size 必须在 family 之前，否则样式将不生效，font 中不能设置颜色，可以单独设置 style weight 和 size，不能单独设置 family</li>
<li>color 为设置字体颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为 0~255，如果想不显示颜色可以设置值为透明 transparent</li>
<li>字体颜色用的是 color 属性，没有 font-color 这个属性的</li>
</ul>
<h1 id="文字位置"><a href="#文字位置" class="headerlink" title="文字位置"></a>文字位置</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">text-align: left center;</span><br><span class="line">padding-left: <span class="number">10</span>px;</span><br><span class="line">padding-top: <span class="number">8</span>px;</span><br><span class="line">padding-right: <span class="number">7</span>px;</span><br><span class="line">padding-bottom: <span class="number">9</span>px;</span><br></pre></td></tr></table></figure>

<ul>
<li>text-align 为设置文字位置，只支持 left right top bottom center；值 left right center 为设置水平位置，值 top bottom center 为设置垂直位置</li>
<li>padding-left 为设置文字距离左边边界的距离</li>
<li>padding-top 为设置文字距离顶边边界的距离</li>
<li>padding-right 为设置文字距离右边边界的距离</li>
<li>padding-bottom 为设置文字距离底边边界的距离</li>
<li>特殊的位置可以使用 text-align 来设置，如果要精确设置位置只能通过 padding 来设置，一般 padding-left 相当于 x 坐标，padding-top 相当于 y 坐标，设置这两个就可以显示任意位置显示了（默认情况下文字是上下左右都居中显示的）</li>
</ul>
<h1 id="边框样式"><a href="#边框样式" class="headerlink" title="边框样式"></a>边框样式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-style: solid;</span><br><span class="line">border-width: <span class="number">2</span>px;</span><br><span class="line">border-color: red;</span><br><span class="line">border: <span class="number">2</span>px solid red;</span><br></pre></td></tr></table></figure>

<ul>
<li>border-style 为设置边框样式，solid 为实线， dashed 为虚线， dotted 为点线， none 为不显示（如果不设置 border-style 的话，默认会设置为 none）</li>
<li>border-width 为设置边框宽度，单位为 px 像素</li>
<li>border-color 为设置边框颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为 0~255，如果想不显示颜色可以设置值为透明 transparent</li>
<li>border 为同时设置 border 的 width style color 属性，但值的顺序必须是按照 width style color 来写，不然不会生效！</li>
<li>也可以单独设置某一条边框的样式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-top-style: solid;</span><br><span class="line">border-top-width: <span class="number">2</span>px;</span><br><span class="line">border-top-color: red;</span><br><span class="line">border-top: <span class="number">2</span>px solid red;</span><br><span class="line"></span><br><span class="line">border-right-style: solid;</span><br><span class="line">border-right-width: <span class="number">3</span>px;</span><br><span class="line">border-right-color: green;</span><br><span class="line">border-right: <span class="number">3</span>px solid green;</span><br><span class="line"></span><br><span class="line">border-bottom-style: solid;</span><br><span class="line">border-bottom-width: <span class="number">2</span>px;</span><br><span class="line">border-bottom-color: blue;</span><br><span class="line">border-bottom: <span class="number">2</span>px solid blue;</span><br><span class="line"></span><br><span class="line">border-left-style: solid;</span><br><span class="line">border-left-width: <span class="number">3</span>px;</span><br><span class="line">border-left-color: aqua;</span><br><span class="line">border-left: <span class="number">3</span>px solid aqua;</span><br></pre></td></tr></table></figure>

<ul>
<li>border-top-style 为设置顶部边框样式</li>
<li>border-top-width 为设置顶部边框宽度</li>
<li>border-top-color 为设置顶部边框颜色</li>
<li>border-top 为设置顶部边框 width style color 的属性，原理和 border 一致<br>其它三个边框：right bottom left 边框的设置都相同</li>
</ul>
<h2 id="设置边框半径"><a href="#设置边框半径" class="headerlink" title="设置边框半径"></a>设置边框半径</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">border-top-left-radius: <span class="number">20</span>px;</span><br><span class="line">border-top-right-radius: <span class="number">20</span>px;</span><br><span class="line">border-bottom-left-radius: <span class="number">20</span>px;</span><br><span class="line">border-bottom-right-radius: <span class="number">20</span>px;</span><br><span class="line">border-radius: <span class="number">20</span>px;</span><br></pre></td></tr></table></figure>

<ul>
<li>border-top-left-radius 为设置左上角圆角半径，单位 px 像素</li>
<li>border-top-right-radius 为设置右上角圆角半径，单位 px 像素</li>
<li>border-bottom-left-radius 为设置左下角圆角半径，单位 px 像素</li>
<li>border-bottom-right-radius 为设置右上角圆角半径，单位 px 像素</li>
<li>border-radius 为设置所有边框圆角半径，单位为 px 像素，通过圆角半径可以实现圆形的 PushButton</li>
</ul>
<h1 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">background-color: #<span class="number">2E3648</span>;</span><br><span class="line">background-image: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>);</span><br><span class="line">background-repeat: no-repeat; </span><br><span class="line">background-position: left center;</span><br><span class="line">background: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>) no-repeat left center #<span class="number">2E3648</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>background-color 为设置背景颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为 0~255，如果想不显示颜色可以设置值为透明 transparent</li>
<li>background-image 为设置背景图片，图片路径为 url(image-path)</li>
<li>background-repeat 为设置背景图是否重复填充背景，如果背景图片尺寸小于背景实际大小的话，默认会自动重复填充图片，可以设置为 no-repeat 不重复，repeat-x 在 x 轴重复，repeat-y 在 y 轴重复</li>
<li>background-position 为设置背景图片显示位置，只支持 left right top bottom center；值 left right center 为设置水平位置，值 top bottom center 为设置垂直位置</li>
<li>background 为设置背景的所有属性，color image repeat position 这些属性值出现的顺序可以任意</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton &#123;</span><br><span class="line">    font-family: <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line">    font-size: <span class="number">16</span>px;</span><br><span class="line">    color: #BDC8E2;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    text-align: left center;</span><br><span class="line">    padding-left: <span class="number">25</span>px;</span><br><span class="line">    padding-top: <span class="number">0</span>px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-width: <span class="number">2</span>px;</span><br><span class="line">    border-color: aqua;</span><br><span class="line">    border-radius: <span class="number">20</span>px;</span><br><span class="line">    background-color: #<span class="number">2E3648</span>;</span><br><span class="line">    background-image: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-position: left center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态样式设置"><a href="#动态样式设置" class="headerlink" title="动态样式设置"></a>动态样式设置</h1><p>鼠标悬浮时的样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton:hover&#123;</span><br><span class="line">	color: red;</span><br><span class="line">	border-color: green;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鼠标点击时的样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton:pressed&#123;</span><br><span class="line">	color: green;</span><br><span class="line">	border-color: blueviolet;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按钮禁止时的样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton:disabled&#123;</span><br><span class="line">	color: blue;</span><br><span class="line">	border-color: brown;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h1><p>对于 QPushButton，可以给它设置添加一个下拉菜单，这需要调用 QPushButton 的 setMenu() 方法，当菜单设置成功后，QPushButton 就会默认添加一个 menu-indicator 下拉菜单指示器图标，我们可以对这个菜单图标进行样式修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton::menu-indicator &#123;</span><br><span class="line">    image: <span class="built_in">url</span>(<span class="string">&quot;./image.png&quot;</span>);</span><br><span class="line">    subcontrol-position: right center;</span><br><span class="line">    subcontrol-origin: padding;</span><br><span class="line">    right: <span class="number">10</span>px;</span><br><span class="line">    top: <span class="number">15</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>image 为设置菜单指示器图标</li>
<li>subcontrol-position 设置菜单指示器图标的位置，如果不设置的话会默认放在右下角</li>
<li>subcontrol-origin 为设置菜单指示器图标与按钮之间的停靠位置，默认为 padding</li>
<li>right top left bottom 为设置菜单指示器图标距离按钮四个位置的距离</li>
</ul>
<p>当然下拉菜单指示器图标也有动态样式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton::menu-indicator:hover &#123;</span><br><span class="line">    image: <span class="built_in">url</span>(./image1.png)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QPushButton::menu-indicator:pressed&#123;</span><br><span class="line">    image: <span class="built_in">url</span>(./image2.png)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QPushButton::menu-indicator:open&#123;</span><br><span class="line">    image: <span class="built_in">url</span>(./image2.png)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 menu-indicator 来说 pressed 和 open 原理相同</p>
]]></content>
      <categories>
        <category>1.语言</category>
        <category>Qt</category>
        <category>样式表</category>
      </categories>
  </entry>
</search>

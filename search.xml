<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1. 博客服务器环境部署</title>
    <url>/2024/03/10/Server-Setup/</url>
    <content><![CDATA[<h1 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h1><p><code>sudo apt update</code></p>
<h1 id="更新nodejs到最新版本"><a href="#更新nodejs到最新版本" class="headerlink" title="更新nodejs到最新版本"></a>更新nodejs到最新版本</h1><p>卸载自带的nodejs</p>
<p><code>sudo apt autoremove nodejs</code></p>
<p><code>sudo apt purge nodejs</code></p>
<p>安装20版本的nodejs</p>
<p><code>curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - &amp;&amp; sudo apt-get install -y nodejs</code></p>
<p>查看版本是否更新，否则关闭命令行重新打开</p>
<p><code>nodejs -v</code></p>
<p><del>安装nodejs安装工具到全局</del></p>
<p><del>sudo npm install n -g</del></p>
<p><del>安装稳定版本nodejs</del></p>
<p><del>sudo n stable</del></p>
<h1 id="安装npm"><a href="#安装npm" class="headerlink" title="安装npm"></a>安装npm</h1><p><code>sudo apt install npm -y</code></p>
<h1 id="FTP配置-用于图床"><a href="#FTP配置-用于图床" class="headerlink" title="FTP配置-用于图床"></a><del>FTP配置-用于图床</del></h1><p><del>安装ftp服务端</del></p>
<p><del>sudo apt install vsftpd -y</del></p>
<p><del>修改配置文件</del></p>
<p><del>sudo vi &#x2F;etc&#x2F;vsftpd.conf</del></p>
<blockquote>
<p><del>#禁止匿名访问</del><br><del>anonymous_enable&#x3D;NO</del><br><del>#接受本地用户</del><br><del>local_enable&#x3D;YES</del><br><del>#允许上传</del><br><del>write_enable&#x3D;YES</del></p>
<p><del>#更改创建文件权限</del></p>
<p><del>local_umask&#x3D;022</del></p>
</blockquote>
<p><del>重启服务</del></p>
<p><del>sudo service vsftpd restart</del></p>
<p><del>创建FTP用户</del></p>
<p><del>sudo useradd -d &#x2F;home&#x2F;lemonade -M lemonade</del></p>
<p><del>sudo passwd lemonade</del></p>
<h1 id="Mysql环境搭建"><a href="#Mysql环境搭建" class="headerlink" title="Mysql环境搭建"></a>Mysql环境搭建</h1><p>安装mysql</p>
<p><code>sudo apt install mysql-server -y</code></p>
<blockquote>
<p>sudo service mysql status # 查看服务状态<br>sudo service mysql start # 启动服务<br>sudo service mysql stop # 停止服务<br>sudo service mysql restart # 重启服务</p>
</blockquote>
<p>查看并更新密码</p>
<p><code>sudo cat /etc/mysql/debian.cnf</code></p>
<p>采用默认用户名密码登录</p>
<p><code>mysql -u *** -p</code></p>
<p>更新root用户密码</p>
<p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;newpasswd&#39;;</code></p>
<p>退出后，用root用户确认正常登录</p>
<p><code>mysql -u root -p newpasswd</code></p>
<p>创建Qexo要使用表</p>
<p><code>create database qexo;</code></p>
<h1 id="Python环境安装"><a href="#Python环境安装" class="headerlink" title="Python环境安装"></a>Python环境安装</h1><p>安装编译 Python 3.10 所需的依赖项：</p>
<p><code>sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev wget</code></p>
<p>下载 Python 3.10 的源代码：</p>
<p><code>wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz</code></p>
<p>解压源代码：</p>
<p><code>tar -xf Python-3.10.0.tgz</code></p>
<p>进入解压后的目录：</p>
<p><code>cd Python-3.10.0</code></p>
<p>配置 Python 3.10 的编译选项：</p>
<p><code>./configure --enable-optimizations</code></p>
<p>编译并安装 Python 3.10：</p>
<p><code>make -j 8</code><br><code>sudo make altinstall</code></p>
<p>确认 Python 3.10 是否安装成功：</p>
<p><code>python3.10 --version</code></p>
<p>如果输出了 Python 3.10 的版本号，则说明安装成功。</p>
<blockquote>
<p><strong>pip下载时出现网络问题</strong></p>
<p>临时使用：</p>
<p>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> gevent，这样就会从清华这边的镜像去安装gevent库。</p>
<p>永久修改，一劳永逸：</p>
<p>Linux下，修改 ~&#x2F;.pip&#x2F;pip.conf (没有就创建一个)， 修改 index-url至tuna，内容如下：</p>
<p>[global]<br>index-url &#x3D; <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下</p>
<p>[global]<br>index-url &#x3D; <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
</blockquote>
<h1 id="nginx环境安装"><a href="#nginx环境安装" class="headerlink" title="nginx环境安装"></a>nginx环境安装</h1><p><del>安装nginx</del></p>
<p><code>sudo apt install nginx</code></p>
<p><del>访问公网IP，发现nginx页面安装成功</del></p>
<p><del>修改nginx配置文件<code>sudo vi /etc/nginx/sites-enabled/default</code></del></p>
<p><del>修改完成后重启nginx服务<code>sudo service nginx restart</code></del></p>
<h1 id="FRP内网穿透配置"><a href="#FRP内网穿透配置" class="headerlink" title="FRP内网穿透配置"></a>FRP内网穿透配置</h1><p>待补充</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境下终端的使用</title>
    <url>/2024/03/26/terminal/</url>
    <content><![CDATA[<h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p>一个基于文本的交互界面</p>
<blockquote>
<p><strong>快捷键</strong></p>
<p>打开命令行终端<code>Ctrl+Alt+t</code></p>
<p>放大终端<code>Ctrl Shirft +</code></p>
<p>缩小终端<code>Ctrl -</code></p>
</blockquote>
<p><strong>终端提示符含义</strong><br><code>lemonade@ubuntu:~$</code>对应<br>用户名(lemonade)@主机名(ubuntu):工作目录(~) 提示符($)</p>
<blockquote>
<p>~：家目录</p>
</blockquote>
<blockquote>
<p>$: 普通用户<br>#: 超级用户(root)</p>
</blockquote>
<p><strong>命令</strong>—在终端中用于告诉计算机去执行一个动作</p>
<p><strong>参数</strong>—</p>
<p><strong>选项</strong>—选项通常用一个连接号（<code>-</code>）或两个连接号（<code>--</code>）来划分</p>
<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><ul>
<li><code>ls</code>: 列出当前目录内容</li>
<li><code>cd ~</code>: 进入当前用户的家目录</li>
<li><code>./</code>当前目录(可省略)</li>
<li><code>../</code>上一层目录</li>
<li><code>../../ </code>上一层的上一层</li>
</ul>
<p><strong>文件操作指令</strong></p>
<ul>
<li><code>mkdir</code> 创建文件夹 <code>mkdir  mydir</code></li>
<li><code>touch</code> 创建空文件 <code>touch myfile</code></li>
<li><code>rmdir</code>删除一个空文件夹</li>
<li><code>rm</code> 删除一个文件或文件夹,默认删除文件</li>
<li><code>rm -r</code> 	删除文件夹</li>
</ul>
<p><strong>打印定向指令</strong></p>
<ul>
<li><code>echo</code>  打印一串字符 <code>echo  hello world</code></li>
<li>&gt; 输出重定向&#x2F;指定输出的目标文件</li>
<li>&gt;&gt; 向指定文件中追加内容</li>
<li><code>cat</code>  读文件内容并打印 <code>cat readme</code></li>
</ul>
<p><strong>root&amp;sudo</strong></p>
<ul>
<li><code>sudo passwd</code> 通过普通用户修改超级用户(root)的密码.</li>
<li><code>su  root</code> 切换用户为root用户(超级用户)</li>
<li><code>su  lemonade</code>    切换为lemonade用户.</li>
<li><code>sudo</code> 用普通用户权限执行root的功能</li>
</ul>
<blockquote>
<p>普通用户权限执行root的功能需注意用户环境下的环境变量和root用户环境的下环境变量是否一致</p>
</blockquote>
<p><strong>移动拷贝指令</strong></p>
<ul>
<li><code>mv</code> 移动命令<code>mv   source  dest``mv   source  dir</code></li>
<li><code>cp</code> 拷贝命令</li>
</ul>
<p><strong>man 用户帮助手册</strong></p>
<p><code>man ls </code></p>
<blockquote>
<p><code>ls  [options]...    [file]... </code></p>
<p><code>options</code>选项或参数</p>
<p><code>file</code>目标文件或文件夹</p>
<p><code>[]</code>可选标志</p>
<p><code>...</code> 多参机制</p>
</blockquote>
<p><strong>改变权值的命令</strong></p>
<ul>
<li><code>chmod  777 readme.sh </code>所有用户可读可写可执行</li>
</ul>
<blockquote>
<p>文件类型:</p>
<p>- ：普通文件<br>d : 文件夹&#x2F;目录<br>l : 链接(快捷方式)<br>s : 网络套接字<br>p: 管道<br>b : 块设备, 磁盘   c : 字符设备, 键盘</p>
</blockquote>
<p><strong>关机</strong></p>
<ul>
<li><code>halt</code> 关机</li>
<li><code>reboot</code> 重启</li>
<li><code>sudo shutdown  -h  now</code> 加上关机时间</li>
<li><code>sudo shutdown  -h  +1 &quot;See You la la&quot;</code> 加上关机备注</li>
</ul>
<h1 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h1><h2 id="设置服务"><a href="#设置服务" class="headerlink" title="设置服务"></a>设置服务</h2><p>编辑或创建<code>/usr/lib/systemd/system/startmyapp.service</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]    #服务的说明</span><br><span class="line">Description=nginx    #描述服务</span><br><span class="line">After=network.target    #描述服务类别</span><br><span class="line"></span><br><span class="line">[Service]    #服务运行参数的设置</span><br><span class="line">Type=forking    #是后台运行的形式</span><br><span class="line">PIDFile=/var/run/nginx.pid</span><br><span class="line">ExecStartPre=/usr/bin/nginx -t -c ./nginx.conf</span><br><span class="line">ExecStart=/usr/bin/nginx -c ./nginx.conf    #服务的具体运行命令</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID    #重启命令</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID    #停止命令</span><br><span class="line">PrivateTmp=true    #给服务分配独立的临时空间</span><br><span class="line"></span><br><span class="line">[Install]    #运行级别下服务安装的相关设置</span><br><span class="line">WantedBy=multi-user.target    #设置为多用户，系统运行级别为3</span><br></pre></td></tr></table></figure>

<p><strong>操作服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置开机自启动</span><br><span class="line">systemctl enable startmyapp.service</span><br><span class="line"># 停止开机自启动</span><br><span class="line">systemctl disable startmyapp.service</span><br><span class="line"># 启动服务</span><br><span class="line">systemctl start startmyapp.service</span><br><span class="line"># 关闭服务</span><br><span class="line">systemctl stop startmyapp.service</span><br><span class="line"># 重新启动服务</span><br><span class="line">systemctl restart startmyapp.service</span><br><span class="line"># 重新加载服务配置文件</span><br><span class="line">systemctl reload startmyapp.service</span><br><span class="line"># 查看服务当前状态</span><br><span class="line">systemctl status startmyapp.service</span><br><span class="line"># 查看所有已启动的服务</span><br><span class="line">systemctl list-units --type=services</span><br><span class="line"># 查询服务是否开机启动</span><br><span class="line">systemctl is-enabled startmyapp.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="设置脚本"><a href="#设置脚本" class="headerlink" title="设置脚本"></a>设置脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.local</span><br><span class="line"></span><br><span class="line"># 添加启动脚本</span><br><span class="line">/usr/bin/nginx start</span><br><span class="line"></span><br><span class="line">chmod +x /etc/rc.d/rc.local</span><br><span class="line"># /etc/rc.d/rc.local是/etc/rc.local的软连接</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>版本控制方案</title>
    <url>/2024/05/17/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="Git方案"><a href="#Git方案" class="headerlink" title="Git方案"></a>Git方案</h1><p>1.      仓库创建</p>
<p>仓库创建基于当前的项目，例如备份仪表项目仓库，LSA项目等</p>
<p>2.      分支创建</p>
<p>项目主分支保存项目代码及文档，负责发布代码</p>
<p>项目开发分支保存项目源码，分支仅管理员可见</p>
<p>项目运行分支保存项目头文件及库文件代码，分支所有人可见</p>
<p>项目人员开发分支基于运行分支创建，仅该人员有权限，该人员开发任务基于该分支进行修改代码</p>
<p>3.      代码提交</p>
<p>各人员代码仅提交在单独分支，提交完成后，由管理员审核后，同步源代码至开发分支</p>
<p>4.      版本回退</p>
<h1 id="SVN方案"><a href="#SVN方案" class="headerlink" title="SVN方案"></a>SVN方案</h1>]]></content>
  </entry>
  <entry>
    <title>AnythingLLM笔记</title>
    <url>/2024/05/17/AI-AnythingLLM%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>RAG检索知识体系</title>
    <url>/2024/05/17/AI-RAG%E6%A3%80%E7%B4%A2%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="Windows本地部署Ollama-AnythingLLM解读本地文档-构建私有知识库"><a href="#Windows本地部署Ollama-AnythingLLM解读本地文档-构建私有知识库" class="headerlink" title="Windows本地部署Ollama + AnythingLLM解读本地文档 构建私有知识库"></a>Windows本地部署Ollama + AnythingLLM解读本地文档 构建私有知识库</h1><p>现阶段切入大模型应用落地最合适的方案依然是结合大模型基于RAG检索增强来实现知识库的检索和生存。从而构建个人或者企业私有化的本地知识库。</p>
<p>你只需要将本地私有的 PDF、Word 文档和文本文件嵌入到本地向量库，连接上LLM，然后就可以通过对话、搜索的方式进行回答问题、提供见解，甚至生成摘要。</p>
<p>Ollama 下载地址 <a href="https://ollama.com/download">https://ollama.com/download</a><br>Ollama配置文档<a href="ollama%E7%AC%94%E8%AE%B0.md">ollama笔记</a><br>AnythingLLM 下载地址 <a href="https://useanything.com/download">https://useanything.com/download</a><br>AnythingLLM配置文档<a href="AnythingLLM%E7%AC%94%E8%AE%B0.md">AnythingLLM笔记</a></p>
<blockquote>
<p><strong>AnythingLLM</strong> 是 Mintplex Labs Inc. 开发的一个基于RAG（Retrieval-Augmented Generation）方案构建的开源、高效、可定制的私有知识库解决方案，一款开源 ChatGPT 等效工具，用于在安全的环境中与文档等进行聊天，专为想要使用现有文档进行智能聊天或构建知识库的任何人而构建。</p>
<p><strong>AnythingLLM 能够把各种文档、资料或者内容转换成一种格式</strong>，让LLM（如ChatGPT）在聊天时可以引用这些内容。然后你就可以用它来和各种文档、内容、资料聊天，<strong>支持多个用户同时使用，还可以设置谁能看或改哪些内容。</strong> <strong>支持多种LLM、嵌入器和向量数据库。</strong></p>
</blockquote>
<p>Open WebUI 安装地址 <a href="https://github.com/v1cc0/open-webui">https://github.com/v1cc0/open-webui</a></p>
<ol>
<li><p>安装Ollama工具后，在命令行输入 ollama pull qwen:4b  下载模型 千问4b的模型，也可以下载其他模型 ，支持的模型列表：<a href="https://ollama.com/library%E3%80%82">https://ollama.com/library。</a></p>
</li>
<li><p>要开始运行Ollama的话，只需要在命令行输入 ollama run qwen:4b 就可以使用并访问这个模型了。</p>
</li>
<li><p>接下来我们需要安装向量模型和数据库，在<a href="https://ollama.com/%E9%87%8C%E9%9D%A2%E6%90%9C%E7%B4%A2">https://ollama.com/里面搜索</a> nomic-embed-text ，这个模型可以将文本内容转换成向量数据，里面是模型介绍。</p>
</li>
<li><p>安装模型可以在命令行输入 ollama pull nomic-embed-text 进行下载和安装。</p>
</li>
<li><p>安装AnythingLLM工具后打开初始化界面，会进入到配置页面，在 LLM Preference 选项卡中，选择Ollama，然后配置 <a href="http://127.0.0.1:11434/">http://127.0.0.1:11434</a> 、选择运行的大模型 qwen:4b ，token填 8192 </p>
</li>
<li><p>下一步是配置 Embedding Preference 选项卡中，一样选择 Ollama，然后配置 <a href="http://127.0.0.1:11434/">http://127.0.0.1:11434</a> 、选择运行的大模型 nomic-embed-text ，length填 512 </p>
</li>
<li><p>下一步是配置 Vector Database ，选择默认的 LanceDB ，这是内置的向量数据库，如果想用云端数据库，可以选择 Pinecone 进行云端配置。</p>
</li>
<li><p>后面就是按提示下一步下一步，如果是要加新的工作空间，可以点new workspace来增加不同场景下的工作空间。如果需要更换模型，可以点左下角的配置按钮，重新执行上面三步完成配置。</p>
<p>到这里环境已经部署了，这时你已经可以跟大模型进行对话了。</p>
</li>
<li><p>接下来的步骤是对私有知识库的内容进行分析和获取。需要将文档上传到AnythinLLM，通过 nomic-embed-text 模型进行向量转换，然后存在向量数据库中。最后通过提问，去向量数据库获取内容并分析回答。</p>
<blockquote>
<p>Data Connectors 是一种工具，它允许用户将外部数据源无缝集成到他们的 AnythingLLM 工作空间中，而无需编写任何自定义代码或处理复杂的配置。这些经过验证的数据连接器确保与你的 AnythingLLM 实例兼容，提供了一种简单且直接的方式来扩展你的工作空间功能。</p>
<p>以下是一些可用的数据连接器及其功能：</p>
<ol>
<li><p><strong>GitHub Repo</strong>:</p>
<p>- 通过这个连接器，你可以一键导入整个公共或私有的 GitHub 仓库到你的 AnythingLLM 工作空间中。</p>
<p>- 访问 <a href="%5Bhttps://github.com%5D(https://github.com/)">GitHub</a> 来获取你想要导入的仓库的链接。</p>
<p>- 这个功能对于开发者和团队来说非常有用，因为它允许他们直接在 AnythingLLM 中管理和查看代码库，跟踪问题和特性请求，以及审查代码。</p>
</li>
<li><p><strong>YouTube Transcript</strong>:</p>
<p>- 这个连接器允许你从 YouTube 视频链接导入整个视频的转录文本。</p>
<p>- 只需提供 YouTube 视频的链接，就可以轻松获取视频的文字内容。</p>
<p>- 这对于需要分析视频内容、创建视频摘要或者进行视频内容相关的研究的用户来说非常有用。</p>
</li>
</ol>
<p>使用这些数据连接器，你可以快速地将外部数据集成到你的工作流程中，从而提高效率和生产力。例如，如果你正在研究一个特定的编程问题，你可以直接导入相关的 GitHub 仓库来查看代码和文档；或者，如果你需要分析一个教育视频的内容，你可以导入视频的转录文本来进行文本分析。</p>
<p>这些连接器的使用通常涉及到在 AnythingLLM 工作空间中选择相应的连接器，然后按照提示输入必要的信息，如仓库链接或视频链接，之后就可以开始导入数据了。整个过程简单直观，无需专业的编程知识，使得用户可以专注于数据分析和决策，而不是技术细节。</p>
</blockquote>
</li>
<li><p>在工作空间页面上有一个上传文档的按钮，点击可以上传我们的文档内容。上传后选中文档，点击 Save and Embed ，等待一段时间，让模型进行向量转换和保存。</p>
</li>
<li><p>然后回到主界面点击工作空间的设置，选择 Chat Setting 选项卡，这里对话模式选择 Query ，这个模式是指只从提供的文档内容进行查找分析，而不要求大语言模型里面提供的信息作答。最后点击 Update workspace 进行更新。</p>
</li>
<li><p>然后就可以进行提问了，以上是本地部署应用的地方，如果你的电脑不太行，可以装Ollama部署在云端GPU服务器，然后本地安装AnythingLLM，在选择URL上填写云端Ollama的地址即可。</p>
<blockquote>
<p><strong>配置LLM</strong><br>这里选择Ollama作为后台的服务，URL这里填写<code>http://127.0.0.1:11434</code>，也就是前面Ollama启动的服务端口，填写后LLM模型选择<code>gemma:2b</code></p>
<p><strong>配置Embedding Model</strong><br>这里同样选择Ollama作为后台的服务，URL这里同样填写<code>http://127.0.0.1:11434</code>，填写后Embedding Model选择<code>nomic-embed-text:latest</code></p>
<p><strong>配置Vector Database</strong><br>Vector Database选择默认的第一个<code>LanceDB</code></p>
<p>以上三个关键配置完成后，就可以开始使用AnythingLLM了。</p>
<p><strong>创建文档库</strong><br>点击<code>New Workspace</code>新建文档库，并填写名称<br>点击按钮开始添加文档<br>我们使用的文档是<code>paul_graham_essay.txt</code>，这个文档也可以从github上下载：<a href="https://github.com/xinsblog/try-llama-index/blob/master/data/paul_graham_essay.txt">https://github.com/xinsblog/try-llama-index/blob/master/data/paul_graham_essay.txt</a> 。</p>
<p>添加文档后还要将文档<code>Move to Workspace</code><br>然后点击<code>Save and Embed</code><br>出现<code>Workspace updated successfully</code>就表示配置已经完成</p>
<p><strong>开始测试</strong><br>回到主页面，输入问题<code>What did the author do in 9th grade?</code><br>几秒钟后就可以看到AnythingLLM给出的回答</p>
</blockquote>
</li>
<li><p>第三个工具就是Open WebUI，此工具可以支持云端部署web界面，在浏览器上访问大模型。</p>
</li>
<li><p>前置需要安装Docker，具体安装步骤可以看<a href="https://github.com/v1cc0/open-webui%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%86%8D%E8%B5%98%E8%BF%B0%E3%80%82">https://github.com/v1cc0/open-webui上面的安装步骤，这里就不再赘述。</a></p>
</li>
<li><p>安装完后输入github上的指令即可连通Ollama，并进行使用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>ollama笔记</title>
    <url>/2024/05/17/AI-ollama%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>支持的模型</p>
<p><a href="https://ollama.com/library">https://ollama.com/library</a></p>
<h1 id="在用的ollama模型"><a href="#在用的ollama模型" class="headerlink" title="在用的ollama模型"></a>在用的ollama模型</h1><p>ollama.exe list<br>ollama run llama3:8b<br>ollama run codellama:7b<br>ollama run qwen:14b<br>ollama run starcoder2:7b<br>ollama run nomic-embed-text</p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>SIZE</th>
<th>FEATURES</th>
</tr>
</thead>
<tbody><tr>
<td>codellama:latest</td>
<td>3.8 GB</td>
<td></td>
</tr>
<tr>
<td>llama3:latest</td>
<td>4.7 GB</td>
<td></td>
</tr>
<tr>
<td>starcoder2:3b</td>
<td>1.7 GB</td>
<td></td>
</tr>
<tr>
<td>qwen:4b</td>
<td></td>
<td></td>
</tr>
<tr>
<td>nomic-embed-text</td>
<td></td>
<td></td>
</tr>
<tr>
<td>系统变量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>OLLAMA_MODELS</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指定模型位置</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="Ollama-on-Linux"><a href="#Ollama-on-Linux" class="headerlink" title="Ollama on Linux"></a>Ollama on Linux</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure>

<h1 id="Ollama使用"><a href="#Ollama使用" class="headerlink" title="Ollama使用"></a>Ollama使用</h1><h1 id="Ollama大模型联网"><a href="#Ollama大模型联网" class="headerlink" title="Ollama大模型联网"></a>Ollama大模型联网</h1><h2 id="Python及库"><a href="#Python及库" class="headerlink" title="Python及库"></a>Python及库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure>

<h2 id="定义联网函数"><a href="#定义联网函数" class="headerlink" title="定义联网函数"></a>定义联网函数</h2><p>需要定义一个联网函数，用于与互联网上的服务器进行通信。这个函数可以发送HTTP请求，接收服务器的响应，并返回结果。以下是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connect_to_server</span>(<span class="params">url, data</span>):</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;</span><br><span class="line">    response = requests.post(url, data=json.dumps(data), headers=headers)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error connecting to server:&quot;</span>, response.status_code)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="配置Ollama"><a href="#配置Ollama" class="headerlink" title="配置Ollama"></a>配置Ollama</h2><p>在联网之前，我们需要对Ollama大模型进行一些配置。这包括设置模型的参数、训练数据和测试数据等。具体的配置方法取决于你所使用的Ollama大模型。以下是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置模型参数</span></span><br><span class="line">model_params = &#123;</span><br><span class="line">    <span class="string">&quot;learning_rate&quot;</span>: <span class="number">0.001</span>,</span><br><span class="line">    <span class="string">&quot;num_epochs&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">&quot;batch_size&quot;</span>: <span class="number">32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载训练数据和测试数据</span></span><br><span class="line">train_data = load_train_data()</span><br><span class="line">test_data = load_test_data()</span><br></pre></td></tr></table></figure>

<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>在配置好Ollama大模型后，我们可以开始训练模型。训练过程中，我们可以使用之前定义的联网函数将模型的中间结果上传到服务器上。以下是一个示例：</p>
<pre><code>for epoch in range(model_params[&quot;num_epochs&quot;]):
    # 训练模型
    train_model(train_data, model_params)

    # 将中间结果上传到服务器
    url = &quot;http://example.com/upload&quot;
    data = &#123;
        &quot;epoch&quot;: epoch,
        &quot;loss&quot;: get_current_loss(),
        &quot;accuracy&quot;: get_current_accuracy()
    &#125;
    connect_to_server(url, data)
</code></pre>
<h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><p>训练完成后，我们可以使用测试数据对模型进行测试。同样，我们可以使用联网函数将测试结果上传到服务器上。以下是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试模型</span></span><br><span class="line">test_model(test_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将测试结果上传到服务器</span></span><br><span class="line">url = <span class="string">&quot;http://example.com/upload&quot;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;test_loss&quot;</span>: get_test_loss(),</span><br><span class="line">    <span class="string">&quot;test_accuracy&quot;</span>: get_test_accuracy()</span><br><span class="line">&#125;</span><br><span class="line">connect_to_server(url, data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过以上步骤，我们已经成功地让Ollama大模型联网了。在实际应用中，你可能需要根据具体的需求和环境进行调整和优化。希望本文能够帮助你更好地理解和应用Ollama大模型的联网功能。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>Qexo管理Hexo博客</title>
    <url>/2024/05/21/%E5%8D%9A%E5%AE%A2-Qexo%E7%AE%A1%E7%90%86Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>克隆qexo项目到本地<br><code>git clone https://github.com/Qexo/Qexo.git</code><br>编辑配置，以使用 Mysql 为例, 确认好安装相关依赖后在manage.py的同级目录下创建并修改 configs.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql  </span><br><span class="line">pymysql.install_as_MySQLdb()  </span><br><span class="line">DOMAINS = [<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;124.222.246.202&quot;</span>]  </span><br><span class="line">DATABASES = &#123;  </span><br><span class="line">	<span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">		<span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;数据库表&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;数据库用户名&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;数据库密码&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,  </span><br><span class="line">		<span class="string">&#x27;OPTIONS&#x27;</span>: &#123;  </span><br><span class="line">		<span class="string">&quot;init_command&quot;</span>: <span class="string">&quot;SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;&quot;</span>  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirements.txt  </span><br><span class="line">python3 manage.py makemigrations  </span><br><span class="line">python3 manage.py migrate</span><br></pre></td></tr></table></figure>
<p>启动Qexo博客管理后端<br><code>python3 manage.py runserver 0.0.0.0:9051 --noreload</code><br>访问公网IP+端口即可打开管理页面</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1>]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>我的博客</title>
    <url>/2024/05/17/%E5%8D%9A%E5%AE%A2-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>要更换主题的情况下</p>
<ul>
<li>修改.github&#x2F;workflows&#x2F;blogPublish.yml</li>
<li>修改_config.theme.yml</li>
<li>修改_config.yml</li>
<li><a href="#GitHub%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2">GitHub仓库部署</a></li>
</ul>
<p>拉取仓库并本地部署脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf ./BlogDeploy</span><br><span class="line">git clone git@github.com:liuluhua/BlogDeploy.git</span><br><span class="line">cd ./BlogDeploy</span><br><span class="line">mkdir themes</span><br><span class="line">cd themes</span><br><span class="line">git clone git@github.com:xaoxuu/hexo-theme-stellar.git</span><br><span class="line">git clone git@github.com:next-theme/hexo-theme-next.git</span><br><span class="line">cd ..</span><br><span class="line">npm install</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s -p 9050</span><br></pre></td></tr></table></figure>

<ol>
<li>博客框架采用Hexo</li>
<li>部署到GitHubPages（）</li>
<li>部署到Vercel（GitHub Publish）</li>
<li>通过Netlify部署和构建</li>
<li>利用Obsidian Digital Garden&#x2F;Flowershow插件在Vercel上将笔记内容部署为Obsidian数字花园</li>
</ol>
<h1 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h1><ul>
<li>创建GitHub发布仓库<a href="#GitHub%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2">GitHub仓库部署</a></li>
<li>创建GitHub源码仓库，并在仓库中部署Hexo</li>
<li>在源码仓库中创建工作流，工作流主要完成任务是在接收到同步后，完成以下几个动作<a href="#GitHub%20Actions">GitHub Actions</a><ul>
<li>构建静态页面生成public文件夹，在构建之前需要调用hexo插件自动生成category信息</li>
<li>将public文件夹拷贝至发布仓库</li>
</ul>
</li>
</ul>
<h1 id="确定Hexo仓库部署在GitHub还是本地"><a href="#确定Hexo仓库部署在GitHub还是本地" class="headerlink" title="确定Hexo仓库部署在GitHub还是本地"></a>确定Hexo仓库部署在GitHub还是本地</h1><h2 id="如果部署在GitHub"><a href="#如果部署在GitHub" class="headerlink" title="如果部署在GitHub"></a>如果部署在GitHub</h2><p>则需要整个仓库拉取到obsidian，主要显示post下文件，需要通过github actions进行发布管理<br>优点：本地不需要Hexo环境，直接提交后自动构建页面<br>缺点：所有源码都在Github且仓库必须公开</p>
<h2 id="如果部署在本地"><a href="#如果部署在本地" class="headerlink" title="如果部署在本地"></a>如果部署在本地</h2><p>需要在本地生成静态网页，之后将静态网页通过publisher发布public文件夹到github仓库<br>优点：仓库可以不开源<br>缺点：本地需要具有Hexo环境，且需要在本地生成静态网页</p>
<h2 id="两个仓库都在Github"><a href="#两个仓库都在Github" class="headerlink" title="两个仓库都在Github"></a>两个仓库都在Github</h2><p>是否可以实现，编辑完成后，github从源码仓库复制到发布仓库？<br>源码仓库闭源，同步笔记到源码仓库后，源码仓库通过actions时触发同步到发布仓库，更新发布仓库页面</p>
<ul>
<li>扩展：三仓库管理，Markdown仓库只用于编辑Markdown文件，同步后触发actions，同步到源码仓库中的post，源码仓库接受到push后，触发actions生成静态页面public，public生成完成后拷贝public到发布仓库<br>利用actions，可以实现，感觉没啥必要，太过复杂了，源码仓库+发布仓库基本就可以了</li>
</ul>
<h2 id="两仓库实现步骤"><a href="#两仓库实现步骤" class="headerlink" title="两仓库实现步骤"></a>两仓库实现步骤</h2><p>可以实现两个仓库都在 GitHub，并通过 GitHub Actions 自动将源码仓库的内容复制到发布仓库。这样可以将编辑完成后的 Hexo 源码仓库内容自动同步到发布仓库，实现自动化的发布管理。</p>
<ol>
<li>将 Hexo 的源码仓库设置在 GitHub 上，你可以在这个仓库中编辑和管理 Hexo 的源代码、主题和文章。</li>
<li>创建另一个 GitHub 仓库作为发布仓库，用于存放生成的静态网页。你可以将 Hexo 生成的 public 文件夹的内容推送到这个仓库中。该仓库利用GitHub Pages，直接通过.github.io进行访问</li>
<li>在 Hexo 源码仓库中设置一个 GitHub Actions workflow，以便在每次提交或推送时自动将更新的内容复制到发布仓库。</li>
<li>需要配置GitHub的ssh，可以有权限访问两个仓库</li>
<li>需要配置发布仓库的deploy key，可以有权限写入发布仓库</li>
</ol>
<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><ul>
<li>GitHub二级域名<a href="https://pages.github.com/">GitHubPages</a></li>
<li>二级域名<a href="https://freedomain.one/">https://freedomain.one/</a></li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>包括添加三条解析记录</p>
<ul>
<li>192.30.252.153是GitHub的地址，你也可以ping你的 <a href="https://liuluhua.github.io/">http:&#x2F;&#x2F;你的用户名.github.io</a> 的ip地址，填入进去。</li>
<li>第三个记录类型是CNAME，CNAME的记录值是：<a href="https://liuluhua.github.io/">http:&#x2F;&#x2F;你的用户名.github.io</a> 这里千万别弄错了。</li>
<li>绑定Github域名，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名</li>
</ul>
<h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><h2 id="GitHub图床"><a href="#GitHub图床" class="headerlink" title="GitHub图床"></a>GitHub图床</h2><ul>
<li>创建一个public仓库</li>
<li>进入Settings-Developer Settings-Personal access tokens (classic)生成token</li>
</ul>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>图床设计选择GitHub，输入在GitHub的仓库名，分支名和token即可</p>
<h1 id="Obsidian"><a href="#Obsidian" class="headerlink" title="Obsidian"></a>Obsidian</h1><p><code>Ctrl+Shift+I</code>在控制台里可以查看详细日志，所有插件的日志都可以在这里看到</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Hexo忽略文件和文件夹"><a href="#Hexo忽略文件和文件夹" class="headerlink" title="Hexo忽略文件和文件夹"></a>Hexo忽略文件和文件夹</h3><p>由于 hexo 的文章只存在于 <code>source</code> 目录下，我们需要让 Obsidian 忽略其他文件的内容以优化性能以及减少不必要的搜索结果。具体的操作是在 <code>设置-文件与链接-Exclude Files</code>，将需要忽略的文件添加进去（尤其是 node_modules）。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Templater"><a href="#Templater" class="headerlink" title="Templater"></a>Templater</h3><p>模板配置说明文档 <a href="https://silentvoid13.github.io/Templater/introduction.html">https://silentvoid13.github.io/Templater/introduction.html</a> </p>
<p>首先我们要创建模板，我们可以在 <code>source</code> 目录下创建 <code>_obsidian</code> 文件夹，并创建一篇 <code>Post Template</code> 的文章（md文件），我们再创建新文章的时候，只需要点击侧边栏的『插入模板』按钮就可以快速生成 Front-matter 信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: &lt;% tp.file.title %&gt;</span><br><span class="line">date: &lt;% tp.file.creation_date(format=&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;</span><br><span class="line">update: &lt;% tp.file.last_modified_date(&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;</span><br><span class="line">comments: true</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">dg-publish: true</span><br><span class="line">---</span><br><span class="line">定义脚本</span><br><span class="line"></span><br><span class="line">function generateTimestampUrl() &#123;  </span><br><span class="line">  var timestamp = Math.round(new Date() / 1000);  </span><br><span class="line">  var url = timestamp.toString(36)  </span><br><span class="line">  return url;  </span><br><span class="line">&#125;  </span><br><span class="line">module.exports = generateTimestampUrl;</span><br></pre></td></tr></table></figure>

<h3 id="osidian-git"><a href="#osidian-git" class="headerlink" title="osidian-git"></a>osidian-git</h3><p>快捷键<code>Ctrl + P</code>打开命令面板，输入open source control view启用可视化操作面板</p>
<h3 id="obsidian-pangu"><a href="#obsidian-pangu" class="headerlink" title="### obsidian-pangu"></a>### obsidian-pangu</h3><p>中英文之间加空格</p>
<h3 id="Hidden-Folder"><a href="#Hidden-Folder" class="headerlink" title="Hidden Folder"></a>Hidden Folder</h3><p>目录隐藏插件</p>
<h3 id="FileTree"><a href="#FileTree" class="headerlink" title="FileTree"></a>FileTree</h3><p>左侧菜单出现了一个 <code>File Tree</code> 的 Tab 页，点击后就可以看到文件以树形的结构呈现，我们展开 <code>source</code> 文件夹，并右键 <code>_post</code> 文件夹，选择 <code>Focuse on Folder</code> 后，左侧的文件列表中就只会显示 <code>_post</code> 文件夹中的内容了</p>
<h3 id="Github-Publisher"><a href="#Github-Publisher" class="headerlink" title="Github Publisher"></a>Github Publisher</h3><p>将 Obsidian 中的文章和本地附件上传到 Github 仓库，上传前可以指定文件目录、自定义内容替换等操作。<br>能将Obsidian仓库里的任意笔记自动或者手动同步到GitHub代码仓库的任意位置。首先设置好Github相关信息，包括Github repository，用户名，token以及Branch。当然也可以在单个笔记文件里，通过文档属性（frontmatter），单独设置接收笔记上传的Github仓库信息（可以选择同一用户下的不同仓库，同一仓库下的不同位置）。<br><strong>上传设置</strong><br>设定上传的笔记存储在Github仓库的位置。因为我的hexo博客日志文件保存在source&#x2F;posts目录下，故选择Fixed Folder，设定好默认上传到的目录。<br><strong>文章发布</strong><br>在文章文档属性添加一个share属性（可以根据需要在插件设置里改成其他任意名称），赋予值 true。文章写好后，<code>share: true</code>右键发布。</p>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>用于插入一个按钮<br>设置按钮信息：</p>
<ul>
<li>按钮类型（也就是功能）选择Link - open a url or uri</li>
<li>链接可以使用<code>file://</code>或者<code>Obsidian URI</code>，这个时候后者的好处就体现出来了，因为<code>file://</code>只能用绝对路径，例如<code>file://C:\Users\GavinCrown\Desktop\SecondBrain\Blog\_config.yml</code>，意味着每换一台设备你的链接就得改一次。</li>
<li>设置完成后，点Insert Button就可以将按钮插入到当前Markdown文件中：</li>
</ul>
<h3 id="ShellCommand"><a href="#ShellCommand" class="headerlink" title="ShellCommand"></a>ShellCommand</h3><p>再介绍个终极优化方案，之前我们执行命令是通过运行bat文件，而Shell commands可以在Obsidian中设置好命令，并通过Obsidian的命令面板或快捷键快速运行。<br>在插件设置面板中添加命令<br>运行博客：</p>
<ul>
<li>Shell commands没有显示终端窗口的功能，所以需要我们启动powershell再传入命令</li>
<li>有了终端窗口我们才可以在窗口中按Ctrl + C关闭Hexo服务，否则它会一直占用端口<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start powershell <span class="string">&#x27;-NoExit -Command start http://localhost:4000 ; cd Blog ; hexo s&#x27;</span></span><br></pre></td></tr></table></figure>
打开站点和主题配置文件：<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">start Blog/_config.yml</span><br><span class="line">start Blog/themes/butterfly4.3.1/_config.yml</span><br></pre></td></tr></table></figure>
然后修改默认执行环境为PowerShell 5，可以为每个命令设置下别名，就是在命令面板显示的名字</li>
</ul>
<h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><ul>
<li>Obsidian Linter 插件,我只用了在英文两边加空格的设置。</li>
<li>Image Converter 转化图片格式，我统一转为 webp，并设置了图片分辨率大小。</li>
<li>Unique attachments 用于将附件的文件名统一为 “字母 + 数字”的格式,记着在配置里加入 webp 图片格式</li>
<li>Image Inserter 用于找图片，我用于设置文章封面，即设置 <code>cover.image</code> 属性。</li>
</ul>
<h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="Github-Pages部署"><a href="#Github-Pages部署" class="headerlink" title="Github Pages部署"></a>Github Pages部署</h2><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。<br>创建GitHub账号，并创建一个基于用户名.github.io的仓库</p>
<ul>
<li>使用GitHub Pages进行部署，所建仓库必须取名为“GitHub用户名.github.io”</li>
<li>勾选“Add a README file”，不然后面会看不到GitHub Pages域名和部署分支</li>
<li>仓库需要创建为公有仓库，即public</li>
<li>仓库大小限制为</li>
<li>创建完成后GitHub Pages给我们提供了一个格式为 <a href="https://liuluhua.github.io/">https://GitHub用户名.github.io</a>  的免费域名，并且相应的网站是从该仓库的 main&#x2F;master 分支构建得到的</li>
<li>自定义域名，在GitHub 仓库<code>Settings</code>-<code>Pages</code>-<code>Custom domain</code>添加自己的域名</li>
</ul>
<h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><blockquote>
<p>GitHub Actions 是 GitHub 提供的一项持续集成（CI）和持续部署（CD）服务，允许开发者自动化软件开发工作流程。通过 GitHub Actions，你可以在 GitHub 上运行自定义的代码（称为动作），以响应存储库中的事件，例如推送代码、创建拉取请求等。<br>一个 GitHub Actions 的核心概念是 workflow（工作流），它是一系列由动作组成的自定义任务，这些任务可以在特定的事件触发时自动执行。每个 workflow 都定义了一系列步骤，每个步骤又包含一个或多个动作。workflow 可以用 YAML 格式定义，并存储在存储库的 <code>.github/workflows</code> 目录中。</p>
</blockquote>
<p>通过GitHub Actions，实现将代码同步GitHub之后，由GitHub Actions执行页面的发布。</p>
<ul>
<li>执行GitHub Actions，在需要执行的储存库中前往 <code>Settings &gt; Pages &gt; Source</code>，并将 <code>Source</code> 改为 <code>GitHub Actions</code>。</li>
<li>在储存库中建立 <code>.github/workflows/blogPublish.yml</code>并写入内容</li>
<li>环境变量配置在<code>Settings –&gt; Secrets and Variables –&gt; Actions</code> 里面,配置后，可以在actions里面通过 <code>$&#123;&#123; secrets.dingtalk_secret &#125;&#125;</code> 调用到对应的数据</li>
</ul>
<p><strong>使用Github Actions造成的文章更新时间问题</strong><br>参考原文：<a href="https://mrseawave.github.io/blogs/articles/2021/01/07/ci-hexo-update-time/">https://mrseawave.github.io/blogs/articles/2021/01/07/ci-hexo-update-time/</a></p>
<p>当使用 Travis CI or Github Actions 自动化部署时，发现部署成功后，所有文章的更新时间都变成了此次提交修改的时间，但有些文章在上一次提交后是没有发生过任何修改的。</p>
<p>这是因为 git 在推送更新时，并不记录保存文件的访问时间、修改时间等元信息，（原因在这里）所以每次使用 git 把项目 clone 下来时，文件的时间都是克隆时的时间。又因为如果没有在 front-matter 中指定 updated，Hexo 会默认使用文件的最后修改时间作为文章的更新时间，所以会出现所有文章的更新时间都发生变化的情况。</p>
<p>总的来说，使用 git clone 下来的文件的时间都不是原来文件的时间，而自动化部署每次都需要 clone 源码才能进行后面的生成和部署操作，所以目前如果想正确显示更新时间。对于Github Actions可以使用命令在构建之前进行处理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy_gh_pages:</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restore</span> <span class="string">file</span> <span class="string">modification</span> <span class="string">time</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">git</span> <span class="string">ls-files</span> <span class="string">-z</span> <span class="string">|</span> <span class="string">while</span> <span class="string">read</span> <span class="string">-d</span> <span class="string">&#x27;&#x27;</span> <span class="string">path;</span> <span class="string">do</span> <span class="string">touch</span> <span class="string">-d</span> <span class="string">&quot;$(git log -1 --format=&quot;</span><span class="string">@%ct&quot;</span> <span class="string">&quot;$path&quot;</span><span class="string">)&quot;</span> <span class="string">&quot;$path&quot;</span><span class="string">;</span> <span class="string">done</span></span><br></pre></td></tr></table></figure>

<p>如果git命令不好用， 也可以使用find命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find <span class="built_in">source</span>/_posts -name <span class="string">&#x27;*.md&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> file; <span class="keyword">do</span> <span class="built_in">touch</span> -d <span class="string">&quot;<span class="subst">$(git log -1 --format=<span class="string">&quot;@%ct&quot;</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span>)</span>&quot;</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>实际上，clone 下来的文件的时间还是克隆时的时间，然后通过上面的命令，它将 clone 下来的文件的时间改成了该文件最近一次变动的推送时间（也即文件最后一次修改的 push 时间）。</p>
<p>注：如果github actions中使用actions&#x2F;checkout@v2，请设定它的参数fetch-depth: 0，因为0表示获取所有分支和标签的所有历史记录。默认值为1</p>
<h2 id="Git-Hook"><a href="#Git-Hook" class="headerlink" title="Git Hook"></a>Git Hook</h2><p>Git hook是一种机制，允许在特定的Git事件发生时触发自定义的脚本或命令。这些事件可以包括提交(commit)、推送(push)、合并(merge)等。使用Git hook，你可以在这些事件发生时执行自定义的操作，比如运行测试、格式化代码、触发构建等。Git提供了一系列的预定义钩子，你可以将自己的脚本绑定到这些钩子上，或者创建自定义的钩子。</p>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>在Git仓库的根目录下编辑有.gitignore文件，该文件中定义了一些不需要上传至GitHub的内容，列在该文件中的文件或文件夹将会被忽略，不在上传</p>
<h3 id="Hexo忽略文件"><a href="#Hexo忽略文件" class="headerlink" title="Hexo忽略文件"></a>Hexo忽略文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">_multiconfig.yml</span><br></pre></td></tr></table></figure>

<h3 id="Obsidian忽略文件"><a href="#Obsidian忽略文件" class="headerlink" title="Obsidian忽略文件"></a>Obsidian忽略文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.obsidian/workspace</span><br></pre></td></tr></table></figure>
<p>.obsidian 文件本身是可以同步的，当前存储库的插件以及相关的配置都会下载在这个文件夹中，因此将其同步到 git 记录中也是非常有用的，假如你切换设备就不需要重新为当前的存储库重新配置 Obsidian 了。</p>
<h2 id="GitHub仓库部署"><a href="#GitHub仓库部署" class="headerlink" title="GitHub仓库部署"></a>GitHub仓库部署</h2><h3 id="源码仓库部署"><a href="#源码仓库部署" class="headerlink" title="源码仓库部署"></a>源码仓库部署</h3><ul>
<li>创建一个私有仓库，此处我创建一个BlogDeploy仓库，仓库拉取到本地后，在仓库中部署Hexo<a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li>创建gitignore文件，排除Hexo不用上传的文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#.DS_Store</span><br><span class="line">#Thumbs.db</span><br><span class="line">#db.json</span><br><span class="line">#*.log</span><br><span class="line">#node_modules/</span><br><span class="line">#.deploy*/</span><br><span class="line">#_multiconfig.yml</span><br><span class="line">public/</span><br></pre></td></tr></table></figure></li>
<li>同步仓库到远端</li>
</ul>
<h3 id="发布仓库部署"><a href="#发布仓库部署" class="headerlink" title="发布仓库部署"></a>发布仓库部署</h3><ul>
<li>创建一个GitHub仓库，仓库必须取名为“GitHub用户名.github.io”</li>
<li>仓库需要创建为公有仓库，即public</li>
<li>创建一个分支，分支名为ImageBed，用于做图床上传</li>
<li>获取Token，选择用户Settings-&gt;Developer settings-&gt;Personal access tokens，token的权限获取，勾上workflow即可</li>
</ul>
<h4 id="图床分支创建"><a href="#图床分支创建" class="headerlink" title="图床分支创建"></a>图床分支创建</h4><p>用于存储图片，图床分支的相关信息部署完成后，需要在<a href="#PicGo">PicGo</a>中进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b my-test  //在当前分支下创建my-test的本地分支分支</span><br><span class="line">git push origin my-test  //将my-test分支推送到远程</span><br><span class="line">git branch --set-upstream-to=origin/my-test //将本地分支my-test关联到远程分支my-test上   </span><br><span class="line">git branch -a //查看远程分支 </span><br></pre></td></tr></table></figure>
<h1 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h1><p>Hexo是一个基于Node.js的静态网站生成器，主要用于快速、简单地搭建个人博客或静态网站。它采用Markdown格式来撰写内容，并提供了丰富的主题和插件生态系统，可以轻松扩展和定制网站功能和外观。 适用于个人博客、项目文档、个人简历等各种静态网站的搭建和管理。</p>
<h2 id="目录架构"><a href="#目录架构" class="headerlink" title="目录架构"></a>目录架构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml #网站的配置信息</span><br><span class="line">package.json #应用程序的信息</span><br><span class="line">scaffolds #模版文件夹</span><br><span class="line">source #存放用户资源，Markdown 文档</span><br><span class="line">	_drafts</span><br><span class="line">	_posts</span><br><span class="line">themes #主题文件夹</span><br><span class="line">public #网站文件</span><br></pre></td></tr></table></figure>
<h2 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h2><p><strong>使用流程</strong></p>
<ol>
<li>安装hexo<code>sudo npm install -g hexo-cli</code></li>
<li>查看版本，确认安装成功<code>hexo -v</code></li>
<li>创建一个新文件夹<code>Hexo</code>，并初始化该文件夹<code>hexo init Hexo</code></li>
<li>清除缓存<code>hexo clean</code></li>
<li>生成静态文件<code>hexo g</code></li>
<li>开启本地服务器并修改端口为80<code>hexo s -p 9050</code></li>
</ol>
<p><strong>常用命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli #安装Hexo  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init #初始化博客  </span><br><span class="line">  </span><br><span class="line">命令简写  </span><br><span class="line">hexo n &quot;我的博客&quot;</span><br><span class="line">hexo new &quot;我的博客&quot; #新建文章  </span><br><span class="line">hexo g</span><br><span class="line">hexo generate #生成  </span><br><span class="line">hexo s</span><br><span class="line">hexo server #启动服务预览  </span><br><span class="line">hexo d</span><br><span class="line">hexo deploy #部署  </span><br><span class="line">  </span><br><span class="line">hexo server #Hexo会监视文件变动并自动更新，无须重启服务器  </span><br><span class="line">hexo server -s #静态模式  </span><br><span class="line">hexo server -p 5000 #更改端口  </span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP  </span><br><span class="line">hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</span><br><span class="line"></span><br><span class="line">端口修改 node_modules\hexo-server\index.js </span><br><span class="line">临时启动 hexo s -p 9050</span><br></pre></td></tr></table></figure>

<p><code>hexo generate</code>将Hexo源码目录中已有的源码编译生成为静态网页文件，生成以下：</p>
<ul>
<li>db.json文件：编译过程中产生的中间文件，不用关心；</li>
<li>public文件夹：新生成的静态网页文件就存放在这个目录下。</li>
</ul>
<p><code>hexo deploy</code>将静态网页文件推送到GitHub Pages</p>
<ul>
<li>Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置快捷打开<br>站点配置文件和主题配置文件是我们DIY博客经常要编辑的两个文件，在Obsidian中没法编辑yml文件，可以通过URL来打开yml文件，会自动调用默认的编辑器打开。</p>
<p>在主页Markdown中，按Ctrl+K插入链接，写入我们两个配置文件所在的相对路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[打开站点配置文件](Blog/_config.yml)</span><br><span class="line">[打开主题配置文件](Blog/themes/butterfly4.3.1/_config.yml)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者写成Obsidian URI的形式</span></span><br><span class="line">[打开站点配置文件](obsidian://open?file=Blog/_config.yml)</span><br><span class="line">[打开主题配置文件](obsidian://open?file=Blog/themes/butterfly4.3.1/_config.yml)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">![打开站点配置文件](Blog/_config.yml)</span><br><span class="line">![打开主题配置文件](Blog/themes/butterfly4.3.1/_config.yml)</span><br><span class="line">![运行博客](Blog/RunBlog.bat)</span><br></pre></td></tr></table></figure>
<h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p>在blog根目录里的_config.yml文件称为<strong>站点</strong>配置文件</p>
<ul>
<li>主题修改：theme</li>
<li>网站标题:title</li>
<li>副标题:subtitle</li>
<li>网站描述:description</li>
<li>作者:author</li>
<li>网站头像外部链接:avatar</li>
<li>网站语言:language:zh-Hans</li>
<li>时区:timezone:Asia&#x2F;Shanghai</li>
<li>自定义域名：url:</li>
<li>忽略文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render:   </span><br><span class="line"># 这里排除的是obsidian编辑器需要的文件  </span><br><span class="line">  - &#x27;_posts/.obsidian/*&#x27;  </span><br><span class="line">  - &#x27;_posts/Scripts/*&#x27;  </span><br><span class="line">  - &#x27;_posts/Templates/*&#x27;  </span><br><span class="line">  - &#x27;**/README.md&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><p>使用的主题：</p>
<ul>
<li>stellar</li>
<li>Next&#96;<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a> themes&#x2F;next</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Next主题配置文件</span><br><span class="line">scheme: Gemini</span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon.png</span><br><span class="line">  safari_pinned_tab: /images/avatar.svg</span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-sa  post: true</span><br><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">avatar:</span><br><span class="line">  url: /images/avatar.jpg</span><br><span class="line">  rounded: true</span><br><span class="line">  rotated: true</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/cuefe || fab fa-github</span><br><span class="line">  E-Mail: mailto:me@cuefe.com || fa fa-envelope</span><br><span class="line">tag_icon: true</span><br><span class="line">codeblock:</span><br><span class="line">  theme:</span><br><span class="line">    light: atom-one-light</span><br><span class="line">    dark: atom-one-light</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  sidebar: true</span><br><span class="line">  scrollpercent: true</span><br><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line">  host: https://fonts.loli.net</span><br><span class="line">  global:</span><br><span class="line">    family: Noto Serif SC</span><br><span class="line">    size: 0.9</span><br><span class="line">pjax: true</span><br><span class="line">mediumzoom: true</span><br><span class="line">lazyload: true</span><br><span class="line">quicklink:</span><br><span class="line">  enable: true</span><br><span class="line">  home: true</span><br><span class="line">  archive: true</span><br><span class="line">  delay: true</span><br><span class="line">  priority: true</span><br><span class="line">motion:</span><br><span class="line">  enable: false</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>


<p>*进入根目录里的themes文件夹，里面也有个_config.yml文件，为<strong>主题</strong>配置文件</p>
<ul>
<li>社交外链的设置，即在侧栏展示你的个人社交网站信息。(插件jiathis)</li>
<li>插入网易云，进入网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器，在侧栏插入这首歌的音乐播放器，修改 <code>blog/themes/next/layout/_macro</code>的sidebar.swig文件，添加刚刚复制的外链代码</li>
<li>设置背景，在<code>blog/themes/next/source/css/_custom</code>文件的custom.styl首部添加<code>body &#123; background:url(./background.jpg);  background-attachment: fixed; &#125;</code>，fixed固定背景图片</li>
<li>增加侧栏菜单条目，默认的侧栏菜单条目有：首页、归档、标签、关于、搜索等。如果你想要增加其他的菜单条目，修改主题配置文件_config.yml里的Menu Settings中的menu和menu_icons两个地方</li>
</ul>
<h3 id="域名配置文件"><a href="#域名配置文件" class="headerlink" title="域名配置文件"></a>域名配置文件</h3><p>进入blog&#x2F;source目录下，创建一个文件，文件名CNAME，写入你的自定义域名即可</p>
<h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量。</p>
<h3 id="category"><a href="#category" class="headerlink" title="category"></a>category</h3><p><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/17/20240517101429.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并列分类，了解一下：  </span><br><span class="line">categories:  </span><br><span class="line">- [Linux]  </span><br><span class="line">- [Tools]</span><br><span class="line"></span><br><span class="line">并列+子分类，再了解一下：  </span><br><span class="line">categories:  </span><br><span class="line">- [Linux, Hexo]  </span><br><span class="line">- [Tools, PHP]</span><br></pre></td></tr></table></figure>

<p>扩展<br>abbrlink<br>文章永久链接</p>
<h3 id="自定义文章标签"><a href="#自定义文章标签" class="headerlink" title="自定义文章标签"></a>自定义文章标签</h3><p>生成标签页面<br><code>hexo new page tags</code><br>修改blog&#x2F;source&#x2F;tags&#x2F;index.md，添加type: “tags”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2023-01-08 11:27:57</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>以后就可以在文章文件头添加标签了，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Hexo + GitHub 搭建个人博客</span><br><span class="line">date: 2023-01-07 13:15:00</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- Next</span><br><span class="line">- 博客 </span><br></pre></td></tr></table></figure>

<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>基于stellar主题的<a href="https://waline.js.org/guide/get-started/#leancloud-%E8%AE%BE%E7%BD%AE-%E6%95%B0%E6%8D%AE%E5%BA%93">评论系统的配置</a> </p>
<ol>
<li>注册leancloud <a href="https://console.leancloud.app/">https://console.leancloud.app/</a></li>
<li>创建一个应用后，并进入应用，选择左下角的 <code>设置</code> &gt; <code>应用 Key</code>。你可以看到你的 <code>APP ID</code>,<code>APP Key</code> 和 <code>Master Key</code>。请记录它们，以便后续使用。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AppID`LuASoYE3f9mviMTY6yuhsDXQ-MdYXbMMI` </span><br><span class="line">AppKey`etyMOUJxZGMmiUFeBRb30zS2` </span><br><span class="line">MasterKey</span><br><span class="line">`MutkN6OjDzogLjWR6smA91CN`</span><br></pre></td></tr></table></figure></li>
<li>vercel上部署服务端</li>
<li></li>
</ol>
<ul>
<li>前往 Waline 官网 根据指引到 Vercel 进行 Waline 服务端部署</li>
<li>安装 @waline&#x2F;hexo-next<code>npm install @waline/hexo-next</code></li>
<li>为了不使用魔法也能正常评论，我们需要有自己的域名解析到 Waline 服务端，可以在域名控制台给自己的博客域名添加二级域名，添加 CNAME 解析到cname-china.vercel-dns.com或添加 A 解析到76.223.126.88（也可以前往 Vercel All IP 自行挑选合适的节点），接着进入 Vercel 的 Waline 应用的控制台，在Settings-Domains里添加上文提到的二级域名，这样在主题配置文件添加配置后就可以正常评论了</li>
<li>主题配置文件添加配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Waline Config File</span><br><span class="line"># For more information:</span><br><span class="line"># - https://waline.js.org</span><br><span class="line"># - https://waline.js.org/reference/component.html</span><br><span class="line">waline:</span><br><span class="line">  # New! Whether enable this plugin</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Waline server address url, you should set this to your own link</span><br><span class="line">  serverURL: #serverURL填写自己解析到 Waline 服务端的域名https://waline.vercel.app/</span><br><span class="line"></span><br><span class="line">  # Waline library CDN url, you can set this to your preferred CDN</span><br><span class="line">  libUrl: https://npm.elemecdn.com/@waline/client@v2/dist/waline.js</span><br><span class="line"></span><br><span class="line">  # Waline CSS styles CDN url, you can set this to your preferred CDN</span><br><span class="line">  cssUrl: https://npm.elemecdn.com/@waline/client@v2/dist/waline.css</span><br><span class="line"></span><br><span class="line">  # Custom locales</span><br><span class="line">  # locale:</span><br><span class="line">  #   placeholder: Welcome to comment # Comment box placeholder</span><br><span class="line"></span><br><span class="line">  # If false, comment count will only be displayed in post page, not in home page</span><br><span class="line">  commentCount: true</span><br><span class="line"></span><br><span class="line">  # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`.</span><br><span class="line">  pageview: false</span><br><span class="line"></span><br><span class="line">  # Custom emoji</span><br><span class="line">  emoji:</span><br><span class="line">    - https://npm.elemecdn.com/@waline/emojis@1.0.1/weibo</span><br><span class="line">    - https://npm.elemecdn.com/@waline/emojis@1.0.1/alus</span><br><span class="line">    - https://npm.elemecdn.com/@waline/emojis@1.0.1/bilibili</span><br><span class="line">    - https://npm.elemecdn.com/@waline/emojis@1.0.1/qq</span><br><span class="line">    - https://npm.elemecdn.com/@waline/emojis@1.0.1/tieba</span><br><span class="line">    - https://npm.elemecdn.com/@waline/emojis@1.0.1/tw-emoji</span><br><span class="line"></span><br><span class="line">  # Comment infomation, valid meta are nick, mail and link</span><br><span class="line">  # meta:</span><br><span class="line">  #   - nick</span><br><span class="line">  #   - mail</span><br><span class="line">  #   - link</span><br><span class="line"></span><br><span class="line">  # Set required meta field, e.g.: [nick] | [nick, mail]</span><br><span class="line">  # requiredMeta:</span><br><span class="line">  #   - nick</span><br><span class="line"></span><br><span class="line">  # Language, available values: en-US, zh-CN, zh-TW, pt-BR, ru-RU, jp-JP</span><br><span class="line">  # lang: zh-CN</span><br><span class="line"></span><br><span class="line">  # Word limit, no limit when setting to 0</span><br><span class="line">  # wordLimit: 0</span><br><span class="line"></span><br><span class="line">  # Whether enable login, can choose from &#x27;enable&#x27;, &#x27;disable&#x27; and &#x27;force&#x27;</span><br><span class="line">  # login: enable</span><br><span class="line"></span><br><span class="line">  # comment per page</span><br><span class="line">  # pageSize: 10</span><br></pre></td></tr></table></figure></li>
<li>在<code>blog/source/_data</code>文件夹下新建<code>languages.yml</code>并编辑<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># language</span><br><span class="line">zh-CN:</span><br><span class="line">  # items</span><br><span class="line">  post:</span><br><span class="line">    views: 阅读</span><br><span class="line">    comments:</span><br><span class="line">      waline: 评论</span><br></pre></td></tr></table></figure></li>
<li>配置完评论后及时到 Waline 服务端登录，以便管理评论</li>
<li>可选择开启评论邮件提醒功能， <a href="https://waline.js.org/">Waline 官网</a> 有详细的说明</li>
</ul>
<h3 id="评论系统-1"><a href="#评论系统-1" class="headerlink" title="评论系统"></a>评论系统</h3><p>Valine基于LeanCloud<br>编辑主题配置文件，启用评论插件<code>comments</code>，补充<code>type</code>参数（valine&#x2F;waline）<br>在主题配置文件中配置valine</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Valine</span><br><span class="line"># 基于Leancloud</span><br><span class="line"># Based on LeanCloud</span><br><span class="line"># See: https://valine.js.org/</span><br><span class="line">valine:</span><br><span class="line">	appId: </span><br><span class="line">	appKey: </span><br><span class="line">	placeholder:说点什么</span><br><span class="line">	path: window.location.pathname</span><br><span class="line">	avatar:retro</span><br><span class="line">	meta:[&#x27;nick&#x27;,&#x27;mail&#x27;,&quot;link&#x27;]</span><br><span class="line">	pagesize:10</span><br><span class="line">	lang:zh-CN</span><br><span class="line">	highlight:false</span><br><span class="line">	recordIP:false</span><br><span class="line">	serverURLs:&#x27;&#x27;</span><br><span class="line">	emojiCDN:</span><br><span class="line">	emojiMaps :</span><br><span class="line">	enableQQ:false</span><br><span class="line">	requiredrFields:[]</span><br></pre></td></tr></table></figure>

<h2 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h2><h3 id="部署插件-hexo-deployer-git"><a href="#部署插件-hexo-deployer-git" class="headerlink" title="部署插件  hexo-deployer-git"></a>部署插件  hexo-deployer-git</h3><p> 编辑Hexo顶层目录下的_config.yml文件，文件最后可以看到deployment相关内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">deploy：</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:liuluhua/liuluhua.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<ul>
<li>repo填写仓库ssh地址</li>
<li>branch的填写需要和<a href="#%5Ed4aa3b">GitHub Pages部分指定的<strong>Branch</strong>保持一致</a></li>
</ul>
<h3 id="搜索插件-hexo-generator-searchdb"><a href="#搜索插件-hexo-generator-searchdb" class="headerlink" title="搜索插件 hexo-generator-searchdb"></a>搜索插件 hexo-generator-searchdb</h3><ul>
<li>安装 hexo-generator-searchdb<code>npm install hexo-generator-searchdb</code></li>
<li>修改主题配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">	enable: true</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自动标签插件hexo-auto-category"><a href="#自动标签插件hexo-auto-category" class="headerlink" title="自动标签插件hexo-auto-category"></a>自动标签插件hexo-auto-category</h3><p>该插件在 Hexo 进行 build 的时候会去自动根据文章目录情况来自动修改文章的 <code>categories</code> 信息</p>
<ul>
<li>安装插件<code>npm install hexo-auto-category --save</code></li>
<li>修改站点配置文件<code>_config.yml</code>，使文章链接清晰<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Generate categories from directory-tree</span><br><span class="line"># Dependencies: https://github.com/xu-song/hexo-auto-category</span><br><span class="line"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span><br><span class="line"># multiple: multiple category hierarchies</span><br><span class="line">auto_category:</span><br><span class="line"> enable: true</span><br><span class="line"> multiple: true</span><br><span class="line"> depth: 5</span><br><span class="line"></span><br><span class="line"># 修改 permalink 让你的文章链接更加友好，并且有益于 SEO </span><br><span class="line">permalink: :year/:month/:hash.html</span><br><span class="line"># 规定你的新文章在 _post 目录下是以 cateory   </span><br><span class="line">new_post_name: :category/:title|</span><br></pre></td></tr></table></figure></li>
</ul>
<p>该插件需要每次手动构建时才会更新<code>categories</code>信息。<br>执行hexo g</p>
<p><em>使用 git hook，在我们每次执行 <code>commit</code> 前都自动运行 <code>npx hexo generate</code> 触发自动生成 <code>categories</code> 的行为，并将生成后的变更自动添加到本次提交中，然后一同 push 到 github 上去。这里可以使用 husky 来很方便的设置这样一个 git hook</em><br><em>1. 安装 huksy：<code>npm install husky --save-dev</code></em><br><em>2. 执行 huksy 初始化指令：<code>npx husky install</code></em><br>*3. 在 <code>package.json</code> 中的 <code>scripts</code> 中写入：<code>&quot;prepare&quot;: &quot;husky install&quot;</code><br><em>4. 在生成的 <code>.husky</code> 目录创建 <code>pre-commit</code> 文件（<code>chmod a+x pre-commit</code>），并写入以下内容：</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env sh  </span><br><span class="line">. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;  </span><br><span class="line">  </span><br><span class="line">npx hexo generate &amp;&amp; git add .</span><br></pre></td></tr></table></figure>
<p><em>提交代码时，检查有无<code>categories</code>的生成信息。</em></p>
<h3 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a>阅读量统计</h3><p><code>Leancloud</code>（<a href="https://console.leancloud.cn/%EF%BC%89">https://console.leancloud.cn/）</a></p>
<ol>
<li>创建应用，进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用</li>
<li>配置_config.yml启用网页访问统计，配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code>，打开计数功能，统计来源改为 <code>leancloud</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#网页访问统计</span><br><span class="line">#Analysis of website visitors</span><br><span class="line">web analytics:</span><br><span class="line">	enable:true</span><br><span class="line"></span><br><span class="line">leancloud:</span><br><span class="line">	app id: </span><br><span class="line">	app key: </span><br><span class="line"></span><br><span class="line"># 浏览量计数</span><br><span class="line"># Number of visits</span><br><span class="line">views:</span><br><span class="line">	enable:true</span><br><span class="line">	#统计数据来源</span><br><span class="line">	#Data Source</span><br><span class="line">	#Options:busuanzi | leancloud</span><br><span class="line">	source:&quot;leancloud&quot;</span><br><span class="line">	format:&quot;&#123;&#125;次&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h3><p>显示页面的访问量和访客数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 展示网站的 pv、w 统计数</span><br><span class="line"># Display website pv and uv statistics</span><br><span class="line">statistics:</span><br><span class="line">	enable:true</span><br><span class="line">	#统计数据来源，使用leancloud 需要设置&#x27;web analytics:leancloud&#x27;中的参数;busuanzi 显示统计数据很大属于正常现象，部署后会正常</span><br><span class="line">	# Data source.If use leancloud,you need to set the parameter in&#x27;web analytics:leancloud</span><br><span class="line">	# Options:busuanzian | leancloud</span><br><span class="line">	source:&quot;leancloud&#x27;</span><br><span class="line">	#页面显示的文本，&#123;&#125;是数字的占位符(必须包含)，下同</span><br><span class="line">	# Displayed text, &#123;&#125;is a placeholder for numbers (must be included), the same below</span><br><span class="line">	pv format:&quot;总访问量 &#123;&#125;次&quot;</span><br><span class="line">	uv format:&quot;总访客数 &#123;&#125;人&quot;</span><br></pre></td></tr></table></figure>


<h3 id="Canvas-nest-背景动画"><a href="#Canvas-nest-背景动画" class="headerlink" title="Canvas nest 背景动画"></a>Canvas nest 背景动画</h3><ol>
<li><p>在<code>blog/source/_data</code>文件夹下新建<code>footer.njk</code>并编辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script color=&quot;0,255,255&quot; opacity=&quot;1&quot; zIndex=&quot;-1&quot; count=&quot;70&quot; src=&quot;https://cdn.staticfile.org/canvas-nest.js/1.0.1/canvas-nest.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  footer: source/_data/footer.njk</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h3><ol>
<li>安装 hexo-filter-mathjax</li>
<li>修改主题配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
此后可在文章文件开头添加参数<code>mathjax: true</code>以使用 MathJax</li>
</ol>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ol>
<li>修改主题配置文件<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">plugins:</span> <span class="string">custom</span></span><br><span class="line">  <span class="attr">custom_cdn_url:</span> <span class="string">https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;cdnjs_file&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><ol>
<li>安装 hexo-word-counter</li>
</ol>
<h3 id="烟花动画"><a href="#烟花动画" class="headerlink" title="烟花动画"></a>烟花动画</h3><ol>
<li>安装 next-theme&#x2F;hexo-next-fireworks</li>
<li>主题配置文件添加配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fireworks:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>由于烟花动画比较遮挡视线，已修改<code>/blog/node_modules/hexo-next-fireworks/fireworks.js</code>，更换为礼花动画</li>
</ul>
<h3 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h3><ol>
<li>安装 hexo-next-darkmode</li>
<li>主题配置文件添加配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Darkmode JS</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/rqh656418510/hexo-next-darkmode, https://github.com/sandoche/Darkmode.js</span></span><br><span class="line"><span class="attr">darkmode_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="string">&#x27;64px&#x27;</span> <span class="comment"># default: &#x27;32px&#x27;</span></span><br><span class="line">  <span class="attr">right:</span> <span class="string">&#x27;unset&#x27;</span> <span class="comment"># default: &#x27;32px&#x27;</span></span><br><span class="line">  <span class="attr">left:</span> <span class="string">&#x27;32px&#x27;</span> <span class="comment"># default: &#x27;unset&#x27;</span></span><br><span class="line">  <span class="attr">time:</span> <span class="string">&#x27;0.5s&#x27;</span> <span class="comment"># default: &#x27;0.3s&#x27;</span></span><br><span class="line">  <span class="attr">mixColor:</span> <span class="string">&#x27;transparent&#x27;</span> <span class="comment"># default: &#x27;#fff&#x27;</span></span><br><span class="line">  <span class="attr">backgroundColor:</span> <span class="string">&#x27;transparent&#x27;</span> <span class="comment"># default: &#x27;#fff&#x27;</span></span><br><span class="line">  <span class="attr">buttonColorDark:</span> <span class="string">&#x27;#100f2c&#x27;</span> <span class="comment"># default: &#x27;#100f2c&#x27;</span></span><br><span class="line">  <span class="attr">buttonColorLight:</span> <span class="string">&#x27;#fff&#x27;</span> <span class="comment"># default: &#x27;#fff&#x27;</span></span><br><span class="line">  <span class="attr">isActivated:</span> <span class="literal">false</span> <span class="comment"># default false</span></span><br><span class="line">  <span class="attr">saveInCookies:</span> <span class="literal">true</span> <span class="comment"># default: true</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">&#x27;🌓&#x27;</span> <span class="comment"># default: &#x27;&#x27;</span></span><br><span class="line">  <span class="attr">autoMatchOsTheme:</span> <span class="literal">true</span> <span class="comment"># default: true</span></span><br><span class="line">  <span class="attr">libUrl:</span> <span class="string">https://npm.elemecdn.com/darkmode-js@1.5.7/lib/darkmode-js.min.js</span> <span class="comment"># Set custom library cdn url for Darkmode.js</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>在<code>/blog/themes/next/layout/_partials/footer.njk</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><br><span class="line">  &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date();</span><br><span class="line">    function createtime() &#123;</span><br><span class="line">        var grt= new Date(&quot;01/07/2023 13:15:00&quot;);//此处修改你的建站时间或者网站上线时间</span><br><span class="line">        now.setTime(now.getTime()+250);</span><br><span class="line">        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);</span><br><span class="line">        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);</span><br><span class="line">        if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);</span><br><span class="line">        mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125;</span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);</span><br><span class="line">        snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125;</span><br><span class="line">        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;;</span><br><span class="line">        document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><ol>
<li>安装 hexo-generator-sitemap</li>
<li>修改主题配置文件<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br></pre></td></tr></table></figure></li>
<li>执行<code>hexo cl &amp;&amp; hexo g</code>生成<code>sitemap.xml</code></li>
<li>此时可以在<code>blog/public</code>文件夹下看到<code>sitemap.xml</code></li>
<li>验证，进入 <a href="https://search.google.com/search-console/welcome">Google Search Console</a> ，选择<strong>网址前缀</strong>，输入网址时记得加上https:&#x2F;&#x2F;，选择 HTML 标记，你会得到元标记<code>&lt;meta name=&quot;google-site-verification&quot; content=&quot;xxxxxxxx&quot; /&gt;</code>，将 content 后的内容加入到主题配置文件中<code>google_site_verification: &quot;xxxxxxxx&quot;</code>，执行<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code></li>
</ol>
<p>点击前往资源页面<br>添加站点地图，成功提交</p>
<h3 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h3><ol>
<li>安装 hexo-neat</li>
<li>主题配置文件添加配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.js&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="自定义-CSS"><a href="#自定义-CSS" class="headerlink" title="自定义 CSS"></a>自定义 CSS</h3><ol>
<li>在<code>/blog/source/_data</code>文件夹下新建<code>styles.styl</code>并编辑<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--content-bg-color</span>: <span class="built_in">rgb</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> / <span class="number">0%</span>);</span><br><span class="line">  <span class="attr">--text-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attr">--waline-theme-color</span>: <span class="number">#222</span> !important;</span><br><span class="line">  <span class="attr">--waline-color</span>: <span class="number">#000</span> !important;</span><br><span class="line">  <span class="attr">--waline-bgcolor</span>: <span class="built_in">rgb</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> / <span class="number">0%</span>) !important;</span><br><span class="line">  <span class="attr">--waline-bgcolor-light</span>: <span class="built_in">rgb</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> / <span class="number">0%</span>) !important;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-inner</span> <span class="selector-class">.sub-menu</span>, <span class="selector-class">.main-inner</span> <span class="selector-class">.post-block</span>, <span class="selector-class">.main-inner</span> <span class="selector-class">.tabs-comment</span>, <span class="selector-class">.main-inner</span> &gt; <span class="selector-class">.comments</span>, <span class="selector-class">.main-inner</span> <span class="selector-class">.comment-position</span> <span class="selector-class">.comments</span>, <span class="selector-class">.main-inner</span> <span class="selector-class">.pagination</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar-inner</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-inner</span> <span class="selector-class">.tabs-comment</span>, <span class="selector-class">.main-inner</span> &gt; <span class="selector-class">.comments</span>, <span class="selector-class">.main-inner</span> <span class="selector-class">.comment-position</span> <span class="selector-class">.comments</span>, <span class="selector-class">.main-inner</span> <span class="selector-class">.pagination</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-inner</span> <span class="selector-class">.post-block</span><span class="selector-pseudo">:not</span>(:first-child)<span class="selector-pseudo">:not</span>(:first-child) &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.darkmode--activated</span> &#123;</span><br><span class="line">  <span class="attr">--content-bg-color</span>: <span class="built_in">rgb</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> / <span class="number">0%</span>) !important;</span><br><span class="line">  <span class="attr">--waline-theme-color</span>: <span class="number">#999</span> !important;</span><br><span class="line">  <span class="attr">--waline-color</span>: <span class="number">#ccc</span> !important;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-title-link</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--text-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-header</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-button</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-block</span>, <span class="selector-class">.comments</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-tags</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改主题配置文件<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="文章页眉显示标签"><a href="#文章页眉显示标签" class="headerlink" title="文章页眉显示标签"></a>文章页眉显示标签</h3><ol>
<li>在<code>blog/source/_data</code>文件夹下新建<code>post-meta.njk</code>并编辑<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span>&gt;</span> </span><br><span class="line">  &#123;%- if post.tags and post.tags.length %&#125;</span><br><span class="line">    &#123;%- set tag_indicate = &#x27;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-tag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&#x27; if theme.tag_icon else &#x27;#&#x27; %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-tags&quot;</span>&gt;</span></span><br><span class="line">      &#123;%- for tag in post.tags.toArray() %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      &#123;%- endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>修改主题配置文件<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">postMeta:</span> <span class="string">source/_data/post-meta.njk</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p> ## <a href="https://gohugo.io/">Hugo</a> 框架和 <a href="https://github.com/HEIGE-PCloud/DoIt">DoIt</a> 主题
 </p>
<h2 id="Netlify"><a href="#Netlify" class="headerlink" title="Netlify"></a>Netlify</h2><h2 id="Railway"><a href="#Railway" class="headerlink" title="Railway"></a>Railway</h2><p><a href="https://railway.app/">https://railway.app/</a><br>Railway提供免费容器服务。支持主流语言python、nodejs等直接运行，支持Dockerfile在线构建docker镜像。支持使用CLI部署。此外，还提供大量模板直接构建。例如code server（vscode网页版）等。</p>
<p>不自动休眠，不自动删数据（手动重新部署当然会删），支持自定义域名，自动SSL加密。<br>提供数据库支持，部署完成之后添加数据库插件即可。<br>按量付费，每个月5美元免费额度，跑个小程序够用。具体可以参考定价。</p>
<p><strong>部署</strong><br>railway支持三种部署方式：</p>
<ul>
<li>通过Github repo进行部署，需要连接到你自己的特定仓库。如果你的仓库中有Dockerfile文件，则会自动解析。参见：Dockerfiles | Railway Docs</li>
<li>使用它们的CLI，这个我试用了下感觉体验不是很好。不太推荐。</li>
<li>通过自带的模板进行部署，例如code server。选择Deploy Starter即可</li>
</ul>
<h2 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h2><p><a href="https://vercel.com/">https://vercel.com/</a><br>Vercel 是一个云服务平台，支持静态网站和动态网站的应用部署、预览和上线。如果你用过 GitHub Pages ，那么心里可能不会太陌生，但你也能通过 vercel 集成 GitHub 后后，在 GitHub 项目进行代码推送，PR合并自动部署的目的，且你不需要考虑服务器问题。<br>Vercel 它是一个免费的网站托管平台，也是我目前用过最好的网站托管平台，不仅仅可以部署静态网站，而且还可以部署动态网站，所以我们可以拿 vercel 充当你免费的服务器，主要有以下好处。</p>
<ul>
<li>关联 github，只需要往 github 提交代码，它会自动获取最新的提交，然后自动部署</li>
<li>提供了免费的域名，省去了申请域名的问题，如果有自己的域名，还可以做个域名解析到这个平台上</li>
<li>提供了免费的 Https 证书，如果证书到期了，它会自动替换，完全不需要操心</li>
<li>傻瓜式的部署方式，它的操作非常简单，Vercel 提供了两种方式：通过命令行部署、通过 Vercel 提供管理后台部署，这期视频我们主要介绍通过命令行部署，因为命令行的部署方式更加简单</li>
</ul>
<h2 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h2><h2 id="stellar主题提交Github报错"><a href="#stellar主题提交Github报错" class="headerlink" title="stellar主题提交Github报错"></a>stellar主题提交Github报错</h2><p>检查后发现是博客内容中包含了github的token明文。。。。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>数字花园建设</title>
    <url>/2024/05/17/%E5%8D%9A%E5%AE%A2-%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD%E5%BB%BA%E8%AE%BE/</url>
    <content><![CDATA[<h1 id="页面部署"><a href="#页面部署" class="headerlink" title="页面部署"></a>页面部署</h1><p>打开github下方仓库<br><a href="https://github.com/oleeskild/digitalgarden">https://github.com/oleeskild/digitalgarden</a></p>
<p>fork到自己仓库</p>
<p>直接点击deploy，部署到vercel</p>
<h1 id="Obsidian插件配置"><a href="#Obsidian插件配置" class="headerlink" title="Obsidian插件配置"></a>Obsidian插件配置</h1><p>搜索digital garden插件，配置Github仓库即可</p>
<p>写文章时，需要在文章属性中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dg-publish: true</span><br></pre></td></tr></table></figure>
<p>搜索publish single note，发布文章</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>1. Markdown笔记</title>
    <url>/2024/03/12/%E8%AF%AD%E8%A8%80-markdown/</url>
    <content><![CDATA[<h1 id="Markdown-笔记语法"><a href="#Markdown-笔记语法" class="headerlink" title="Markdown 笔记语法"></a>Markdown 笔记语法</h1><h2 id="表格-文本样式"><a href="#表格-文本样式" class="headerlink" title="表格 &amp; 文本样式"></a>表格 &amp; 文本样式</h2><table>
<thead>
<tr>
<th align="center">样式</th>
<th>语法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">加粗</td>
<td>前后<code>**</code> 或  <code>__</code></td>
<td><strong>加粗1</strong> <strong>加粗2</strong></td>
</tr>
<tr>
<td align="center">斜体</td>
<td>前后<code>*</code> 或  <code>_</code></td>
<td><em>斜体1</em> <em>斜体2</em></td>
</tr>
<tr>
<td align="center">删除线</td>
<td>前后<code>~~</code></td>
<td><del>删除线</del></td>
</tr>
<tr>
<td align="center">内联代码</td>
<td>前后 &#96;</td>
<td><code>code</code></td>
</tr>
<tr>
<td align="center">下划线</td>
<td>前<code>&lt;u&gt;</code>  后 <code>&lt;/u&gt;</code></td>
<td><u>下划线</u></td>
</tr>
<tr>
<td align="center">高亮</td>
<td>前后<code>==</code></td>
<td>&#x3D;&#x3D;高亮文本&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>此内容为引用内容</p>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><em>鼠标右击</em> 或 <em>Ctrl 键 + 点击</em> 系统默认浏览器打开链接</p>
<p><a href="https://liuluhua.github.io/">Blog网址</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>拖放图片文件、粘贴截图可直接将图片源数据存储到笔记中</p>
<p><img src="https://raw.githubusercontent.com/liuluhua/GitHubImageBed/main/Qexo/24/3/title-icon_7de1fad10dc19f682355e8b3bbfb87c3.jpg" alt="LOGO"></p>
<p><em>图片可拖动为文件到任意窗口使用</em></p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li>项目<ul>
<li>项目 1<ul>
<li>项目 A</li>
<li>项目 B</li>
</ul>
</li>
<li>项目 2</li>
</ul>
</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol>
<li>项目 1<ol>
<li>项目 A</li>
<li>项目 B</li>
</ol>
</li>
<li>项目 2</li>
</ol>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><ul>
<li><input checked="" disabled="" type="checkbox"> A 计划<ul>
<li><input checked="" disabled="" type="checkbox"> A1 计划</li>
<li><input disabled="" type="checkbox"> A2 计划</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> B 计划</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块支持 168 种编程语言</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript 冒泡排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> swapped = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    swapped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; array.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = array[j];</span><br><span class="line">        array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">        array[j + <span class="number">1</span>] = temp;</span><br><span class="line">        swapped = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (swapped);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KaTeX-数学公式"><a href="#KaTeX-数学公式" class="headerlink" title="KaTeX 数学公式"></a><a href="https://katex.org/">KaTeX</a> 数学公式</h2><h3 id="内联公式"><a href="#内联公式" class="headerlink" title="内联公式"></a>内联公式</h3><p>质能方程 $E&#x3D;mc^2$</p>
<h3 id="公式块"><a href="#公式块" class="headerlink" title="公式块"></a>公式块</h3><p>$$<br>\displaystyle \left( \sum_{k&#x3D;1}^n a_k b_k \right)^2 \leq \left( \sum_{k&#x3D;1}^n a_k^2 \right) \left( \sum_{k&#x3D;1}^n b_k^2 \right)<br>$$</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 正则表达式笔记</title>
    <url>/2024/03/12/%E8%AF%AD%E8%A8%80-regular/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h1 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h1><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。</p>
<p><strong>正则表达式就是记录文本规则的代码</strong>，用于模式匹配和搜索文本的工具。</p>
<h1 id="正则表达式的模式"><a href="#正则表达式的模式" class="headerlink" title="正则表达式的模式"></a>正则表达式的模式</h1><ul>
<li><strong>字面值字符</strong>：普通字符按照字面意义进行匹配,例如字母、数字、空格等，可以直接匹配它们自身。</li>
<li><strong>特殊字符</strong>：例如点号 <code>.</code>、星号 <code>*</code>、加号 <code>+</code>、问号 <code>?</code> 等，它们具有特殊的含义和功能。</li>
<li><strong>字符类</strong>：用方括号 <code>[ ]</code> 包围的字符集合，用于匹配方括号内的任意一个字符。<code>[^ ]</code>匹配除了括号内的字符以外的任意一个字符</li>
<li><strong>元字符</strong>：例如 <code>\d</code>、<code>\w</code>、<code>\s</code> 等，用于匹配特定类型的字符，如数字、字母、空白字符等。</li>
<li><strong>量词</strong>：例如 <code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code> 等，用于指定匹配的次数或范围。</li>
<li><strong>边界符号</strong>：例如 <code>^</code>、<code>$</code>、<code>\b</code>、<code>\B</code> 等，用于匹配字符串的开头、结尾或单词边界与非边界位置。</li>
<li><strong>分组和捕获</strong>：<code>( )</code>：用于分组和捕获子表达式。<code>(?: )</code>：用于分组但不捕获子表达式。</li>
</ul>
<h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><p>字符匹配直接在方括号里列出：</p>
<ul>
<li>[aeiou]就匹配任何一个英文元音字母</li>
<li>[.?!]匹配标点符号(.或?或!)</li>
</ul>
<p>也可以指定一个字符范围：</p>
<ul>
<li>[0-9]代表的含意与\d就是完全一致的：一位数字</li>
<li>[a-z0-9A-Z_]也完全等同于\w。</li>
</ul>
<p><strong>普通字符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[ABC]</td>
<td align="left">匹配 […] 中的所有字符</td>
</tr>
<tr>
<td align="center">[^ABC]</td>
<td align="left">匹配除了 […] 中字符的所有字符</td>
</tr>
<tr>
<td align="center">[A-Z]</td>
<td align="left">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。</td>
</tr>
<tr>
<td align="center">[\s\S]</td>
<td align="left">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配字母、数字、下划线。等价于<code>[A-Za-z0-9_]</code></td>
</tr>
</tbody></table>
<p><strong>非打印字符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\cx</td>
<td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<p><strong>特殊字符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$</td>
<td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则$ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td>
</tr>
<tr>
<td align="center">( )</td>
<td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次。要匹配 *字符，请使用*。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td align="center">[</td>
<td align="left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用?。</td>
</tr>
<tr>
<td align="center"><code>\</code></td>
<td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘&#39; 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用^。</td>
</tr>
<tr>
<td align="center">{</td>
<td align="left">标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">指明两项之间的一个选择。要匹配|，请使用 |。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>分支条件</strong><br><code>|</code> 元字符，用于在两种或多种模式之间进行选择</p>
<p>匹配分枝条件时，将会从左到右地测试每个条件，如果满足某个分枝，就不会再去向右测试。</p>
<p><strong>分组</strong><br>() 元字符，标记一个子表达式的开始和结束位置。例如IP地址表达式:<br><code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code></p>
</blockquote>
<p><strong>限定符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配 “z” 以及 “zoo”。</em> 等价于 {0,}。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，zo+ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 “do” 、 “does”、 “doxy” 中的 “do” 和 “does”。? 等价于 {0,1}。</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 “Bob” 中的 o，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于<code>o*</code>。</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 “fooooood” 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<p><strong>定位符</strong></p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">非单词边界匹配。</td>
</tr>
</tbody></table>
<blockquote>
<p>不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <code>^*</code> 之类的表达式</p>
</blockquote>
<p><strong>转义字符与反义字符</strong></p>
<p>在正则表达式中，还有一些常用的转义字符,转义字符可以方便地匹配一些常见的字符类型:</p>
<table>
<thead>
<tr>
<th align="center">—</th>
<th align="center">—</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\d</td>
<td align="center">表示匹配任意一个数字字符</td>
<td></td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">表示匹配任意一个字母、数字或下划线字符</td>
<td></td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">表示匹配任意一个空白字符（包括空格、制表符、换行符等）</td>
<td></td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">表示匹配单词的边界等。</td>
<td></td>
</tr>
</tbody></table>
<p>在正则表达式中，反义字符是指用于匹配除了某些字符之外的任意字符的特殊字符。</p>
<p>反义字符以 \ 开头，后面跟着一个大写字母，表示匹配除了这个字符类别中的任意一个字符之外的所有字符。</p>
<table>
<thead>
<tr>
<th align="center">—</th>
<th align="center">—</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\D</td>
<td align="center">匹配任意一个非数字字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">匹配任意一个非字母、数字或下划线字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">匹配任意一个非空白字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">匹配不在单词边界上的任意一个字符。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>小括号的另一种用途是通过语法(?#comment)来包含注释</p>
<blockquote>
<p>IP地址 2[0-4]\d(?#200-249)|25<a href="http://124.222.246.202:8080/2023/06/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#250-255">0-5</a>|[01]?\d\d?(?#0-199)。</p>
</blockquote>
<h1 id="贪婪和懒惰"><a href="#贪婪和懒惰" class="headerlink" title="贪婪和懒惰"></a>贪婪和懒惰</h1><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。</p>
<p>以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。</p>
<p>如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为<strong>贪婪匹配</strong>。</p>
<p>有时，我们更需要<strong>懒惰匹配</strong>，也就是匹配尽可能少的字符。</p>
<p>前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。</p>
<p>这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>
<p>现在看看懒惰版的例子吧： <code>a.*?b</code>匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>
<h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>
<p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">转义符</td>
</tr>
<tr>
<td align="center">(), (?:), (?&#x3D;), []</td>
<td align="center">圆括号和方括号</td>
</tr>
<tr>
<td align="center">*, +, ?, {n}, {n,}, {n,m}</td>
<td align="center">限定符</td>
</tr>
<tr>
<td align="center">^, $, \任何元字符、任何字符</td>
<td align="center">定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">替换，”或”操作,字符具有高于替换运算符的优先级，使得&#96;m</td>
</tr>
</tbody></table>
<h1 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h1><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。</p>
<p><strong>反向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code>代表分组1匹配的文本。</strong></p>
<blockquote>
<p>分组0对应整个正则表达式 <code>\b(\w+)\b\s+\1\b</code>可以用来匹配重复的单词，像go go, 或者kitty kitty。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>确定需要匹配的基本字符或字符类别&#x2F;集合等</li>
<li>确定匹配的字符或字符集合的数量</li>
<li>特殊字符和转义字符的处理</li>
<li>边界和位置的匹配</li>
<li>使用捕获组<code>()</code>进行多组匹配</li>
<li>使用反向引用</li>
<li>使用逻辑操作符进行判定</li>
</ol>
<h1 id="正则表达式字符含义表"><a href="#正则表达式字符含义表" class="headerlink" title="正则表达式字符含义表"></a>正则表达式字符含义表</h1><h1 id="正则表达式字符含义表-1"><a href="#正则表达式字符含义表-1" class="headerlink" title="正则表达式字符含义表"></a>正则表达式字符含义表</h1><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，<code>n</code> 匹配字符 “n”。<code>\\n</code> 匹配一个换行符。序列 <code>\\</code> 匹配 “\ 而 “(“ 则匹配 “(“。</td>
<td></td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配<code>\\n</code> 或 <code>\\r</code> 之后的位置。</td>
<td></td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配<code>\\n</code> 或 <code>\\r</code> 之前的位置。</td>
<td></td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
<td></td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，<code>zo+</code> 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
<td></td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td>
<td></td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，<code>o&#123;2&#125;</code> 不能匹配 “Bob” 中的 <code>o</code>，但是能匹配 “food” 中的两个 o。</td>
<td></td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配n 次。例如，<code>o&#123;2,&#125;</code> 不能匹配 “Bob” 中的 <code>o</code>，但能匹配 “foooood” 中的所有 o。<code>o&#123;1,&#125;</code> 等价于 <code>o+</code>。<code>o&#123;0,&#125;</code> 则等价于 <code>o*</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。<code>o&#123;0,1&#125;</code> 等价于 <code>o?</code>。请注意在逗号和两个数之间不能有空格。</td>
<td></td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，<code>o+?</code> 将匹配单个 “o”，而 <code>o+</code> 将匹配所有 <code>o</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括<code>\\n</code> 在内的任何字符，请使用像&#96;(.</td>
<td>\n)&#96;的模式。</td>
</tr>
<tr>
<td align="center">(pattern)</td>
<td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用<code>(</code> 或 <code>)</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">(?:pattern)</td>
<td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (&#96;</td>
<td><code>) 来组合一个模式的各个部分是很有用。例如， </code>industr(?:y</td>
</tr>
<tr>
<td align="center">(?&#x3D;pattern)</td>
<td align="left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，&#96;Windows(?&#x3D;95</td>
<td>98</td>
</tr>
<tr>
<td align="center">(?!pattern)</td>
<td align="left">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&#96;Windows(?!95</td>
<td>98</td>
</tr>
<tr>
<td align="center">(?&lt;&#x3D;pattern)</td>
<td align="left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，&#96;(?&lt;&#x3D;95</td>
<td>98</td>
</tr>
<tr>
<td align="center">(?</td>
<td align="left">反向否定预查，与正向否定预查类似，只是方向相反。例如”(?”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。</td>
<td></td>
</tr>
<tr>
<td align="center">&#96;x</td>
<td align="left">y&#96;</td>
<td>匹配 x 或 y。例如，&#96;z</td>
</tr>
<tr>
<td align="center">[xyz]</td>
<td align="left">字符集合。匹配所包含的任意一个字符。例如，<code>[abc]</code> 可以匹配 “plain” 中的 <code>a</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">[^xyz]</td>
<td align="left">负值字符集合。匹配未包含的任意字符。例如，<code>[^abc]</code> 可以匹配 “plain” 中的p、l、i、n。</td>
<td></td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="left">字符范围。匹配指定范围内的任意字符。例如，<code>[a-z]</code> 可以匹配 <code>a</code> 到 <code>z</code> 范围内的任意小写字母字符。</td>
<td></td>
</tr>
<tr>
<td align="center">[^a-z]</td>
<td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，<code>[^a-z]</code> 可以匹配任何不在 <code>a</code> 到 <code>z</code> 范围内的任意字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如，<code>er\\b</code> 可以匹配”never” 中的 <code>er</code>，但不能匹配 “verb” 中的 <code>er</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">匹配非单词边界。<code>er\\B</code> 能匹配 “verb” 中的 <code>er</code>，但不能匹配 “never” 中的 <code>er</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\cx</td>
<td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的<code>c</code> 字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">匹配一个数字字符。等价于 [0-9]。</td>
<td></td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">匹配一个非数字字符。等价于 [^0-9]。</td>
<td></td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
<td></td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
<td></td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
<td></td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
<td></td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
<td></td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
<td></td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
<td></td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配字母、数字、下划线。等价于<code>[A-Za-z0-9_]</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">匹配非字母、数字、下划线。等价于<code>[^A-Za-z0-9_]</code>。</td>
<td></td>
</tr>
<tr>
<td align="center">\xn</td>
<td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，<code>\\x41</code> 匹配 “A”。<code>\\x041</code> 则等价于 <code>\\x04</code> &amp; “1”。正则表达式中可以使用 ASCII 编码。</td>
<td></td>
</tr>
<tr>
<td align="center">\num</td>
<td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，<code>(.)\\1</code> 匹配两个连续的相同字符。</td>
<td></td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td>
<td></td>
</tr>
<tr>
<td align="center">\nm</td>
<td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td>
<td></td>
</tr>
<tr>
<td align="center">\nml</td>
<td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td>
<td></td>
</tr>
<tr>
<td align="center">\un</td>
<td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td>
<td>&#96;</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>3D打印控制命令</title>
    <url>/2024/05/21/%E5%85%B6%E4%BB%96-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="限位开关"><a href="#限位开关" class="headerlink" title="限位开关"></a>限位开关</h1><p>确保X、Y和Z轴的限位开关都没有被触发，然后通过控制台发送命令：<br><code>QUERY_ENDSTOPS</code><br>返回值是<code>open</code>打开，则限位触发电平类型设置正确，如果是<code>triggered</code>（触发），则需要修改限位的电平类型（以X轴为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[stepper_X]</span><br><span class="line">endstop_pin: ^PE5   #修改前</span><br><span class="line">endstop_pin: ^!PE5    #修改后</span><br></pre></td></tr></table></figure>

<h1 id="热床PID校正"><a href="#热床PID校正" class="headerlink" title="热床PID校正"></a>热床PID校正</h1><p>G28归零后，将喷嘴移至热床中心，高出床面约5-10mm，然后发送命令<br><code>PID_CALIBRATE HEATER=heater_bed TARGET=100</code><br>它将执行一个PID校准程序，将持续约10分钟，完成后控制台将会返回PID数值，将其复制到热床的PID设置即可。</p>
<h1 id="挤出头PID校正"><a href="#挤出头PID校正" class="headerlink" title="挤出头PID校正"></a>挤出头PID校正</h1><p>先将模型冷却风扇设置为25%的转速 <code>M106 S64</code> ，然后发送命令<br><code>PID_CALIBRATE HEATER=extruder TARGET=245</code><br>它将执行一个PID校准程序，将持续约5分钟，完成后控制台将返回PID数值，将其复制到配置文件即可。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>使 Klipper 进入 “shutdown”（关闭）状态<br><code>M112</code></p>
<p>重新加载配置文件并重启<br><code>FIRMWARE_RESTART</code></p>
<p>保存配置文件<br><code>SAVE_CONFIG</code></p>
<p>查看使用的printer.cfg文件位置<br><code>ps -ef | grep klippy</code></p>
<p>获取位置<br><code>GET_POSITION</code></p>
<p>QUAD_GANTRY_LEVEL</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>3D打印机</category>
      </categories>
  </entry>
  <entry>
    <title>3D打印机介绍</title>
    <url>/2024/04/02/%E5%85%B6%E4%BB%96-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="FDM-3D打印机"><a href="#FDM-3D打印机" class="headerlink" title="FDM 3D打印机"></a>FDM 3D打印机</h1><p>通过将加热的材料挤出打印头，逐层堆积形成打印件</p>
<ul>
<li>打印头</li>
<li>打印床&#x2F;热床</li>
<li>控制系统（主板、电机、传感器和用户界面）</li>
<li>打印材料</li>
<li>G-Code<br>  *一种用于控制数控机床（包括3D打印机、数控铣床、数控车床等）运动和操作的编程语言。</li>
</ul>
<h1 id="结构：corexy"><a href="#结构：corexy" class="headerlink" title="结构：corexy"></a>结构：corexy</h1><h1 id="硬件：MKS-GEN-Lv2-1"><a href="#硬件：MKS-GEN-Lv2-1" class="headerlink" title="硬件：MKS GEN_Lv2.1"></a>硬件：MKS GEN_Lv2.1</h1>]]></content>
      <categories>
        <category>其他</category>
        <category>3D打印机</category>
      </categories>
      <tags>
        <tag>3D打印机</tag>
      </tags>
  </entry>
  <entry>
    <title>3D打印机环境配置</title>
    <url>/2024/03/12/%E5%85%B6%E4%BB%96-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>OctoPrint和Fluidd二选一安装配置即可。</p>
<h1 id="Klipper"><a href="#Klipper" class="headerlink" title="Klipper"></a>Klipper</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>获取klipper源码<br><code>git clone https://github.com/Klipper3d/klipper</code><br>执行脚本安装一些系统依赖、设置<br><code>./klipper/scripts/install-octopi.sh</code><br>*安装很慢时，可以更换下pip的源<a href="source/_posts/%E8%AF%AD%E8%A8%80/Python/pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98.md">pip下载网络问题</a></p>
<p>然后配置和构建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/klipper/</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>需要确定连接到微控制器的串行端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/serial/by-id/*</span><br><span class="line"><span class="built_in">ls</span> /dev/ttyUSB*</span><br></pre></td></tr></table></figure>

<p>可以用类似以下的方法来刷写固件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service klipper stop</span><br><span class="line">make flash FLASH_DEVICE=/dev/ttyUSB0</span><br><span class="line">sudo service klipper start</span><br></pre></td></tr></table></figure>
<p>*刷写时要确保 端口没有被占用</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打印机配置文件，一般在用户主目录中名为<code>printer.cfg</code>的文件<code>/home/linux/printer.cfg</code>。</p>
<p>刷写Klipper后，名称可能会改变，检查USB节点名称：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/serial/by-id/*</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">ls</span> /dev/ttyUSB*</span><br></pre></td></tr></table></figure>
<p>确认节点名称并写入配置文件中去。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0</span><br><span class="line">或者</span><br><span class="line">/dev/ttyUSB0</span><br></pre></td></tr></table></figure>
<p>用这个唯一的名字更新配置文件。更新[mcu]部分，类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mcu]</span><br><span class="line">serial: /dev/ttyUSB0</span><br></pre></td></tr></table></figure>

<p>在编辑该文件后，发出 <code>restart</code> 或 <code>FIREWARE_RESTART</code> 命令以重新加载配置（命令根据实际上位机）。如果Klipper配置文件被成功读取，并且成功找到并配置了微控制器，那么”status”命令将报告打印机已准备就绪。<br>*默认的Klipper启动脚本也在&#x2F;tmp&#x2F;klippy.log中放置一个日志，提供更详细的信息。</p>
<h1 id="OctoPrint"><a href="#OctoPrint" class="headerlink" title="OctoPrint"></a>OctoPrint</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>应该在虚拟环境中完成，以帮助防止依赖性冲突。<br>首先设置 Python、依赖项和虚拟环境。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3 python3-pip python3-dev python3-setuptools python3-venv git libyaml-dev build-essential libffi-dev libssl-dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> OctoPrint &amp;&amp; <span class="built_in">cd</span> OctoPrint</span><br><span class="line">python3 -m venv venv</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br></pre></td></tr></table></figure>

<p>然后可以使用以下命令安装 OctoPrint 及其 Python 依赖项pip：<br><code>pip install pip --upgrade</code><br><code>pip install octoprint</code><br>*如果安装了旧版本的 OctoPrint，pip可能仍然有一些缓存。在那种情况下添加<code>--no-cache-dir</code>到安装命令，例如<code>pip install --no-cache-dir octoprint</code><br>要使这个永久的、干净的pip缓存：<code>rm -r ~/.cache/pip</code></p>
<p>在启动 OctoPrint 之前，添加用户权限，以便用户可以访问串行端口：<br><code>sudo usermod -a -G tty pi</code><br><code>sudo usermod -a -G dialout pi</code><br>您可能必须注销并重新登录才能使这些更改生效。</p>
<p>之后使用<code>octoprint serve</code>命令启动 <code>OctoPrint</code> 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ ~/OctoPrint/venv/bin/octoprint serve</span><br><span class="line">2020-11-03 17:39:17,979 - octoprint.startup - INFO - ***************************</span><br><span class="line">2020-11-03 17:39:17,980 - octoprint.startup - INFO - Starting OctoPrint 1.4.2</span><br><span class="line">2020-11-03 17:39:17,980 - octoprint.startup - INFO - ***************************</span><br></pre></td></tr></table></figure>
<p>访问<code>http://&lt;pi&#39;s IP&gt;:5000</code></p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>OctoPrint网络服务器需要进行配置，以便与Klipper host 软件进行通信。使用网络浏览器，登录到OctoPrint网页，然后配置以下项目：</p>
<ul>
<li>导航到 “设置 “（页面顶部的扳手图标）。在 “串行连接 “下的 “附加串行端口 “中添加”&#x2F;tmp&#x2F;printer”。然后点击 “保存”。</li>
<li>再次进入 “设置”，在 “串行连接” 下将 “串行端口” 设置改为”&#x2F;tmp&#x2F;printer”。</li>
<li>在 “设置 “中，浏览到 “Behavior “子选项卡，选择 “取消任何正在进行的打印，但保持与打印机的连接 “选项。点击 “保存”。</li>
<li>在主页上，在 “连接 “部分（在页面的左上方），确保 “串行端口 “被设置为”&#x2F;tmp&#x2F;printer”，然后点击 “连接”。(如果”&#x2F;tmp&#x2F;printer “不是一个可用的选择，那么试着重新加载页面)</li>
<li>连接后，导航到 “终端 “选项卡，在命令输入框中输入 “status”（不带引号），然后点击 “发送”。终端窗口可能会报告在打开配置文件时出现了错误–这意味着 OctoPrint 与 Klipper 成功地进行了通信。</li>
<li>需要继续配置klipper的print.cfg文件。</li>
</ul>
<h1 id="Fluidd"><a href="#Fluidd" class="headerlink" title="Fluidd"></a>Fluidd</h1><p>Fluidd适用于3D打印机的Klipper固件，提供WEB页面和控制。<br>项目地址 <a href="https://github.com/fluidd-core/fluidd">https://github.com/fluidd-core/fluidd</a></p>
<h2 id="KIAUH安装"><a href="#KIAUH安装" class="headerlink" title="KIAUH安装"></a>KIAUH安装</h2><p>项目地址 <a href="https://github.com/dw-0/kiauh">https://github.com/dw-0/kiauh</a><br>安装 git 后，克隆 KIAUH 项目<br><code>git clone https://github.com/dw-0/kiauh.git</code><br>启动KIAUH<br><code>./kiauh/kiauh.sh</code><br>KIAUH 的主菜单中。您将看到多个操作可供选择，具体取决于您想要执行的操作。要选择操作，只需在“执行操作”提示中输入相应的数字，然后按 ENTER 确认即可。</p>
<h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p>Fluidd 附带一个<code>build</code>脚本，可在项目地址<br><a href="https://github.com/fluidd-core/fluidd/releases">https://github.com/fluidd-core/fluidd/releases</a> 的<code>fluidd.zip</code>中找到。<br>需要安装NodeJS (v16.x) 和 Git<br>克隆Fluidd 源代码<br><code>git clone https://github.com/fluidd-core/fluidd.git</code><br>导航到 Fluidd 源代码目录<br><code>cd fluidd</code><br>安装依赖<br><code>npm ci</code><br>构建并捆绑 Fluidd<br><code>npm run build</code></p>
<p>构建的文件将写入该<code>dist</code>目录。您可以使用您首选的 HTTP 服务器来提供这些服务，例如NGINX。<br>*要出于开发目的构建 Fluidd，请运行<code>npm run serve</code>而不是<code>npm run build</code>启用热重载。</p>
<h2 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h2><p>热床找平及各限位开关触发状态</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>3D打印机</category>
      </categories>
      <tags>
        <tag>3D打印机</tag>
      </tags>
  </entry>
  <entry>
    <title>3D打印相关软件</title>
    <url>/2024/05/21/%E5%85%B6%E4%BB%96-3D%E6%89%93%E5%8D%B0%E6%9C%BA-3D%E6%89%93%E5%8D%B0%E7%9B%B8%E5%85%B3%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="系统固件"><a href="#系统固件" class="headerlink" title="系统固件"></a>系统固件</h1><p><strong>Klipper</strong><br>Klipper 是一个高性能、灵活的3D打印机固件，它通过将一些计算工作转移到更强大的主机（如Raspberry Pi）上来提高打印质量和速度。</p>
<p><strong>Marlin</strong><br>Marlin 是目前最流行的3D打印机固件之一，支持广泛的硬件平台和3D打印机模型，具有丰富的功能和高度的可定制性。</p>
<h1 id="控制软件"><a href="#控制软件" class="headerlink" title="控制软件"></a>控制软件</h1><p><strong>fluidd</strong><br>Fluidd 是一个基于网页的控制界面，用于管理和监控运行 Klipper 固件的3D打印机。它提供了用户友好的界面和实时监控功能。<br>GitHub地址: <a href="https://github.com/fluidd-core/fluidd">https://github.com/fluidd-core/fluidd</a><br>安装手册: <a href="https://github.com/dw-0/kiauh">https://github.com/dw-0/kiauh</a></p>
<p><strong>Make-me</strong><br>Make-me 是一个通过 WiFi 控制 Replicator 2 打印机的开源项目，使用 GitHub 的聊天机器人 Hubot 来监控和完成打印任务。目前只支持 Mac 的 OS X。</p>
<p><strong>Pepeteir-Server</strong><br>Pepeteir-Server 是一个新型的 Repeteir 产品，可以在 Raspberry Pi 上运行，支持控制多台打印机，内存消耗极小。它的网页操作界面简单，但不支持 Mac 和 PC。</p>
<p><strong>Octoprint</strong><br>Octoprint 是一个完全基于网页的3D打印机控制程序，可以远程控制打印机，并通过网络摄像头监控打印过程。支持 Raspberry Pi。</p>
<p><strong>Botqueue</strong><br>Botqueue 是一个开源的远程打印机控制软件，可以控制多台打印机。用户上传 .stl 文件后，软件会完成切片和打印工作。它支持为每台打印机设置独立的切片特性。</p>
<h1 id="切片软件"><a href="#切片软件" class="headerlink" title="切片软件"></a>切片软件</h1><p>切片软件用于将3D模型按层切片，并生成用于打印的G代码。</p>
<p><strong>Cura</strong><br>Cura 由 Ultimaker 开发，兼容多种3D打印机。它不仅可以切片，还提供3D打印机控制界面，尤其适用于 Ultimaker 的3D打印机。</p>
<p><strong>Slic3r</strong><br>Slic3r 是开源且免费的切片软件，因其快捷性和高度可定制化而广受欢迎。许多3D打印机制造商提供默认的 Slic3r 配置文件（.INI 文件），可以用作初始设置。</p>
<p><strong>Skeinforge</strong><br>另一款非常流行的切片软件。同样开源，免费。</p>
<p><strong>kisslicer</strong><br>KISSlicer 是一款跨平台的切片软件，名称源自 “Keep It Simple”（保持简单），目标是提供一个简单易用的界面。</p>
<p><strong>Printrun</strong><br>Printrun 既是控制软件，也是切片软件，可以独立完成从切片到打印的整个过程。支持 Mac、Linux 和 PC 操作平台。</p>
<p><strong>Repetier-Host</strong><br>Repetier-Host 与 Printrun 类似，是一款综合性软件，具有切片、零件定位和机器控制功能。用户界面相对更复杂但更直观，同样支持 Mac、Linux 和 PC 操作平台。</p>
<h1 id="3D建模软件"><a href="#3D建模软件" class="headerlink" title="3D建模软件"></a>3D建模软件</h1><p><strong>Blender</strong><br>Blender 是一款开源的3D建模软件，功能强大且完全免费。它不仅可以用于3D建模，还支持动画、渲染、雕刻等多种功能，适用于各种复杂的3D设计和制作。</p>
<p><strong>Tinkercad</strong><br>Tinkercad 是一个由 Autodesk 开发的在线3D建模工具，适合初学者使用。它基于浏览器，无需下载软件，界面友好且易于使用。</p>
<p><strong>Fusion 360</strong><br>Fusion 360 同样由 Autodesk 开发，是一款功能强大的云端3D CAD、CAM和CAE工具。它适用于从初学者到专业人士的各个层级，提供了全面的建模、仿真和制造功能。</p>
<p><strong>SketchUp</strong><br>SketchUp 是一款广受欢迎的3D建模软件，以其直观的用户界面和易用性著称。它有免费版本（SketchUp Free）和专业版本（SketchUp Pro），适用于建筑、工程、游戏开发等多个领域。</p>
<p><strong>FreeCAD</strong><br>FreeCAD 是一款开源的3D CAD建模软件，适合于产品设计、机械工程以及建筑设计。它具有模块化的架构，可以通过插件扩展其功能。</p>
<p><strong>SolidWorks</strong><br>SolidWorks 是一款由 Dassault Systèmes 开发的专业3D CAD软件，广泛应用于工程设计、产品设计和制造业。它功能强大，但价格较高，通常用于工业级应用。</p>
<p><strong>Onshape</strong><br>Onshape 是一个基于云的3D CAD建模软件，适用于团队协作和设计项目。它无需安装，直接在浏览器中运行，支持实时协作和版本控制。</p>
<p><strong>OpenSCAD</strong><br>OpenSCAD 是一款开源的3D CAD建模软件，适用于创建精确的3D模型。它使用编程语言来定义模型，适合那些有编程经验的用户。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>3D打印机</category>
      </categories>
  </entry>
  <entry>
    <title>Linux自启动脚本</title>
    <url>/2024/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux-Linux%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="Adding-as-a-startup-service-recommended"><a href="#Adding-as-a-startup-service-recommended" class="headerlink" title="Adding as a startup service (recommended)"></a>Adding as a startup service (recommended)</h3><p>Create a service file in <code>/etc/systemd/system/my_startup.service</code>:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=myStartUp Service</span><br><span class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/start/bash/path </span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=default.target</span><br></pre></td></tr></table></figure>

<p>Then start the service:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> my_startup</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-VMware-Vmware%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>在虚拟机中设置共享文件夹完成后，发现共享文件夹没有出现，执行<br><code>vmhgfs-fuse .host:/ /home/forlinx/3568Share</code><br>将共享文件夹挂载到&#x2F;home&#x2F;forlinx&#x2F;3568Share</p>
<p>创建一个<code>startShare.sh</code><br>写入<br><code>vmhgfs-fuse .host:/ /home/forlinx/3568Share</code><br>加权限<br><code>chmod a+x startShare.sh</code><br>添加该脚本到自启中</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>VMware</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-WSL-USB%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E5%88%B0WSL/</url>
    <content><![CDATA[<p>在WSL2中连接3D打印机的USB端口，须将该设备从windows中挂载至Linux中，需要在windows环境中安装usbipd</p>
<p>usbipd GitHub地址 <a href="https://github.com/dorssel/usbipd-win">https://github.com/dorssel/usbipd-win</a></p>
<p>安装usbipd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在win命令行中执行</span><br><span class="line">winget install usbipd</span><br></pre></td></tr></table></figure>
<p>安装环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##在你的wsl中执行</span><br><span class="line">sudo apt install linux-tools-virtual hwdata</span><br><span class="line">sudo update-alternatives --install /usr/local/bin/usbip usbip `ls /usr/lib/linux-tools/*/usbip | tail -n1` 20</span><br></pre></td></tr></table></figure>
<p>*usbipd: error: WSL ‘usbip’ client not correctly installed.<br>重新执行此步骤</p>
<p>列出并挂载win中的设备到linux环境下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在win终端中执行</span><br><span class="line">usbipd wsl list</span><br><span class="line">usbipd wsl attach --busid=4-1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>WSL</category>
      </categories>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2024/05/21/%E8%AF%AD%E8%A8%80-Python-Python/</url>
    <content><![CDATA[<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><p>打开终端，使用以下命令更新软件包列表：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>安装编译 Python 3.10 所需的依赖项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev wget</span><br></pre></td></tr></table></figure>
<p>下载 Python 3.10 的源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz</span><br></pre></td></tr></table></figure>
<p>解压源代码并进入解压后的目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xf Python-3.10.0.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.10.0</span><br></pre></td></tr></table></figure>
<p>配置 Python 3.10 的编译选项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --enable-optimizations</span><br></pre></td></tr></table></figure>
<p>编译并安装 Python 3.10：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make -j 8</span><br><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure>
<p>确认 Python 3.10 是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3.10 --version</span><br></pre></td></tr></table></figure>
<p>如果输出了 Python 3.10 的版本号，则说明安装成功。</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>pip下载网络问题</title>
    <url>/2024/05/21/%E8%AF%AD%E8%A8%80-Python-pip%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>临时使用</strong></p>
<p>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple gevent</span><br></pre></td></tr></table></figure>
<p>这样就会从清华这边的镜像去安装gevent库。</p>
<p><strong>永久修改</strong></p>
<ul>
<li>Linux下<code>~/.pip/pip.conf</code></li>
<li>Windows下<code>C:\Users\admin\pip\pip.ini</code><br>内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>2. Shell笔记</title>
    <url>/2024/03/12/%E8%AF%AD%E8%A8%80-%E8%A7%A3%E9%87%8A%E5%9E%8B-shell/</url>
    <content><![CDATA[<p>待补充</p>
]]></content>
      <categories>
        <category>语言</category>
        <category>解释型</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg简介</title>
    <url>/2024/03/22/%E8%BD%AF%E4%BB%B6-Ffmpeg-other-ffmpeg/</url>
    <content><![CDATA[<h1 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h1>]]></content>
      <categories>
        <category>软件</category>
        <category>Ffmpeg</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Git介绍和基本命令</title>
    <url>/2024/03/12/%E8%BD%AF%E4%BB%B6-Git-Git%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理。</p>
<p>Git是免费、开源的<strong>分布式版本控制系统</strong>。</p>
<h2 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h2><p>集中管理的中央服务器，保存着所有文件的修改历史版本。</p>
<p>协同开发者通过客户端连接到这台服务器，从服务器上同步更新或上传自己的修改。</p>
<h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><p>远程仓库同步所有版本信息到本地的每个用户</p>
<ol>
<li>本地可以查看所有的历史版本信息，偶尔远程更新，查看其他用户修改提交到远程</li>
<li>用户即使离线也可以本地提交，push推送到远程服务器才需要联网</li>
<li>每个用户都保存了历史版本</li>
</ol>
<h1 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h1><p><strong>Workspace</strong>：电脑本地看到的文件和目录，在Git的版本控制下，构成了工作区。</p>
<p><strong>Index&#x2F;Stage</strong>：暂存区，一般存放在.git目录下，即.git&#x2F;index,它又叫待提交更新区，用于临时存放你未提交的改动。<strong>执行git add，这些改动就添加到这个区域</strong>。</p>
<p><strong>Repository</strong>：本地仓库，你执行git clone 地址，就是把远程仓库克隆到本地仓库。它是一个存放在本地的版本库，其中HEAD指向最新放入仓库的版本。当你执行git commit，文件改动就到本地仓库。</p>
<p><strong>Remote</strong>：远程仓库，云端版本库</p>
<h1 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h1><p><strong>Untracked</strong>: 文件未加入到git库，未参与版本控制，处于未跟踪状态。通过git add，可以变为Staged状态</p>
<p><strong>Unmodified</strong>：文件已经加入git库，版本库中的文件快照内容与文件夹中还完全一致。 Unmodified的文件如果被修改, 就会变为Modified。如果使用git remove移出版本库，则成为Untracked文件。</p>
<p><strong>Modified</strong>：文件被修改进入modified状态，文件这个状态通过stage命令可以进入staged状态</p>
<p><strong>staged</strong>：暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodified状态。</p>
<h1 id="正向工作流"><a href="#正向工作流" class="headerlink" title="正向工作流"></a>正向工作流</h1><p>git 的正向工作流程一般就这样：</p>
<ol>
<li>从远程仓库拉取文件代码回来；<code>git pull</code></li>
<li>在工作目录，增删改文件；</li>
<li>把改动的文件放入暂存区；<code>git add</code></li>
<li>将暂存区的文件提交本地仓库；<code>git commit</code></li>
<li>将本地仓库的文件推送到远程仓库；<code>git push</code></li>
</ol>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone [url] #克隆远程仓库</span><br><span class="line">git add [dir/file]#添加目录/文件到暂存区</span><br><span class="line">git commit [--amend] -m [msg] #提交暂存区到仓库区,msg为说明信息(amend用新的commit覆盖提交)</span><br><span class="line">git log [--oneline] [-p [file]]#查看提交历史(online精简模式)(p指定文件)</span><br><span class="line">git blame #列表方式查看指定文件的提交历史</span><br><span class="line">git diff #显示暂存区和工作区的差异</span><br><span class="line">git diff #显示暂存区和工作区的差异</span><br><span class="line">git diff filepath   #filepath路径文件中，工作区与暂存区的比较差异</span><br><span class="line">git diff HEAD filepath #工作区与HEAD ( 当前工作分支)的比较差异</span><br><span class="line">git diff branchName filepath #当前分支文件与branchName分支的文件的比较差异</span><br><span class="line">git diff commitId filepath #与某一次提交的比较差异</span><br><span class="line">git status [-s] [--show-stash] #查看当前工作区暂存区变动(-s概要信息)（show-stash显示暂存文件）</span><br><span class="line">git pull/fetch #拉取远端代码</span><br><span class="line">#git pull = git fetch+ git merge。pull的话，拉取远程分支并与本地分支合并</span><br><span class="line">#fetch只是拉远程分支，怎么合并，可以自己再做选择。</span><br><span class="line">git pull  #拉取远程仓库所有分支更新并合并到本地分支。</span><br><span class="line">git pull origin master #将远程master分支合并到当前本地master分支</span><br><span class="line">git pull origin master:master #将远程master分支合并到当前本地master分支，冒号后面表示本地分支</span><br><span class="line">git fetch --all  #拉取所有远端的最新代码</span><br><span class="line">git fetch origin master #拉取远程最新master分支代码</span><br><span class="line">git push #推送到远端</span><br><span class="line">git push origin master #将本地分支的更新全部推送到远程仓库master分支。</span><br><span class="line">git push origin -d    #删除远程branchname分支</span><br><span class="line">git push --tags #推送所有标签</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># git rebase</span><br><span class="line"></span><br><span class="line">`rebase`又称为衍合，是合并的另外一种选择。 `rebase`好处是： 获得更优雅的提交树，可以线性的看到每一次提交，并且没有增加提交节点。所以很多时候，看到有些伙伴都是这个命令拉代码：`git pull --rebase`</span><br><span class="line"></span><br><span class="line"># git stash</span><br><span class="line"></span><br><span class="line">`stash`命令可用于临时保存和恢复修改</span><br><span class="line"></span><br><span class="line">git stash  把当前的工作隐藏起来 等以后恢复现场后继续工作</span><br><span class="line">git stash list 显示保存的工作进度列表</span><br><span class="line">git stash pop stash@&#123;num&#125; 恢复工作进度到工作区</span><br><span class="line">git stash show ：显示做了哪些改动</span><br><span class="line">git stash drop stash@&#123;num&#125; ：删除一条保存的工作进度</span><br><span class="line">git stash clear 删除所有缓存的stash。</span><br><span class="line"># git reflog</span><br><span class="line"></span><br><span class="line">显示当前分支的最近几次提交</span><br><span class="line"></span><br><span class="line"># git blame</span><br><span class="line"></span><br><span class="line">`git blame filepath`记录了某个文件的更改历史和更改人</span><br><span class="line"></span><br><span class="line"># git remote</span><br><span class="line"></span><br><span class="line">git remote   查看关联的远程仓库的名称</span><br><span class="line">git remote add url   添加一个远程仓库</span><br><span class="line">git remote show [remote] 显示某个远程仓库的信息</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作</title>
    <url>/2024/03/12/%E8%BD%AF%E4%BB%B6-Git-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><h2 id="对于网络项目"><a href="#对于网络项目" class="headerlink" title="对于网络项目"></a>对于网络项目</h2><p><code>git clone [url]</code>将GitHub中的网络项目复制到本地，只需在修改完之后commit即可，然后更新仓库代码，就可同步修改。</p>
<h2 id="对于本地项目"><a href="#对于本地项目" class="headerlink" title="对于本地项目"></a>对于本地项目</h2><p>首先要创建一个文件夹用以存放文件，然后使用</p>
<ul>
<li><code>git init</code> 对进行初始化操作</li>
<li><code>git status</code> 得到git中文件的状态</li>
<li><code>git add filename</code> 将filename文件加入到git本地仓库中去（git rm -cached 可移除）</li>
<li><code>git commit -m ‘status’</code> 表示提交信息（status表示附加信息）</li>
</ul>
<p>之后对本地项目进行关联</p>
<ul>
<li><code>git remote add origin [url]</code> 添加本地到远程origin仓库</li>
<li><code>git remote -v</code> 查看当前项目有哪些远程仓库 关联之后可以向远程仓库提交代码（更新仓库代码）</li>
</ul>
<h2 id="日常push"><a href="#日常push" class="headerlink" title="日常push"></a>日常push</h2><ul>
<li><code>git status</code> #获取状态</li>
<li><code>git add . </code>#添加文件到暂存区</li>
<li><code>git commit -m &quot;20191121 push&quot; </code>#提交文件</li>
<li><code>git push origin master </code>#推送</li>
</ul>
<h2 id="日常pull"><a href="#日常pull" class="headerlink" title="日常pull"></a>日常pull</h2><ul>
<li><code>git diff</code> <em>比较工作目录和 Index 中的代码。</em></li>
<li><code>git fetch</code> <em>当于从远程获取最新版本到本地，不会自动merge ，比 Git pull 更安全些</em></li>
<li><code>git checkout app/model/user.rb</code> <em>将 user.rb 文件从上一个已提交的版本中更新回来，未提交的工作目录中的内容全部会被覆盖</em></li>
</ul>
<h2 id="首次使用配置ssh"><a href="#首次使用配置ssh" class="headerlink" title="首次使用配置ssh"></a>首次使用配置ssh</h2><ul>
<li><code>ssh-keygen -t rsa</code></li>
<li><code>ssh -T &lt;git@github.com&gt;</code></li>
</ul>
<h2 id="首次使用设置用户"><a href="#首次使用设置用户" class="headerlink" title="首次使用设置用户"></a>首次使用设置用户</h2><ul>
<li><code>git config (--global) user.name &quot;username&quot;</code></li>
<li><code>git config (--global) user.email &quot;&lt;username@gmail.com&gt;&quot;</code></li>
</ul>
<h2 id="上传-下载常用命令"><a href="#上传-下载常用命令" class="headerlink" title="上传&#x2F;下载常用命令"></a>上传&#x2F;下载常用命令</h2><ul>
<li><code>git push origin（仓库名） master（分支）</code> <em>更新仓库代码（上传）</em></li>
<li><code>git pull origin（仓库名） master（分支）</code> <em>更新本地代码（下载）</em></li>
</ul>
<h2 id="回退历史版本"><a href="#回退历史版本" class="headerlink" title="回退历史版本"></a>回退历史版本</h2><ul>
<li><code>git log</code></li>
<li><code>git reset --hard \[commit\_id]</code></li>
<li><code>git revert \[commit\_id]</code></li>
</ul>
<h2 id="网络项目"><a href="#网络项目" class="headerlink" title="网络项目"></a>网络项目</h2><ul>
<li><code>git clone \[url]</code></li>
<li><code>git remote add origin \[url]</code> <em>添加本地到远程origin仓库</em></li>
<li><code>git remote -v</code> <em>查看当前项目有哪些远程仓库</em></li>
</ul>
<h2 id="版本情况"><a href="#版本情况" class="headerlink" title="版本情况"></a>版本情况</h2><ul>
<li><code>git tag</code> <em>查看版本情况</em></li>
<li><code>git tag V1.0</code> <em>新建版本</em></li>
<li><code>git checkout V1.0</code> <em>切换至版本V1.0</em></li>
</ul>
<h2 id="分支情况"><a href="#分支情况" class="headerlink" title="分支情况"></a>分支情况</h2><ul>
<li><code>git branch</code> <em>查看当前分支情况</em></li>
<li><code>git checkout a</code> <em>切换到分支a</em></li>
<li><code>git checkout -b a</code> <em>新建分支a并切换到分支a</em></li>
<li><code>git branch -d a</code> <em>删除a分支</em></li>
<li><code>git merge a</code> <em>将a分支的代码合并到master分支上</em></li>
</ul>
<h2 id="撤销或回退"><a href="#撤销或回退" class="headerlink" title="撤销或回退"></a>撤销或回退</h2><p>在Git中，撤销和回退是指<strong>撤销</strong>或<strong>回退</strong>先前的提交或更改。 简单介绍下Git中的撤销和回退操作，以及如何使用它们来管理代码库。</p>
<p>#可以把版本库上的提交回退到暂存区，修改记录保留<br><code>git reset –-soft []</code><br>#可以把版本库上的提交回退到工作区，修改记录保留<br><code>git reset –-mixed []</code><br>#可以把版本库上的提交彻底回退，修改的记录全部revert。<br><code>git reset –-hard</code></p>
<h2 id="reset和revert的区别"><a href="#reset和revert的区别" class="headerlink" title="reset和revert的区别"></a>reset和revert的区别</h2><p><code>git reset</code> 和<code> git revert</code> 的主要区别在于它们对历史记录的处理方式。git reset 会删除历史记录并永久删除更改，而 git revert 会创建一个新的提交来撤销更改并保留历史记录。</p>
<p><code>git reset</code>命令会将 HEAD 指针指向指定的 commit，并将暂存区和工作目录恢复到该 commit 的状态。这意味着在执行 <code>git reset</code> 后，之前的更改将不再存在于工作目录和暂存区中。如果您希望永久删除一些更改并且不再需要它们，可以使用 <code>git reset</code>。</p>
<p><code>git revert</code> 命令会创建一个新的提交来撤销指定的提交。这意味着在执行 <code>git revert</code> 后，之前的更改仍然存在于工作目录和暂存区中，并且您需要提交一个新的撤销提交。如果您想要保留更改历史记录并且不想永久删除更改，可以使用 <code>git revert</code>。</p>
<h2 id="获取ID"><a href="#获取ID" class="headerlink" title="获取ID"></a>获取ID</h2><p><code>git log</code>获取到想要回退的commit_id</p>
<h2 id="撤销-回退未提交的更改"><a href="#撤销-回退未提交的更改" class="headerlink" title="撤销&#x2F;回退未提交的更改"></a>撤销&#x2F;回退未提交的更改</h2><p>**(add之后，commit之前)**要撤销未提交的更改，请使用以下命令： <code>git checkout &lt;file-name&gt;</code>将名为file-name的文件恢复到上一个提交的状态。</p>
<blockquote>
<p>本地本次的更改也不再保存，恢复到上一个提交(commit)的状态</p>
</blockquote>
<p><code>git reset HEAD --file </code>回退暂存区里的某个文件，回退到当前版本工作区状态</p>
<blockquote>
<p>保存工作区的更改，只是撤销<code>git add</code>这一步操作</p>
</blockquote>
<p><code>git checkout .</code>将所有文件恢复到最新提交的状态。请注意，此操作将删除所有未提交的更改。</p>
<h2 id="撤销-回退上一个提交"><a href="#撤销-回退上一个提交" class="headerlink" title="撤销&#x2F;回退上一个提交"></a>撤销&#x2F;回退上一个提交</h2><p>**(commit之后，push之前)**撤销上一个提交 <code>git reset HEAD~1</code>将HEAD指针移动到上一个提交。</p>
<blockquote>
<p>工作区保留先前的更改，需要重新添加到暂存区(git add)</p>
</blockquote>
<p>回退到上一个提交 <code>git reset --hard HEAD~1</code>将HEAD指针和工作树都重置为上一个提交的状态。</p>
<blockquote>
<p>请注意，此操作将删除所有未提交(commit)的更改。</p>
</blockquote>
<h2 id="撤销-回退到特定的提交"><a href="#撤销-回退到特定的提交" class="headerlink" title="撤销&#x2F;回退到特定的提交"></a>撤销&#x2F;回退到特定的提交</h2><p>**(push之后)**撤销到特定版本 <code>git revert &lt;commit_id&gt;</code>这将创建一个新的提交，该提交撤销名为commit-hash的提交所做的更改。</p>
<blockquote>
<p>本次撤销操作也会作为一次提交(push)进行保存</p>
</blockquote>
<p>回退到特定版本 <code>git reset --hard &lt;commit_id&gt;</code>将HEAD指针和工作树都重置为名为commit-hash的提交的状态。</p>
<blockquote>
<p>请注意，此操作将删除所有未提交的更改。</p>
</blockquote>
<p>回退完成后，git push -f 强制提交</p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>Git是一个流行的分布式版本控制系统，一般都是存在多个分支的，开发分支，回归测试分支以及主干分支等 在Git中，分支是指指向Git提交历史中某个特定提交的指针。 每个分支都包含在Git提交历史中的一系列提交，这些提交构成了分支的历史记录。 分支在Git中非常重要，因为它们允许多个开发人员同时在同一个代码库中工作，而不会相互干扰。 通过创建分支，每个开发人员都可以在自己的分支上进行工作，而不会影响其他人的工作。 这样，开发人员可以在不干扰其他人的情况下，独立地开发和测试新功能，最终将这些更改合并到主分支中。</p>
<p>在Git中，分支操作非常简单。以下是一些常用的Git分支操作：</p>
<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>要创建一个新分支，请使用以下命令： <code>git branch &lt;branch-name&gt;</code>这将创建一个名为branch-name的新分支。</p>
<blockquote>
<p>注意，此时仍然在当前分支上工作。</p>
</blockquote>
<p><code>git checkout -b &lt;branch-name&gt;</code>新建一个分支，并且切换到新的分支branch-name</p>
<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>要查看所有分支，请使用以下命令： <code>git branch</code>这将列出所有分支，当前分支将用一个星号标记。</p>
<blockquote>
<p>git branch -r 查看所有远程的分支 git branch -a 查看所有远程分支和本地分支</p>
</blockquote>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>要删除一个分支，请使用以下命令： <code>git branch -d &lt;branch-name&gt;</code>这将删除名为的分支。</p>
<blockquote>
<p>注意，如果该分支包含未合并的更改，则必须使用<code>-D</code>选项而不是<code>-d</code>选项来强制删除该分支。</p>
</blockquote>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>要切换到另一个分支，请使用以下命令： <code>git checkout &lt;branch-name&gt;</code>这将使您从当前分支切换到名为branch-name的分支。</p>
<blockquote>
<p>注意，需要在切换分支之前将所有更改提交或保存。</p>
</blockquote>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>要将一个分支合并到另一个分支，请使用以下命令： <code>git merge &lt;branch-name&gt;</code>将名为branch-name的分支合并到当前分支中。</p>
<blockquote>
<p>注意，如果两个分支上都有对同一文件的更改，则可能会发生冲突。在这种情况下，需要手动解决冲突并提交更改。 git merge –no-ff origin&#x2F;dev 在当前分支上合并远程分支dev git merge –abort 终止本次merge，并回到merge前的状态</p>
</blockquote>
<p>以上是一些常用的Git分支操作。使用这些操作，您可以轻松地创建、切换、合并和删除分支。这些操作使多人协作变得更加容易，因为每个开发人员都可以在自己的分支上进行工作，并将更改合并到主分支中。在实际开发中，分支操作是非常重要的，最好能够熟练掌握并运用这些操作</p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>在 Git 中，tag 是用于标记某个特定提交的名称。它类似于一个<strong>快照</strong>，可以用于标记版本、发布或重要的里程碑。Git 中有两种类型的 tag：轻量级标签和附注标签。</p>
<p>轻量级标签是一个简单的指向某个特定提交的<strong>引用</strong>，类似于一个分支，但不会随着新的提交而移动。创建轻量级标签的方法很简单，只需在命令行中输入 <code>git tag &lt;tag-name&gt; </code>即可。例如，<code>git tag v1.0</code> 将创建一个名为 v1.0 的轻量级标签。</p>
<p>附注标签是一个包含标签名称、标签创建者、标签创建日期和标签说明的 Git 对象。它们是 Git 中最常用的标签类型，可以用于发布版本、重要的里程碑和其他<strong>重要的提交</strong>。创建附注标签的方法是使用 -a 标志和标签名称，然后输入标签说明。例如，<code>git tag -a v1.0 -m &quot;Release version 1.0&quot;</code> 将创建一个名为 v1.0 的附注标签，并将其说明设置为 “Release version 1.0”。</p>
<p>标签可以使用 <code>git push</code> 命令推送到远程存储库中，以便在其他计算机上使用。例如，要将名为 v1.0 的标签推送到远程存储库，可以使用 <code>git push origin v1.0</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag  #列出所有tag</span><br><span class="line">git tag [tag] #新建一个tag在当前commit</span><br><span class="line">git tag [tag] [commit] #新建一个tag在指定commit</span><br><span class="line">git tag -d [tag] #删除本地tag</span><br><span class="line">git push origin [tag] #推送tag到远程</span><br><span class="line">git show [tag] #查看特定tag</span><br><span class="line">git checkout -b [branch] [tag] #新建一个分支，指向某个tag</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git服务器环境搭建和客户端使用</title>
    <url>/2024/03/12/%E8%BD%AF%E4%BB%B6-Git-Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><del>服务端</del></h1><p>安装<code>git</code>和<code>ssh</code></p>
<p><code>sudo apt-get install git</code><br><code>sudo apt-get install openssh-server openssh-client</code></p>
<p>增加git用户并生成文件夹</p>
<p><code>sudo adduser git</code></p>
<p><code>sudo mkdir /home/git</code></p>
<p>创建ssh证书认证文件</p>
<p><code>sudo mkdir /home/git/.ssh</code><br><code>sudo touch /home/git/.ssh/authorized_keys</code></p>
<p>临时修改authorized_keys文件的权限</p>
<p><code>sudo chmod 777 /home/git/.ssh/authorized_keys</code></p>
<p>把需要访问git服务器的<strong>客户端公钥id_rsa.pub</strong>的内容复制到authorized_keys文件</p>
<p>修改authorized_keys文件的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 700 /home/git</span><br><span class="line">sudo chmod 700 /home/git/.ssh</span><br><span class="line">sudo chmod 600 /home/git/authorized_keys</span><br><span class="line">sudo chown -R git:git /home/git</span><br><span class="line">sudo chown -R git:git /home/git/.ssh</span><br><span class="line">sudo chown -R git:git /home/git/.ssh/authorized_keys</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>为了安全考虑禁止登录git服务器的shell，修改git的shell</p>
<p>用<code>/usr/bin/git-shell</code>把<code>/etc/passwd</code>的 <code>git:x:1004:1004:,,,:/home/git:/bin/bash</code></p>
<p>改成： <code>git:x:1004:1004:,,,:/home/git:/usr/bin/git-shell</code>保存</p>
<p>建代码仓库</p>
<p><code>sudo mkdir /home/Repo #创建仓库的目录</code></p>
<p><code>sudo git init --bare /home/Repo/test.git #创建仓库</code></p>
<p><code>sudo chown -R git:git /home/Repo/test.git #修改权限为git</code></p>
<blockquote>
<p>以后每创建一个新的仓库，记得最后一步操作: 修改仓库所属用户为git。</p>
</blockquote>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>安装<code>git</code></p>
<p><code>Linux</code>环境下 <code>sudo apt-get install git</code></p>
<p>Windows环境下直接安装<a href="https://git-scm.com/downloads">Git安装包</a></p>
<p>配置连接</p>
<p>通过密钥方式 <code>ssh-keygen -t rsa [-C &quot;你的邮箱地址&quot;]</code>会生成<code>id_rsa.pub</code>文件</p>
<p>添加该公钥到到服务器</p>
<p>Linux环境下，密钥默认位于<code>/home/ubuntu/.ssh/id\_rsa</code></p>
<p>Windows环境下密钥位于<code>C:\Users\xxx.ssh\id\_rsa.pub</code></p>
<p>通过用户名&#x2F;密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config –global user.name “username”</span><br><span class="line">git config –global user.email “username@gmail.com”</span><br></pre></td></tr></table></figure>

<p>在连接git时，会需要输入账号密码，直接输入即可</p>
<h1 id="附注：增量备份-Git服务器备份"><a href="#附注：增量备份-Git服务器备份" class="headerlink" title="附注：增量备份-Git服务器备份"></a>附注：增量备份-Git服务器备份</h1><p><strong>使用crontab建立每天凌晨3点定时触发的任务</strong><code>crontab -e </code></p>
<p><code>0 3 * * * * rsync -av -e &quot;ssh -i /path/to/id_rsa&quot; /homt/git/ remote_user@X.X.X.X:~/backup</code></p>
]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习笔记</title>
    <url>/2024/04/09/%E8%BD%AF%E4%BB%B6-Nginx-Nginx-1/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>功能：</p>
<ul>
<li>Web服务器</li>
<li>负载均衡</li>
<li>API网关</li>
<li>DDoS防御</li>
<li>反向代理</li>
<li>Web应用防火墙</li>
<li>缓存</li>
</ul>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>查看nginx版本</p>
<p><code>nginx -v</code></p>
<p>配置文件所在位置<code>/etc/nginx</code>，文件名<code>nginx.conf</code></p>
<p>检查配置文件是否有问题</p>
<p><code>nginx -t</code></p>
<p>重新加载nginx配置文件</p>
<p><code>nginx -s reload</code></p>
<p>关闭nginx</p>
<p><code>nginx -s quit</code>或<code>nginx -s stop</code></p>
<p><strong>events</strong></p>
<p><strong>http</strong></p>
<p><strong>server</strong></p>
<p><strong>include</strong></p>
<p><strong>listen</strong></p>
<p><strong>server_name</strong></p>
<p><strong>root</strong> 根目录节点</p>
<p><strong>index</strong> 指定页面</p>
<p><strong>return</strong></p>
<p><strong>location</strong> &#x3D;(完全匹配)  ~(启用正则表达式)</p>
<p><strong>rewrite</strong>  重写</p>
<p><strong>proxy_pass</strong></p>
<blockquote>
<p>curl 命令</p>
<blockquote>
<p>是一个功能强大的命令行传输工具，用于发送请求和下载文件。它支持多种协议，如HTTP、HTTPS、FTP等，可以设置请求头、请求参数等</p>
</blockquote>
<p>-i 参数</p>
<blockquote>
<p>打印出服务器回应的 HTTP 标头</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>软件</category>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>CANopen</title>
    <url>/2024/05/20/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CANopen/</url>
    <content><![CDATA[<h1 id="CANopen"><a href="#CANopen" class="headerlink" title="CANopen"></a>CANopen</h1><p>CANopen是一种基于CAN（Controller Area Network）通信协议的高层协议和设备协议，主要用于嵌入式系统中的网络通信。</p>
<p>CANopen协议定义了网络管理、设备配置、通信对象和应用对象等方面的标准，以确保不同设备之间的互操作性和通信的一致性。</p>
<p>CANopen的OSI模型<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520145302.png" alt="image.png"><br>Data link和Physical是由CAN进行实现的<br>Presentation和Session是由CANopen进行实现的</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>通讯模式<br>*设备&#x2F;节点通信有3种模型：主设备&#x2F;从设备、客户端&#x2F;服务器和生产者&#x2F;消费者</p>
<p>通讯协议<br>*协议用于通信，例如配置节点（SDO）或传输实时数据（PDO）<br>定义了设备之间通信的机制和方式，包括对象字典、服务数据对象（SDO）、过程数据对象（PDO）、网络管理（NMT）等。</p>
<p>设备状态<br>*设备支持不同的状态。“主”节点可以更改“从”节点的状态，例如将其重置。</p>
<p>对象字典（Object Dictionary，OD）<br>*每个CANopen设备都有一个对象字典，OD带有指定设备配置的条目，类似于一个查找表，列出了设备中的所有参数和数据。对象字典包括通信对象和应用对象，使用16位索引和8位子索引进行标识。可以通过SDO访问。</p>
<p>EDS（Electronic Data Sheet）<br>*EDS是用于OD的标准文件格式，允许更新设备的服务</p>
<p>设备配置文件<br>*定义了特定设备类型的功能和行为，例如I&#x2F;O模块、传感器、执行器等。这些配置文件确保了同类型设备的互操作性。</p>
<h2 id="通信对象"><a href="#通信对象" class="headerlink" title="通信对象"></a>通信对象</h2><p>CANopen协议定义了几种不同类型的通信对象，每种对象都用于特定的通信目的：</p>
<ol>
<li><strong>过程数据对象（PDO）</strong>：用于实时数据传输，具有高优先级和低延迟。PDO传输的数据量小，但传输速度快，适用于传感器数据和控制命令等实时性要求高的场景。</li>
<li><strong>服务数据对象（SDO）</strong>：用于非实时数据传输，如配置参数和大数据块的传输。SDO传输的灵活性更大，但优先级较低，适用于设备配置和诊断等场景。</li>
<li><strong>网络管理对象（NMT）</strong>：用于控制设备状态和网络操作模式，如启动、停止和复位设备。</li>
<li><strong>同步对象（SYNC）</strong>：用于网络同步，确保所有节点在同一时间点进行操作。</li>
<li><strong>时间戳对象（TIME）</strong>：提供时间参考，用于时间相关的操作。</li>
</ol>
<p>11位的CAN ID称为通信对象标识符（COB-ID），分为两个部分：默认情况下，前4位等于功能代码，后7位包含节点ID。CANopen网络中使用的标识符的预定义分配<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520150656.png" alt="image.png"></p>
<h2 id="CANopen配置"><a href="#CANopen配置" class="headerlink" title="CANopen配置"></a>CANopen配置</h2><p>所有CANopen节点必须具有对象字典（OD），对象字典是指含有描述的CANopen节点的行为的所有参数的标准化结构。</p>
<p>通过16位索引和8位子索引查找OD条目。例如，符合CANopen的节点OD的索引1008（子索引0）包含节点设备名。</p>
<p>具体来说，对象字典中的条目由属性定义：</p>
<ul>
<li>索引：对象的16位基址</li>
<li>对象名称：制造商设备名称</li>
<li>目标代码：数组，变量或记录</li>
<li>数据类型：例如VISIBLE_STRING或UNSIGNED32或记录名称</li>
<li>访问： rw（读&#x2F;写），ro（只读），wo（只写）</li>
<li>类别：指示此参数是否为必需&#x2F;可选（M &#x2F; O）</li>
</ul>
<h3 id="OD标准化部分"><a href="#OD标准化部分" class="headerlink" title="OD标准化部分"></a>OD标准化部分</h3><p>设备（例如从设备）的OD条目可以由其他设备（例如主机）使用SDO通过CAN进行访问。例如，通过SDO可以使应用程序主机更改从属发送心跳的频率。</p>
<p>对象字典分为标准化部分，其中一些条目是必填项，而其他条目则是完全可定制的。要了解OD，查看电子数据表和设备配置文件会很有帮助。</p>
<h4 id="电子数据表（EDS）"><a href="#电子数据表（EDS）" class="headerlink" title="电子数据表（EDS）"></a>电子数据表（EDS）</h4><p>实际上，将使用适当的软件工具来配置&#x2F;管理复杂的CANopen网络。</p>
<p>为了简化此过程，CiA 306标准定义了一种人类可读（且对机器友好）的INI文件格式，用作设备OD（例如“ ServoMotor3000”）的“模板”。此EDS通常由供应商提供的，并且包含信息的所有设备的对象（但不是值）。</p>
<h4 id="设备配置文件（DCF）"><a href="#设备配置文件（DCF）" class="headerlink" title="设备配置文件（DCF）"></a>设备配置文件（DCF）</h4><p>DCF通常是在设备集成时创建的。但是，通常需要在初始配置后读取和&#x2F;或更改节点的对象值。</p>
<p>假设一家工厂购买了ServoMotor3000集成到其传送带中。为此，操作员编辑设备EDS并添加特定的参数值和&#x2F;或更改EDS中描述的每个对象的名称。</p>
<p>这样做，操作员可以有效地创建所谓的设备配置文件（DCF）。有了这个，ServoMotor3000就可以现场集成到特定的CANopen网络中。</p>
<h4 id="EDS和DCF示例"><a href="#EDS和DCF示例" class="headerlink" title="EDS和DCF示例"></a>EDS和DCF示例</h4><p>EDS &#x2F; DCF示例是真正了解CANopen对象字典的最佳方法，例如，请参见下面的EDS和DCF对象条目之间的区别。我们建议您查看CiA 306标准，以通过实际示例更深入地了解OD，EDS和DCF。</p>
<h2 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h2><p>下面我们简要概述了上述7种服务类型，包括如何利用8个CAN帧数据字节。</p>
<h3 id="网络管理（NMT）"><a href="#网络管理（NMT）" class="headerlink" title="网络管理（NMT）"></a>网络管理（NMT）</h3><p>NMT服务用于通过NMT命令来控制CANopen设备的状态。</p>
<p>为了更改状态，NMT主设备发送2字节的消息，其CAN ID为0（即功能代码0和节点ID 0）。所有从节点都处理此消息。</p>
<p>第一个CAN数据字节Requested State包含请求的状态<br>*命令包括转换到操作（状态01），停止（状态02），操作前（状态80）以及复位应用程序（81）和复位通信（82）。</p>
<p>第二个CAN数据字节包含目标节点的节点ID。节点ID 0表示广播命令。<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520151626.png" alt="image.png"></p>
<h3 id="同步（SYNC）"><a href="#同步（SYNC）" class="headerlink" title="同步（SYNC）"></a>同步（SYNC）</h3><p>SYNC消息通常由应用程序主机触发。</p>
<p>应用程序主机将SYNC消息（COB ID 080）发送到CANopen网络。</p>
<h3 id="紧急情况（EMCY）"><a href="#紧急情况（EMCY）" class="headerlink" title="紧急情况（EMCY）"></a>紧急情况（EMCY）</h3><p>紧急服务用于设备发生致命错误（例如传感器故障）的情况，从而使其可以向网络的其余部分指示此错误。</p>
<p>受影响的节点以高优先级向网络发送单个EMCY消息<br>*例如，节点5具有COB-ID 085</p>
<p>数据字节包含有关错误的信息，可以查找有关详细信息。</p>
<h3 id="时间戳（TIME）-PDO"><a href="#时间戳（TIME）-PDO" class="headerlink" title="时间戳（TIME）[PDO]"></a>时间戳（TIME）[PDO]</h3><p>利用该通信服务，可以分配全球网络时间。TIME服务包含一个6字节的日期和时间信息。</p>
<p>主机发出带有CAN ID 100的TIME消息，其中最初的4个数据字节包含午夜之后的毫秒数，随后的2个字节包含自1984年1月1日以来的天数。</p>
<h3 id="过程数据对象-PDO"><a href="#过程数据对象-PDO" class="headerlink" title="过程数据对象[PDO]"></a>过程数据对象[PDO]</h3><p>PDO服务用于在设备之间传输实时数据，例如来自压力传感器的压力数据或来自温度传感器的温度数据。PDO承载大量信息，被视为最重要的CANopen协议。<br>*原则上可以使用SDO服务。但是单个SDO响应只能携带4个数据字节（需要包含命令字节和OD地址）。假设一个主节点需要来自节点5的两个参数值（例如“ SensTemp2”和“ Torque5”），要通过SDO获得此值，它将需要4个完整的CAN帧（2个请求，2个响应）。<br>相比之下，PDO消息可以包含8个完整字节的数据-并且它可以在单个帧中包含多个对象参数值。因此，可能需要在PDO服务中用1帧完成SDO至少需要4帧的操作。</p>
<p>对于PDO，使用消费者&#x2F;生产者术语。因此，生产者“生产数据”，并使用传输PDO（TPDO）将其传输到“消费者”（主用户）。相反，它可以通过接收PDO（RPDO）从使用者接收数据。</p>
<p>生产者节点可以被配置为每100ms响应消费者所广播的SYNC触发。<br>然后，节点5可以例如在下面广播，以COB-ID 185发送PDO：<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520153344.png" alt="image.png"></p>
<p>注意数据字节是如何用3个参数值打包的。这些值反映了节点5特定OD条目的实时数据。使用此信息的节点（使用者）当然需要知道如何解释PDO数据字节。</p>
<h3 id="服务数据对象-SDO"><a href="#服务数据对象-SDO" class="headerlink" title="服务数据对象[SDO]"></a>服务数据对象[SDO]</h3><p>SDO服务用于访问&#x2F;更改CANopen设备的对象字典中的值-例如，当应用程序主机需要更改CANopen设备的某些配置时。</p>
<p>SDO服务允许的CANopen节点通过CAN网络读取另一个节点的对象字典&#x2F;编辑值。<br>如“通信模型”中所述，SDO服务利用“客户端&#x2F;服务器”行为。</p>
<p>客户端节点可以通过在CAN帧以下广播来启动SDO下载到节点5，这将触发节点5（并被其他节点忽略）。SDO“接收”（即请求）CAN帧如下所示：<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520153535.png" alt="image.png"><br>SDO消息变量说明：</p>
<ul>
<li>COB-ID 605反映了“ SDO接收”（COB-ID 600 +节点ID）的使用。</li>
<li>所述CCS（客户端命令说明符）是传输类型（例如，1：下载，2：上载）</li>
<li>n是数据字节4-7中不包含数据的#bytes （如果设置了e＆s则有效）</li>
<li>如果设置，e表示“快速传输”（所有数据在单个CAN帧中）</li>
<li>如果设置，s表示数据大小显示在n中</li>
<li>索引（16位）和子索引（8位）反映了要访问的OD地址</li>
<li>最后，字节4-7包含要下载到节点5的数据</li>
</ul>
<p>*一旦主节点（客户端）发送了CAN帧，从节点5（服务器）便会通过“ SDO发送”进行响应，并带有COB-ID585。该响应包含索引&#x2F;子索引和4个空数据字节。自然地，如果客户端节点请求上传（即从节点5 OD读取数据），则节点5将以字节4-7中包含的相关数据进行响应。</p>
<p>每个SDO使用2个标识符，创建一个“ SDO渠道（包含命令字节和OD地址）”，数据包含在4个字节中，对于较大的数据方案，可以使用SDO 分段&#x2F;块传输。</p>
<p>SDO灵活，但会带来大量输出，使其不适用于实时操作数据。</p>
<h3 id="节点监视-SDO"><a href="#节点监视-SDO" class="headerlink" title="节点监视[SDO]"></a>节点监视[SDO]</h3><p>心跳服务有两个目的：提供“活动”消息并确认NMT命令。</p>
<p>NMT从设备会定期（例如，每100毫秒）发送心跳消息（例如，节点5的CAN ID 705），并在第一个数据字节中发送节点的“状态”</p>
<p>如果在一定时间内没有收到消息，则心跳消息的“消费者”（例如NMT主设备和可选的任何其他设备）会做出反应。</p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CAN和CANFD</title>
    <url>/2024/05/20/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN%E5%92%8CCANFD/</url>
    <content><![CDATA[<h1 id="CAN和CANFD"><a href="#CAN和CANFD" class="headerlink" title="CAN和CANFD"></a>CAN和CANFD</h1><p>CAN与CAN-FD主要区别：</p>
<ul>
<li>传输速率不同<br>  CAN：最大传输速率1Mbps。<br>  CAN-FD：速率可变，仲裁比特率最高1Mbps（与CAN相同），数据比特率最高8Mbps。</li>
<li>数据长度不同<br>  CAN：一帧数据最长8字节<br>  CAN-FD：一帧数据最长64字节。</li>
<li>帧格式不同和ID长度不同。</li>
</ul>
<p>CANFD不存在远程帧，CAN报文中的RTR（用于区别标准帧与远程帧）被替换为RRS（远程请求替代位，默认值为0）</p>
<p>CANFD报文的标准帧和扩展帧—IDE为1表示为扩展帧、为0表示标准帧</p>
<p>FDF用于传统CAN报文和CANFD报文，FDF位为0时为传统报文，FDF为1时为CANFD报文<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520123827.png" alt="image.png"></p>
<p>BRS位速率切换为，BRS位为0时CANFD速率保持恒定速率、BRS位为1时CANFD的数据段会被切换到高速率。</p>
<p>ESI错误状态指示位：CAN报文中发送节点的错误状态只有该节点自己知道，CANFD报文中可以通过ESI标志位来告诉其他节点该节点的错误状态，当ESI为1时表示发送节点处于被动错误状态、当ESI为0时表示发送节点处于主动错误状态</p>
<p>CRC：随着数据场的扩大，为了保证信息发送的质量，CAN FD的CRC计算不仅要包括数据段的位，还包括来自SOF的Stuff Count和填充位。通过比较CRC的计算结果，可以判断接收节点是否能够正常接收。<br>在CAN中，CRC的位数是15位，而在CAN FD中，CRC场扩展到了21位。<br>当传输报文为15字节时：CRC 15位<br>当传输数据为16字节或更少时：CRC 17位<br>当传输数据超过16字节时：CRC 21位</p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>CAN协议介绍</title>
    <url>/2024/05/17/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-CAN-CAN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CAN 总线是一种串行通信协议，使用的是两条差分信号线，只能表达一个信号。<br>简洁的物理层决定了CAN必然要配上一套复杂的协议。<br>根据不同的距离、不同的网络，可配置不同的速度，最高速度为1MBit&#x2F;s。<br>CAN 2.0A为标准格式，CAN 2.0B为扩展格式。<br>优点：</p>
<ul>
<li>可以多主方式工作，网络上的任意节点均可以在任意时刻主动地向网络上的其他节点发送信息，而不分主从，通信方式灵活。</li>
<li>网络上的节点(信息)可分成不同的优先级，可以满足不同的实时要求。</li>
<li>采用非破坏性位仲裁总线结构机制，当两个节点同时向网络上传送信息时，优先级低的节点主动停止数据发送，而优先级高的节点可不受影响地继续传输数据。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>当CAN 总线上的节点发送数据时，以报文形式广播给网络中的所有节点，总线上的所有节点都不使用节点地址等系统配置信息，只根据每组报文开头的11位标识符(CAN 2.0A规范)解释数据的含义来决定是否接收。这种数据收发方式称为面向内容的编址方案。<br>当某个节点要向其他节点发送数据时，这个节点的处理器将要发送的数据和自己的标识符传送给该节点的CAN总线接口控制器，并处于准备状态；当收到总线分配时，转为发送报文状态。数据根据协议组织成一定的报文格式后发出，此时网络上的其他节点处于接收状态。处于接收状态的每个节点对接收到的报文进行检 测，判断这些报文是否是发给自己的以确定是否接收。</p>
<h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p>CAN被细分为三个层次：<br>（1）CAN对象层（the object layer）；<br>（2）CAN传输层（the transfer layer）；<br>（3）CAN物理层（the phyical layer）；<br>对象层和传输层包括所有由ISO&#x2F;OSI模型定义的数据链路层的服务和功能。<br>对象层的作用范围包括：<br>（1）查找被发送的报文。<br>（2）确定由实际要使用的传输层接收哪一个报文。<br>（3）为应用层相关硬件提供接口。<br>传输层的作用主要：<br>（1）传送规则，也就是控制帧结构、执行仲裁、错误检测、出错标定、故障界定。<br>（2）总线上什么时候开始发送新报文及什么时候开始接收报文，均在传输层里确定。<br>（3）位定时的一些普通功能也可以看作是传输层的一部分。<br>（4）传输层的修改是受到限制的。<br>物理层的作用：<br>在不同节点之间根据所有的电气属性进行位信息的实际传输。当然，同一网络内，物理层对于所有的节点必须是相同的。</p>
<p>编程在对象层进行，这一层直接与应用层交互，并且提供了管理和处理CAN消息的接口。通过对象层，应用程序可以发送和接收CAN的打包消息。打包的过程就是在原始数据的基础上再加上帧起始段、仲裁段、控制段、CRC校验、应答和帧结束，把这些内容按特定的格式打包好，就可以用一个通道表达各种信号了，当数据包被发送时，只要接收方按约定格式去解读，就能还原出原始数据。</p>
<p>传输层的功能主要由CAN控制器硬件和驱动程序实现。通常，程序员不直接操作传输层，而是通过对象层的API间接利用传输层的功能。<br>传输层负责处理CAN协议的低级细节，如位级传输、错误处理和仲裁。<br>*位填充（BitStuffing）<br>位填充是为了防止突发错误而设定的功能。位填充的规则如下：<br>（1）5位连续相同电平之后，必须填充一位反向位，即不允许有6个连续相同位；<br>（2）SOF之前为总线空闲状态，不需要同步，因此不需要位填充；<br>（3）CRC之后为固定格式，不允许填充；<br>（4）<strong>由CAN控制器自动实现</strong>；</p>
<p>物理层通常由CAN收发器硬件和相关电气接口组成。</p>
<h2 id="CAN属性"><a href="#CAN属性" class="headerlink" title="CAN属性"></a>CAN属性</h2><p>CAN具有以下的属性：<br>（1）报文（Messages）：CAN协议对数据、操作命令(如读&#x2F;写)以及同步信号进行打包，打包后的这些内容称为报文，简单来说就是具有固定格式的数据包。<br>（2）信息路由（Information Routing）：即，报文寻找结点的方式。<br>（3）位速率（Bit rate）：数据位的传输速度。<br>（4）优先权（Priorities）：即报文发送的优先权。<br>（5）远程数据请求（Remote Data Request）：通过发送远程帧，需要数据的节点可以请求另一节点发送相应的数据帧。<br>（6）多主机（Multimaster）：总线空闲时，任何结点都可以开始传送报文。<br>（7）仲裁（Arbitration）：当2个及以上的单元同时开始传送报文，那么就会有总线访问冲突。仲裁是确定哪个单元的具有发送优先权。<br>（8）安全性（Safety）：CAN的每一个节点均采取了强有力的措施以进行错误检测、错误标定及错误自检。<br>（9）错误检测（Error Detection）：包括监视、循环冗余检查、位填充、报文格式检查。<br>（10）错误检测的执行（Performance of Error Detection）<br>（11）错误标定和恢复时间（Error Sinalling and Recovery Time）：任何检测到错误的结点会标志出已损坏的报文。此报文会失效并将自动地开始重新传送。如果不再出现新的错误，从检测到错误到下一报文的传送开始为止，恢复时间最多为29个位的时间。<br>（12）故障界定（Fault Confinement）：CAN结点能够把永久故障和短暂扰动区分开来。永久故障的结点会被关闭。<br>（13）连接（Connections）：CAN串行通讯链路是可以连接许多结点的总线。理论上，可连接无数多的结点。但由于实际上受延迟时间或者总线线路上电气负载的影响，连接结点的数量是有限的。<br>（14）单通道（Single Channel）：总线是由单一进行双向位信号传送的通道组成。<br>（15）总线值（Bus value）：总线可以具有两种互补的逻辑值之一：“显性”（可表示为逻辑0）或“隐性”（可表示为逻辑1）。<br>（16）应答（Acknowledgment）：所有的接收器检查报文的连贯性。对于连贯的报文，接收器应答；对于不连贯的报文，接收器作出标志。<br>（17） 睡眠模式／唤醒（Sleep Mode &#x2F; Wake-up）：为了减少系统电源的功率消耗，可以将CAN器件设为睡眠模式以便停止内部活动及断开与总线驱动器的连接。CAN器件可由总线激活，或系统内部状态而被唤醒。</p>
<h2 id="仲裁方式"><a href="#仲裁方式" class="headerlink" title="仲裁方式"></a>仲裁方式</h2><p>在总线空闲态，最先开始发送消息的单元获得发送权。多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。<strong>连续输出显性电平最多的单元可继续发送</strong>。即逐位地对比 各个结点发出的报文ID。</p>
<p>由于线与的关系，显示位“0”可以覆盖隐性位“1”，因此ID最小的节点赢得仲裁，总线上表现为该结点的报文，其他结点失去仲裁，退出发送，转为接收状态。</p>
<p>*标准格式ID与具有相同ID的远程帧或者扩展格式的数据帧在总线上竞争时，标准格式的RTR位为显性位的具有优先权，可继续发送。</p>
<h1 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h1><h2 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h2><p>为了更有效地控制通讯，CAN一共规定了5种类型的帧</p>
<ul>
<li>数据帧：发送单元向接收单元传送数据的帧。</li>
<li>远程帧：接收单元向发送单元请求数据的帧。</li>
<li>错误帧：检测出错误时向其它单元通知错误的帧。</li>
<li>过载帧：接收单元通知其尚未就绪的帧。</li>
<li>间隔帧：将数据帧及遥控帧与前面的帧分离开来的帧。</li>
</ul>
<p>*数据帧和遥控帧有<strong>标准帧和扩展帧</strong>两种帧，标准帧有 11 个位的标识符ID，扩展帧有 29 个位的 ID</p>
<h2 id="标准CAN帧定义"><a href="#标准CAN帧定义" class="headerlink" title="标准CAN帧定义"></a>标准CAN帧定义</h2><p>数据帧由帧起始、仲裁段、控制段、数据段、CRC、ACK、帧结束共7个段构成<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520113845.png" alt="image.png"></p>
<p><code>隐形=1</code><br><code>显性=0</code></p>
<p>帧起始(Start Of Frame,SOF)，1bit<br>表示帧开始的段，设置为0。</p>
<p>仲裁段（Identifier，ID），11bits&#x2F;29bits<br>表示数据帧优先级的段<br>标准帧与扩展帧的构成有所不同，均禁止高7位为隐性(ID&#x3D;1111111XXXX…)<br>仲裁段的内容主要为本数据帧的ID，标准帧的ID 有11 个位，扩展帧的 ID 有29 个位，在CAN协议中，ID决定着数据帧发送的优先级，也决定着其它节点是否会接收这个数据帧。CAN总线不对挂载在它之上的节点分配优先级和地址，对总线的占有权是由信息的ID决定的，即对于重要的信息，优先级高的ID，能够优先发送出去</p>
<ul>
<li>RTR位(Remote Transmission Request Bit)<br>远程传输请求位，用于区分数据帧和遥控帧的，为0表示数据帧，1表示遥控帧。</li>
</ul>
<p>控制段<br>控制段由 6 个位构成，表示数据段的字节数  </p>
<ul>
<li>IDE位(Identifier Extension Bit)<br>标识符扩展位，用于区分标准帧与扩展帧，为0表示标准帧，1表示扩展帧</li>
<li>SRR位(Substitute Remote Request Bit)<br>只存在于扩展帧，它用于替代标准帧中的RTR位，扩展帧中的SRR位固定为1，RTR在数据帧中为0，所以两个ID相同的标准帧与扩展帧，标准帧的优先级较高 </li>
<li>DLC数据长度码（Data Length Code）<br>数据的字节数必须为 0～8 字节</li>
</ul>
<p>数据段（Data Field）<br>数据段可包含 0～8 个字节的数据</p>
<p>CRC段</p>
<ul>
<li>CRC 段是检查帧传输错误的段，由15 个位的CRC值和1 个位的CRC界定符(隐性分隔位)构成</li>
<li>CRC是根据多项式生成的CRC值，CRC的计算范围包括帧起始、仲裁段、控制段、数据段  </li>
<li>接收方以同样的方式计算CRC值并进行比较，不一致时利用错误帧请求重新发送</li>
</ul>
<p>ACK段<br>ACK段包括ACK槽位、ACK界定符位2个位<br>发送单元的ACK 段：发送单元在 ACK 段发送2 个位的隐性位<br>接收单元的ACK 段：接收到正确消息的单元在ACK 槽发送显性位，通知发送单元正常接收结束，这称作“发送ACK”或者“返回ACK”</p>
<p>帧结束(End Of Frame，EOF)<br>帧结束是表示该帧结束的段，由发送节点发送 7 个位的隐性位构成<br>*CAN数据帧的结束符长度并不是完全不定的，而是根据数据位速率（Data Bit Rate，DBR）而定。CAN总线协议规定，对于数据位速率低于等于125kbps的网络，CAN数据帧的结束符长度为7个位；对于数据位速率大于125kbps的网络，CAN数据帧的结束符长度为3个位。这是因为在高速网络中，由于数据传输速率更快，所以CAN控制器可以更快地检测到结束位，因此可以减少结束符的长度，从而提高网络的传输效率。而在低速网络中，由于数据传输速率较慢，所以CAN控制器需要更长的时间来检测结束位，因此需要一个更长的结束符来确保数据帧传输的正确性和完整性。因此，CAN数据帧的结束符长度是根据数据位速率而定的，并不是完全不定的。</p>
<h2 id="Linux下的Socket-CAN帧定义"><a href="#Linux下的Socket-CAN帧定义" class="headerlink" title="Linux下的Socket CAN帧定义"></a>Linux下的Socket CAN帧定义</h2><ul>
<li>帧头，<code>canid_t</code>定义了一个无符号的32位整形数，按位确定功能<br> *0-28位为标识符，如果是扩展帧，则高11位为标准ID<br> 29位标识是数据帧还是错误消息<br> 30位说明是否是远程帧<br> 31位说明是标准帧还是扩展帧。</li>
<li>帧长，8位无符号表示数据区长度</li>
<li>数据区，定义<code>CAN_MAX_DLEN</code>个8位无符号数，按照数组的形式申请<br>*<code>__attribute__((aligned(8)))</code> 告诉编译器，将变量 <code>data</code> 放在一个地址是 8 的倍数的内存位置上。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CAN payload length and DLC definitions according to ISO 11898-1 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_MAX_DLC 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_MAX_DLEN 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> &#123;</span><br><span class="line"> <span class="type">canid_t</span> can_id; <span class="comment">/* 32 bit CAN_ID + EFF/RTR/ERR flags */</span></span><br><span class="line"> __u8 can_dlc; <span class="comment">/* frame payload length in byte */</span></span><br><span class="line"> __u8 data[CAN_MAX_DLEN] __attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Controller Area Network Identifier structure</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* bit 0-28 : CAN identifier (11/29 bit)</span></span><br><span class="line"><span class="comment">* bit 29 : error message frame flag (0 = data frame, 1 = error message)</span></span><br><span class="line"><span class="comment">* bit 30 : remote transmission request flag (1 = rtr frame)</span></span><br><span class="line"><span class="comment">* bit 31 : frame format flag (0 = standard 11 bit, 1 = extended 29 bit)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> __u32 <span class="type">canid_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> __u8;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Linux处理can_frame时用到的掩码和标识符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* special address description flags for the CAN_ID */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_EFF_FLAG 0x80000000U <span class="comment">/* EFF/SFF is set in the MSB */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_RTR_FLAG 0x40000000U <span class="comment">/* remote transmission request */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_ERR_FLAG 0x20000000U <span class="comment">/* error message frame */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* valid bits in CAN ID for frame formats */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_SFF_MASK 0x000007FFU <span class="comment">/* standard frame format (SFF) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_EFF_MASK 0x1FFFFFFFU <span class="comment">/* extended frame format (EFF) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_ERR_MASK 0x1FFFFFFFU <span class="comment">/* omit EFF, RTR, ERR flags */</span></span></span><br></pre></td></tr></table></figure>

<p>实际对can_frame的处理是在mcp251x_hw_tx&#x2F;mcp251x_hw_rx_frame中进行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mcp251x_hw_tx</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> can_frame *frame,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> tx_buf_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mcp251x_priv</span> *priv = <span class="built_in">spi_get_drvdata</span>(spi);</span><br><span class="line">u32 sid, eid, exide, rtr;</span><br><span class="line">u8 buf[SPI_TRANSFER_BUF_LEN];</span><br><span class="line"><span class="comment">//取can_id的31位，判断是标准帧还是扩展帧</span></span><br><span class="line">exide = (frame-&gt;can_id &amp; CAN_EFF_FLAG) ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (exide)<span class="comment">//如果是扩展帧，can_id的0-28位为ID，其中高11位为标准ID</span></span><br><span class="line">sid = (frame-&gt;can_id &amp; CAN_EFF_MASK) &gt;&gt; <span class="number">18</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sid = frame-&gt;can_id &amp; CAN_SFF_MASK; <span class="comment">/* Standard ID */</span></span><br><span class="line">eid = frame-&gt;can_id &amp; CAN_EFF_MASK; <span class="comment">/* Extended ID */</span></span><br><span class="line">rtr = (frame-&gt;can_id &amp; CAN_RTR_FLAG) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">/* 是否是远程帧*/</span></span><br><span class="line">buf[TXBCTRL_OFF] = <span class="built_in">INSTRUCTION_LOAD_TXB</span>(tx_buf_idx); <span class="comment">//发送缓冲器控制寄存器地址</span></span><br><span class="line">buf[TXBSIDH_OFF] = sid &gt;&gt; SIDH_SHIFT; <span class="comment">//发送缓冲器标准ID高8位</span></span><br><span class="line"><span class="comment">//5-7位存放发送缓冲器低3位,3位存放帧格式，0-1位存放扩展标识符低18位的高两位（16-17）</span></span><br><span class="line">buf[TXBSIDL_OFF] = ((sid &amp; SIDL_SID_MASK) &lt;&lt; SIDL_SID_SHIFT) | (exide &lt;&lt;</span><br><span class="line">SIDL_EXIDE_SHIFT) | ((eid &gt;&gt; SIDL_EID_SHIFT) &amp; SIDL_EID_MASK);</span><br><span class="line">buf[TXBEID8_OFF] = <span class="built_in">GET_BYTE</span>(eid, <span class="number">1</span>); <span class="comment">//存放扩展标识符低18位的8-15位</span></span><br><span class="line">buf[TXBEID0_OFF] = <span class="built_in">GET_BYTE</span>(eid, <span class="number">0</span>); <span class="comment">//扩展标识符低18位的低8位（0-7）</span></span><br><span class="line">buf[TXBDLC_OFF] = (rtr &lt;&lt; DLC_RTR_SHIFT) | frame-&gt;can_dlc; <span class="comment">//6位存放远程帧标识符，0-3存放数据长度码</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf + TXBDAT_OFF, frame-&gt;data, frame-&gt;can_dlc);<span class="comment">//拷贝要发送的数据</span></span><br><span class="line"><span class="built_in">mcp251x_hw_tx_frame</span>(spi, buf, frame-&gt;can_dlc, tx_buf_idx);</span><br><span class="line"><span class="comment">/* use INSTRUCTION_RTS, to avoid &quot;repeated frame problem&quot; */</span></span><br><span class="line">priv-&gt;spi_tx_buf[<span class="number">0</span>] = <span class="built_in">INSTRUCTION_RTS</span>(<span class="number">1</span> &lt;&lt; tx_buf_idx);</span><br><span class="line"><span class="built_in">mcp251x_spi_trans</span>(priv-&gt;spi, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mcp251x_hw_rx_frame</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, u8 *buf,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> buf_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mcp251x_priv</span> *priv = <span class="built_in">spi_get_drvdata</span>(spi);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mcp251x_is_2510</span>(spi)) &#123;</span><br><span class="line"><span class="type">int</span> i, len;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; RXBDAT_OFF; i++)</span><br><span class="line">	buf[i] = <span class="built_in">mcp251x_read_reg</span>(spi, <span class="built_in">RXBCTRL</span>(buf_idx) + i);</span><br><span class="line">	len = <span class="built_in">get_can_dlc</span>(buf[RXBDLC_OFF] &amp; RXBDLC_LEN_MASK);</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; (RXBDAT_OFF + len); i++)</span><br><span class="line">	buf[i] = <span class="built_in">mcp251x_read_reg</span>(spi, <span class="built_in">RXBCTRL</span>(buf_idx) + i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	priv-&gt;spi_tx_buf[RXBCTRL_OFF] = <span class="built_in">INSTRUCTION_READ_RXB</span>(buf_idx);</span><br><span class="line">	<span class="built_in">mcp251x_spi_trans</span>(spi, SPI_TRANSFER_BUF_LEN);</span><br><span class="line">	<span class="built_in">memcpy</span>(buf, priv-&gt;spi_rx_buf, SPI_TRANSFER_BUF_LEN);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Linux-CAN-功能分析"><a href="#Linux-CAN-功能分析" class="headerlink" title="Linux CAN 功能分析"></a>Linux CAN 功能分析</h1><p>一个标准的CAN功能包括：</p>
<ul>
<li>CAN接口号指定CAN接口号<code>can0</code></li>
<li>指定CAN通讯波特率，单位Kbps，默认为 500 Kbps</li>
<li>指定CAN发送帧ID</li>
<li>指定CAN发送帧数据<br>*需要包含数据的大小端模式转换</li>
<li>指定CAN帧发送间隔，单位ms， 默认为250ms, 最小值为1ms  </li>
<li>指定CAN帧发送次数</li>
<li>指定CAN发送帧为标准帧&#x2F;扩展帧  </li>
<li>发送数据时错误判断，本地环回功能<br>基于LINUX SOCKET机制实现的CAN接口，其基本的流程如下所示：</li>
<li>设置套接字<code>socket</code></li>
<li>指定CAN设备<code>ioctl</code></li>
<li>绑定套接字与设备<code>bind</code></li>
<li>设置过滤规则<code>setsockopt</code></li>
<li>发送&#x2F;接受报文<code>read/write</code></li>
<li>关闭套接字<code>close</code><br>以下介绍各部分如何实现。</li>
</ul>
<h1 id="Linux应用层SocketCAN实例"><a href="#Linux应用层SocketCAN实例" class="headerlink" title="Linux应用层SocketCAN实例"></a>Linux应用层SocketCAN实例</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>SocketCAN 中大部分的数据结构和函数在头文件 linux&#x2F;can.h 中进行了定义。 CAN 总线套接字的创建采用标准的网络套接字操作来完成。网络套接字在头文件 sys&#x2F;socket.h 中定义。 套接字的初始化方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_can</span> addr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ifreq</span> ifr;</span><br><span class="line">s = <span class="built_in">socket</span>(PF_CAN, SOCK_RAW, CAN_RAW);<span class="comment">//创建SocketCAN 套接字</span></span><br><span class="line"><span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span>);</span><br><span class="line"><span class="built_in">ioctl</span>(s, SIOCGIFINDEX, &amp;ifr);<span class="comment">//指定 can0 设备</span></span><br><span class="line">addr.can_family = AF_CAN;</span><br><span class="line">addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line"><span class="built_in">bind</span>(s, (structsockaddr *)&amp;addr,<span class="built_in">sizeof</span>(addr)); <span class="comment">//将套接字与 can0 绑定</span></span><br></pre></td></tr></table></figure>

<h2 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h2><p>在数据收发的内容方面， CAN 总线与标准套接字通信稍有不同，每一次通信都采用 can_ frame 结构体将数据封装成帧。 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">structcan_frame &#123;</span><br><span class="line"><span class="type">canid_t</span> can_id;<span class="comment">//CAN 标识符</span></span><br><span class="line">__u8 can_dlc;<span class="comment">//数据场的长度</span></span><br><span class="line">__u8 data[<span class="number">8</span>];<span class="comment">//数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>can_id 为帧的标识符， 如果发出的是标准帧， 就使用 can_id 的低 11 位； 如果为扩展帧， 就使用 0～ 28 位。 can_id 的第 29、 30、 31 位是帧的标志位，用来定义帧的类型，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_EFF_FLAG 0x80000000U <span class="comment">//扩展帧的标识</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_RTR_FLAG 0x40000000U <span class="comment">//远程帧的标识</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAN_ERR_FLAG 0x20000000U <span class="comment">//错误帧的标识，用于错误检查</span></span></span><br></pre></td></tr></table></figure>
<p>数据发送使用 write 函数来实现。 如果发送的数据帧(标识符为 0x123)包含单个字节(0xAB)的数据，可采用如下方法进行发送：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> frame;</span><br><span class="line"><span class="comment">//如果为扩展帧，那么frame.can_id = CAN_EFF_FLAG | 0x123;</span></span><br><span class="line">frame.can_id = <span class="number">0x123</span>;</span><br><span class="line"></span><br><span class="line">frame.can_dlc = <span class="number">1</span>; <span class="comment">//数据长度为 1</span></span><br><span class="line">frame.data[<span class="number">0</span>] = <span class="number">0xAB</span>; <span class="comment">//数据内容为 0xAB</span></span><br><span class="line"><span class="type">int</span> nbytes = <span class="built_in">write</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame));<span class="comment">//发送数据</span></span><br><span class="line"><span class="keyword">if</span>(nbytes != <span class="built_in">sizeof</span>(frame)) <span class="comment">//如果 nbytes 不等于帧长度，就说明发送失败</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error\n!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果要发送远程帧(标识符为 0x123)，可采用如下方法进行发送：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> frame;</span><br><span class="line">frame.can_id = CAN_RTR_FLAG | <span class="number">0x123</span>;</span><br><span class="line"><span class="built_in">write</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame));</span><br></pre></td></tr></table></figure>

<h2 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h2><p>数据接收使用 read 函数来完成，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_frame</span> frame;</span><br><span class="line"><span class="type">int</span> nbytes = <span class="built_in">read</span>(s, &amp;frame, <span class="built_in">sizeof</span>(frame));</span><br></pre></td></tr></table></figure>
<p>套接字数据收发时常用的 send、 sendto、 sendmsg 以及对应的 recv 函数也都可以用于CAN总线数据的收发。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当帧接收后，可以通过判断 can_id 中的 CAN_ERR_FLAG 位来判断接收的帧是否为错误帧。 如果为错误帧，可以通过 can_id 的其他符号位来判断错误的具体原因。<br>错误帧的符号位在头文件 linux&#x2F;can&#x2F;error.h 中定义。</p>
<h2 id="过滤规则设置"><a href="#过滤规则设置" class="headerlink" title="过滤规则设置"></a>过滤规则设置</h2><p>在数据接收时，系统可以根据预先设置的过滤规则，实现对报文的过滤。过滤规则使用 can_filter 结构体来实现，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">can_filter</span> &#123;</span><br><span class="line"><span class="type">canid_t</span> can_id;</span><br><span class="line"><span class="type">canid_t</span> can_mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>过滤的规则为：接收到的数据帧的 <code>can_id &amp; mask == can_id &amp; mask</code><br>通过这条规则可以在系统中过滤掉所有不符合规则的报文，使得应用程序不需要对无关的报文进行处理。在 can_filter 结构的 can_id 中，符号位 CAN_INV_FILTER 在置位时可以实现 can_id 在执行过滤前的位反转。<br>用户可以为每个打开的套接字设置多条独立的过滤规则，使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">structcan_filter rfilter[<span class="number">2</span>];</span><br><span class="line">rfilter[<span class="number">0</span>].can_id = <span class="number">0x123</span>;</span><br><span class="line">rfilter[<span class="number">0</span>].can_mask = CAN_SFF_MASK;</span><br><span class="line"><span class="comment">//#define CAN_SFF_MASK 0x000007FFU</span></span><br><span class="line">rfilter[<span class="number">1</span>].can_id = <span class="number">0x200</span>;</span><br><span class="line">rfilter[<span class="number">1</span>].can_mask = <span class="number">0x700</span>;</span><br><span class="line"><span class="comment">//设置规则</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_FILTER,&amp;rfilter, <span class="built_in">sizeof</span>(rfilter));</span><br></pre></td></tr></table></figure>

<p>在极端情况下，如果应用程序不需要接收报文，可以禁用过滤规则。这样的话，原始套接字就会忽略所有接收到的报文。在这种仅仅发送数据的应用中，可以在内核中省略接收队列，以此减少 CPU 资源的消耗。禁用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_FILTER, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//禁用过滤规则</span></span><br></pre></td></tr></table></figure>
<p>通过错误掩码可以实现对错误帧的过滤， 例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">can_err_mask_t</span> err_mask = (CAN_ERR_TX_TIMEOUT | CAN_ERR_BUSOFF );</span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW,CAN_RAW_ERR_FILTER, err_mask,<span class="built_in">sizeof</span>(err_mask));</span><br></pre></td></tr></table></figure>

<h2 id="回环功能设置"><a href="#回环功能设置" class="headerlink" title="回环功能设置"></a>回环功能设置</h2><p>在默认情况下， 本地回环功能是开启的，可以使用下面的方法关闭回环&#x2F;开启功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> loopback = <span class="number">0</span>; <span class="comment">// 0 表示关闭, 1 表示开启( 默认)</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_LOOPBACK,&amp;loopback, <span class="built_in">sizeof</span>(loopback));</span><br></pre></td></tr></table></figure>
<p>在本地回环功能开启的情况下，所有的发送帧都会被回环到与 CAN 总线接口对应的套接字上。 默认情况下，发送 CAN 报文的套接字不想接收自己发送的报文，因此发送套接字上的回环功能是关闭的。<br>可以在需要的时候改变这一默认行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ro = <span class="number">1</span>; <span class="comment">// 0 表示关闭( 默认), 1 表示开启</span></span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS, &amp;ro, <span class="built_in">sizeof</span>(ro));</span><br></pre></td></tr></table></figure>

<h1 id="如何在ARM上实现CAN通讯"><a href="#如何在ARM上实现CAN通讯" class="headerlink" title="如何在ARM上实现CAN通讯"></a>如何在ARM上实现CAN通讯</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>ARM需要有CAN控制器和CAN收发器<br><em>CAN控制器</em>（CAN Controller）是负责实现CAN协议的逻辑部分的组件<br><em>CAN收发器</em>（CAN Transceiver）是负责CAN总线电平信号和CAN控制器之间的电信号转换的组件<br><strong>CAN控制器</strong>示例：</p>
<ul>
<li>内置于微控制器中的CAN模块（例如STM32系列微控制器的内置CAN控制器）。</li>
<li>独立的CAN控制器芯片（例如MCP2515）。<br><strong>CAN收发器</strong>示例：</li>
<li>常见的独立CAN收发器芯片（例如MCP2551、TJA1050等）。</li>
</ul>
<p>先选择CAN控制器芯片，一般的PC和ARM都没有CAN控制器，一般是MCP2515和SJA1000，主要区别是MCP2515是SPI接口，SJA1000是I&#x2F;O接口。所以MCP2515占用资源少，5-6个管脚就可以控制，SJA1000占用的管脚就多。</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>需要支持CAN控制器驱动，控制CAN控制器发送CAN帧<br>对于一般的CAN控制器，进行初始化时，最关键的是以下两步：</p>
<ol>
<li>配置CAN的位时序；</li>
<li>配置CAN的消息报文；</li>
</ol>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>Linux中有对CAN（Controller Area Network）总线的支持，主要通过SocketCAN子系统实现。内核编译时选择响应的支持芯片。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make linux-menuconfig</span><br><span class="line">Networking support ---&gt;</span><br><span class="line">CAN bus subsystem support ---&gt;</span><br><span class="line">--- CAN bus subsystem support</span><br><span class="line">Raw CAN Protocol (raw access with CAN-ID filtering)</span><br><span class="line">Broadcast Manager CAN Protocol (with content filtering)</span><br><span class="line">CAN Device Drivers ---&gt;</span><br><span class="line">Virtual Local CAN Interface (vcan)</span><br><span class="line">Platform CAN drivers with Netlink support</span><br><span class="line">[*] CAN bit-timing calculation</span><br><span class="line">Microchip 251x series SPI CAN Controller</span><br></pre></td></tr></table></figure>
<p>SocketCAN支持多种CAN控制器硬件，通过不同的内核驱动程序实现对具体硬件的支持。例如，以下是一些常见的CAN控制器驱动程序：</p>
<ul>
<li><code>sja1000</code>：Philips&#x2F;NXP SJA1000 CAN控制器</li>
<li><code>mcp251x</code>：Microchip MCP251x SPI CAN控制器系列（如MCP2515）</li>
<li><code>flexcan</code>：Freescale&#x2F;NXP FlexCAN模块<br>这些驱动程序通常位于内核源代码树的<code>drivers/net/can</code>目录下。</li>
</ul>
<h3 id="CAN数据发送跟踪"><a href="#CAN数据发送跟踪" class="headerlink" title="CAN数据发送跟踪"></a>CAN数据发送跟踪</h3><p>当我们在用户层通过socket进行CAN数据的发送时，需要进行以下操作：</p>
<ol>
<li>创建一个套接字<code>socket</code>，采用<code>AF_CAN</code>协议。</li>
<li>将创建的套接字返回描述符<code>sockfd</code>，绑定到本地的地址。</li>
<li>通过<code>sendto</code>系统调用函数进行发送，<code>sendto</code>的系统调用会发送一帧数据报到指定的地址，在CAN协议调用之前把该地址移到内核空间和检查用户空间数据域是否可读。</li>
<li>在<code>net/socket.c</code>源文件中，在<code>sendto</code>的系统调用<code>（sys_sendto）</code>里，会调用到<code>sock_sendmsg()</code>函数，接下来调用<code>__sock_sendmsg()</code>函数。</li>
<li>再往下一步就是<code>__sock_sendmsg_nosec</code>函数。在<code>__sock_sendmsg_nosec()</code>函数中会返回一个<code>sendmsg</code>函数指针。</li>
<li>在<code>/net/can/raw.c</code>源文件中，将<code>raw_sendmsg</code>函数地址赋给<code>sendmsg</code>函数指针，即在函数<code>__sock_sendmsg_nosec()</code>中<code>return sock-&gt;ops-&gt;sendmsg(iocb,sock, msg, size)</code>，返回的函数指针将指向<code>raw_sendmsg()</code>函数。</li>
<li>在<code>net/can/af_can.c</code>源文件中，<code>can_send</code>函数负责CAN协议层的数据传输，即传输一帧CAN报文（可选本地回环）。参数<code>skb</code>指针指向套接字缓冲区和在数据段的CAN帧。loop参数是在本地CAN套接字上为监听者提供回环。</li>
</ol>
<p>以下开始进行到CAN的底层驱动代码了，由于CAN驱动是编译进内核中，所以在系统启动时会注册CAN驱动。</p>
<ul>
<li>注册CAN驱动过程中会初始化<code>d_can_netdev_ops</code>结构体变量。</li>
<li>在这个过程中，<code>d_can_netdev_ops</code>结构体变量定义了3个函数指针，其中<code>(*ndo_start_xmit)</code>函数指针指向<code>d_can_start_xmit</code>函数的入口地址。</li>
<li>在<code>d_can_start_xmit()</code>函数中，会调用<code>d_can_write_msg_object()</code>函数准备消息报文进行传输。</li>
</ul>
<h3 id="CAN数据接收跟踪"><a href="#CAN数据接收跟踪" class="headerlink" title="CAN数据接收跟踪"></a>CAN数据接收跟踪</h3><p>对于网络设备，数据接收大体上采用中断+NAPI机制进行数据的接收。同样，我们现在的CAN模块也是采用同样的方式进行数据的接收。由于我们只针对CAN总线接收数据这条主线进行分析。因些，会忽略一些针对CAN协议的设置及初始化等相关代码。<br>*NAPI（New API）是一种改进的网络数据接收机制，它通过减少中断处理的次数来提高性能。NAPI的基本思想是延迟数据包的处理，使得多个数据包可以一次性地在中断处理程序中进行处理，从而减少了中断的数量，提高了系统的处理效率。<br>中断+NAPI机制的工作原理大致如下：<br>当网络数据包到达时，网络接口卡会生成一个中断通知操作系统。<br>中断服务程序会执行一些必要的处理，然后调用NAPI机制。<br>NAPI机制会检查网络接口缓冲区中是否有足够的数据需要处理。<br>如果有足够的数据，NAPI会立即开始处理这些数据，而不会再次触发中断。如果数据量不足，NAPI会退出，并要求在将来的某个时候再次调用。<br>处理完数据后，系统可以选择性地决定是否重新启用中断服务程序。<br>通过将数据包的处理延迟到一组数据包到达时再进行，中断+NAPI机制能够大大减少中断的数量，提高系统的处理效率，特别是在高负载情况下。</p>
<ol>
<li>在初始化CAN设备时，我们需要给CAN设备分配NAPI功能。我们通过<code>netif_napi_add()</code>函数将CAN设备添加到NAPI机制列表中。</li>
<li>将CAN设备添加到NAPI机制列表中后，在中断处理函数<code>d_can_isr</code>中，我们通过<code>napi_schedule()</code>函数调度已经在NAPI机制列表中的<code>d_can_poll()</code>函数。该函数会通过轮询的方式接收数据。而根据NAPI机制，当中断产生后，会调度轮询机制同时关闭所有的中断。</li>
<li>当中断产生时，会调用函数<code>d_can_poll()</code>，该函数即采用轮询的方式进行数据的接收。由于CAN总线状态中断具有最高优先权，在接收数据之前，需要对CAN总线的状态进行判断。而对于CAN总线错误状态有三种：主动&#x2F;被动&#x2F;关闭。</li>
<li>当总线状态数据状态正常时，从CAN模块的接收寄存器中接收数据。</li>
</ol>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>要在linux下面配置和测试CAN，需要安装以下三个组件。</p>
<ul>
<li>iproute2 （配置CAN接口时需要）</li>
<li>libsocketcan（使用CAN必须）</li>
<li>can-utils <a href="https://github.com/linux-can/can-utils">https://github.com/linux-can/can-utils</a>  (CAN的测试小工具，linux下测试CAN比较好用应用程序)</li>
</ul>
<p>可以直接通过命令行形式控制CAN</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置CAN接口（假设设备名为`can0`）：</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 500000</span><br><span class="line"><span class="comment"># 启动CAN接口</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> up can0</span><br><span class="line"><span class="comment"># 查看CAN接口状态</span></span><br><span class="line">ip -details <span class="built_in">link</span> show can0</span><br><span class="line"><span class="comment"># CAN 2.0 linkup</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 100000</span><br><span class="line"><span class="comment"># CAN 2.0 FD linkup</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up <span class="built_in">type</span> can bitrate 500000 dbitrate 2000000 fd on</span><br><span class="line"><span class="comment"># 命令来配置 CAN 总线的位速率：</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> cantq 125 prop-seg 6phase-seg1 7 phase-seg2 2 sjw 1</span><br><span class="line"><span class="comment"># 可以使用 ip 命令直接设定位速率500kbps：</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> can bitrate 500000</span><br><span class="line"><span class="comment"># 当设置完成后，可以通过下面的命令查询 can0 设备的参数设置：</span></span><br><span class="line">ip -details <span class="built_in">link</span> show can0</span><br><span class="line"><span class="comment"># 当设置完成后，可以使用下面的命令使能 can0 设备：</span></span><br><span class="line">ifconfig can0 up</span><br><span class="line"><span class="comment"># 使用下面的命令取消 can0 设备使能：</span></span><br><span class="line">ifconfig can0 down</span><br><span class="line"><span class="comment"># 在设备工作中，可以使用下面的命令来查询工作状态：</span></span><br><span class="line">ip -details -statistics <span class="built_in">link</span> show can0</span><br></pre></td></tr></table></figure>

<p><code>ip link set can0 type cantq 125 prop-seg 6phase-seg1 7 phase-seg2 2 sjw 1</code><br>*同步段（Sync Segment）: 固定为1 TQ，用于同步位定时器。<br>传播时间段（Propagation Segment, prop-seg）: 用于补偿信号在总线上传播的时间延迟。<br>相位缓冲段1（Phase Buffer Segment 1, phase-seg1）: 用于提高抗干扰能力，允许时间调整。<br>相位缓冲段2（Phase Buffer Segment 2, phase-seg2）: 也用于提高抗干扰能力，允许时间调整。</p>
<p>*ip link set can0 type can: 设置名为 can0 的网络接口的类型为 CAN。<br>tq 125: 设置时间量化（Time Quantum，TQ）为 125 ns。TQ 是CAN控制器内部的基本时间单位，用于划分整个位时间。<br>prop-seg 6: 设置传播时间段（Propagation Segment）为 6 TQ。传播时间段用于补偿信号在CAN总线上传播的延迟。<br>phase-seg1 7: 设置相位缓冲段1（Phase Buffer Segment 1）为 7 TQ。这个时间段用于调整边沿相位，通常包括采样点之前的时间。<br>phase-seg2 2: 设置相位缓冲段2（Phase Buffer Segment 2）为 2 TQ。这个时间段用于调整边沿相位，通常包括采样点之后的时间。<br>sjw 1: 设置同步跳跃宽度（Synchronization Jump Width，SJW）为 1 TQ。SJW 用于重新同步时可以跳跃的最大时间量。</p>
<p>*具体计算<br>tq 125: 时间量化为125 ns。<br>prop-seg 6: 传播时间段为 6 个时间量化，6 * 125 ns &#x3D; 750 ns。<br>phase-seg1 7: 相位缓冲段1为 7 个时间量化，7 * 125 ns &#x3D; 875 ns。<br>phase-seg2 2: 相位缓冲段2为 2 个时间量化，2 * 125 ns &#x3D; 250 ns。<br>sjw 1: 同步跳跃宽度为 1 个时间量化，1 * 125 ns &#x3D; 125 ns。<br>计算位时间<br>总位时间是所有段的时间总和：<br>Sync Segment: 1 TQ<br>Propagation Segment: 6 TQ<br>Phase Buffer Segment 1: 7 TQ<br>Phase Buffer Segment 2: 2 TQ<br>总时间量化数 &#x3D; 1 + 6 + 7 + 2 &#x3D; 16 TQ<br>总位时间 &#x3D; 16 * 125 ns &#x3D; 2000 ns &#x3D; 2 μs<br>位速率（Bit Rate） &#x3D; 1 &#x2F; 总位时间 &#x3D; 1 &#x2F; 2 μs &#x3D; 500 kbps</p>
<h1 id="Qt中使用SocketCAN"><a href="#Qt中使用SocketCAN" class="headerlink" title="Qt中使用SocketCAN"></a>Qt中使用SocketCAN</h1><p>需要编译安装socketCAN插件， <a href="https://doc.qt.io/qt-5/qtserialbus-socketcan-overview.html">https://doc.qt.io/qt-5/qtserialbus-socketcan-overview.html</a> ，关键字【Using SocketCAN Plugin】</p>
<p>pro文件中添加<code>QT += serialbus</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString errorString;</span><br><span class="line"><span class="type">const</span> QList&lt;QCanBusDeviceInfo&gt; devices = QCanBus::<span class="built_in">instance</span>()-&gt;<span class="built_in">availableDevices</span>(</span><br><span class="line">	<span class="built_in">QStringLiteral</span>(<span class="string">&quot;socketcan&quot;</span>), &amp;errorString);</span><br><span class="line"><span class="keyword">if</span> (!errorString.<span class="built_in">isEmpty</span>())</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; errorString;</span><br></pre></td></tr></table></figure>

<h1 id="在Qt中利用线程权限进行高速的CAN通信"><a href="#在Qt中利用线程权限进行高速的CAN通信" class="headerlink" title="在Qt中利用线程权限进行高速的CAN通信"></a>在Qt中利用线程权限进行高速的CAN通信</h1><p>用PC里能达到的CAN通信（使用USBCAN-II）速度是1ms</p>
<ul>
<li>使用3个线程类：1个用来接收，1个用来发送，1个用来解析</li>
<li>接收线程使用最高线程权限：<strong>QThread::HighestPriority</strong>，其余线程用 <strong>QThread::HighPriority</strong></li>
<li>如何循环发送报文：在发送线程里再多加一个定时器，timeout时间为需要循环发送的时间（可达到1ms）；</li>
<li>用户在主界面设置需要发送的报文为OBJ结构体数组，然后通过构造函数的方式传到发送线程，最后发送就行了。</li>
<li>解析过程：接收函数循环接收报文，每接收到n帧就发送到解析线程，然后根据ID解析，将解析数据发送主界面显示（不要append）</li>
</ul>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>CAN</category>
      </categories>
  </entry>
  <entry>
    <title>USB挂载监测</title>
    <url>/2024/05/17/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-USB-USB%E6%8C%82%E8%BD%BD%E7%9B%91%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><pre><code>程序监测到插入U盘后，自动执行执行U盘内和本地指定文件夹双向同步功能
</code></pre>
<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol>
<li>Linux下如何用QT检测到U盘已经插入，并实现mount与umount</li>
</ol>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>使用qt自带的QDBus可以实现，下面为连接代码，当系统有设备插入时，可以调用<code>slotDeviceAdded(QString udi)</code>函数。</p>
<p>在pro文件中应该加入<br><code>QT +=dbus</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtDBus/QDBusConnection&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDbusInterface&gt;</span></span></span><br><span class="line"><span class="comment">//以下为检测设备的插入</span></span><br><span class="line">      QDBusConnection::<span class="built_in">systemBus</span>().<span class="built_in">connect</span>(    <span class="string">&quot;org.freedesktop.Hal&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/org/freedesktop/Hal/Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;org.freedesktop.Hal.Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;DeviceAdded&quot;</span>,</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        <span class="built_in">SLOT</span>(<span class="built_in">slotDeviceAdded</span>(QString )));</span><br><span class="line"><span class="comment">//以下为检查设备的拨出</span></span><br><span class="line">    QDBusConnection::<span class="built_in">systemBus</span>().<span class="built_in">connect</span>(    <span class="string">&quot;org.freedesktop.Hal&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/org/freedesktop/Hal/Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;org.freedesktop.Hal.Manager&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;DeviceRemoved&quot;</span>,</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        <span class="built_in">SLOT</span>(<span class="built_in">slotDeviceRemoved</span>(QString )));</span><br></pre></td></tr></table></figure>


<p>在slotDeviceAdded(QString udi)函数中，要使用到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QDBusInterface <span class="title">device</span><span class="params">(<span class="string">&quot;org.freedesktop.Hal&quot;</span>, udi, <span class="string">&quot;org.freedesktop.Hal.Device&quot;</span> , QDBusConnection::systemBus())</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过HAL可以查询到设备为volume的设备，然后通过判断是否为&#x2F;dev&#x2F;sd的设备，就可以判断出是否为U盘，然后调用mount就可以了。</p>
<p>这时记录下U盘的UDI，在检测到设备拨出时，再查询一下U盘的UDI是否还在，就知道U盘是否被拨出了。</p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>USB权限设置</title>
    <url>/2024/05/20/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-USB-USB%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>因Linux系统下将涉及到usb底层驱动的调用，运行时，一定要加sudo获取权限运行，否则USB设备没有权限操作。<br>现通过创建UDEV规则，配置USB权限后，可以调用指定设备不加权限运行。</p>
<p>输入lsusb，查看当前的USB设备的ID，确定需要配置的USB。</p>
<p>创建一个新的udev规则。名称取为：99-myusb.rules<br><code>sudo vi /etc/udev/rules.d/99-myusb.rules</code></p>
<p>在99-myusb.rules文件中，输入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##</span><br><span class="line">ACTION==&quot;add&quot;,SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;04d8&quot;, ATTRS&#123;idProduct&#125;==&quot;0053&quot;, GROUP=&quot;users&quot;, MODE=&quot;0777&quot;</span><br></pre></td></tr></table></figure>
<p>*这条<code>udev</code>规则的作用是，当供应商ID为<code>04d8</code>且产品ID为<code>0053</code>的USB设备插入系统时，将该设备的用户组设置为<code>users</code>，并赋予所有用户读、写、执行的全部权限。</p>
<p>插拔一下USBCAN设备或重启一下电脑后，即可不加sudo权限运行程序了</p>
<p>对某个特定USB设备设置权限。每当这个设备插入系统时，规则会自动应用。</p>
<ol>
<li><code>ACTION==&quot;add&quot;</code>：这表示规则在设备添加（插入）时生效。<code>udev</code>可以根据不同的动作（如添加、移除等）触发规则，<code>add</code>动作指设备插入时。</li>
<li><code>SUBSYSTEMS==&quot;usb&quot;</code>：表示规则适用于USB子系统的设备。<code>udev</code>管理系统中的设备，子系统用于分类，USB是其中一种。</li>
<li><code>ATTRS&#123;idVendor&#125;==&quot;04d8&quot;</code>：表示设备的供应商ID（Vendor ID）为<code>04d8</code>。每个USB设备都有唯一的供应商ID，用于标识设备的制造商。</li>
<li><code>ATTRS&#123;idProduct&#125;==&quot;0053&quot;</code>：表示设备的产品ID（Product ID）为<code>0053</code>。每个供应商的不同产品有不同的产品ID，用于区分供应商的各个设备。</li>
<li><code>GROUP=&quot;users&quot;</code>：表示设备的用户组被设置为<code>users</code>。这决定了哪些用户组的成员有权访问该设备。</li>
<li><code>MODE=&quot;0777&quot;</code>：表示设备的权限模式被设置为<code>0777</code>，即所有用户对该设备都有读、写、执行权限。</li>
</ol>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下的CH34x串口识别</title>
    <url>/2024/05/21/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-%E4%B8%B2%E5%8F%A3-Linux%E4%B8%8B%E7%9A%84CH34x%E4%B8%B2%E5%8F%A3%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p><strong>判断是否识别</strong><br>使用<code>lsusb</code>命令可以看到有<code>Bus 001 Device 005: ID 1a86:7523 QinHeng Electronics CH340 serial converter</code>是能识别出ch34x设备</p>
<p><strong>检查串口是否被驱动加载</strong><br>输入指令<code>ls /dev/ttyUSB*</code>将会列出USB的加载情况。如果提示No such file or directory则是没有被驱动加载。</p>
<p><strong>占用情况</strong><br>因报文件不存在错误，采用<code>dmesg|grep tty</code>命令检查发现，被<code>brltty</code>进程占用。</p>
<p><code>brltty</code>是一个后台进程（守护进程），为盲人提供对Linux&#x2F;Unix控制台的访问（当处于文本模式时），使用可刷新盲文显示。<br>移除该<code>apt remove brltty</code>。</p>
<p><strong>权限</strong><br><code>chmod a+rw /dev/ttyUSB0</code>即可</p>
<p><strong>重装驱动</strong><br>下载最新的驱动CH341SER_LINUX<br><a href="https://github.com/WCHSoftGroup/ch341ser_linux">https://github.com/WCHSoftGroup/ch341ser_linux</a> </p>
<ol>
<li>解压后进入”driver”目录下</li>
<li>输入<code>make</code>命令编译驱动，正常编译完成后，将会看到生成了<code>ch341.ko</code>模块</li>
<li>输入<code>sudo make load</code> 或者 <code>sudo insmod ch341.ko</code>动态加载驱动（重启需要再次加载），或者输入 <code>sudo make install</code> 安装驱动（重启不丢失）</li>
<li>输入<code>sudo make unload</code> 或者 <code>sudo rmmod ch341.ko</code> 或者<code>sudo make uninstall</code> 卸载驱动</li>
</ol>
<p>*如果编译失败，可能是ch34x.c和实际内核版本不匹配，<code>uname -r</code> 可查看操作系统的发行版号，之后在 <a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source</a> 中查找对应内核版本的源代码文件，一般位于<code>/drivers/usb/serial/ch341.c</code>，替换后重新编译</p>
<p>*如果insmod失败，查看<code>/lib/modules/$(uname -r)/kernel/drivers/usb/serial</code>目录下是否已经有了ko模块，将目录中生成ko文件复制到此处，使用<code>lsmod</code>查看模块</p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>串口</category>
      </categories>
  </entry>
  <entry>
    <title>Socket套接字</title>
    <url>/2024/05/20/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-%E7%BD%91%E7%BB%9C-Socket%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<p>Socket最初是作为网络上不同主机之间进程的通信接口，后来应用越来越广，在同一主机上的不同进程之间通信也可以用Socket。</p>
<p>简单来说，当网络上不同主机之间的两个进程（A、B）采用Socket进行通信时，那么它们之间需要建立一个通信端点，即创建Socket，创建Socket时就分配端口号和网络地址。当进程A向进程B发送数据时，那么进程A必须要知道进程B的网络地址及端口号。</p>
<p>Socket采用C&#x2F;S模型进行设计的，即Client&#x2F;Server，面向客户端—服务器模型。</p>
<p>每一个Socket都用一个半相关描述：<br>{协议，本地地址，本地端口}<br>一个完整的Socket则用一个相关描述:<br>{协议，本地地址，本地端口，远程地址，远程端口}</p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="字节流套接字（SOCK-STREAM）"><a href="#字节流套接字（SOCK-STREAM）" class="headerlink" title="字节流套接字（SOCK_STREAM）"></a>字节流套接字（SOCK_STREAM）</h2><p>字节流的套接字可以提供可靠的数据传输、面向连接的通讯流。数据按何种顺序发送，就按何种顺序接收。例如，当我们按顺序发送A-B-C，那么在数据到达接收端时，它的顺序也是A-B-C。字节流套接字采用的是TCP（Transmission Control Protocol）协议。保证了数据传输的可靠性。<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520132726.png" alt="image.png"></p>
<h2 id="数据报套接字（SOCK-DGRAM）"><a href="#数据报套接字（SOCK-DGRAM）" class="headerlink" title="数据报套接字（SOCK_DGRAM）"></a>数据报套接字（SOCK_DGRAM）</h2><p>数据报套接字定义了一种无连接的服务。所谓无连接服务，简单来说，即在发送数据时，无需在收发两端建立类似TCP那样的握手连接，在发送时，将数据打包，然后加上远程IP地址，即可把该数据包发送出去。<br>数据通过相互独立的报文进行传输。并且是无序的、不可靠的传输。<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/20/20240520132823.png" alt="image.png"></p>
<h2 id="原始套接字（SOCK-ROW）"><a href="#原始套接字（SOCK-ROW）" class="headerlink" title="原始套接字（SOCK_ROW）"></a>原始套接字（SOCK_ROW）</h2><p>先启动服务器，通过调用socket()函数建立一个套接字，然后调用bind()函数将该套接字和本地网络地址联系在一起，再调用listen()函数使套接字做好侦听的准备，并规定它的请求队列的长度，之后就调用accept()函数来接收连接。</p>
<p>客户端在建立套接字之后就可调用 connect()和服务器建立连接。</p>
<p>连接一旦建立，客户端和服务器之间就可以通过调用recv()&#x2F;recvfrom()函数和send()&#x2F;sendto函数来进行发收数据。</p>
<p>最后，待数据传送结束后，双方调用close()函数关闭套接字。</p>
]]></content>
      <categories>
        <category>通讯协议</category>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>DRM+GBM+EGL显示</title>
    <url>/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux-Linux-Graphics-DRM-GBM-EGL%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>DRM (Direct Rendering Manager)、GBM (Generic Buffer Manager) 和 EGL (Embedded-System Graphics Library) 组合在一起，是在 Linux 平台上进行图形渲染和硬件加速的常见方式。这些组件一起提供了一个完整的图形渲染栈，允许应用程序直接与图形硬件进行交互。</p>
<ul>
<li><p><strong>DRM（Direct Rendering Manager）</strong>：DRM 是 Linux 内核中的一个子系统，用于管理图形硬件的驱动程序。它提供了一种通用的接口，允许用户空间程序直接与硬件交互，通过设备文件 <code>/dev/dri/cardX</code> 访问。DRM 提供了诸如模式设置、显示控制、渲染加速等功能。</p>
</li>
<li><p><strong>GBM（Generic Buffer Manager）</strong>：GBM 是一个用于管理图形缓冲区的库，通常与 DRM 配合使用。它提供了一种标准的接口，用于分配、管理和操作图形内存。GBM 还提供了与 EGL 和 OpenGL ES 兼容的接口，使应用程序能够使用硬件加速进行渲染。</p>
</li>
<li><p><strong>EGL（Embedded-System Graphics Library）</strong>：EGL 是一个用于管理图形资源的库，提供了一个通用的接口，用于创建和管理 OpenGL 和 OpenGL ES 上下文、表面和其他相关对象。EGL 通常与 GBM 和 DRM 一起使用，通过 GBM 提供的接口来创建图形表面，并将其与 OpenGL 或 OpenGL ES 上下文关联起来，实现硬件加速的图形渲染。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
        <category>Linux Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Mesa</title>
    <url>/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux-Linux-Graphics-Mesa/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
        <category>Linux Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>OpenGL显示</title>
    <url>/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux-Linux-Graphics-OpenGL%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="GLU"><a href="#GLU" class="headerlink" title="GLU"></a>GLU</h1><p>GLU（OpenGL Utility Library）是OpenGL的一个辅助库，提供了一些更高级的几何计算和对象构造函数，如曲面和体的生成、平移、旋转等，这些函数在处理复杂的几何操作时非常有用。</p>
<h1 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h1><p>GLFW是一个流行的开源库，主要用于创建和管理图形应用程序中的窗口、OpenGL或Vulkan上下文，以及处理用户输入、定时器等功能。适用于各种图形应用程序的开发，提供了窗口管理、上下文管理、输入处理等功能，使开发者能够专注于图形渲染和应用逻辑的实现。<br>主要功能：</p>
<ol>
<li><strong>窗口管理：</strong> GLFW允许开发者创建窗口并对其进行管理，包括调整大小、最小化、最大化、关闭等操作。</li>
<li><strong>上下文管理：</strong> 它提供了创建OpenGL或Vulkan上下文的功能，使得图形渲染程序可以在窗口中绘制图形。</li>
<li><strong>输入处理：</strong> GLFW支持处理用户输入，包括键盘输入、鼠标移动和点击、游戏手柄等。</li>
<li><strong>事件处理：</strong> 它允许开发者监听和响应各种事件，如窗口大小改变、键盘按键、鼠标移动等。</li>
<li><strong>监视器管理：</strong> GLFW支持多个显示器的管理，可以获取显示器的分辨率、刷新率等信息。</li>
</ol>
<p>使用步骤：</p>
<ol>
<li><strong>初始化：</strong> 在程序启动时，调用GLFW的初始化函数来初始化库。</li>
<li><strong>创建窗口：</strong> 使用GLFW的窗口创建函数来创建一个窗口并指定其属性，如大小、标题等。</li>
<li><strong>创建上下文：</strong> 使用GLFW的上下文创建函数来创建一个OpenGL或Vulkan上下文。</li>
<li><strong>主循环：</strong> 在主循环中轮询事件，并根据事件类型做出相应的处理。</li>
<li><strong>渲染：</strong> 在渲染阶段，使用OpenGL或Vulkan等图形API绘制场景。</li>
<li><strong>清理：</strong> 在程序结束时，调用GLFW的清理函数来释放资源并关闭库。</li>
</ol>
<p>利用glfw监视器Demo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="comment">// 初始化 GLFW </span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">glfwInit</span>()) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125; </span><br><span class="line">	<span class="comment">// 获取监视器（显示器）列表 </span></span><br><span class="line">	<span class="type">int</span> count; GLFWmonitor** monitors = <span class="built_in">glfwGetMonitors</span>(&amp;count); </span><br><span class="line">	<span class="comment">// 指定要使用的显示设备索引 </span></span><br><span class="line">	<span class="type">int</span> monitor_index = <span class="number">0</span>; </span><br><span class="line">	<span class="comment">// 设置为你想要的显示设备索引 </span></span><br><span class="line">	<span class="comment">// 获取指定索引的显示设备 </span></span><br><span class="line">	GLFWmonitor* monitor = (monitor_index &lt; count) ? monitors[monitor_index] : <span class="literal">NULL</span>; </span><br><span class="line">	<span class="comment">// 获取显示设备的视频模式 </span></span><br><span class="line">	<span class="type">const</span> GLFWvidmode* mode = <span class="built_in">glfwGetVideoMode</span>(monitor); </span><br><span class="line">	<span class="comment">// 创建窗口并指定显示设备 </span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(mode-&gt;width, mode-&gt;height, <span class="string">&quot;OpenGL Window&quot;</span>, monitor, <span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">if</span> (!window) &#123; <span class="built_in">glfwTerminate</span>(); <span class="keyword">return</span> <span class="number">-1</span>; &#125; </span><br><span class="line">	<span class="comment">// 进入主循环 </span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123; </span><br><span class="line">		<span class="comment">// 渲染代码 </span></span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT); </span><br><span class="line">		<span class="comment">// ... </span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window); </span><br><span class="line">		<span class="built_in">glfwPollEvents</span>(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 清理资源 </span></span><br><span class="line">	<span class="built_in">glfwDestroyWindow</span>(window); </span><br><span class="line">	<span class="built_in">glfwTerminate</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GLUT（OpenGL-Utility-Toolkit）"><a href="#GLUT（OpenGL-Utility-Toolkit）" class="headerlink" title="GLUT（OpenGL Utility Toolkit）"></a>GLUT（OpenGL Utility Toolkit）</h1><p> GLUT 是一个跨平台的工具包，用于创建和管理 OpenGL 窗口、处理用户输入等。它提供了一组简单的 API，使得编写基本的 OpenGL 程序变得更加容易。<br>    - GLUT 支持多种操作系统，包括 Windows、Linux 和 macOS。<br>    - 使用 GLUT，你可以很快地编写出一个可以在不同平台上运行的简单 OpenGL 程序，而不必担心平台特定的细节。<br>    - 但是，GLUT 对于创建复杂的图形用户界面（GUI）可能不够灵活，因为它的功能相对有限。</p>
<ul>
<li><p><strong>GLUT</strong> 是一个跨平台的工具包，用于简化 OpenGL 应用程序的开发。它提供了一组函数，用于创建窗口、处理输入事件、进行基本的图形绘制等，使开发者可以更轻松地编写 OpenGL 应用程序，而无需处理底层的窗口系统的细节。</p>
</li>
<li><p>GLUT 提供了一个相对简单的接口，适用于快速原型设计和简单的图形应用程序。它通常用于学习 OpenGL、编写小型游戏、演示程序等。</p>
</li>
</ul>
<h1 id="GLX（OpenGL-Extension-to-the-X-Window-System）"><a href="#GLX（OpenGL-Extension-to-the-X-Window-System）" class="headerlink" title="GLX（OpenGL Extension to the X Window System）"></a>GLX（OpenGL Extension to the X Window System）</h1><ul>
<li><p><strong>GLX</strong> 是 OpenGL 在 X Window System 上的扩展，它允许 OpenGL 应用程序与 X 服务器通信，并在 X 窗口系统中创建 OpenGL 上下文。GLX 提供了一组函数，用于在 X 窗口系统中创建 OpenGL 渲染上下文、管理 OpenGL 窗口和图形渲染等。</p>
</li>
<li><p>GLX 允许 OpenGL 应用程序直接与 X 服务器通信，而不需要借助其他库或工具。它提供了对 OpenGL 的完整支持，可以实现高性能的图形渲染和交互。</p>
</li>
</ul>
<p>GLX 则是 OpenGL 在 X 窗口系统上的扩展，提供了与 X 服务器通信和在 X 窗口系统中创建 OpenGL 渲染上下文的功能。</p>
<h1 id="EGL（Embedded-Graphics-Library）"><a href="#EGL（Embedded-Graphics-Library）" class="headerlink" title="EGL（Embedded Graphics Library）"></a>EGL（Embedded Graphics Library）</h1><p>EGL 是一个用于管理图形渲染上下文的接口，通常用于嵌入式系统和移动设备上。<br>    - EGL 是 OpenGL ES 和 OpenVG 的标准的本地显示系统接口，它提供了与底层窗口系统交互的能力。<br>    - 在 Linux 上，EGL 通常与 GBM（Generic Buffer Manager）或其他图形系统配合使用，如 Wayland。<br>    - 使用 EGL，你可以在嵌入式系统上更好地控制 OpenGL 上下文的创建和管理，以及与窗口系统的交互。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
        <category>Linux Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu源</title>
    <url>/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux-Ubuntu-ubuntu%E6%BA%90/</url>
    <content><![CDATA[<h1 id="Ubuntu18-04更换国内源"><a href="#Ubuntu18-04更换国内源" class="headerlink" title="Ubuntu18.04更换国内源"></a>Ubuntu18.04更换国内源</h1><p>Ubuntu本身的源使用的是国内的源，下载速度比较慢，不像CentOS一样yum安装的时候对镜像站点进项选择，<br>所以选择了更换成国内的源。 </p>
<p><code>bionic</code>代表ubuntu18</p>
<h3 id="备份-etc-apt-sources-list文件"><a href="#备份-etc-apt-sources-list文件" class="headerlink" title="备份&#x2F;etc&#x2F;apt&#x2F;sources.list文件"></a>备份&#x2F;etc&#x2F;apt&#x2F;sources.list文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sourses.list.backup</span><br></pre></td></tr></table></figure>

<h3 id="新建-etc-apt-sources-list文件并添加以下内容"><a href="#新建-etc-apt-sources-list文件并添加以下内容" class="headerlink" title="新建&#x2F;etc&#x2F;apt&#x2F;sources.list文件并添加以下内容"></a>新建&#x2F;etc&#x2F;apt&#x2F;sources.list文件并添加以下内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#163源</span></span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h3 id="更改完成之后执行以下命令"><a href="#更改完成之后执行以下命令" class="headerlink" title="更改完成之后执行以下命令"></a>更改完成之后执行以下命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt update</span></span><br><span class="line"><span class="comment"># apt upgrade</span></span><br></pre></td></tr></table></figure>

<h3 id="其他的一些apt命令"><a href="#其他的一些apt命令" class="headerlink" title="其他的一些apt命令"></a>其他的一些apt命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  更新源</span><br><span class="line">sudo apt-get install package 安装包</span><br><span class="line">sudo apt-get remove package 删除包</span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line">sudo apt-get install package --reinstall  重新安装包</span><br><span class="line">sudo apt-get -f install  修复安装</span><br><span class="line">sudo apt-get remove package --purge 删除包，包括配置文件等</span><br><span class="line">sudo apt-get build-dep package 安装相关的编译环境</span><br><span class="line">sudo apt-get upgrade 更新已安装的包</span><br><span class="line">sudo apt-get dist-upgrade 升级系统</span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line">sudo apt-get <span class="built_in">source</span> package  下载该包的源代码</span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</span><br><span class="line">sudo apt-get check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure>

<h3 id="其他几个国内的源："><a href="#其他几个国内的源：" class="headerlink" title="其他几个国内的源："></a>其他几个国内的源：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#中科大源</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#阿里云源</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#清华源</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下实现加密</title>
    <url>/2024/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux-%E5%8A%A0%E5%AF%86-linux-crypto/</url>
    <content><![CDATA[<p>加密技术通常分为两大类“对称式”和“非对称式”<br><img src="https://raw.githubusercontent.com/liuluhua/liuluhua.github.io/ImageBed/PicGo/2024/05/21/20240521132053.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
        <category>加密</category>
      </categories>
  </entry>
</search>

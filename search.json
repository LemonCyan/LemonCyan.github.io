[{"title":"数字花园建设","path":"/2024/05/17/博客-数字花园建设/","content":"打开github下方仓库 https://github.com/oleeskild/digitalgarden 直接点击deploy，部署到vercel","categories":["博客"]},{"title":"README","path":"/2024/05/17/README/","content":"基金 减肥食谱 好用软件： 翻译软件：deepL 工具软件：utools 图床：PicGo 终端：MobaXterm RSS阅读：Lettura 磁盘空间分析：SpaceSniffer 重复文件清除：Duplicate Cleaner Pro 5 笔记软件：Obsidian&#x2F;Notion"},{"title":"版本控制方案","path":"/2024/05/17/版本控制方案/","content":"Git方案1. 仓库创建 仓库创建基于当前的项目，例如备份仪表项目仓库，LSA项目等 2. 分支创建 项目主分支保存项目代码及文档，负责发布代码 项目开发分支保存项目源码，分支仅管理员可见 项目运行分支保存项目头文件及库文件代码，分支所有人可见 项目人员开发分支基于运行分支创建，仅该人员有权限，该人员开发任务基于该分支进行修改代码 3. 代码提交 各人员代码仅提交在单独分支，提交完成后，由管理员审核后，同步源代码至开发分支 4. 版本回退 SVN方案"},{"title":"RAG检索知识体系","path":"/2024/05/17/AI-RAG检索知识体系/","content":"Windows本地部署Ollama + AnythingLLM解读本地文档 构建私有知识库现阶段切入大模型应用落地最合适的方案依然是结合大模型基于RAG检索增强来实现知识库的检索和生存。从而构建个人或者企业私有化的本地知识库。 你只需要将本地私有的 PDF、Word 文档和文本文件嵌入到本地向量库，连接上LLM，然后就可以通过对话、搜索的方式进行回答问题、提供见解，甚至生成摘要。 Ollama 下载地址 https://ollama.com/downloadOllama配置文档ollama笔记AnythingLLM 下载地址 https://useanything.com/downloadAnythingLLM配置文档AnythingLLM笔记 AnythingLLM 是 Mintplex Labs Inc. 开发的一个基于RAG（Retrieval-Augmented Generation）方案构建的开源、高效、可定制的私有知识库解决方案，一款开源 ChatGPT 等效工具，用于在安全的环境中与文档等进行聊天，专为想要使用现有文档进行智能聊天或构建知识库的任何人而构建。 AnythingLLM 能够把各种文档、资料或者内容转换成一种格式，让LLM（如ChatGPT）在聊天时可以引用这些内容。然后你就可以用它来和各种文档、内容、资料聊天，支持多个用户同时使用，还可以设置谁能看或改哪些内容。 支持多种LLM、嵌入器和向量数据库。 Open WebUI 安装地址 https://github.com/v1cc0/open-webui 安装Ollama工具后，在命令行输入 ollama pull qwen:4b 下载模型 千问4b的模型，也可以下载其他模型 ，支持的模型列表：https://ollama.com/library。 要开始运行Ollama的话，只需要在命令行输入 ollama run qwen:4b 就可以使用并访问这个模型了。 接下来我们需要安装向量模型和数据库，在https://ollama.com/里面搜索 nomic-embed-text ，这个模型可以将文本内容转换成向量数据，里面是模型介绍。 安装模型可以在命令行输入 ollama pull nomic-embed-text 进行下载和安装。 安装AnythingLLM工具后打开初始化界面，会进入到配置页面，在 LLM Preference 选项卡中，选择Ollama，然后配置 http://127.0.0.1:11434 、选择运行的大模型 qwen:4b ，token填 8192 下一步是配置 Embedding Preference 选项卡中，一样选择 Ollama，然后配置 http://127.0.0.1:11434 、选择运行的大模型 nomic-embed-text ，length填 512 下一步是配置 Vector Database ，选择默认的 LanceDB ，这是内置的向量数据库，如果想用云端数据库，可以选择 Pinecone 进行云端配置。 后面就是按提示下一步下一步，如果是要加新的工作空间，可以点new workspace来增加不同场景下的工作空间。如果需要更换模型，可以点左下角的配置按钮，重新执行上面三步完成配置。 到这里环境已经部署了，这时你已经可以跟大模型进行对话了。 接下来的步骤是对私有知识库的内容进行分析和获取。需要将文档上传到AnythinLLM，通过 nomic-embed-text 模型进行向量转换，然后存在向量数据库中。最后通过提问，去向量数据库获取内容并分析回答。 Data Connectors 是一种工具，它允许用户将外部数据源无缝集成到他们的 AnythingLLM 工作空间中，而无需编写任何自定义代码或处理复杂的配置。这些经过验证的数据连接器确保与你的 AnythingLLM 实例兼容，提供了一种简单且直接的方式来扩展你的工作空间功能。 以下是一些可用的数据连接器及其功能： GitHub Repo: - 通过这个连接器，你可以一键导入整个公共或私有的 GitHub 仓库到你的 AnythingLLM 工作空间中。 - 访问 GitHub 来获取你想要导入的仓库的链接。 - 这个功能对于开发者和团队来说非常有用，因为它允许他们直接在 AnythingLLM 中管理和查看代码库，跟踪问题和特性请求，以及审查代码。 YouTube Transcript: - 这个连接器允许你从 YouTube 视频链接导入整个视频的转录文本。 - 只需提供 YouTube 视频的链接，就可以轻松获取视频的文字内容。 - 这对于需要分析视频内容、创建视频摘要或者进行视频内容相关的研究的用户来说非常有用。 使用这些数据连接器，你可以快速地将外部数据集成到你的工作流程中，从而提高效率和生产力。例如，如果你正在研究一个特定的编程问题，你可以直接导入相关的 GitHub 仓库来查看代码和文档；或者，如果你需要分析一个教育视频的内容，你可以导入视频的转录文本来进行文本分析。 这些连接器的使用通常涉及到在 AnythingLLM 工作空间中选择相应的连接器，然后按照提示输入必要的信息，如仓库链接或视频链接，之后就可以开始导入数据了。整个过程简单直观，无需专业的编程知识，使得用户可以专注于数据分析和决策，而不是技术细节。 在工作空间页面上有一个上传文档的按钮，点击可以上传我们的文档内容。上传后选中文档，点击 Save and Embed ，等待一段时间，让模型进行向量转换和保存。 然后回到主界面点击工作空间的设置，选择 Chat Setting 选项卡，这里对话模式选择 Query ，这个模式是指只从提供的文档内容进行查找分析，而不要求大语言模型里面提供的信息作答。最后点击 Update workspace 进行更新。 然后就可以进行提问了，以上是本地部署应用的地方，如果你的电脑不太行，可以装Ollama部署在云端GPU服务器，然后本地安装AnythingLLM，在选择URL上填写云端Ollama的地址即可。 配置LLM这里选择Ollama作为后台的服务，URL这里填写http://127.0.0.1:11434，也就是前面Ollama启动的服务端口，填写后LLM模型选择gemma:2b 配置Embedding Model这里同样选择Ollama作为后台的服务，URL这里同样填写http://127.0.0.1:11434，填写后Embedding Model选择nomic-embed-text:latest 配置Vector DatabaseVector Database选择默认的第一个LanceDB 以上三个关键配置完成后，就可以开始使用AnythingLLM了。 创建文档库点击New Workspace新建文档库，并填写名称点击按钮开始添加文档我们使用的文档是paul_graham_essay.txt，这个文档也可以从github上下载：https://github.com/xinsblog/try-llama-index/blob/master/data/paul_graham_essay.txt 。 添加文档后还要将文档Move to Workspace然后点击Save and Embed出现Workspace updated successfully就表示配置已经完成 开始测试回到主页面，输入问题What did the author do in 9th grade?几秒钟后就可以看到AnythingLLM给出的回答 第三个工具就是Open WebUI，此工具可以支持云端部署web界面，在浏览器上访问大模型。 前置需要安装Docker，具体安装步骤可以看https://github.com/v1cc0/open-webui上面的安装步骤，这里就不再赘述。 安装完后输入github上的指令即可连通Ollama，并进行使用。","categories":["AI"]},{"title":"ollama笔记","path":"/2024/05/17/AI-ollama笔记/","content":"支持的模型 https://ollama.com/library 在用的ollama模型ollama.exe listollama run llama3:8bollama run codellama:7bollama run qwen:14bollama run starcoder2:7bollama run nomic-embed-text NAME SIZE FEATURES codellama:latest 3.8 GB llama3:latest 4.7 GB starcoder2:3b 1.7 GB qwen:4b nomic-embed-text 系统变量 OLLAMA_MODELS 指定模型位置 DocumentationGetting Started Quickstart Examples Importing models Linux Documentation Windows Documentation Docker Documentation Reference API Reference Modelfile Reference OpenAI Compatibility Resources Troubleshooting Guide FAQ Development guide Ollama on LinuxInstallInstall Ollama running this one-liner: 1curl -fsSL https://ollama.com/install.sh | sh AMD Radeon GPU supportWhile AMD has contributed the amdgpu driver upstream to the official linuxkernel source, the version is older and may not support all ROCm features. Werecommend you install the latest driver fromhttps://www.amd.com/en/support/linux-drivers for best support of your RadeonGPU. Manual installDownload the ollama binaryOllama is distributed as a self-contained binary. Download it to a directory in your PATH: 12sudo curl -L https://ollama.com/download/ollama-linux-amd64 -o /usr/bin/ollamasudo chmod +x /usr/bin/ollama Adding Ollama as a startup service (recommended)Create a user for Ollama: 1sudo useradd -r -s /bin/false -m -d /usr/share/ollama ollama Create a service file in /etc/systemd/system/ollama.service: 12345678910111213[Unit]Description=Ollama ServiceAfter=network-online.target[Service]ExecStart=/usr/bin/ollama serveUser=ollamaGroup=ollamaRestart=alwaysRestartSec=3[Install]WantedBy=default.target Then start the service: 12sudo systemctl daemon-reloadsudo systemctl enable ollama Install CUDA drivers (optional – for Nvidia GPUs)Download and install CUDA. Verify that the drivers are installed by running the following command, which should print details about your GPU: 1nvidia-smi Install ROCm (optional - for Radeon GPUs)Download and Install Make sure to install ROCm v6 Start OllamaStart Ollama using systemd: 1sudo systemctl start ollama UpdateUpdate ollama by running the install script again: 1curl -fsSL https://ollama.com/install.sh | sh Or by downloading the ollama binary: 12sudo curl -L https://ollama.com/download/ollama-linux-amd64 -o /usr/bin/ollamasudo chmod +x /usr/bin/ollama Viewing logsTo view logs of Ollama running as a startup service, run: 1journalctl -e -u ollama UninstallRemove the ollama service: 123sudo systemctl stop ollamasudo systemctl disable ollamasudo rm /etc/systemd/system/ollama.service Remove the ollama binary from your bin directory (either /usr/local/bin, /usr/bin, or /bin): 1sudo rm $(which ollama) Remove the downloaded models and Ollama service user and group: 123sudo rm -r /usr/share/ollamasudo userdel ollamasudo groupdel ollama Ollama联网Python及库123import requestsimport jsonimport time 定义联网函数需要定义一个联网函数，用于与互联网上的服务器进行通信。这个函数可以发送HTTP请求，接收服务器的响应，并返回结果。以下是一个示例： 12345678def connect_to_server(url, data): headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125; response = requests.post(url, data=json.dumps(data), headers=headers) if response.status_code == 200: return response.json() else: print(&quot;Error connecting to server:&quot;, response.status_code) return None 配置Ollama在联网之前，我们需要对Ollama大模型进行一些配置。这包括设置模型的参数、训练数据和测试数据等。具体的配置方法取决于你所使用的Ollama大模型。以下是一个示例： 12345678910# 设置模型参数model_params = &#123; &quot;learning_rate&quot;: 0.001, &quot;num_epochs&quot;: 100, &quot;batch_size&quot;: 32&#125;# 加载训练数据和测试数据train_data = load_train_data()test_data = load_test_data() 训练模型在配置好Ollama大模型后，我们可以开始训练模型。训练过程中，我们可以使用之前定义的联网函数将模型的中间结果上传到服务器上。以下是一个示例： for epoch in range(model_params[&quot;num_epochs&quot;]): # 训练模型 train_model(train_data, model_params) # 将中间结果上传到服务器 url = &quot;http://example.com/upload&quot; data = &#123; &quot;epoch&quot;: epoch, &quot;loss&quot;: get_current_loss(), &quot;accuracy&quot;: get_current_accuracy() &#125; connect_to_server(url, data) 测试模型训练完成后，我们可以使用测试数据对模型进行测试。同样，我们可以使用联网函数将测试结果上传到服务器上。以下是一个示例： 1234567891011# 测试模型test_model(test_data)# 将测试结果上传到服务器url = &quot;http://example.com/upload&quot;data = &#123; &quot;test_loss&quot;: get_test_loss(), &quot;test_accuracy&quot;: get_test_accuracy()&#125;connect_to_server(url, data) 通过以上步骤，我们已经成功地让Ollama大模型联网了。在实际应用中，你可能需要根据具体的需求和环境进行调整和优化。希望本文能够帮助你更好地理解和应用Ollama大模型的联网功能。","categories":["AI"]},{"title":"DRM+GBM+EGL显示","path":"/2024/05/17/Linux-Linux-Graphics-DRM-GBM-EGL显示/","content":"DRM (Direct Rendering Manager)、GBM (Generic Buffer Manager) 和 EGL (Embedded-System Graphics Library) 组合在一起，是在 Linux 平台上进行图形渲染和硬件加速的常见方式。这些组件一起提供了一个完整的图形渲染栈，允许应用程序直接与图形硬件进行交互。 DRM（Direct Rendering Manager）：DRM 是 Linux 内核中的一个子系统，用于管理图形硬件的驱动程序。它提供了一种通用的接口，允许用户空间程序直接与硬件交互，通过设备文件 /dev/dri/cardX 访问。DRM 提供了诸如模式设置、显示控制、渲染加速等功能。 GBM（Generic Buffer Manager）：GBM 是一个用于管理图形缓冲区的库，通常与 DRM 配合使用。它提供了一种标准的接口，用于分配、管理和操作图形内存。GBM 还提供了与 EGL 和 OpenGL ES 兼容的接口，使应用程序能够使用硬件加速进行渲染。 EGL（Embedded-System Graphics Library）：EGL 是一个用于管理图形资源的库，提供了一个通用的接口，用于创建和管理 OpenGL 和 OpenGL ES 上下文、表面和其他相关对象。EGL 通常与 GBM 和 DRM 一起使用，通过 GBM 提供的接口来创建图形表面，并将其与 OpenGL 或 OpenGL ES 上下文关联起来，实现硬件加速的图形渲染。","categories":["Linux","Linux Graphics"]},{"title":"OpenGL显示","path":"/2024/05/17/Linux-Linux-Graphics-OpenGL显示/","content":"GLUGLU（OpenGL Utility Library）是OpenGL的一个辅助库，提供了一些更高级的几何计算和对象构造函数，如曲面和体的生成、平移、旋转等，这些函数在处理复杂的几何操作时非常有用。 GLFWGLFW是一个流行的开源库，主要用于创建和管理图形应用程序中的窗口、OpenGL或Vulkan上下文，以及处理用户输入、定时器等功能。适用于各种图形应用程序的开发，提供了窗口管理、上下文管理、输入处理等功能，使开发者能够专注于图形渲染和应用逻辑的实现。主要功能： 窗口管理： GLFW允许开发者创建窗口并对其进行管理，包括调整大小、最小化、最大化、关闭等操作。 上下文管理： 它提供了创建OpenGL或Vulkan上下文的功能，使得图形渲染程序可以在窗口中绘制图形。 输入处理： GLFW支持处理用户输入，包括键盘输入、鼠标移动和点击、游戏手柄等。 事件处理： 它允许开发者监听和响应各种事件，如窗口大小改变、键盘按键、鼠标移动等。 监视器管理： GLFW支持多个显示器的管理，可以获取显示器的分辨率、刷新率等信息。 使用步骤： 初始化： 在程序启动时，调用GLFW的初始化函数来初始化库。 创建窗口： 使用GLFW的窗口创建函数来创建一个窗口并指定其属性，如大小、标题等。 创建上下文： 使用GLFW的上下文创建函数来创建一个OpenGL或Vulkan上下文。 主循环： 在主循环中轮询事件，并根据事件类型做出相应的处理。 渲染： 在渲染阶段，使用OpenGL或Vulkan等图形API绘制场景。 清理： 在程序结束时，调用GLFW的清理函数来释放资源并关闭库。 利用glfw监视器Demo 1234567891011121314151617181920212223242526272829#include &lt;GLFW/glfw3.h&gt; int main() &#123; // 初始化 GLFW if (!glfwInit()) &#123; return -1; &#125; // 获取监视器（显示器）列表 int count; GLFWmonitor** monitors = glfwGetMonitors(&amp;count); // 指定要使用的显示设备索引 int monitor_index = 0; // 设置为你想要的显示设备索引 // 获取指定索引的显示设备 GLFWmonitor* monitor = (monitor_index &lt; count) ? monitors[monitor_index] : NULL; // 获取显示设备的视频模式 const GLFWvidmode* mode = glfwGetVideoMode(monitor); // 创建窗口并指定显示设备 GLFWwindow* window = glfwCreateWindow(mode-&gt;width, mode-&gt;height, &quot;OpenGL Window&quot;, monitor, NULL); if (!window) &#123; glfwTerminate(); return -1; &#125; // 进入主循环 while (!glfwWindowShouldClose(window)) &#123; // 渲染代码 glClear(GL_COLOR_BUFFER_BIT); // ... glfwSwapBuffers(window); glfwPollEvents(); &#125; // 清理资源 glfwDestroyWindow(window); glfwTerminate(); return 0; &#125; GLUT（OpenGL Utility Toolkit） GLUT 是一个跨平台的工具包，用于创建和管理 OpenGL 窗口、处理用户输入等。它提供了一组简单的 API，使得编写基本的 OpenGL 程序变得更加容易。 - GLUT 支持多种操作系统，包括 Windows、Linux 和 macOS。 - 使用 GLUT，你可以很快地编写出一个可以在不同平台上运行的简单 OpenGL 程序，而不必担心平台特定的细节。 - 但是，GLUT 对于创建复杂的图形用户界面（GUI）可能不够灵活，因为它的功能相对有限。 GLUT 是一个跨平台的工具包，用于简化 OpenGL 应用程序的开发。它提供了一组函数，用于创建窗口、处理输入事件、进行基本的图形绘制等，使开发者可以更轻松地编写 OpenGL 应用程序，而无需处理底层的窗口系统的细节。 GLUT 提供了一个相对简单的接口，适用于快速原型设计和简单的图形应用程序。它通常用于学习 OpenGL、编写小型游戏、演示程序等。 GLX（OpenGL Extension to the X Window System） GLX 是 OpenGL 在 X Window System 上的扩展，它允许 OpenGL 应用程序与 X 服务器通信，并在 X 窗口系统中创建 OpenGL 上下文。GLX 提供了一组函数，用于在 X 窗口系统中创建 OpenGL 渲染上下文、管理 OpenGL 窗口和图形渲染等。 GLX 允许 OpenGL 应用程序直接与 X 服务器通信，而不需要借助其他库或工具。它提供了对 OpenGL 的完整支持，可以实现高性能的图形渲染和交互。 GLX 则是 OpenGL 在 X 窗口系统上的扩展，提供了与 X 服务器通信和在 X 窗口系统中创建 OpenGL 渲染上下文的功能。 EGL（Embedded Graphics Library）EGL 是一个用于管理图形渲染上下文的接口，通常用于嵌入式系统和移动设备上。 - EGL 是 OpenGL ES 和 OpenVG 的标准的本地显示系统接口，它提供了与底层窗口系统交互的能力。 - 在 Linux 上，EGL 通常与 GBM（Generic Buffer Manager）或其他图形系统配合使用，如 Wayland。 - 使用 EGL，你可以在嵌入式系统上更好地控制 OpenGL 上下文的创建和管理，以及与窗口系统的交互。","categories":["Linux","Linux Graphics"]},{"title":"ubuntu源","path":"/2024/05/17/Linux-Ubuntu-ubuntu源/","content":"Ubuntu18.04更换国内源Ubuntu本身的源使用的是国内的源，下载速度比较慢，不像CentOS一样yum安装的时候对镜像站点进项选择，所以选择了更换成国内的源。 bionic代表ubuntu18 备份&#x2F;etc&#x2F;apt&#x2F;sources.list文件1mv /etc/apt/sources.list /etc/apt/sourses.list.backup 新建&#x2F;etc&#x2F;apt&#x2F;sources.list文件并添加以下内容1234567891011#163源deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse 更改完成之后执行以下命令12# apt update# apt upgrade 其他的一些apt命令12345678910111213141516sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package --reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package --purge 删除包，包括配置文件等sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 其他几个国内的源：1234567891011121314151617181920212223242526272829303132333435#中科大源deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse#阿里云源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse#清华源deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse","categories":["Linux","Ubuntu"]},{"title":"USB挂载监测","path":"/2024/05/17/通讯协议-USB-USB挂载监测/","content":"Linux下如何用QT检测到U盘已经插入，并实现mount与umount 因为开发一个自动插入U盘就自动复制，并且要能在复制开始前先对U盘进行格式化。想让Linux先对U盘进行格式化，然后再对U盘进行加载，加载完成后开始复制，复制完成后自动卸载。现在Linux好像都可以自动加载。但不知道用QT的话应该怎么样编写。 已经找到解决方法，下面只描述最主要的部分，其他部分不是难题，问题主要在于怎么样发现U盘的插入与拨出，使用qt自带的QDBus可以实现，下面为连接代码，当系统有设备插入时，可以调用slotDeviceAdded(QString udi)函数。 在pro文件中应该加入 QT +=dbus 12345678910111213141516#include &lt;QtDBus/QDBusConnection&gt;#include &lt;QDbusInterface&gt;//以下为检测设备的插入 QDBusConnection::systemBus().connect( &quot;org.freedesktop.Hal&quot;, &quot;/org/freedesktop/Hal/Manager&quot;, &quot;org.freedesktop.Hal.Manager&quot;, &quot;DeviceAdded&quot;, this, SLOT(slotDeviceAdded(QString )));//以下为检查设备的拨出 QDBusConnection::systemBus().connect( &quot;org.freedesktop.Hal&quot;, &quot;/org/freedesktop/Hal/Manager&quot;, &quot;org.freedesktop.Hal.Manager&quot;, &quot;DeviceRemoved&quot;, this, SLOT(slotDeviceRemoved(QString ))); 在slotDeviceAdded(QString udi)函数中，要使用到 1QDBusInterface device(&quot;org.freedesktop.Hal&quot;, udi, &quot;org.freedesktop.Hal.Device&quot; , QDBusConnection::systemBus()); 通过HAL可以查询到设备为volume的设备，然后通过判断是否为&#x2F;dev&#x2F;sd的设备，就可以判断出是否为U盘，然后调用mount就可以了。这时记录下U盘的UDI，在检测到设备拨出时，再查询一下U盘的UDI是否还在，就知道U盘是否被拨出了。 因为开发一个自动插入U盘就自动复制，并且要能在复制开始前先对U盘进行格式化。想让Linux先对U盘进行格式化，然后再对U盘进行加载，加载完成后开始复制，复制完成后自动卸载。现在Linux好像都可以自动加载。但不知道用QT的话应该怎么样编写。 已经找到解决方法，下面只描述最主要的部分，其他部分不是难题，问题主要在于怎么样发现U盘的插入与拨出，使用qt自带的QDBus可以实现，下面为连接代码，当系统有设备插入时，可以调用slotDeviceAdded(QString udi)函数。 在pro文件中应该加入 QT +=dbus 12345678910111213141516#include &lt;QtDBus/QDBusConnection&gt;#include &lt;QDbusInterface&gt;//以下为检测设备的插入 QDBusConnection::systemBus().connect( &quot;org.freedesktop.Hal&quot;, &quot;/org/freedesktop/Hal/Manager&quot;, &quot;org.freedesktop.Hal.Manager&quot;, &quot;DeviceAdded&quot;, this, SLOT(slotDeviceAdded(QString )));//以下为检查设备的拨出 QDBusConnection::systemBus().connect( &quot;org.freedesktop.Hal&quot;, &quot;/org/freedesktop/Hal/Manager&quot;, &quot;org.freedesktop.Hal.Manager&quot;, &quot;DeviceRemoved&quot;, this, SLOT(slotDeviceRemoved(QString ))); 在slotDeviceAdded(QString udi)函数中，要使用到 1QDBusInterface device(&quot;org.freedesktop.Hal&quot;, udi, &quot;org.freedesktop.Hal.Device&quot; , QDBusConnection::systemBus()); 通过HAL可以查询到设备为volume的设备，然后通过判断是否为&#x2F;dev&#x2F;sd的设备，就可以判断出是否为U盘，然后调用mount就可以了。这时记录下U盘的UDI，在检测到设备拨出时，再查询一下U盘的UDI是否还在，就知道U盘是否被拨出了。","categories":["通讯协议","USB"]},{"title":"我的博客","path":"/2024/05/17/博客-我的博客/","content":"要更换主题的情况下 修改.github&#x2F;workflows&#x2F;blogPublish.yml 修改_config.theme.yml 修改_config.yml GitHub仓库部署 拉取仓库并本地部署脚本 123456789101112rm -rf ./BlogDeploygit clone git@github.com:liuluhua/BlogDeploy.gitcd ./BlogDeploymkdir themescd themesgit clone git@github.com:xaoxuu/hexo-theme-stellar.gitgit clone git@github.com:next-theme/hexo-theme-next.gitcd ..npm installhexo cleanhexo ghexo s -p 9050 博客框架采用Hexo 部署到GitHubPages（） 部署到Vercel（GitHub Publish） 通过Netlify部署和构建 利用Obsidian Digital Garden&#x2F;Flowershow插件在Vercel上将笔记内容部署为Obsidian数字花园 部署流程 创建GitHub发布仓库GitHub仓库部署 创建GitHub源码仓库，并在仓库中部署Hexo 在源码仓库中创建工作流，工作流主要完成任务是在接收到同步后，完成以下几个动作GitHub Actions 构建静态页面生成public文件夹，在构建之前需要调用hexo插件自动生成category信息 将public文件夹拷贝至发布仓库 确定Hexo仓库部署在GitHub还是本地如果部署在GitHub则需要整个仓库拉取到obsidian，主要显示post下文件，需要通过github actions进行发布管理优点：本地不需要Hexo环境，直接提交后自动构建页面缺点：所有源码都在Github且仓库必须公开 如果部署在本地需要在本地生成静态网页，之后将静态网页通过publisher发布public文件夹到github仓库优点：仓库可以不开源缺点：本地需要具有Hexo环境，且需要在本地生成静态网页 两个仓库都在Github是否可以实现，编辑完成后，github从源码仓库复制到发布仓库？源码仓库闭源，同步笔记到源码仓库后，源码仓库通过actions时触发同步到发布仓库，更新发布仓库页面 扩展：三仓库管理，Markdown仓库只用于编辑Markdown文件，同步后触发actions，同步到源码仓库中的post，源码仓库接受到push后，触发actions生成静态页面public，public生成完成后拷贝public到发布仓库利用actions，可以实现，感觉没啥必要，太过复杂了，源码仓库+发布仓库基本就可以了 两仓库实现步骤可以实现两个仓库都在 GitHub，并通过 GitHub Actions 自动将源码仓库的内容复制到发布仓库。这样可以将编辑完成后的 Hexo 源码仓库内容自动同步到发布仓库，实现自动化的发布管理。 将 Hexo 的源码仓库设置在 GitHub 上，你可以在这个仓库中编辑和管理 Hexo 的源代码、主题和文章。 创建另一个 GitHub 仓库作为发布仓库，用于存放生成的静态网页。你可以将 Hexo 生成的 public 文件夹的内容推送到这个仓库中。该仓库利用GitHub Pages，直接通过.github.io进行访问 在 Hexo 源码仓库中设置一个 GitHub Actions workflow，以便在每次提交或推送时自动将更新的内容复制到发布仓库。 需要配置GitHub的ssh，可以有权限访问两个仓库 需要配置发布仓库的deploy key，可以有权限写入发布仓库 域名获取 GitHub二级域名GitHubPages 二级域名https://freedomain.one/ 解析包括添加三条解析记录 192.30.252.153是GitHub的地址，你也可以ping你的 http:&#x2F;&#x2F;你的用户名.github.io 的ip地址，填入进去。 第三个记录类型是CNAME，CNAME的记录值是：http:&#x2F;&#x2F;你的用户名.github.io 这里千万别弄错了。 绑定Github域名，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名 图床GitHub图床 创建一个public仓库 进入Settings-Developer Settings-Personal access tokens (classic)生成token PicGo图床设计选择GitHub，输入在GitHub的仓库名，分支名和token即可 ObsidianCtrl+Shift+I在控制台里可以查看详细日志，所有插件的日志都可以在这里看到 配置Hexo忽略文件和文件夹由于 hexo 的文章只存在于 source 目录下，我们需要让 Obsidian 忽略其他文件的内容以优化性能以及减少不必要的搜索结果。具体的操作是在 设置-文件与链接-Exclude Files，将需要忽略的文件添加进去（尤其是 node_modules）。 插件Templater模板配置说明文档 https://silentvoid13.github.io/Templater/introduction.html 首先我们要创建模板，我们可以在 source 目录下创建 _obsidian 文件夹，并创建一篇 Post Template 的文章（md文件），我们再创建新文章的时候，只需要点击侧边栏的『插入模板』按钮就可以快速生成 Front-matter 信息： 123456789101112131415161718---title: &lt;% tp.file.title %&gt;date: &lt;% tp.file.creation_date(format=&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;update: &lt;% tp.file.last_modified_date(&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;comments: truetags:categories:dg-publish: true---定义脚本function generateTimestampUrl() &#123; var timestamp = Math.round(new Date() / 1000); var url = timestamp.toString(36) return url; &#125; module.exports = generateTimestampUrl; osidian-git快捷键Ctrl + P打开命令面板，输入open source control view启用可视化操作面板 ### obsidian-pangu中英文之间加空格 Hidden Folder目录隐藏插件 FileTree左侧菜单出现了一个 File Tree 的 Tab 页，点击后就可以看到文件以树形的结构呈现，我们展开 source 文件夹，并右键 _post 文件夹，选择 Focuse on Folder 后，左侧的文件列表中就只会显示 _post 文件夹中的内容了 Github Publisher将 Obsidian 中的文章和本地附件上传到 Github 仓库，上传前可以指定文件目录、自定义内容替换等操作。能将Obsidian仓库里的任意笔记自动或者手动同步到GitHub代码仓库的任意位置。首先设置好Github相关信息，包括Github repository，用户名，token以及Branch。当然也可以在单个笔记文件里，通过文档属性（frontmatter），单独设置接收笔记上传的Github仓库信息（可以选择同一用户下的不同仓库，同一仓库下的不同位置）。上传设置设定上传的笔记存储在Github仓库的位置。因为我的hexo博客日志文件保存在source&#x2F;posts目录下，故选择Fixed Folder，设定好默认上传到的目录。文章发布在文章文档属性添加一个share属性（可以根据需要在插件设置里改成其他任意名称），赋予值 true。文章写好后，share: true右键发布。 Button用于插入一个按钮设置按钮信息： 按钮类型（也就是功能）选择Link - open a url or uri 链接可以使用file://或者Obsidian URI，这个时候后者的好处就体现出来了，因为file://只能用绝对路径，例如file://C:\\Users\\GavinCrown\\Desktop\\SecondBrain\\Blog\\_config.yml，意味着每换一台设备你的链接就得改一次。 设置完成后，点Insert Button就可以将按钮插入到当前Markdown文件中： ShellCommand再介绍个终极优化方案，之前我们执行命令是通过运行bat文件，而Shell commands可以在Obsidian中设置好命令，并通过Obsidian的命令面板或快捷键快速运行。在插件设置面板中添加命令运行博客： Shell commands没有显示终端窗口的功能，所以需要我们启动powershell再传入命令 有了终端窗口我们才可以在窗口中按Ctrl + C关闭Hexo服务，否则它会一直占用端口1start powershell &#x27;-NoExit -Command start http://localhost:4000 ; cd Blog ; hexo s&#x27; 打开站点和主题配置文件：12start Blog/_config.ymlstart Blog/themes/butterfly4.3.1/_config.yml 然后修改默认执行环境为PowerShell 5，可以为每个命令设置下别名，就是在命令面板显示的名字 其他插件 Obsidian Linter 插件,我只用了在英文两边加空格的设置。 Image Converter 转化图片格式，我统一转为 webp，并设置了图片分辨率大小。 Unique attachments 用于将附件的文件名统一为 “字母 + 数字”的格式,记着在配置里加入 webp 图片格式 Image Inserter 用于找图片，我用于设置文章封面，即设置 cover.image 属性。 GitHubGithub Pages部署GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。创建GitHub账号，并创建一个基于用户名.github.io的仓库 使用GitHub Pages进行部署，所建仓库必须取名为“GitHub用户名.github.io” 勾选“Add a README file”，不然后面会看不到GitHub Pages域名和部署分支 仓库需要创建为公有仓库，即public 仓库大小限制为 创建完成后GitHub Pages给我们提供了一个格式为 https://GitHub用户名.github.io 的免费域名，并且相应的网站是从该仓库的 main&#x2F;master 分支构建得到的 自定义域名，在GitHub 仓库Settings-Pages-Custom domain添加自己的域名","categories":["博客"]},{"title":"Linux下实现加密","path":"/2024/04/24/Linux-加密-linux-crypto/","content":"加密技术通常分为两大类“对称式”和“非对称式”","categories":["Linux","加密"]},{"title":"Nginx学习笔记","path":"/2024/04/09/软件-Nginx-Nginx-1/","content":"Nginx功能： Web服务器 负载均衡 API网关 DDoS防御 反向代理 Web应用防火墙 缓存 命令查看nginx版本 nginx -v 配置文件所在位置/etc/nginx，文件名nginx.conf 检查配置文件是否有问题 nginx -t 重新加载nginx配置文件 nginx -s reload 关闭nginx nginx -s quit或nginx -s stop events http server include listen server_name root 根目录节点 index 指定页面 return location &#x3D;(完全匹配) ~(启用正则表达式) rewrite 重写 proxy_pass curl 命令 是一个功能强大的命令行传输工具，用于发送请求和下载文件。它支持多种协议，如HTTP、HTTPS、FTP等，可以设置请求头、请求参数等 -i 参数 打印出服务器回应的 HTTP 标头","categories":["软件","Nginx"]},{"title":"3D打印机软件配置","path":"/2024/04/02/其他-3D打印机-3d-printer-6/","content":"FDM 3D打印机通过将加热的材料挤出打印头，逐层堆积形成打印件 打印头 打印床&#x2F;热床 控制系统（主板、电机、传感器和用户界面） 打印材料 G-Code：一种用于控制数控机床（包括3D打印机、数控铣床、数控车床等）运动和操作的编程语言。 结构：corexy 交互：Fluidd配置文档通过kiauh安装 热床找平及各限位开关触发状态 固件：klipper配置文档123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302[include fluidd.cfg][virtual_sdcard]path: /home/liuluhua/printer_data/gcodeson_error_gcode: CANCEL_PRINT[mcu]serial:/dev/ttyUSB0[printer]kinematics: corexymax_velocity: 400max_accel: 1500max_accel_to_decel: 3000max_z_velocity: 10max_z_accel: 30square_corner_velocity: 10.0[stepper_x] #min:0 max:240step_pin: PF0 # X轴电机脉冲引脚dir_pin: PF1 # 方向设置 改变方向(±)!enable_pin: !PD7 # 使能引脚 rotation_distance: 40 # 主动轮周长mm (2GT-20T为 40mm 16T为 32mm 30T为 60mm)microsteps: 16 # 电机细分设置full_steps_per_rotation:200 # 电机单圈所需脉冲数（1.8度电机:200，0.9度电机:400）endstop_pin:^PE4 # 限位开关接口 PE5:X-Min, PE4:X-Max 改变(±)^position_endstop: 240 # 限位开关位置 ，机械复位点坐标position_min: 0 # 软件限位最小行程position_max: 240 # 软件限位最大行程 homing_speed: 20 # 复位速度-最大 100homing_retract_dist: 5 # 第一次触发复位开关之后的后退距离 [stepper_y] #min:0 max:230step_pin: PF6 # Y轴电机脉冲引脚dir_pin: PF7 # 方向设置 改变方向(±)!enable_pin: !PF2 # 使能引脚rotation_distance: 40 # 主动轮周长mm （2GT-20T为 40mm 16T为 32mm 30T为 60mm）microsteps: 16 # 细分full_steps_per_rotation:200 # 单圈脉冲数-对于0.9度步进设置为400endstop_pin: ^PJ1 # 限位开关接口 PJ1:Y-Min, PJ0:Y-Max 改变(±)^position_endstop: 240 # 限位开关位置 position_min: 3 # 机械限位最小行程position_max: 240 # 机械限位最大行程 homing_speed: 20 # 复位速度-最大 100homing_retract_dist: 5 # 后撤距离[stepper_z] #min:0 max:230step_pin: PL3 # Z电机脉冲引脚dir_pin: !PL1 # 方向设置 改变方向(±)!enable_pin: !PK0 # 使能引脚rotation_distance: 8 # 丝杠导程mm （2GT-20T为 40mm 16T为 32mm）microsteps: 16 # 细分full_steps_per_rotation:200 # 单圈脉冲数-对于0.9度步进设置为400endstop_pin: ^PD3 # 限位开关接口 PD3:Z-Min, PD2:Z-Max 改变(±)^#position_endstop: 0 # 限位开关位置position_max: 200 # 软限位最大行程 (240mm-290mm-340mm)position_min: 0 # 软限位最小行程（配置喷嘴清洁需要-5左右）homing_speed: 5 # 复位速度-最大 20second_homing_speed: 3 # 二次复位速度-最大 10homing_retract_dist: 10 # 后撤距离[stepper_z1]step_pin: PC1 # Z1电机脉冲引脚dir_pin: !PC3 # 方向设置 改变方向(±)!enable_pin: !PC7 # 使能引脚rotation_distance: 8 # 丝杆导程mm （2GT-20T为 40mm 16T为 32mm）microsteps: 16 # 细分full_steps_per_rotation:200 # 单圈脉冲数-对于0.9度步进设置为400endstop_pin: ^PD2 # 限位开关接口 PD3:Z-Min, PD2:Z-Max 改变(±)^[thermistor my_thermistor]#temperature1:#resistance1:#temperature2:#resistance2:#temperature3:#resistance3:# 三个在给定温度（以摄氏度为单位）下的阻值（以欧姆为单位）# 这三个测量值将会被用于计算热敏电阻的Steinhart-Hart系数# 当使用Steinhart-Hart来定义热敏电阻时这三个参数必须给定#beta:# 或者，可以使用temperature1 resistance1和beta来定义热敏电阻参数# 当使用beta来定义热敏电阻时这个参数必须给定temperature1: 25resistance1: 100000beta: 3950[extruder]step_pin: PA4 # E0电机脉冲引脚dir_pin: !PA6 # 方向设置 改变方向(±)!enable_pin: !PA2 # 使能引脚rotation_distance: 22.6789511gear_ratio: 50:17 # BMG 传动比microsteps: 16 # 细分full_steps_per_rotation: 200 # 单圈脉冲数 （200 为 1.8 度, 400 为 0.9 度）nozzle_diameter: 0.400 # 喷嘴直径filament_diameter: 1.75 # 耗材直径heater_pin: PB4 # 加热棒引脚sensor_type: my_thermistor #NTC 100K beta 3950 #传感器型号 (NTC 100K beta 3950,ATC Semitec 104GT-2)sensor_pin: PK5 # 传感器接口min_temp: 0 # 最小温度max_temp: 260 # 最大温度max_power: 1.0 # 最大功率min_extrude_temp: 170 # 最小挤出温度max_extrude_only_distance: 50.0 #一次最大挤出或回抽的长度#PID parameters: pid_Kp=20.866 pid_Ki=1.070 pid_Kd=101.721control: pid pid_Kp: 20.866pid_Ki: 1.070pid_Kd: 101.721#pid_Kp=19.831 pid_Ki=0.987 pid_Kd=99.651pressure_advance: 0.05795 # 推进压力-尽量将压力保持在1.0以下pressure_advance_smooth_time: 0.040 # 平稳推进时间-默认值为0.040[heater_bed]heater_pin: PH5 # 热床接口# sensor_type: NTC 100K beta 3950 # 热床传感器类型sensor_type: my_thermistorsensor_pin: PK6 # 热床传感器接口max_power: 0.9 # 热床功率min_temp: 0 # 最小温度（注意：测量温度超过设定值会触发紧急停止）max_temp: 80 # 最大温度（注意：测量温度超过设定值会触发紧急停止）control: pid # PID热床温度自动校准项（默认被注释）pid_kp: 67.163 # PID热床温度自动校准项（默认被注释）pid_ki: 1.178 # PID热床温度自动校准项（默认被注释）pid_kd: 957.069 # PID热床温度自动校准项（默认被注释）#pid_Kp=67.829 pid_Ki=1.154 pid_Kd=997.083#PID parameters: pid_Kp=67.163 pid_Ki=1.178 pid_Kd=957.069[bed_mesh] #热床补偿speed: 120 # 校准期间非探测移动速度horizontal_move_z: 5 # 探头移动前，喷嘴的高度mesh_min: 10,10 # 最小校准点坐标x，ymesh_max: 230, 230 # 最大校准点坐标x，yprobe_count: 3,3 # 采样点数（4X4为16点）fade_start: 1 #开始逐步淘汰调整的Z高度。在开始淡入淡出过程之前，最好先减少几层fade_end: 10 #可以根据打印表面的弯曲程度来调整此值fade_target: 0 #可以被认为是附加的Z偏移褪色完成之后施加到整个床的mesh_pps: 2,2 # 补充采样点数algorithm: bicubic # 算法模型bicubic_tension: 0.2 # 算法插值不要动#relative_reference_index: 7 # 第多少个点作为±0.00 （最好将点位设置在热床中间或者较平处）##############调平设置#################################################################################### 自定义gcode宏#####################################################################[gcode_macro PRINT_START] # 将 PRINT_START 设置为开始打印时的宏，打印前画线动作gcode: #M117 Heating... #等待机器升温至第一层打印温度 # Parameters #&#123;% set bedtemp = params.BED|int %&#125; #设置热床温度 #&#123;% set hotendtemp = params.HOTEND|int %&#125; #设置打印头温度 #M190 S&#123;bedtemp&#125; #等待热床温度稳定 #M109 S&#123;hotendtemp&#125; #等待加热头温度稳定 #画线 G28 G1 Z5 F3000 G92 E0 #重置挤出 G1 X20 F3000 G1 Y20 F3000 #G90 #设置绝对坐标体系 #G0 X5 Y1 F6000 #移动至x5 y1位置，速度100mm/s（F6000，意思为6000mm每分钟） #G0 Z0.3 #移动z轴高度至0.4 #G91 #设置坐标体系为相对坐标 #G1 X100 E20 F1200; #移动x轴100mm，并挤出，更改F可更改挤出率 #G1 Y1 #移动y轴1mm #G1 X-100 E20 F1200; #反方向移动x轴100mm，并挤出，更改F可更改挤出率 #G0 z5 #抬高z轴5mm #G92 E0; #重置挤出 #G90 #设置绝对坐标体系[gcode_macro PRINT_END] # 将 PRINT_END 设置为打印结束时的宏，自定义打印完成之后动作gcode: M400 # 等待缓冲区清除 G92 E0 # 将挤出机归零 G1 E-10.0 F3600 # 缩回耗材丝 G91 # 相对定位 G0 Z2.00 X20.0 Y20.0 F6000 # 移动喷嘴以移除架线 TURN_OFF_HEATERS # 关闭热端 M107 # 关闭风扇 G1 Z50 F3000 # 将喷嘴向上移动50毫米 #G0 X135 Y265 F3600 # 将喷嘴停在后部 BED_MESH_CLEAR # 卸载网床 [pause_resume][gcode_macro PAUSE]rename_existing: BASE_PAUSE# change this if you need more or less extrusionvariable_extrude: 1.0gcode: ##### read E from pause macro ##### &#123;% set E = printer[&quot;gcode_macro PAUSE&quot;].extrude|float %&#125; ##### set park positon for x and y ##### # default is your max posion from your printer.cfg &#123;% set x_park = printer.toolhead.axis_maximum.x|float - 5.0 %&#125; &#123;% set y_park = printer.toolhead.axis_maximum.y|float - 5.0 %&#125; ##### calculate save lift position ##### &#123;% set max_z = printer.toolhead.axis_maximum.z|float %&#125; &#123;% set act_z = printer.toolhead.position.z|float %&#125; &#123;% if act_z &lt; (max_z - 2.0) %&#125; &#123;% set z_safe = 2.0 %&#125; &#123;% else %&#125; &#123;% set z_safe = max_z - act_z %&#125; &#123;% endif %&#125; ##### end of definitions ##### SAVE_GCODE_STATE NAME=PAUSE_state BASE_PAUSE G91 G1 E-&#123;E&#125; F2100 G1 Z&#123;z_safe&#125; F900 G90 G1 X&#123;x_park&#125; Y&#123;y_park&#125; F6000[gcode_macro CANCEL_PRINT]description: Cancel the actual running printrename_existing: BASE_CANCEL_PRINTgcode: TURN_OFF_HEATERS CLEAR_PAUSE SDCARD_RESET_FILE BASE_CANCEL_PRINT#[force_move]enable_force_move: True[respond][gcode_macro DIRECTION]gcode: #G28 Z #G1 Z30 F2000 FORCE_MOVE STEPPER=stepper_x DISTANCE=20 VELOCITY=10 G4 S2 FORCE_MOVE STEPPER=stepper_y DISTANCE=20 VELOCITY=10###################################################################### 风扇配置#####################################################################[fan] # 模型冷却风扇pin: PH6 # 信号接口kick_start_time: 0.75 # 启动时间,风扇启动时全速运行时间，防止风扇无法克服阻力开始转动off_below: 0.10 # 勿动max_power: 1.0 #模型散热风扇最大输出功率（默认：1.0）###################################################################### 闲置关闭热床#####################################################################[idle_timeout]gcode:M112timeout: 1800 # 空闲时间超过30分钟则关闭热床#*# &lt;---------------------- SAVE_CONFIG ----------------------&gt;#*# DO NOT EDIT THIS BLOCK OR BELOW. The contents are auto-generated.#*##*# [stepper_z]#*# position_endstop = 0.0#*##*# [bed_mesh default]#*# version = 1#*# points =#*# 1.500000, 1.600000, 1.400000#*# 1.400000, 1.500000, 1.000000#*# 1.000000, 1.000000, 1.000000#*# x_count = 3#*# y_count = 3#*# mesh_x_pps = 2#*# mesh_y_pps = 2#*# algo = bicubic#*# tension = 0.2#*# min_x = 10.0#*# max_x = 230.0#*# min_y = 10.0#*# max_y = 230.0#*##*# [bed_mesh 20240402]#*# version = 1#*# points =#*# 1.500000, 1.600000, 1.400000#*# 1.400000, 1.500000, 1.000000#*# 1.000000, 1.000000, 1.000000#*# x_count = 3#*# y_count = 3#*# mesh_x_pps = 2#*# mesh_y_pps = 2#*# algo = bicubic#*# tension = 0.2#*# min_x = 10.0#*# max_x = 230.0#*# min_y = 10.0#*# max_y = 230.0 硬件：MKS GEN_Lv2.1","tags":["3D打印机"],"categories":["其他","3D打印机"]},{"title":"3D打印机的USB设备连接到WSL","path":"/2024/04/02/其他-3D打印机-3d-printer-5/","content":"USB设备连接到WSL在WSL2中连接3D打印机的USB端口，须将该设备从windows中挂载至Linux中 首先在windows环境中安装usbipd usbipd GitHub地址 安装usbipd12#在win命令行中执行winget install usbipd 安装环境123##在你的wsl中执行sudo apt install linux-tools-virtual hwdatasudo update-alternatives --install /usr/local/bin/usbip usbip `ls /usr/lib/linux-tools/*/usbip | tail -n1` 20 usbipd: error: WSL ‘usbip’ client not correctly installed. 重新执行此步骤 列出并挂载win中的设备到linux环境下123# 在win终端中执行usbipd wsl listusbipd wsl attach --busid=4-1","tags":["3D打印机"],"categories":["其他","3D打印机"]},{"title":"Linux环境下终端的使用","path":"/2024/03/26/terminal/","content":"终端一个基于文本的交互界面 快捷键 打开命令行终端Ctrl+Alt+t 放大终端Ctrl Shirft + 缩小终端Ctrl - 终端提示符含义lemonade@ubuntu:~$对应用户名(lemonade)@主机名(ubuntu):工作目录(~) 提示符($) ~：家目录 $: 普通用户#: 超级用户(root) 命令—在终端中用于告诉计算机去执行一个动作 参数— 选项—选项通常用一个连接号（-）或两个连接号（--）来划分 常用 ls: 列出当前目录内容 cd ~: 进入当前用户的家目录 ./当前目录(可省略) ../上一层目录 ../../ 上一层的上一层 文件操作指令 mkdir 创建文件夹 mkdir mydir touch 创建空文件 touch myfile rmdir删除一个空文件夹 rm 删除一个文件或文件夹,默认删除文件 rm -r 删除文件夹 打印定向指令 echo 打印一串字符 echo hello world &gt; 输出重定向&#x2F;指定输出的目标文件 &gt;&gt; 向指定文件中追加内容 cat 读文件内容并打印 cat readme root&amp;sudo sudo passwd 通过普通用户修改超级用户(root)的密码. su root 切换用户为root用户(超级用户) su lemonade 切换为lemonade用户. sudo 用普通用户权限执行root的功能 普通用户权限执行root的功能需注意用户环境下的环境变量和root用户环境的下环境变量是否一致 移动拷贝指令 mv 移动命令mv source dest``mv source dir cp 拷贝命令 man 用户帮助手册 man ls ls [options]... [file]... options选项或参数 file目标文件或文件夹 []可选标志 ... 多参机制 改变权值的命令 chmod 777 readme.sh 所有用户可读可写可执行 文件类型: - ：普通文件d : 文件夹&#x2F;目录l : 链接(快捷方式)s : 网络套接字p: 管道b : 块设备, 磁盘 c : 字符设备, 键盘 关机 halt 关机 reboot 重启 sudo shutdown -h now 加上关机时间 sudo shutdown -h +1 &quot;See You la la&quot; 加上关机备注 开机自启动设置服务编辑或创建/usr/lib/systemd/system/startmyapp.service文件 123456789101112131415[Unit] #服务的说明Description=nginx #描述服务After=network.target #描述服务类别[Service] #服务运行参数的设置Type=forking #是后台运行的形式PIDFile=/var/run/nginx.pidExecStartPre=/usr/bin/nginx -t -c ./nginx.confExecStart=/usr/bin/nginx -c ./nginx.conf #服务的具体运行命令ExecReload=/bin/kill -s HUP $MAINPID #重启命令ExecStop=/bin/kill -s QUIT $MAINPID #停止命令PrivateTmp=true #给服务分配独立的临时空间[Install] #运行级别下服务安装的相关设置WantedBy=multi-user.target #设置为多用户，系统运行级别为3 操作服务 12345678910111213141516171819# 设置开机自启动systemctl enable startmyapp.service# 停止开机自启动systemctl disable startmyapp.service# 启动服务systemctl start startmyapp.service# 关闭服务systemctl stop startmyapp.service# 重新启动服务systemctl restart startmyapp.service# 重新加载服务配置文件systemctl reload startmyapp.service# 查看服务当前状态systemctl status startmyapp.service# 查看所有已启动的服务systemctl list-units --type=services# 查询服务是否开机启动systemctl is-enabled startmyapp.service 设置脚本1234567vi /etc/rc.local# 添加启动脚本/usr/bin/nginx startchmod +x /etc/rc.d/rc.local# /etc/rc.d/rc.local是/etc/rc.local的软连接","tags":["Linux"]},{"title":"ffmpeg简介","path":"/2024/03/22/软件-Ffmpeg-other-ffmpeg/","content":"FFmpeg","tags":["其他"],"categories":["软件","Ffmpeg"]},{"title":"4. Fluidd配置和使用","path":"/2024/03/18/其他-3D打印机-3d-printer-4/","content":"FluiddFluidd是用于3D打印机Klipper固件的轻量化的快速的用户接口 KIAUH 需要安装git。 安装 git 后，克隆 KIAUH 项目git clone https://github.com/dw-0/kiauh.git 启动KIAUH，./kiauh/kiauh.sh KIAUH 的主菜单中。您将看到多个操作可供选择，具体取决于您想要执行的操作。要选择操作，只需在“执行操作”提示中输入相应的数字，然后按 ENTER 确认即可。 手动安装Fluidd 附带一个build脚本，可在GitHub 版本( fluidd.zip) 中找到。 需要安装NodeJS (v16.x) 和 Git 克隆Fluidd 源代码：git clone https://github.com/fluidd-core/fluidd.git 导航到 Fluidd 源代码目录：cd fluidd 安装依赖项：npm ci 构建并捆绑 Fluidd：npm run build 构建的文件将写入该dist目录。您可以使用您首选的 HTTP 服务器来提供这些服务，例如NGINX。 要出于开发目的构建 Fluidd，请运行npm run serve而不是npm run build启用热重载。","tags":["3D打印机"],"categories":["其他","3D打印机"]},{"title":"3. 正则表达式笔记","path":"/2024/03/12/语言-regular/","content":"正则表达式什么是正则表达式在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。 正则表达式就是记录文本规则的代码，用于模式匹配和搜索文本的工具。 正则表达式的模式 字面值字符：普通字符按照字面意义进行匹配,例如字母、数字、空格等，可以直接匹配它们自身。 特殊字符：例如点号 .、星号 *、加号 +、问号 ? 等，它们具有特殊的含义和功能。 字符类：用方括号 [ ] 包围的字符集合，用于匹配方括号内的任意一个字符。[^ ]匹配除了括号内的字符以外的任意一个字符 元字符：例如 \\d、\\w、\\s 等，用于匹配特定类型的字符，如数字、字母、空白字符等。 量词：例如 &#123;n&#125;、&#123;n,&#125;、&#123;n,m&#125; 等，用于指定匹配的次数或范围。 边界符号：例如 ^、$、\\b、\\B 等，用于匹配字符串的开头、结尾或单词边界与非边界位置。 分组和捕获：( )：用于分组和捕获子表达式。(?: )：用于分组但不捕获子表达式。 字符字符匹配直接在方括号里列出： [aeiou]就匹配任何一个英文元音字母 [.?!]匹配标点符号(.或?或!) 也可以指定一个字符范围： [0-9]代表的含意与\\d就是完全一致的：一位数字 [a-z0-9A-Z_]也完全等同于\\w。 普通字符 字符 含义 [ABC] 匹配 […] 中的所有字符 [^ABC] 匹配除了 […] 中字符的所有字符 [A-Z] [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。 . 匹配除换行符（ 、\\r）之外的任何单个字符，相等于 [^ \\r]。 [\\s\\S] 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，不包括换行。 \\w 匹配字母、数字、下划线。等价于[A-Za-z0-9_] 非打印字符 字符 含义 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f \\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f \\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符 字符 含义 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则$ 也匹配 ‘ ’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 *字符，请使用*。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’ ’ 匹配换行符。序列 ‘&#39; 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配|，请使用 |。 分支条件| 元字符，用于在两种或多种模式之间进行选择 匹配分枝条件时，将会从左到右地测试每个条件，如果满足某个分枝，就不会再去向右测试。 分组() 元字符，标记一个子表达式的开始和结束位置。例如IP地址表达式:((2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?).)&#123;3&#125;(2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?) 限定符 字符 含义 * 匹配前面的子表达式零次或多次。例如，zo能匹配 “z” 以及 “zoo”。 等价于 {0,}。 + 匹配前面的子表达式一次或多次。例如，zo+ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 “do” 、 “does”、 “doxy” 中的 “do” 和 “does”。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 “Bob” 中的 o，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于o*。 {n,m} m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 “fooooood” 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。 定位符 字符 含义 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式 转义字符与反义字符 在正则表达式中，还有一些常用的转义字符,转义字符可以方便地匹配一些常见的字符类型: — — \\d 表示匹配任意一个数字字符 \\w 表示匹配任意一个字母、数字或下划线字符 \\s 表示匹配任意一个空白字符（包括空格、制表符、换行符等） \\b 表示匹配单词的边界等。 在正则表达式中，反义字符是指用于匹配除了某些字符之外的任意字符的特殊字符。 反义字符以 \\ 开头，后面跟着一个大写字母，表示匹配除了这个字符类别中的任意一个字符之外的所有字符。 — — \\D 匹配任意一个非数字字符。 \\W 匹配任意一个非字母、数字或下划线字符。 \\S 匹配任意一个非空白字符。 \\B 匹配不在单词边界上的任意一个字符。 注释小括号的另一种用途是通过语法(?#comment)来包含注释 IP地址 2[0-4]\\d(?#200-249)|250-5|[01]?\\d\\d?(?#0-199)。 贪婪和懒惰当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。 以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。 如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。 前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。 这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。 现在看看懒惰版的例子吧： a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。 运算符优先级正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。 相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序： 运算符 描述 \\ 转义符 (), (?:), (?&#x3D;), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \\任何元字符、任何字符 定位点和序列（即：位置和顺序） | 替换，”或”操作,字符具有高于替换运算符的优先级，使得&#96;m 反向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。 反向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。 分组0对应整个正则表达式 \\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。 总结 确定需要匹配的基本字符或字符类别&#x2F;集合等 确定匹配的字符或字符集合的数量 特殊字符和转义字符的处理 边界和位置的匹配 使用捕获组()进行多组匹配 使用反向引用 使用逻辑操作符进行判定 正则表达式字符含义表正则表达式字符含义表 字符 含义 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，n 匹配字符 “n”。\\ 匹配一个换行符。序列 \\\\ 匹配 “\\ 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配\\ 或 \\\\r 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配\\ 或 \\\\r 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，zo+ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，o&#123;2&#125; 不能匹配 “Bob” 中的 o，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，o&#123;2,&#125; 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。o&#123;1,&#125; 等价于 o+。o&#123;0,&#125; 则等价于 o*。 {n,m} m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。o&#123;0,1&#125; 等价于 o?。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，o+? 将匹配单个 “o”，而 o+ 将匹配所有 o。 . 匹配除换行符（ 、\\r）之外的任何单个字符。要匹配包括\\ 在内的任何字符，请使用像&#96;(. )&#96;的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用( 或 )。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (&#96; ) 来组合一个模式的各个部分是很有用。例如， industr(?:y (?&#x3D;pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，&#96;Windows(?&#x3D;95 98 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&#96;Windows(?!95 98 (?&lt;&#x3D;pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，&#96;(?&lt;&#x3D;95 98 (? 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。 &#96;x y&#96; 匹配 x 或 y。例如，&#96;z [xyz] 字符集合。匹配所包含的任意一个字符。例如，[abc] 可以匹配 “plain” 中的 a。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，[^abc] 可以匹配 “plain” 中的p、l、i、n。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，[a-z] 可以匹配 a 到 z 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，[^a-z] 可以匹配任何不在 a 到 z 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，er\\\\b 可以匹配”never” 中的 er，但不能匹配 “verb” 中的 er。 \\B 匹配非单词边界。er\\\\B 能匹配 “verb” 中的 er，但不能匹配 “never” 中的 er。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的c 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f \\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f \\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于[A-Za-z0-9_]。 \\W 匹配非字母、数字、下划线。等价于[^A-Za-z0-9_]。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，\\\\x41 匹配 “A”。\\\\x041 则等价于 \\\\x04 &amp; “1”。正则表达式中可以使用 ASCII 编码。 um 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，(.)\\\\1 匹配两个连续的相同字符。 标识一个八进制转义值或一个向后引用。如果 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 m 标识一个八进制转义值或一个向后引用。如果 m 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 m 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 m 将匹配八进制转义值 nm。 ml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 &#96;","tags":["语言"],"categories":["语言"]},{"title":"2. Shell笔记","path":"/2024/03/12/语言-解释型-shell/","content":"待补充","tags":["语言"],"categories":["语言","解释型"]},{"title":"1. Markdown笔记","path":"/2024/03/12/语言-markdown/","content":"Markdown 笔记语法表格 &amp; 文本样式 样式 语法 示例 加粗 前后** 或 __ 加粗1 加粗2 斜体 前后* 或 _ 斜体1 斜体2 删除线 前后~~ 删除线 内联代码 前后 &#96; code 下划线 前&lt;u&gt; 后 &lt;/u&gt; 下划线 高亮 前后== &#x3D;&#x3D;高亮文本&#x3D;&#x3D; 引用 此内容为引用内容 链接鼠标右击 或 Ctrl 键 + 点击 系统默认浏览器打开链接 Blog网址 图片拖放图片文件、粘贴截图可直接将图片源数据存储到笔记中 图片可拖动为文件到任意窗口使用 无序列表 项目 项目 1 项目 A 项目 B 项目 2 有序列表 项目 1 项目 A 项目 B 项目 2 任务列表 A 计划 A1 计划 A2 计划 B 计划 代码块代码块支持 168 种编程语言 12345678910111213141516// javascript 冒泡排序function bubbleSort(array) &#123; let swapped = true; do &#123; swapped = false; for (let j = 0; j &lt; array.length; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; let temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; swapped = true; &#125; &#125; &#125; while (swapped); return array;&#125; KaTeX 数学公式内联公式质能方程 $E&#x3D;mc^2$ 公式块$$\\displaystyle \\left( \\sum_{k&#x3D;1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k&#x3D;1}^n a_k^2 \\right) \\left( \\sum_{k&#x3D;1}^n b_k^2 \\right)$$","tags":["语言"],"categories":["语言"]},{"title":"3. Klipper常用printer.cfg配置项说明","path":"/2024/03/12/其他-3D打印机-3d-printer-3/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816## Voron Design VORON2 350mm octopus TMC2209 UART config# Virtual SD Card[virtual_sdcard]path: ~/gcode_files# Pause/Resume Functionality[pause_resume][display_status]##***需要更改/检查的事项：***## MCU 路径 [mcu] ## 热敏电阻类型 [extruder] 和 [heater_bed]-请参阅文件末尾的“传感器类型”列表## Z轴限位开关停止位置 [safe_z_home] ## 归位结束位置 [gcode_macro G32] ## Z轴限位开关偏移位置 [stepper_z] ## 探测点 [quad_gantry_level] ## 最小和最大位置 [quad_gantry_level] ## PID 调节 [extruder] and [heater_bed] ## 微调挤出机电机步进值 [extruder] # 主板配置[mcu] # 章鱼主板序列号（通过&quot;ls -l /dev/serial/by-id/&quot;获取主板序列号）serial: /dev/serial/by-id/usb-Klipper_stm32f446xx_hyy-if00##--------------------------------------------------------------------[printer] # 机型和加速度kinematics: corexy # 打印机类型：corexymax_velocity: 1000 ##最大速度max_accel: 3000 #最大加速度max_accel_to_decel: 3000 # 最大加速至减速（最大 3000）max_z_velocity: 15 #Max 15 for 12V TMC Drivers, can increase for 24Vmax_z_accel: 350 #最大加速度square_corner_velocity: 5.0 #直角速度###################################################################### X/Y Stepper Settings # X/Y轴电机#####################################################################[stepper_x] ## X 轴步进电机 on MOTOR0(B Motor)#B Motorstep_pin: PF13 # X轴电机脉冲引脚dir_pin: !PF12 # 方向设置enable_pin: !PF14 # 使能引脚rotation_distance: 40 # 主动轮周长mm (2GT-20T为 40mm 16T为 32mm)microsteps: 32 # 细分full_steps_per_rotation:200 #set to 400 for 0.9 degree stepper # 单圈脉冲数-对于0.9度步进设置为400endstop_pin: PG6 # 限位开关接口position_min: 0 # 软限位最小行程position_endstop: 300 # 软限位最大行程 (250mm-300mm-350mm)position_max: 300 # 机械限位最大行程 (250mm-300mm-350mm)homing_speed: 60 #Max 100 # 复位速度-最大 100homing_retract_dist: 5 # 后撤距离homing_positive_dir: true # 复位方向[tmc2209 stepper_x] # X轴步进电机驱动设置uart_pin: PC4 # 驱动通信端口interpolate: True # 微步插值256run_current:0.7 # 运行电流mAhold_current: 1 # 保持电流mAsense_resistor: 0.110 # 驱动采样电阻不要改stealthchop_threshold: 200 # 静音阀值[stepper_y] # Y 轴步进电机 on MOTOR1 (A Motor)#A Motorstep_pin: PG0 # Y轴电机脉冲引脚dir_pin: PG1 # 方向设置enable_pin: !PF15 # 使能引脚rotation_distance: 40 # 主动轮周长mm （2GT-20T为 40mm 16T为 32mm）microsteps: 32 # 细分full_steps_per_rotation:200 #set to 400 for 0.9 degree stepper # 单圈脉冲数-对于0.9度步进设置为400endstop_pin: PG9 # 限位开关接口position_min: 0 # 软限位最小行程position_endstop: 300 # 软限位最大行程 (250mm-300mm-350mm)position_max: 300 # 机械限位最大行程 (250mm-300mm-350mm)homing_speed: 60 #Max 100 # 复位速度-最大 100homing_retract_dist: 5 # 后撤距离homing_positive_dir: true # 复位方向[tmc2209 stepper_y] # Y轴步进电机驱动设置uart_pin: PD11 # 驱动通信端口interpolate: True # 微步插值256run_current: 0.7 # 运行电流mAhold_current: 1 # 保持电流mAsense_resistor: 0.110 # 驱动采样电阻不要改stealthchop_threshold: 200 # 静音阀值 ###################################################################### Z Stepper Settings # Z轴步进电机####################################################################### Z MCU - In X Position## Z0 Stepper - Front Left ## Z0 步进电机 - 左前 on MOTOR2_1[stepper_z]step_pin: PG4 # Z电机脉冲引脚dir_pin: PC1 # 方向设置enable_pin: !PA0 # 使能引脚rotation_distance: 40 # 主动轮周长mm （2GT-20T为 40mm 16T为 32mm）gear_ratio: 80:16 # 减速比microsteps: 32 # 细分endstop_pin: PG10 # 限位开关接口## Z-position of nozzle (in mm) to z-endstop trigger point relative to print surface (Z0)## (+) value = endstop above Z0, (-) value = endstop below##\tIncreasing position_endstop brings nozzle closer to the bed## After you run Z_ENDSTOP_CALIBRATE, position_endstop will be stored at the very end of your config#position_endstop: -0.5position_max: 280 # 软限位最大行程 (240mm-290mm-340mm)position_min: -10 # 软限位最小行程（配置喷嘴清洁需要-5左右）homing_speed: 10 # 复位速度-最大 20second_homing_speed: 3 # 二次复位速度-最大 10homing_retract_dist: 3 # 后撤距离##\tMake sure to update below for your relevant driver (2208 or 2209)[tmc2209 stepper_z] # Z轴步进电机驱动设置uart_pin: PC7 # 驱动通信端口interpolate: true # 微步插值256run_current: 0.8 # 运行电流mAhold_current: 0.8 # 保持电流mAsense_resistor: 0.110 # 驱动采样电阻不要改stealthchop_threshold: 200 # 静音阀值##\tZ MCU - In Y Position##\tZ1 Stepper - Rear Left ##\tZ1 步进电机 - 左后 on MOTOR3[stepper_z1]step_pin: PF9 # Z1电机脉冲引脚dir_pin: !PF10 # 方向设置enable_pin: !PG2 # 使能引脚rotation_distance: 40 # 主动轮周长mm （2GT-20T为 40mm 16T为 32mm）gear_ratio: 80:16 # 减速比microsteps: 32 # 细分##\tMake sure to update below for your relevant driver (2208 or 2209)[tmc2209 stepper_z1] # Z1轴步进电机驱动设置uart_pin: PF2 # 驱动通信端口interpolate: true # 微步插值256run_current: 0.8 # 运行电流mAhold_current: 0.8 # 保持电流mAsense_resistor: 0.110 # 驱动采样电阻不要改stealthchop_threshold: 200 # 静音阀值##\tZ MCU - In Z Position##\tZ2 Stepper - Rear Right ##\tZ2 步进电机 - 右后 on MOTOR4[stepper_z2] step_pin: PC13 # Z2电机脉冲引脚dir_pin: PF0 # 方向设置enable_pin: !PF1 # 使能引脚rotation_distance: 40 # 主动轮周长mm （2GT-20T为 40mm 16T为 32mmgear_ratio: 80:16 # 减速比microsteps: 32 # 细分##\tMake sure to update below for your relevant driver (2208 or 2209)[tmc2209 stepper_z2] # Z2轴步进电机驱动设置uart_pin: PE4 # 驱动通信端口interpolate: true # 微步插值256run_current: 0.8 # 运行电流mAhold_current: 0.80 # 保持电流mAsense_resistor: 0.110 # 驱动采样电阻不要改stealthchop_threshold: 200 # 静音阀值##\tZ MCU - In E0 Position##\tZ3 Stepper - Front Right ##\tZ3 步进电机 - 右前 on MOTOR5[stepper_z3]step_pin: PE2 # Z3电机脉冲引脚dir_pin: !PE3 # 方向设置enable_pin: !PD4 # 使能引脚rotation_distance: 40 # 主动轮周长mm （2GT-20T为 40mm 16T为 32mm）gear_ratio: 80:16 # 减速比microsteps: 32 # 细分##\tMake sure to update below for your relevant driver (2208 or 2209)[tmc2209 stepper_z3] # Z3轴步进电机驱动设置uart_pin: PE1 # 驱动通信端口interpolate: true # 微步插值256run_current: 0.8 # 运行电流mAhold_current: 0.80 # 保持电流mAsense_resistor: 0.110 # 驱动采样电阻不要改stealthchop_threshold: 200 # 静音阀值###################################################################### Extruder # 挤出机配置######################################################################\tE0 on MCU X/Y[extruder]step_pin: PF11 # E0电机脉冲引脚dir_pin: PG3 # 方向设置enable_pin: !PG5 # 使能引脚##\tUpdate value below when you perform extruder calibration##\tIf you ask for 100mm of filament, but in reality it is 98mm:##\trotation_distance = &lt;previous_rotation_distance&gt; * &lt;actual_extrude_distance&gt; / 100## 22.6789511 is a good starting pointrotation_distance: 22.6119546\t#Bondtech 5mm Drive Gears 挤出距离 # 校准步进值##\tUpdate Gear Ratio depending on your Extruder Type##\tUse 50:17 for Afterburner/Clockwork (BMG Gear Ratio)##\tUse 80:20 for M4, M3.1gear_ratio: 50:17 #BMG Gear Ratio # 传动比 (M4 为 80:20 , BMG 为 50:17)microsteps: 16 # 细分full_steps_per_rotation: 200\t#200 for 1.8 degree, 400 for 0.9 degree # 单圈脉冲数 （200 为 1.8 度, 400 为 0.9 度）nozzle_diameter: 0.400 #喷嘴直径filament_diameter: 1.75 ##耗材直径heater_pin: PA2 #加热棒pin##\tValidate the following thermistor type to make sure it is correctsensor_type: ATC Semitec 104GT-2 ##NTC100 #传感器型号sensor_pin: PF4 #温度传感器的pinmin_temp: 0 # 最小温度max_temp: 300 # 最大温度max_power: 1.0 # 最大功率min_extrude_temp: 170 #挤出最底温度#喷嘴温度PID校准命令： &quot;PID_CALIBRATE HEATER=extruder TARGET=245&quot;#control = pid # PID喷嘴温度自动校准项（默认被注释）#pid_kp = 26.213 # PID喷嘴温度自动校准项（默认被注释）#pid_ki = 1.304 # PID喷嘴温度自动校准项（默认被注释）#pid_kd = 131.721 # PID喷嘴温度自动校准项（默认被注释）##\tTry to keep pressure_advance below 1.0 # 推进压力-尽量将压力保持在1.0以下pressure_advance: 0.05795 # 推进压力-尽量将压力保持在1.0以下##\tDefault is 0.040, leave stockpressure_advance_smooth_time: 0.040 # 平稳推进时间-默认值为0.040##\tMake sure to update below for your relevant driver (2208 or 2209)[tmc2209 extruder] # 挤出步进电机驱动设置uart_pin: PC6 # 驱动通信端口interpolate: false # 微步插值256run_current: 0.5 # 运行电流mA# 运行电流mAhold_current: 0.4 # 保持电流mAsense_resistor: 0.110 # 驱动采样电阻不要改stealthchop_threshold: 200 # 静音阀值##额外的远程BMG## In E4-MOT Position#[extruder_stepper my_extra_stepper]#extruder = extruder #同步到extruder上#step_pin: PE6 # E1电机脉冲引脚#dir_pin: PA14 # 方向设置#enable_pin: !PE0 # 使能引脚#microsteps:32 # 细分#rotation_distance: 22.9315546 #bmg # 校准步进值#gear_ratio: 80:20 #BMG Gear Ratio # 传动比 (M4 为 80:20 , BMG 为 50:17)#full_steps_per_rotation: 200 #200 for 1.8 degree, 400 for 0.9 degree # 单圈脉冲数 （200 为 1.8 度, 400 为 0.9 度）#shared_heater: extruder # 共用热端（双挤出默认不开启）#nozzle_diameter: 0.400 # 喷嘴直径（双挤出默认不开启）#filament_diameter: 1.75 # 耗材直径（双挤出默认不开启）## In E4-MOT Position## Make sure to update below for your relevant driver (2208 or 2209)#[tmc2209 extruder_stepper my_extra_stepper]#uart_pin: PD3 # 驱动通信端口#interpolate: false # 微步插值256#run_current: 0.7 # 运行电流mA#hold_current: 0.8 # 保持电流mA#sense_resistor: 0.110 # 驱动采样电阻不要改#stealthchop_threshold: 25 # 静音阀值[verify_heater extruder] # 加热块温度容差配置max_error: 120 # 最大误差check_gain_time:120 # 容差时间hysteresis: 50 # 容差温度heating_gain: 2 # 加热增益###################################################################### 断料检测#####################################################################[filament_switch_sensor DLJC]# 当设置为True时，将在断料后立即执行暂停。请注意，如果pause_on_runout为False，将在断料后不执行，然后断料检测被禁用。默认是True。pause_on_runout: True# 断料后要执行的 G 代码命令，如果pause_on_runout设置为 True 此 G 代码将在PAUSE 完成。默认不运行任何 G 代码命令。runout_gcode:# 插入耗材丝后要执行的 G 代码命令，这默认是不运行任何 G-Code 命令，这会禁用插入检测。insert_gcode:# 事件之间延迟的最短时间（以秒为单位）。在此时间段内触发的事件将被静默忽略。 默认值为 3 秒。event_delay: 3.0# 暂停命令之间的延迟时间，以秒为单位调度和执行 runout_gcode。 如果出现奇怪的暂停行为，则增加此延迟。默认为 0.5 秒。pause_delay: 0.5# 设置引脚，这个参数必须填switch_pin:!PG15###################################################################### Bed Heater # 热床配置#####################################################################[heater_bed]##\tSSR Pin - Z board, Fan Pinheater_pin: PA1 # 热床接口sensor_type: NTC 100K beta 3950 # 热床传感器类型sensor_pin: PF3 # 热床传感器接口##\tAdjust Max Power so your heater doesn&#x27;t warp your bedmax_power: 0.9 # 热床功率min_temp: 0 # 最小温度（注意：测量温度超过设定值会触发紧急停止）max_temp: 120 # 最大温度（注意：测量温度超过设定值会触发紧急停止）# 热床温度PID校准命令： &quot;PID_CALIBRATE HEATER=heater_bed TARGET=100&quot;#control: pid # PID热床温度自动校准项（默认被注释）#pid_kp: 58.437 # PID热床温度自动校准项（默认被注释）#pid_ki: 2.347 # PID热床温度自动校准项（默认被注释）#pid_kd: 363.769 # PID热床温度自动校准项（默认被注释）###################################################################### Probe#####################################################################[probe] #调平感应探头##\tInductive Probe##\tThis probe is not used for Z height, only Quad Gantry Leveling##\tZ_MAX on mcu_z##\tIf your probe is NO instead of NC, add change pin to !z:P0.10pin: ~!PG11 # 信号接口x_offset: 0 # X轴-传感器相对喷嘴偏移量y_offset: 25.0 # Y轴-传感器相对喷嘴偏移量z_offset: 2.50 # Z轴-传感器相对喷嘴偏移量speed: 4.0 # 调平速度samples: 2 # 采样次数samples_result: median # 取值方式（默认median-中位数）sample_retract_dist: 3.0 # 调平回缩距离samples_tolerance: 0.01 # 采样公差（注意过小的值可能造成采样次数增加）samples_tolerance_retries: 3 # 超公差重试次数###################################################################### Fan Control # 风扇配置#####################################################################[heater_fan hotend_fan] ##喉管##\tHotend Fan - XYE board, HE1 Connectorpin: PE5 # 信号接口max_power: 1.0 # 最大转速kick_start_time: 0.5 # 启动时间（勿动）heater: extruder # 关联的设备：挤出机heater_temp: 50.0 # 挤出机达到多少度启动风扇##\tIf you are experiencing back flow, you can reduce fan_speed#fan_speed: 1.0 # 风扇转速 [output_pin LED] #灯光输出pin: PB10 #信号接口[fan] ##冷却风扇##\tPrint Cooling Fan - XYE board, Fan Pinpin: PA8 # 信号接口kick_start_time: 0.5 # 启动时间（勿动）##\tDepending on your fan, you may need to increase this value##\tif your fan will not start. Can change cycle_time (increase)##\tif your fan is not able to slow down effectivelyoff_below: 0.10 # 勿动[output_pin controller_fan1_out-air] # 排风扇##\tController fan - Z board, HE1 Connectorpin: PD12 # 信号接口#kick_start_time: 0.5#heater: heater_bed#heater_temp: 45.0[output_pin controller_fan2] ##电器仓1##\tController fan - Z board, HE1 Connectorpin: PD13 # 信号接口#kick_start_time: 0.5#heater: heater_bed#heater_temp: 45.0[heater_fan controller_fan3] ##电器仓2##\tController fan - Z board, HE1 Connectorpin: PD14 # 信号接口kick_start_time: 0.5heater: heater_bedheater_temp: 45.0[heater_fan controller_fan4] #电器仓3##\tController fan - Z board, HE1 Connectorpin: PD15 # 信号接口kick_start_time: 0.5heater: heater_bedheater_temp: 45.0[heater_fan exhaust_fan] ##过滤风扇##\tExhaust fan - Z board, HE0 Connectorpin: PA3 # 信号接口max_power: 1.0 # 最大转速shutdown_speed: 0.0 # 关闭速度（勿动）kick_start_time: 5.0 # 开启时间（勿动）heater: heater_bed # 关联的设备：热床heater_temp: 60 # 热床达到多少度启动风扇fan_speed: 1.0 # 风扇转速[temperature_sensor box1] #打印仓温度计sensor_type:ATC Semitec 104GT-2 #温度计型号sensor_pin:PF5 #信号接入点#[temperature_sensor box2] #电器仓温度计#sensor_type:ATC Semitec 104GT-2 #温度计型号#sensor_pin:PF6 #信号接入点###################################################################### LED Control######################################################################[output_pin caselight]# Chamber Lighting - Bed Connector (Optional)#pin: P2.5#pwm:true#shutdown_value: 0#value:100#cycle_time: 0.01###################################################################### Homing and Gantry Adjustment Routines#####################################################################[idle_timeout] # 闲置关闭热床timeout: 1800 # 空闲时间超过30分钟则关闭热床[homing_override] # 归位和龙门调整程序axes: zset_position_z: 0gcode: G90 G0 Z15 F600 G28 X Y ##\tXY Location of the Z Endstop Switch # ## Z 限位开关的 XY 位置 ##\tUpdate X0 and Y0 to your values (such as X157, Y305) after going through # ##通过后将X0和Y0更新为你的值（如X157、Y305） ##\tZ Endstop Pin Location Definition step. # ## Z 轴限位位置定义 G0 X206.5 Y300 F3600 G28 Z G0 Z40 F1800#-------------------------------------------------------------------- [quad_gantry_level]##\tGantry Corners for 350mm Build##\tUncomment for 350mm buildgantry_corners:\t-60,-10\t360,310##\tProbe pointspoints:\t50,50\t50,250\t250,250\t250,50#--------------------------------------------------------------------speed:80 # 调平速度horizontal_move_z: 30 # Z轴起始高度retries: 3 # 超公差重试次数retry_tolerance: 0.01 # 采样公差max_adjust: 18 # 调平最大调整行程###################################################################### 自动调平#####################################################################[bed_mesh]speed: 80horizontal_move_z: 20mesh_min:80,80 mesh_max:220,220probe_count: 7,7fade_start: 0fade_end: 0#split_delta_z: 0.025#move_check_distance: 5.0#mesh_pps: 2,2#algorithm: bicubic#bicubic_tension: 0.2probe_count: 8,8algorithm: bicubicrelative_reference_index: 7###################################################################### Displays#####################################################################[board_pins]aliases: # EXP1 header EXP1_1=PE8, EXP1_2=PE7, EXP1_3=PE9, EXP1_4=PE10, EXP1_5=PE12, EXP1_6=PE13, # Slot in the socket on this side EXP1_7=PE14, EXP1_8=PE15, EXP1_9=&lt;GND&gt;, EXP1_10=&lt;5V&gt;, # EXP2 header EXP2_1=PA6, EXP2_2=PA5, EXP2_3=PB1, EXP2_4=PA4, EXP2_5=PB2, EXP2_6=PA7, # Slot in the socket on this side EXP2_7=PC15, EXP2_8=&lt;RST&gt;, EXP2_9=&lt;GND&gt;, EXP2_10=PC5# See the sample-lcd.cfg file for definitions of common LCD displays.## Uncomment the display that you have. Display connects to Z MCU#--------------------------------------------------------------------[display]lcd_type: uc1701cs_pin: EXP1_3a0_pin: EXP1_4rst_pin: EXP1_5contrast: 63encoder_pins: ^EXP2_5, ^EXP2_3click_pin: ^!EXP1_2## Some micro-controller boards may require an spi bus to be specified:#spi_bus: spi## Alternatively, some micro-controller boards may work with software spi:spi_software_miso_pin: EXP2_1spi_software_mosi_pin: EXP2_6spi_software_sclk_pin: EXP2_2[neopixel LEDlight] # LED灯带配置pin:PB0 # 信号接口chain_count:50 # 灯珠数量color_order:GRB # 颜色顺序initial_RED:0.8 # 初始 红色 量initial_GREEN:0.8 # 初始 绿色 量initial_BLUE:0.8 # 初始 蓝色 量[output_pin beeper]pin: EXP1_1[neopixel mini12864]pin: EXP1_6chain_count: 3color_order: RGBinitial_RED: 0.2initial_GREEN: 0.5initial_BLUE: 1.0#[display]##\tRepRapDiscount 128x64 Full Graphic Smart Controller#lcd_type: st7920#cs_pin: z:P1.19#sclk_pin: z:P1.20#sid_pin: z:P1.18#menu_timeout: 40#encoder_pins: ^z:P3.26, ^z:P3.25 #click_pin: ^!z:P0.28#[output_pin beeper]#pin: z:P1.30#--------------------------------------------------------------------#[display]##\tmini12864 LCD Display#lcd_type: uc1701#cs_pin: z:P1.18#a0_pin: z:P1.19#encoder_pins: ^z:P3.25,^z:P3.26#click_pin: ^!z:P0.28#contrast: 63#[neopixel fysetc_mini12864]##\tTo control Neopixel RGB in mini12864 display#pin: #chain_count: 3#initial_RED: 0.1#initial_GREEN: 0.5#initial_BLUE: 0.0#color_order: RGB##\tSet RGB values on boot up for each Neopixel. ##\tIndex 1 = display, Index 2 and 3 = Knob#[delayed_gcode setdisplayneopixel]#initial_duration: 1#gcode:# SET_LED LED=fysetc_mini12864 RED=1 GREEN=1 BLUE=1 INDEX=1 TRANSMIT=0# SET_LED LED=fysetc_mini12864 RED=1 GREEN=0 BLUE=0 INDEX=2 TRANSMIT=0# SET_LED LED=fysetc_mini12864 RED=1 GREEN=0 BLUE=0 INDEX=3 #--------------------------------------------------------------------###################################################################### Macros########################################################################################################################################### 自定义gcode宏#####################################################################[gcode_arcs] # 允许圆弧插补resolution: 1.0 # 启用圆弧插补G2，G3[gcode_macro CANCEL_PRINT]rename_existing: BASE_CANCEL_PRINTgcode: TURN_OFF_HEATERS CLEAR_PAUSE SDCARD_RESET_FILE BASE_CANCEL_PRINT[gcode_macro PAUSE]rename_existing: BASE_PAUSE# change this if you need more or less extrusionvariable_extrude: 1.0gcode: ##### read E from pause macro ##### &#123;% set E = printer[&quot;gcode_macro PAUSE&quot;].extrude|float %&#125; ##### set park positon for x and y ##### # default is your max posion from your printer.cfg &#123;% set x_park = printer.toolhead.axis_maximum.x|float - 5.0 %&#125; &#123;% set y_park = printer.toolhead.axis_maximum.y|float - 5.0 %&#125; ##### calculate save lift position ##### &#123;% set max_z = printer.toolhead.axis_maximum.z|float %&#125; &#123;% set act_z = printer.toolhead.position.z|float %&#125; &#123;% if act_z &lt; (max_z - 2.0) %&#125; &#123;% set z_safe = 2.0 %&#125; &#123;% else %&#125; &#123;% set z_safe = max_z - act_z %&#125; &#123;% endif %&#125; ##### end of definitions ##### SAVE_GCODE_STATE NAME=PAUSE_state BASE_PAUSE G91 G1 E-&#123;E&#125; F2100 G1 Z&#123;z_safe&#125; F900 G90 G1 X&#123;x_park&#125; Y&#123;y_park&#125; F6000[gcode_macro RESUME]rename_existing: BASE_RESUMEgcode: ##### read E from pause macro ##### &#123;% set E = printer[&quot;gcode_macro PAUSE&quot;].extrude|float %&#125; ##### end of definitions ##### G91 G1 E&#123;E&#125; F2100 RESTORE_GCODE_STATE NAME=PAUSE_state BASE_RESUME[gcode_macro G32]gcode: #释放已加载的热床补偿数据（需开启bed_mesh时有效，平常可忽略 BED_MESH_CLEAR #三轴复位 G28 #吸取探针 XQTZ #4Z调平 QUAD_GANTRY_LEVEL #放回探针 FHTZ #三轴复位 G28 #复位后，挤出头停留位置 G0 X150 Y290 Z20 F6000 #加载网床 #BED_MESH_PROFILE LOAD=&quot;baby&quot; [gcode_macro PRINT_START]# Use PRINT_START for the slicer starting script - please customise for your slicer of choicegcode: G32 ; home all axes G1 Z35 F3000 ; move nozzle away from bed BED_MESH_PROFILE LOAD=&quot;two&quot;[gcode_macro PRINT_END] # 将 PRINT_END 设置为打印结束时的宏，自定义打印完成之后动作# Use PRINT_END for the slicer ending script - please customise for your slicer of choicegcode: M400 ; wait for buffer to clear # 等待缓冲区清除 G92 E0 ; zero the extruder # 将挤出机归零 G1 E-10.0 F3600 ; retract filament # 缩回耗材丝 G91 ; relative positioning # 相对定位 G0 Z1.00 X20.0 Y20.0 F20000 ; move nozzle to remove stringing # 移动喷嘴以移除架线 TURN_OFF_HEATERS # 关闭热端 M107 ; turn off fan # 关闭风扇 G1 Z5 F3000 ; move nozzle up 2mm # 将喷嘴向上移动毫米数 G90 ; absolute positioning # 绝对定位 G0 X125 Y250 F3600 ; park nozzle at rear # 将喷嘴停在后部 BED_MESH_CLEAR # 卸载网床 SET_LED LED=LEDlight RED=0.3 GREEN=0.8 BLUE=0.3 # LED灯控制 ###################################################################### 打完关机######################################################################此打完关机配置 为 &quot;必趣打完关机模块&quot; 与 &quot;章鱼主板&quot;，如无模块请全部注释掉或者删除。#使用本脚本后，在&quot;Klipper首页-自定义宏&quot;处出现&quot;ADWGJ_ON&quot;与&quot;ADWGJ_OFF&quot;#打印前或者打印中点击 &quot;ADWGJ_ON&quot;即开启，&quot;ADWGJ_OFF&quot;即关闭###[gcode_macro ADWGJ_ON] # 使能打完关机###variable_dwgj_on: 0###gcode:### SET_GCODE_VARIABLE MACRO=ADWGJ_ON VARIABLE=dwgj_on VALUE=1### &#123;action_respond_info(&quot;DWGJ-ON-ON-ON!&quot;)&#125; # 需要使用打完关机时只需点击Klipper首页的 &quot;ADWGJ_ON&quot;按钮即开启打完关机#--------------------------------------------------------------------###[gcode_macro ADWGJ_OFF] # 失能打完关机###gcode:### SET_GCODE_VARIABLE MACRO=ADWGJ_ON VARIABLE=dwgj_on VALUE=0### &#123;action_respond_info(&quot;DWGJ-OFF-OFF-OFF!&quot;)&#125; # 不需要使用打完关机时只需点击Klipper首页的 &quot;ADWGJ_OFF&quot;按钮即关闭打完关机#--------------------------------------------------------------------###[gcode_macro M81] # M81指令触发的同时打完关机变量使能才会执行关机###gcode:### &#123;% set is_shutdown = printer[&quot;gcode_macro ADWGJ_ON&quot;].dwgj_on|int %&#125;### &#123;% if is_shutdown == 1 %&#125;### SHUT_DOWN### &#123;% else %&#125; # 若为触发则暂时什么都不做### &#123;% endif %&#125;#--------------------------------------------------------------------###[gcode_macro SHUT_DOWN] # 设置 SHUT_DOWN 为关机宏###gcode:### SET_GCODE_VARIABLE MACRO=ADWGJ_ON VARIABLE=dwgj_on VALUE=0 #失能打完关机### &#123;action_emergency_stop(&quot;Ready to shut down!!!&quot;)&#125; #执行软件层面关机### UPDATE_DELAYED_GCODE ID=Delayed_SHUT_DOWN DURATION=3 #执行切断电源#--------------------------------------------------------------------###[output_pin killbutton] # 打完关机模块引脚###pin:PE11 # 打完关机引脚，必须填写###value: 1 # 默认值#shutdown_value: 0 # 关机值#--------------------------------------------------------------------###[delayed_gcode Delayed_SHUT_DOWN] # 设置延迟关机宏###gcode:### set_pin pin=killbutton value=0.0 # 延迟关机#--------------------------------------------------------------------###[delayed_gcode powerOFF] # 设置延迟执行M81宏###gcode:### M81 value=0.0 # 延迟执行M81###################################################################### 配置结束####################################################################### 热敏电阻（温度传感器）类型## &quot;EPCOS 100K B57560G104F&quot;## &quot;ATC Semitec 104GT-2&quot;## &quot;NTC 100K beta 3950&quot;## &quot;Honeywell 100K 135-104LAG-J01&quot;## &quot;NTC 100K MGB18-104F39050L32&quot; (Keenovo Heater Pad)## &quot;AD595&quot;## &quot;PT100 INA826&quot;[gcode_macro XQTZ]#吸取探针，传感器短轴随喷头走到探针正上方，降 Z 吸取探针，执行 xqtz 命令可查看效果gcode: G90 #动作前，抬升 Z 高度 G0 Z15 F600 #笔筒位置--以下 XY 坐标需要根据笔筒安装的位置调整，参考 Z 复位的调试方法 G0 X62 Y299 F3600 #吸取探针 Z 所需要降至的高度，需要根据笔筒安装的高度调整，确保可以吸取探针即可 G0 Z6 F600 G0 Z30 F600[gcode_macro FHTZ]#放回探针，传感器带长探针随喷头走到笔筒正上方，降 Z 将探针 2/3 插入笔筒，然后喷头向左移动 10mm，以 gcode: G90 G0 X61 Y299 F3600 #探针下落至的高度，确保探针 2/3 插入笔筒即可 G0 Z6.5 F600 #相对笔筒位置，X 向左平移 10mm，摆脱探针（笔筒位置 Z 坐标-15 即可） G0 X150 F1000 #完成摆脱后的 Z 高度，可根据需要自行调整 G0 Z40 F600## Thermistor Types## &quot;EPCOS 100K B57560G104F&quot;## &quot;ATC Semitec 104GT-2&quot;## &quot;NTC 100K beta 3950&quot;## &quot;Honeywell 100K 135-104LAG-J01&quot;## &quot;NTC 100K MGB18-104F39050L32&quot; (Keenovo Heater Pad)## &quot;AD595&quot;## &quot;PT100 INA826&quot;#*# &lt;---------------------- SAVE_CONFIG ----------------------&gt;#*# DO NOT EDIT THIS BLOCK OR BELOW. The contents are auto-generated.#*##*# [stepper_z]#*# position_endstop = 3.205 #Z偏移（增大靠近热床。减小远离热床）#*##*# [heater_bed]#*# control = pid#*# pid_kp = 53.481#*# pid_ki = 2.425#*# pid_kd = 294.817#*##*# [extruder]#*# control = pid#*# pid_kp = 27.148#*# pid_ki = 1.508#*# pid_kd = 122.165#*##*# [input_shaper]#*# shaper_type_x = ei#*# shaper_freq_x = 50.4#*# shaper_type_y = mzv#*# shaper_freq_y = 39.4#*##*# [bed_mesh one]#*# version = 1#*# points =#*# -0.012500, -0.013750, -0.130625, -0.093750#*# 0.000000, -0.026250, -0.112500, -0.085000#*# 0.003750, 0.016875, -0.088125, -0.058750#*# 0.040625, 0.038125, -0.041875, -0.041875#*# tension = 0.2#*# min_x = 80.0#*# algo = bicubic#*# y_count = 4#*# mesh_y_pps = 2#*# min_y = 80.0#*# x_count = 4#*# max_y = 219.98#*# mesh_x_pps = 2#*# max_x = 219.98#*##*# [bed_mesh two]#*# version = 1#*# points =#*# -0.011250, 0.038125, 0.017500, 0.018750#*# 0.000000, -0.016875, 0.007500, -0.018750#*# -0.006875, -0.030625, -0.031250, -0.016875#*# 0.010625, -0.006875, -0.020000, -0.015000#*# tension = 0.2#*# min_x = 80.0#*# algo = bicubic#*# y_count = 4#*# mesh_y_pps = 2#*# min_y = 80.0#*# x_count = 4#*# max_y = 219.98#*# mesh_x_pps = 2#*# max_x = 219.98","tags":["3D打印机"],"categories":["其他","3D打印机"]},{"title":"2. 3D打印机常用配置命令","path":"/2024/03/12/其他-3D打印机-3d-printer-2/","content":"常用命令 M112 使 Klipper 进入 “shutdown”（关闭）状态 FIRMWARE_RESTART 重新加载配置文件并重启 SAVE_CONFIG 保存配置文件 ps -ef | grep klippy 查看使用的printer.cfg文件位置 GET_POSITION 获取位置 QUAD_GANTRY_LEVEL 限位开关确保X、Y和Z轴的限位开关都没有被触发，然后通过控制台发送命令： QUERY_ENDSTOPS 返回值是open打开，则限位触发电平类型设置正确 返回值是triggered（触发），则需要修改限位的电平类型（以X轴为例） 123456[stepper_X]endstop_pin: ^PE5 #修改前endstop_pin: ^!PE5 #修改后 或endstop_pin: PE5 #修改前endstop_pin: ^PE5 #修改后s 热床PID校正G28归零后，将喷嘴移至热床中心，高出床面约5-10mm，然后发送命令 PID_CALIBRATE HEATER=heater_bed TARGET=100 它将执行一个PID校准程序，将持续约10分钟，完成后控制台将会返回PID数值，将其复制到热床的PID设置 挤出头PID校正先将模型冷却风扇设置为25%的转速（ M106 S64 ），然后发送命令 PID_CALIBRATE HEATER=extruder TARGET=245 它将执行一个PID校准程序，将持续约5分钟，完成后控制台将返回PID数值，将其复制到配置文件","tags":["3D打印机"],"categories":["其他","3D打印机"]},{"title":"1. FDM_3D打印机环境配置","path":"/2024/03/12/其他-3D打印机-3d-printer-1/","content":"固件选择 marlin kllipper 上位机搭建OctoPrint安装python python3 --version 安装 OctoPrint 应该在虚拟环境中完成，而不是在操作系统范围内安装，以帮助防止依赖性冲突。要设置 Python、依赖项和虚拟环境，请运行： 123456cd ~sudo apt updatesudo apt install python3 python3-pip python3-dev python3-setuptools python3-venv git libyaml-dev build-essential libffi-dev libssl-devmkdir OctoPrint &amp;&amp; cd OctoPrintpython3 -m venv venvsource venv/bin/activate 然后可以使用以下命令安装 OctoPrint 及其 Python 依赖项pip： pip install pip --upgradepip install octoprint 如果这安装了旧版本的 OctoPrint，pip可能仍然有一些缓存。在那种情况下添加--no-cache-dir到安装命令，例如 pip install --no-cache-dir octoprint 要使这个永久的、干净的pip缓存： rm -r ~/.cache/pip 在启动 OctoPrint 之前，您可能需要将 pi 用户添加到拨出组和 tty，以便用户可以访问串行端口： sudo usermod -a -G tty pisudo usermod -a -G dialout pi 您可能必须注销并重新登录才能使这些更改生效。 第一次启动服务器 然后您应该能够使用以下octoprint serve命令启动 OctoPrint 服务器： 1234pi@raspberrypi:~ $ ~/OctoPrint/venv/bin/octoprint serve2020-11-03 17:39:17,979 - octoprint.startup - INFO - ***************************2020-11-03 17:39:17,980 - octoprint.startup - INFO - Starting OctoPrint 1.4.22020-11-03 17:39:17,980 - octoprint.startup - INFO - *************************** 试试看！通过前往访问服务器http://&lt;pi&#39;s IP&gt;:5000，您应该会看到 OctoPrint UI。 自动启动从 OctoPrint 的存储库下载初始化脚本文件，将它们移动到各自的文件夹并使初始化脚本可执行： wget https://github.com/OctoPrint/OctoPrint/raw/master/scripts/octoprint.service &amp;&amp; sudo mv octoprint.service /etc/systemd/system/octoprint.service 在octoprint_ /etc/systemd/system/octoprint.service如果您如上所述在 virtualenv 中设置它，请确保您/etc/systemd/system/octoprint.service看起来像这样： ExecStart=/home/pi/OctoPrint/venv/bin/octoprint 然后使用 将脚本添加到自动启动sudo systemctl enable octoprint.service。 这也将允许您通过以下方式启动&#x2F;停止&#x2F;重新启动 OctoPrint 守护程序 sudo service octoprint &#123;start|stop|restart&#125; 上位机编译及下载klippergit clone https://github.com/Klipper3d/klipper ./klipper/scripts/install-octopi.sh 然后配置和构建 cd ~/klipper/ make menuconfig make 需要确定连接到微控制器的串行端口，ls /dev/serial/by-id/*或者 ls /dev/ttyUSB*可以用类似以下的方法来刷写固件：sudo service klipper stopmake flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0sudo service klipper start 第一次刷写时要确保 OctoPrint 没有直接连接到打印机（在 OctoPrint 的 “连接 “中点击 “断开连接”）。 为Klipper配置 OctoPrintOctoPrint网络服务器需要进行配置，以便与Klipper host 软件进行通信。使用网络浏览器，登录到OctoPrint网页，然后配置以下项目： 导航到 “设置 “（页面顶部的扳手图标）。在 “串行连接 “下的 “附加串行端口 “中添加”&#x2F;tmp&#x2F;printer”。然后点击 “保存”。 再次进入 “设置”，在 “串行连接” 下将 “串行端口” 设置改为”&#x2F;tmp&#x2F;printer”。 在 “设置 “中，浏览到 “Behavior “子选项卡，选择 “取消任何正在进行的打印，但保持与打印机的连接 “选项。点击 “保存”。 在主页上，在 “连接 “部分（在页面的左上方），确保 “串行端口 “被设置为”&#x2F;tmp&#x2F;printer”，然后点击 “连接”。(如果”&#x2F;tmp&#x2F;printer “不是一个可用的选择，那么试着重新加载页面) 连接后，导航到 “终端 “选项卡，在命令输入框中输入 “status”（不带引号），然后点击 “发送”。终端窗口可能会报告在打开配置文件时出现了错误–这意味着 OctoPrint 与 Klipper 成功地进行了通信。继续下一部分。 配置 Klipper下一步是将打印机配置文件复制到Raspberry Pi。 编写 Klipper 配置文件的最简单方法是使用支持通过“scp”和&#x2F;或“sftp”协议编辑文件的桌面编辑器。一些免费提供的工具支持这一点（例如，Notepad ++，WinSCP和Cyberduck）。在编辑器中加载打印机配置文件，然后将其另存为 pi 用户主目录中名为“printer.cfg”的文件（即 &#x2F;home&#x2F;pi&#x2F;printer.cfg）。 另外，也可以通过 ssh 在树莓派上直接复制和编辑该文件。这可能看起来像下面这样（请确保更新命令以使用适当的打印机配置文件）： cp ~/klipper/config/example-cartesian.cfg ~/printer.cfgnano ~/printer.cfg 通常每台打印机都有自己独特的微控制器名称。刷写Klipper后，名称可能会改变，所以即使在闪存时已经完成，也要重新运行这些步骤。运行： ls /dev/serial/by-id/* 它应该报告类似以下的内容： /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 然后用这个唯一的名字更新配置文件。例如，更新[mcu]部分，类似于： 12[mcu]serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0 在创建和编辑该文件后，必须在OctoPrint网络终端发出”restart”命令以加载配置。如果Klipper配置文件被成功读取，并且成功找到并配置了微控制器，那么”status”命令将报告打印机已准备就绪。 在定制打印机配置文件时，Klipper 报告配置错误是很正常的情况。如果发生错误，请对打印机配置文件进行必要的修正，并发出”restart”，直到”status”报告打印机已准备就绪。 Klipper通过OctoPrint终端标签报告错误信息。可以使用 “status “命令来重新报告错误信息。默认的Klipper启动脚本也在&#x2F;tmp&#x2F;klippy.log中放置一个日志，提供更详细的信息。","tags":["3D打印机"],"categories":["其他","3D打印机"]},{"title":"3. Git常用操作","path":"/2024/03/12/软件-Git-git3/","content":"项目创建对于网络项目git clone [url]将GitHub中的网络项目复制到本地，只需在修改完之后commit即可，然后更新仓库代码，就可同步修改。 对于本地项目首先要创建一个文件夹用以存放文件，然后使用 git init 对进行初始化操作 git status 得到git中文件的状态 git add filename 将filename文件加入到git本地仓库中去（git rm -cached 可移除） git commit -m ‘status’ 表示提交信息（status表示附加信息） 之后对本地项目进行关联 git remote add origin [url] 添加本地到远程origin仓库 git remote -v 查看当前项目有哪些远程仓库 关联之后可以向远程仓库提交代码（更新仓库代码） 日常push git status #获取状态 git add . #添加文件到暂存区 git commit -m &quot;20191121 push&quot; #提交文件 git push origin master #推送 日常pull git diff 比较工作目录和 Index 中的代码。 git fetch 当于从远程获取最新版本到本地，不会自动merge ，比 Git pull 更安全些 git checkout app/model/user.rb 将 user.rb 文件从上一个已提交的版本中更新回来，未提交的工作目录中的内容全部会被覆盖 首次使用配置ssh ssh-keygen -t rsa ssh -T &lt;git@github.com&gt; 首次使用设置用户 git config (--global) user.name &quot;username&quot; git config (--global) user.email &quot;&lt;username@gmail.com&gt;&quot; 上传&#x2F;下载常用命令 git push origin（仓库名） master（分支） 更新仓库代码（上传） git pull origin（仓库名） master（分支） 更新本地代码（下载） 回退历史版本 git log git reset --hard \\[commit\\_id] git revert \\[commit\\_id] 网络项目 git clone \\[url] git remote add origin \\[url] 添加本地到远程origin仓库 git remote -v 查看当前项目有哪些远程仓库 版本情况 git tag 查看版本情况 git tag V1.0 新建版本 git checkout V1.0 切换至版本V1.0 分支情况 git branch 查看当前分支情况 git checkout a 切换到分支a git checkout -b a 新建分支a并切换到分支a git branch -d a 删除a分支 git merge a 将a分支的代码合并到master分支上 撤销或回退在Git中，撤销和回退是指撤销或回退先前的提交或更改。 简单介绍下Git中的撤销和回退操作，以及如何使用它们来管理代码库。 #可以把版本库上的提交回退到暂存区，修改记录保留git reset –-soft []#可以把版本库上的提交回退到工作区，修改记录保留git reset –-mixed []#可以把版本库上的提交彻底回退，修改的记录全部revert。git reset –-hard reset和revert的区别git reset 和 git revert 的主要区别在于它们对历史记录的处理方式。git reset 会删除历史记录并永久删除更改，而 git revert 会创建一个新的提交来撤销更改并保留历史记录。 git reset命令会将 HEAD 指针指向指定的 commit，并将暂存区和工作目录恢复到该 commit 的状态。这意味着在执行 git reset 后，之前的更改将不再存在于工作目录和暂存区中。如果您希望永久删除一些更改并且不再需要它们，可以使用 git reset。 git revert 命令会创建一个新的提交来撤销指定的提交。这意味着在执行 git revert 后，之前的更改仍然存在于工作目录和暂存区中，并且您需要提交一个新的撤销提交。如果您想要保留更改历史记录并且不想永久删除更改，可以使用 git revert。 获取IDgit log获取到想要回退的commit_id 撤销&#x2F;回退未提交的更改**(add之后，commit之前)**要撤销未提交的更改，请使用以下命令： git checkout &lt;file-name&gt;将名为file-name的文件恢复到上一个提交的状态。 本地本次的更改也不再保存，恢复到上一个提交(commit)的状态 git reset HEAD --file 回退暂存区里的某个文件，回退到当前版本工作区状态 保存工作区的更改，只是撤销git add这一步操作 git checkout .将所有文件恢复到最新提交的状态。请注意，此操作将删除所有未提交的更改。 撤销&#x2F;回退上一个提交**(commit之后，push之前)**撤销上一个提交 git reset HEAD~1将HEAD指针移动到上一个提交。 工作区保留先前的更改，需要重新添加到暂存区(git add) 回退到上一个提交 git reset --hard HEAD~1将HEAD指针和工作树都重置为上一个提交的状态。 请注意，此操作将删除所有未提交(commit)的更改。 撤销&#x2F;回退到特定的提交**(push之后)**撤销到特定版本 git revert &lt;commit_id&gt;这将创建一个新的提交，该提交撤销名为commit-hash的提交所做的更改。 本次撤销操作也会作为一次提交(push)进行保存 回退到特定版本 git reset --hard &lt;commit_id&gt;将HEAD指针和工作树都重置为名为commit-hash的提交的状态。 请注意，此操作将删除所有未提交的更改。 回退完成后，git push -f 强制提交 分支Git是一个流行的分布式版本控制系统，一般都是存在多个分支的，开发分支，回归测试分支以及主干分支等 在Git中，分支是指指向Git提交历史中某个特定提交的指针。 每个分支都包含在Git提交历史中的一系列提交，这些提交构成了分支的历史记录。 分支在Git中非常重要，因为它们允许多个开发人员同时在同一个代码库中工作，而不会相互干扰。 通过创建分支，每个开发人员都可以在自己的分支上进行工作，而不会影响其他人的工作。 这样，开发人员可以在不干扰其他人的情况下，独立地开发和测试新功能，最终将这些更改合并到主分支中。 在Git中，分支操作非常简单。以下是一些常用的Git分支操作： 创建分支要创建一个新分支，请使用以下命令： git branch &lt;branch-name&gt;这将创建一个名为branch-name的新分支。 注意，此时仍然在当前分支上工作。 git checkout -b &lt;branch-name&gt;新建一个分支，并且切换到新的分支branch-name 查看分支要查看所有分支，请使用以下命令： git branch这将列出所有分支，当前分支将用一个星号标记。 git branch -r 查看所有远程的分支 git branch -a 查看所有远程分支和本地分支 删除分支要删除一个分支，请使用以下命令： git branch -d &lt;branch-name&gt;这将删除名为的分支。 注意，如果该分支包含未合并的更改，则必须使用-D选项而不是-d选项来强制删除该分支。 切换分支要切换到另一个分支，请使用以下命令： git checkout &lt;branch-name&gt;这将使您从当前分支切换到名为branch-name的分支。 注意，需要在切换分支之前将所有更改提交或保存。 合并分支要将一个分支合并到另一个分支，请使用以下命令： git merge &lt;branch-name&gt;将名为branch-name的分支合并到当前分支中。 注意，如果两个分支上都有对同一文件的更改，则可能会发生冲突。在这种情况下，需要手动解决冲突并提交更改。 git merge –no-ff origin&#x2F;dev 在当前分支上合并远程分支dev git merge –abort 终止本次merge，并回到merge前的状态 以上是一些常用的Git分支操作。使用这些操作，您可以轻松地创建、切换、合并和删除分支。这些操作使多人协作变得更加容易，因为每个开发人员都可以在自己的分支上进行工作，并将更改合并到主分支中。在实际开发中，分支操作是非常重要的，最好能够熟练掌握并运用这些操作 标签在 Git 中，tag 是用于标记某个特定提交的名称。它类似于一个快照，可以用于标记版本、发布或重要的里程碑。Git 中有两种类型的 tag：轻量级标签和附注标签。 轻量级标签是一个简单的指向某个特定提交的引用，类似于一个分支，但不会随着新的提交而移动。创建轻量级标签的方法很简单，只需在命令行中输入 git tag &lt;tag-name&gt; 即可。例如，git tag v1.0 将创建一个名为 v1.0 的轻量级标签。 附注标签是一个包含标签名称、标签创建者、标签创建日期和标签说明的 Git 对象。它们是 Git 中最常用的标签类型，可以用于发布版本、重要的里程碑和其他重要的提交。创建附注标签的方法是使用 -a 标志和标签名称，然后输入标签说明。例如，git tag -a v1.0 -m &quot;Release version 1.0&quot; 将创建一个名为 v1.0 的附注标签，并将其说明设置为 “Release version 1.0”。 标签可以使用 git push 命令推送到远程存储库中，以便在其他计算机上使用。例如，要将名为 v1.0 的标签推送到远程存储库，可以使用 git push origin v1.0 命令。 1234567git tag #列出所有taggit tag [tag] #新建一个tag在当前commitgit tag [tag] [commit] #新建一个tag在指定commitgit tag -d [tag] #删除本地taggit push origin [tag] #推送tag到远程git show [tag] #查看特定taggit checkout -b [branch] [tag] #新建一个分支，指向某个tag","tags":["Git"],"categories":["软件","Git"]},{"title":"2. Git服务器环境搭建和客户端使用","path":"/2024/03/12/软件-Git-git2/","content":"服务端安装git和ssh sudo apt-get install gitsudo apt-get install openssh-server openssh-client 增加git用户并生成文件夹 sudo adduser git sudo mkdir /home/git 创建ssh证书认证文件 sudo mkdir /home/git/.sshsudo touch /home/git/.ssh/authorized_keys 临时修改authorized_keys文件的权限 sudo chmod 777 /home/git/.ssh/authorized_keys 把需要访问git服务器的客户端公钥id_rsa.pub的内容复制到authorized_keys文件 修改authorized_keys文件的权限 1234567sudo chmod 700 /home/gitsudo chmod 700 /home/git/.sshsudo chmod 600 /home/git/authorized_keyssudo chown -R git:git /home/gitsudo chown -R git:git /home/git/.sshsudo chown -R git:git /home/git/.ssh/authorized_keys``` 为了安全考虑禁止登录git服务器的shell，修改git的shell 用/usr/bin/git-shell把/etc/passwd的 git:x:1004:1004:,,,:/home/git:/bin/bash 改成： git:x:1004:1004:,,,:/home/git:/usr/bin/git-shell保存 建代码仓库 sudo mkdir /home/Repo #创建仓库的目录 sudo git init --bare /home/Repo/test.git #创建仓库 sudo chown -R git:git /home/Repo/test.git #修改权限为git 以后每创建一个新的仓库，记得最后一步操作: 修改仓库所属用户为git。 客户端安装git Linux环境下 sudo apt-get install git Windows环境下直接安装Git安装包 配置连接 通过密钥方式 ssh-keygen -t rsa [-C &quot;你的邮箱地址&quot;]会生成id_rsa.pub文件 添加该公钥到到服务器 Linux环境下，密钥默认位于/home/ubuntu/.ssh/id\\_rsa Windows环境下密钥位于C:\\Users\\xxx.ssh\\id\\_rsa.pub 通过用户名&#x2F;密码 12git config –global user.name “username”git config –global user.email “username@gmail.com” 在连接git时，会需要输入账号密码，直接输入即可 附注：增量备份-Git服务器备份使用crontab建立每天凌晨3点定时触发的任务crontab -e 0 3 * * * * rsync -av -e &quot;ssh -i /path/to/id_rsa&quot; /homt/git/ remote_user@X.X.X.X:~/backup","tags":["Git"],"categories":["软件","Git"]},{"title":"1. Git介绍和基本命令","path":"/2024/03/12/软件-Git-git1/","content":"版本控制版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理。 Git是免费、开源的分布式版本控制系统。 集中式版本控制系统集中管理的中央服务器，保存着所有文件的修改历史版本。 协同开发者通过客户端连接到这台服务器，从服务器上同步更新或上传自己的修改。 分布式版本控制系统远程仓库同步所有版本信息到本地的每个用户 本地可以查看所有的历史版本信息，偶尔远程更新，查看其他用户修改提交到远程 用户即使离线也可以本地提交，push推送到远程服务器才需要联网 每个用户都保存了历史版本 工作区域Workspace：电脑本地看到的文件和目录，在Git的版本控制下，构成了工作区。 Index&#x2F;Stage：暂存区，一般存放在.git目录下，即.git&#x2F;index,它又叫待提交更新区，用于临时存放你未提交的改动。执行git add，这些改动就添加到这个区域。 Repository：本地仓库，你执行git clone 地址，就是把远程仓库克隆到本地仓库。它是一个存放在本地的版本库，其中HEAD指向最新放入仓库的版本。当你执行git commit，文件改动就到本地仓库。 Remote：远程仓库，云端版本库 文件状态Untracked: 文件未加入到git库，未参与版本控制，处于未跟踪状态。通过git add，可以变为Staged状态 Unmodified：文件已经加入git库，版本库中的文件快照内容与文件夹中还完全一致。 Unmodified的文件如果被修改, 就会变为Modified。如果使用git remove移出版本库，则成为Untracked文件。 Modified：文件被修改进入modified状态，文件这个状态通过stage命令可以进入staged状态 staged：暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodified状态。 正向工作流git 的正向工作流程一般就这样： 从远程仓库拉取文件代码回来；git pull 在工作目录，增删改文件； 把改动的文件放入暂存区；git add 将暂存区的文件提交本地仓库；git commit 将本地仓库的文件推送到远程仓库；git push 常用命令123456789101112131415161718192021222324git clone [url] #克隆远程仓库git add [dir/file]#添加目录/文件到暂存区git commit [--amend] -m [msg] #提交暂存区到仓库区,msg为说明信息(amend用新的commit覆盖提交)git log [--oneline] [-p [file]]#查看提交历史(online精简模式)(p指定文件)git blame #列表方式查看指定文件的提交历史git diff #显示暂存区和工作区的差异git diff #显示暂存区和工作区的差异git diff filepath #filepath路径文件中，工作区与暂存区的比较差异git diff HEAD filepath #工作区与HEAD ( 当前工作分支)的比较差异git diff branchName filepath #当前分支文件与branchName分支的文件的比较差异git diff commitId filepath #与某一次提交的比较差异git status [-s] [--show-stash] #查看当前工作区暂存区变动(-s概要信息)（show-stash显示暂存文件）git pull/fetch #拉取远端代码#git pull = git fetch+ git merge。pull的话，拉取远程分支并与本地分支合并#fetch只是拉远程分支，怎么合并，可以自己再做选择。git pull #拉取远程仓库所有分支更新并合并到本地分支。git pull origin master #将远程master分支合并到当前本地master分支git pull origin master:master #将远程master分支合并到当前本地master分支，冒号后面表示本地分支git fetch --all #拉取所有远端的最新代码git fetch origin master #拉取远程最新master分支代码git push #推送到远端git push origin master #将本地分支的更新全部推送到远程仓库master分支。git push origin -d #删除远程branchname分支git push --tags #推送所有标签 123456789101112131415161718192021222324252627# git rebase`rebase`又称为衍合，是合并的另外一种选择。 `rebase`好处是： 获得更优雅的提交树，可以线性的看到每一次提交，并且没有增加提交节点。所以很多时候，看到有些伙伴都是这个命令拉代码：`git pull --rebase`# git stash`stash`命令可用于临时保存和恢复修改git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作git stash list 显示保存的工作进度列表git stash pop stash@&#123;num&#125; 恢复工作进度到工作区git stash show ：显示做了哪些改动git stash drop stash@&#123;num&#125; ：删除一条保存的工作进度git stash clear 删除所有缓存的stash。# git reflog显示当前分支的最近几次提交# git blame`git blame filepath`记录了某个文件的更改历史和更改人# git remotegit remote 查看关联的远程仓库的名称git remote add url 添加一个远程仓库git remote show [remote] 显示某个远程仓库的信息","tags":["Git"],"categories":["软件","Git"]},{"title":"1. 博客服务器环境部署","path":"/2024/03/10/Server-Setup/","content":"更新软件包sudo apt update 更新nodejs到最新版本卸载自带的nodejs sudo apt autoremove nodejs sudo apt purge nodejs 安装20版本的nodejs curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - &amp;&amp; sudo apt-get install -y nodejs 查看版本是否更新，否则关闭命令行重新打开 nodejs -v 安装nodejs安装工具到全局 sudo npm install n -g 安装稳定版本nodejs sudo n stable 安装npmsudo apt install npm -y FTP配置-用于图床安装ftp服务端 sudo apt install vsftpd -y 修改配置文件 sudo vi &#x2F;etc&#x2F;vsftpd.conf #禁止匿名访问anonymous_enable&#x3D;NO#接受本地用户local_enable&#x3D;YES#允许上传write_enable&#x3D;YES #更改创建文件权限 local_umask&#x3D;022 重启服务 sudo service vsftpd restart 创建FTP用户 sudo useradd -d &#x2F;home&#x2F;lemonade -M lemonade sudo passwd lemonade Mysql环境搭建安装mysql sudo apt install mysql-server -y sudo service mysql status # 查看服务状态sudo service mysql start # 启动服务sudo service mysql stop # 停止服务sudo service mysql restart # 重启服务 查看并更新密码 sudo cat /etc/mysql/debian.cnf 采用默认用户名密码登录 mysql -u *** -p 更新root用户密码 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;newpasswd&#39;; 退出后，用root用户确认正常登录 mysql -u root -p newpasswd 创建Qexo要使用表 create database qexo; Python环境安装安装编译 Python 3.10 所需的依赖项： sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev wget 下载 Python 3.10 的源代码： wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz 解压源代码： tar -xf Python-3.10.0.tgz 进入解压后的目录： cd Python-3.10.0 配置 Python 3.10 的编译选项： ./configure --enable-optimizations 编译并安装 Python 3.10： make -j 8sudo make altinstall 确认 Python 3.10 是否安装成功： python3.10 --version 如果输出了 Python 3.10 的版本号，则说明安装成功。 pip下载时出现网络问题 临时使用： 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple gevent，这样就会从清华这边的镜像去安装gevent库。 永久修改，一劳永逸： Linux下，修改 ~&#x2F;.pip&#x2F;pip.conf (没有就创建一个)， 修改 index-url至tuna，内容如下： [global]index-url &#x3D; https://pypi.tuna.tsinghua.edu.cn/simple windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下 [global]index-url &#x3D; https://pypi.tuna.tsinghua.edu.cn/simple nginx环境安装安装nginx sudo apt install nginx 访问公网IP，发现nginx页面安装成功 修改nginx配置文件sudo vi /etc/nginx/sites-enabled/default 修改完成后重启nginx服务sudo service nginx restart FRP内网穿透配置待补充","tags":["博客"]},{"title":"简历","path":"/about.html","content":"个人信息 姓名： 刘璐华 学历： 本科 出生年月: 1995.09 性别： 男 联系方式： 15756000566 英语： 四级 邮箱： &#108;&#105;&#x75;&#x6c;&#117;&#104;&#117;&#x61;&#55;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109; 教育经历： 2013-2017 铜陵学院 电气工程及其自动化 工作经历 时间 公司 职位 工作内容 2017.02-2019.10 上海华之邦科技股份有限公司 嵌入式Linux软件工程师 嵌入式Linux环境搭建，数据库，触摸库，USB库等的移植工作，Linux环境下的Qt编程，开发文档，设计文档，API文档，操作手册等文档的编写 2019.10-2020.07 上海金标生物科技有限公司 Linux Qt高级工程师 嵌入式Linux开发板的选型及环境搭建，相关库的移植工作，Linux环境下软件代码的编写&#x2F;重构&#x2F;测试，通信协议的制定，相关文档的编写 2020.07-2021.10 无锡百泰克生物有限公司（上海分公司） 软件开发负责人 NAS部署与管理，redmine的部署与项目进度控制，PCR上位机架构设计，第三方设备的选型及环境搭建使用，上位机代码编写，相关文档的编写 2021.10-至今 安徽华明航空电子系统有限公司 Linux嵌入式软件工程师 Windows环境下的C++代码的开发工作，Linux平台环境的搭建，Windows平台向Linux平台下的迁移工作，窗口的重绘工作，相关设计&#x2F;测试文档的编写工作 奖项荣誉奖学金，优秀社团干部，优秀新人，优秀员工，优秀团队 专业技能 熟练使用Linux ，熟悉Linux环境配置及平台搭建（网络配置，内核配置，文件系统配置等） 熟练掌握Linux环境下的C++程序设计和Qt程序设计 熟练掌握多项外设的移植使用，如4G终端&#x2F;相机&#x2F;扫描模块等 熟练掌握Linux下的串口通讯、MODBUS通讯、TCP/IP通信、USB通信编程 熟悉Shell，会编写脚本用于辅助编译工作 了解Python，会利用Python进行相关的辅助工作 了解Docker及docker-compose，能够编写docker-compose脚本并运行docker服务 项目经历基于嵌入式Linux环境下的烟气在线监测系统（CEMS）&#x2F;水质在线检测设备功能：系统主要通过控制设备采集污染气体&#x2F;水质，在腔体内对污染气体&#x2F;的光学数据通过程序中的Matlab算法进行分析，得到污染物实时浓度，进行监测及上报给环保局。模块：软件系统分为PC端（数据存储与上报），ARM端（数据处理及程序控制），STM32端（动作执行），主要负责的职责涉及以下方面： 环境搭建：嵌入式Linux环境的交叉编译、裁剪 外部库移植：libusb&#x2F;libmodbus&#x2F;MQTT协议等通讯库向linux环境下的移植使用 代码编写：基于Qt4完成ARM端的代码编写及PC端上位机的后期维护工作 设备测试及文档：完成模块及系统测试，输出设计文档，开发文档，测试文档，操作文档等手册 现场调试：对于初始型号在现场调试并根据反馈结果迭代程序 难点： 移植工作，根据实际嵌入式环境编译脚本及编译选项 根据国产的**A3352(基于TI AM3352)**开发板进行嵌入式程序开发、调试 通过libusb等外部库实现USB协议和上位机通讯 实际现场问题的排查，影响设备运行的原因多种多样，包含电磁兼容性，信号屏蔽，电源&#x2F;地线稳定性，从硬件到外设的各方面原因 基于Windows&#x2F;Linux环境下的光谱仪的SDK开发功能：设备主要通过控制氙灯的闪烁频率，并采集CCD的相关数据用于CEMS中的光谱监测分析。模块：设备分为PC端（数据存储与分析），STM32端（动作执行），主要负责的模块涉及以下几个方面： 多平台开发：Windows及Linux环境下PC端代码开发 多通讯协议开发：TCP&#x2F;串口&#x2F;USB三种方式连接设备，并对设备进行操作 代码编写：基于Qt5完成PC端多平台代码的编写 基于Linux环境下的PCR设备&#x2F;心室辅助装置VAD的开发功能：PCR设备主要用于通过控制TEC升降温进行扩增及溶解，通过Basler相机采集荧光数据，通过Matlab算法进行分析，依据在每个循环的荧光数据通过阈值基线计算判断样品的阴阳性。功能：VAD设备主要用于压力传感器进行ms级监测血压并显示，通过手动设置泵的速度，帮助血液泵送到身体其他部位。 环境搭建：Matlab算法移植，相机支持库的配置及使用 通信协议：制定通讯协议，熟悉CAN协议，使用socketCAN进行通讯 代码编写：包括架构涉及，功能配置，业务逻辑 难点： 设计设备的升降温、电机旋转角度、相机数据采集和多线程处理的同步控制 针对不同设备间算法的兼容性及普适性测试及参数微调 根据国产的 OK3568(基于RK3568) 开发板进行嵌入式程序开发、调试 eVTOL航电模拟器系统的平台迁移工作和备份仪表的模块开发功能：系统主要用于飞机的六大仪表显示，飞行路径规划，机体相关信息显示。系统分为Windows和Linux双平台进行开发，其中Windows主要适用于模拟器，Linux主要适用于真机。主要涉及以下几个方面： 环境搭建：Linux环境部署及内核文件系统裁剪，内核实时性xenomai的方案学习 通讯协议：熟悉原来基于socket中间件的通信协议，并基于串口和CAN进行分解 代码迁移：将原来的Windows环境下的系统代码迁移到Linux环境下，并调试程序直至正常运行 窗口系统：为迁移后的程序在Qt环境下设计新的窗口系统 MES系统项目上线 完成MES项目一阶段验收 完成SAP对接测试上线工作 完成立库的一阶段上线 负责光伏项目整体进度推进，未完成项任务计划沟通制定、实施及变更控制 负责组件试运行期间问题清单需求收集、评审和进度跟进 负责组件MES系统迭代升级和测试验证 负责MES项目与各外围系统对接的相关测试及推进工作 负责向项目干系人工作进展和阶段性成果沟通汇报 负责组件MES项目风险识别、分析、反馈风险策略实施 负责组件MES项目用户支持、培训和运维保障 自我介绍 学习了解一些python相关的内容，比较基础，通过BeautifulSoup爬取一些自己想要的信息 在局域网内搭建了一台NAS，利用docker部署了一些nextcloud等应用，用于管理自己的所有资料 基于个人私有的云服务器，利用docker部署了自己的wordpress博客，记录一些学习内容和资料 完成一台3D打印机的DIY工作，搭建了web端的fluidd上位机，连接klipper固件的主板，调试完成3D打印"}]